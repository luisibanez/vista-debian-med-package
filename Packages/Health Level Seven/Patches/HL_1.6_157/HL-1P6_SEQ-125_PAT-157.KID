Released HL*1.6*157 SEQ #125
Extracted from mail message
**KIDS**:HL*1.6*157^

**INSTALL NAME**
HL*1.6*157
"BLD",1552,0)
HL*1.6*157^HEALTH LEVEL SEVEN^0^3110816^y
"BLD",1552,1,0)
^^1^1^3110621^
"BLD",1552,1,1,0)

"BLD",1552,4,0)
^9.64PA^^
"BLD",1552,6.3)
8
"BLD",1552,"ABPKG")
n
"BLD",1552,"KRN",0)
^9.67PA^9002226^21
"BLD",1552,"KRN",.4,0)
.4
"BLD",1552,"KRN",.401,0)
.401
"BLD",1552,"KRN",.402,0)
.402
"BLD",1552,"KRN",.403,0)
.403
"BLD",1552,"KRN",.5,0)
.5
"BLD",1552,"KRN",.84,0)
.84
"BLD",1552,"KRN",3.6,0)
3.6
"BLD",1552,"KRN",3.8,0)
3.8
"BLD",1552,"KRN",9.2,0)
9.2
"BLD",1552,"KRN",9.8,0)
9.8
"BLD",1552,"KRN",9.8,"NM",0)
^9.68A^10^10
"BLD",1552,"KRN",9.8,"NM",1,0)
HLOSRVR^^0^B95024776
"BLD",1552,"KRN",9.8,"NM",2,0)
HLOSRVR3^^0^B1207898
"BLD",1552,"KRN",9.8,"NM",3,0)
HLCSTCPA^^0^B13412536
"BLD",1552,"KRN",9.8,"NM",4,0)
HLCSTCP4^^0^B51177330
"BLD",1552,"KRN",9.8,"NM",5,0)
HLCSTCP^^0^B50599894
"BLD",1552,"KRN",9.8,"NM",6,0)
HLCSTCP3^^0^B15347449
"BLD",1552,"KRN",9.8,"NM",7,0)
HLCSTCP2^^0^B87468876
"BLD",1552,"KRN",9.8,"NM",8,0)
HLCSLNCH^^0^B50153575
"BLD",1552,"KRN",9.8,"NM",9,0)
HLCS2^^0^B53158802
"BLD",1552,"KRN",9.8,"NM",10,0)
HLTF^^0^B26864166
"BLD",1552,"KRN",9.8,"NM","B","HLCS2",9)

"BLD",1552,"KRN",9.8,"NM","B","HLCSLNCH",8)

"BLD",1552,"KRN",9.8,"NM","B","HLCSTCP",5)

"BLD",1552,"KRN",9.8,"NM","B","HLCSTCP2",7)

"BLD",1552,"KRN",9.8,"NM","B","HLCSTCP3",6)

"BLD",1552,"KRN",9.8,"NM","B","HLCSTCP4",4)

"BLD",1552,"KRN",9.8,"NM","B","HLCSTCPA",3)

"BLD",1552,"KRN",9.8,"NM","B","HLOSRVR",1)

"BLD",1552,"KRN",9.8,"NM","B","HLOSRVR3",2)

"BLD",1552,"KRN",9.8,"NM","B","HLTF",10)

"BLD",1552,"KRN",19,0)
19
"BLD",1552,"KRN",19.1,0)
19.1
"BLD",1552,"KRN",101,0)
101
"BLD",1552,"KRN",409.61,0)
409.61
"BLD",1552,"KRN",771,0)
771
"BLD",1552,"KRN",779.2,0)
779.2
"BLD",1552,"KRN",870,0)
870
"BLD",1552,"KRN",8989.51,0)
8989.51
"BLD",1552,"KRN",8989.52,0)
8989.52
"BLD",1552,"KRN",8994,0)
8994
"BLD",1552,"KRN",9002226,0)
9002226
"BLD",1552,"KRN","B",.4,.4)

"BLD",1552,"KRN","B",.401,.401)

"BLD",1552,"KRN","B",.402,.402)

"BLD",1552,"KRN","B",.403,.403)

"BLD",1552,"KRN","B",.5,.5)

"BLD",1552,"KRN","B",.84,.84)

"BLD",1552,"KRN","B",3.6,3.6)

"BLD",1552,"KRN","B",3.8,3.8)

"BLD",1552,"KRN","B",9.2,9.2)

"BLD",1552,"KRN","B",9.8,9.8)

"BLD",1552,"KRN","B",19,19)

"BLD",1552,"KRN","B",19.1,19.1)

"BLD",1552,"KRN","B",101,101)

"BLD",1552,"KRN","B",409.61,409.61)

"BLD",1552,"KRN","B",771,771)

"BLD",1552,"KRN","B",779.2,779.2)

"BLD",1552,"KRN","B",870,870)

"BLD",1552,"KRN","B",8989.51,8989.51)

"BLD",1552,"KRN","B",8989.52,8989.52)

"BLD",1552,"KRN","B",8994,8994)

"BLD",1552,"KRN","B",9002226,9002226)

"BLD",1552,"QDEF")
^^^^NO^^^^NO^^NO
"BLD",1552,"QUES",0)
^9.62^^
"BLD",1552,"REQB",0)
^9.611^3^2
"BLD",1552,"REQB",2,0)
HL*1.6*153^2
"BLD",1552,"REQB",3,0)
HL*1.6*142^2
"BLD",1552,"REQB","B","HL*1.6*142",3)

"BLD",1552,"REQB","B","HL*1.6*153",2)

"MBREQ")
0
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
157^3110816
"PKG",9,22,1,"PAH",1,1,0)
^^1^1^3110816
"PKG",9,22,1,"PAH",1,1,1,0)

"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
10
"RTN","HLCS2")
0^9^B53158802^B49434182
"RTN","HLCS2",1,0)
HLCS2 ;SF/JC - More Communication Server utilities ; 08/05/2011  11:22
"RTN","HLCS2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**14,40,43,49,57,58,82,84,109,122,157**;Oct 13, 1995;Build 8
"RTN","HLCS2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCS2",4,0)
FWD ; Add supplemental clients from HLL("LINKS") to HLSUP array
"RTN","HLCS2",5,0)
 ;This enhancement also supports distribution of a message to
"RTN","HLCS2",6,0)
 ;the same client over multiple logical links.
"RTN","HLCS2",7,0)
 Q:'$D(HLL("LINKS"))
"RTN","HLCS2",8,0)
 N CNT,LNK,CLIAP
"RTN","HLCS2",9,0)
 S CNT=0,ROUTINE=1 F  S CNT=$O(HLL("LINKS",CNT)) Q:CNT<1  D
"RTN","HLCS2",10,0)
 . S PTR=$P(HLL("LINKS",CNT),"^"),LNK=$P(HLL("LINKS",CNT),"^",2)
"RTN","HLCS2",11,0)
 . Q:PTR=""  I +PTR<1 S PTR=$O(^ORD(101,"B",PTR,0)) Q:PTR<1
"RTN","HLCS2",12,0)
 . ;
"RTN","HLCS2",13,0)
 . ; patch HL*1.6*122: excluding subscribers defined in
"RTN","HLCS2",14,0)
 . ; HLP("EXCLUDE SUBSCRIBER",I) = ien of subscriber
"RTN","HLCS2",15,0)
 . N I,EXCLUDE
"RTN","HLCS2",16,0)
 . S (EXCLUDE,I)=0
"RTN","HLCS2",17,0)
 . F  S I=$O(HLP("EXCLUDE SUBSCRIBER",I)) Q:'I  D  Q:EXCLUDE
"RTN","HLCS2",18,0)
 .. N TEMP
"RTN","HLCS2",19,0)
 .. S TEMP=HLP("EXCLUDE SUBSCRIBER",I)
"RTN","HLCS2",20,0)
 .. I 'TEMP,TEMP]"" S TEMP=$O(^ORD(101,"B",TEMP,0))
"RTN","HLCS2",21,0)
 .. I TEMP=PTR S EXCLUDE=1
"RTN","HLCS2",22,0)
 . Q:EXCLUDE
"RTN","HLCS2",23,0)
 . ; 
"RTN","HLCS2",24,0)
 . Q:LNK=""  I +LNK<1 S LNK=$O(^HLCS(870,"B",LNK,0)) Q:LNK<1
"RTN","HLCS2",25,0)
 . Q:'$D(^HLCS(870,LNK))
"RTN","HLCS2",26,0)
 . S CLIAP=$$PTR^HLUTIL2(PTR)
"RTN","HLCS2",27,0)
 . ; patch HL*1.6*122: add the 3rd component as receiving facility
"RTN","HLCS2",28,0)
 . ; S HLSUP("S",PTR,+LNK)=CLIAP_$S(CLIAP<1:U_HLL("LINKS",CNT),1:"")
"RTN","HLCS2",29,0)
 . S HLSUP("S",PTR,+LNK)=CLIAP_U_$S(CLIAP<1:HLL("LINKS",CNT),1:$P(HLL("LINKS",CNT),"^",3))
"RTN","HLCS2",30,0)
 Q
"RTN","HLCS2",31,0)
ADD ;Deliver message to supplemental client list.
"RTN","HLCS2",32,0)
 ;Invoked by HLTP before and after processing normal clients
"RTN","HLCS2",33,0)
 ;Only processes remote links. Local clients must be subscribing
"RTN","HLCS2",34,0)
 ;protocols.
"RTN","HLCS2",35,0)
 Q:'$D(HLSUP("S"))
"RTN","HLCS2",36,0)
 N HLTCP,HLTCPI,HLTCPO,ZHLEIDS,ZLCLIENT,ZLOGLINK,ZMTIENS
"RTN","HLCS2",37,0)
 S ZHLEIDS=0 F  S ZHLEIDS=$O(HLSUP("S",ZHLEIDS)) Q:ZHLEIDS<1  D
"RTN","HLCS2",38,0)
 .S ZLOGLINK=0 F  S ZLOGLINK=$O(HLSUP("S",ZHLEIDS,ZLOGLINK)) Q:ZLOGLINK<1  D
"RTN","HLCS2",39,0)
 ..S ZLCLIENT=+HLSUP("S",ZHLEIDS,ZLOGLINK)
"RTN","HLCS2",40,0)
 ..I ZLCLIENT<1 S:$G(HLERROR)="" HLERROR="15^Invalid Subscriber Protocol in HLL('LINKS'): "_$P(HLSUP("S",ZHLEIDS,ZLOGLINK),U,2,9) Q
"RTN","HLCS2",41,0)
 .. ; patch HL*1.6*122 start
"RTN","HLCS2",42,0)
 .. ; S HLOGLINK=ZLOGLINK D SEND^HLMA2(ZHLEIDS,HLMTIEN,ZLCLIENT,"D",.ZMTIENS,ZLOGLINK),STATUS^HLTF0(+ZMTIENS,1)
"RTN","HLCS2",43,0)
 .. S HLOGLINK=ZLOGLINK
"RTN","HLCS2",44,0)
 .. ; 3rd component for receiving facility
"RTN","HLCS2",45,0)
 .. S ZMTIENS("REC-FACILITY")=$P(HLSUP("S",ZHLEIDS,ZLOGLINK),U,3)
"RTN","HLCS2",46,0)
 .. D SEND^HLMA2(ZHLEIDS,HLMTIEN,ZLCLIENT,"D",.ZMTIENS,ZLOGLINK)
"RTN","HLCS2",47,0)
 .. D STATUS^HLTF0(+ZMTIENS,1)
"RTN","HLCS2",48,0)
 .. ; patch HL*1.6*122 end
"RTN","HLCS2",49,0)
 .. ;
"RTN","HLCS2",50,0)
 K HLL("LINKS"),HLSUP
"RTN","HLCS2",51,0)
 Q
"RTN","HLCS2",52,0)
STALL ;STOP ALL LINKS AND FILERS
"RTN","HLCS2",53,0)
 N DIR,Y
"RTN","HLCS2",54,0)
 W ! S DIR(0)="Y",DIR("A")="Okay to shut down all Links and Filers"
"RTN","HLCS2",55,0)
 D ^DIR
"RTN","HLCS2",56,0)
 I 'Y!($D(DIRUT))!($D(DUOUT)) W !!,"Shutdown Aborted!" Q
"RTN","HLCS2",57,0)
 W !,"Shutting down all Links and Filers..."
"RTN","HLCS2",58,0)
 D CLEAR
"RTN","HLCS2",59,0)
 D LLP(1)
"RTN","HLCS2",60,0)
 Q
"RTN","HLCS2",61,0)
QUE ;Restart Filers and AUTOSTART Logical Links after system re-boot
"RTN","HLCS2",62,0)
 N DIR,Y
"RTN","HLCS2",63,0)
 I '$D(ZTQUEUED) D  Q:'Y!($D(DIRUT))!($D(DUOUT))
"RTN","HLCS2",64,0)
 .W ! S DIR(0)="Y",DIR("A")="Shutdown and restart ALL AUTOSTART links and filers. Okay"
"RTN","HLCS2",65,0)
 .D ^DIR
"RTN","HLCS2",66,0)
 .I 'Y!($D(DIRUT))!($D(DUOUT)) W !!,"RESTART Aborted!" Q
"RTN","HLCS2",67,0)
 .W !,"Restarting all Autostart-Enabled Links and Filers..."
"RTN","HLCS2",68,0)
 D CLEAR
"RTN","HLCS2",69,0)
 D STARTF
"RTN","HLCS2",70,0)
 D LLP(0)
"RTN","HLCS2",71,0)
 D STRT
"RTN","HLCS2",72,0)
 Q
"RTN","HLCS2",73,0)
CLEAR ;Reset state of 869.3
"RTN","HLCS2",74,0)
 S DA(1)=1,DA=0,DIK="^HLCS(869.3,1,2,"
"RTN","HLCS2",75,0)
 F  S DA=$O(^HLCS(869.3,DA(1),2,DA)) Q:DA<1  D ^DIK
"RTN","HLCS2",76,0)
 S DA=0,DIK="^HLCS(869.3,1,3,"
"RTN","HLCS2",77,0)
 F  S DA=$O(^HLCS(869.3,DA(1),3,DA)) Q:DA<1  D ^DIK
"RTN","HLCS2",78,0)
 Q
"RTN","HLCS2",79,0)
STARTF ;Start filers
"RTN","HLCS2",80,0)
 ;Get Defaults
"RTN","HLCS2",81,0)
 N TMP,PTR,DEFCNT,DA,HLCNT,HLNODE1
"RTN","HLCS2",82,0)
 S PTR=+$O(^HLCS(869.3,0)) Q:'PTR
"RTN","HLCS2",83,0)
 ;default # of incoming filers
"RTN","HLCS2",84,0)
 S HLNODE1=$G(^HLCS(869.3,PTR,1)),DEFCNT=+$P(HLNODE1,U) S:'DEFCNT DEFCNT=1
"RTN","HLCS2",85,0)
 F HLCNT=1:1:DEFCNT S TMP=$$TASKFLR^HLCS1("IN")
"RTN","HLCS2",86,0)
 ;default # of outgoing filers
"RTN","HLCS2",87,0)
 S DEFCNT=+$P(HLNODE1,U,2) S:'DEFCNT DEFCNT=1
"RTN","HLCS2",88,0)
 F HLCNT=1:1:DEFCNT S TMP=$$TASKFLR^HLCS1("OUT")
"RTN","HLCS2",89,0)
 Q
"RTN","HLCS2",90,0)
LLP(ALL) ;Stop Logical Links
"RTN","HLCS2",91,0)
 ;ALL=1 OR 0 IF zero, only AUTOSTART LINKS get stopped
"RTN","HLCS2",92,0)
 N HLDP,HLDP0,HLPARM0,HLPARM4,HLJ,X,Y S HLDP=0
"RTN","HLCS2",93,0)
 F  S HLDP=$O(^HLCS(870,HLDP)) Q:'HLDP  S HLDP0=$G(^(HLDP,0)),X=+$P(HLDP0,U,3) D:X
"RTN","HLCS2",94,0)
 .;skip this link if not stopping all and Autostart not enabled
"RTN","HLCS2",95,0)
 . I 'ALL&('$P(HLDP0,U,6)) Q
"RTN","HLCS2",96,0)
 . S HLPARM4=$G(^HLCS(870,HLDP,400))
"RTN","HLCS2",97,0)
 . ; patch HL*1.6*122
"RTN","HLCS2",98,0)
 . ; TCP Multi listener: quit if TCP service as GT.M, DSM,
"RTN","HLCS2",99,0)
 . ; or Cache/VMS
"RTN","HLCS2",100,0)
 . ; patch HL*1.6*157
"RTN","HLCS2",101,0)
 . ; I $P(HLPARM4,U,3)="M" Q:^%ZOSF("OS")'["OpenM"  Q:$$OS^%ZOSV["VMS"
"RTN","HLCS2",102,0)
 . I $P(HLPARM4,U,3)="M" Q:^%ZOSF("OS")'["OpenM"  Q:($$OS^%ZOSV["VMS")!($$OS^%ZOSV["UNIX")
"RTN","HLCS2",103,0)
 . ;
"RTN","HLCS2",104,0)
 . ;4=status,10=Time Stopped,9=Time Started,11=Task Number,3=Device Type,14=shutdown?
"RTN","HLCS2",105,0)
 . S X="HLJ(870,"""_HLDP_","")",@X@(10)=$$NOW^XLFDT,(@X@(11),@X@(9))="@",@X@(14)=1
"RTN","HLCS2",106,0)
 . I "Shutdown,SHUTDOWN"'[$P(HLDP0,U,5) S @X@(4)="Halting"
"RTN","HLCS2",107,0)
 . I $P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4)),'$P(HLDP0,U,12) S @X@(4)="Shutdown"
"RTN","HLCS2",108,0)
 . D FILE^HLDIE("","HLJ","","LLP","HLCS2") ;HL*1.6*109
"RTN","HLCS2",109,0)
 . ; patch HL*1.6*157
"RTN","HLCS2",110,0)
 . ; I ^%ZOSF("OS")["OpenM",($P(HLPARM4,U,3)="M"!($P(HLPARM4,U,3)="S")) D
"RTN","HLCS2",111,0)
 . I ($P(HLPARM4,U,3)="M"!($P(HLPARM4,U,3)="S")) D
"RTN","HLCS2",112,0)
 .. ; pass task number to stop listener
"RTN","HLCS2",113,0)
 .. S:$P(HLDP0,U,12) X=$$ASKSTOP^%ZTLOAD(+$P(HLDP0,U,12))
"RTN","HLCS2",114,0)
 ; patch HL*1.6*122 start
"RTN","HLCS2",115,0)
 ; .. D CALL^%ZISTCP($P(HLPARM4,U),$P(HLPARM4,U,2),10)
"RTN","HLCS2",116,0)
 ; .. I POP D HOME^%ZIS Q
"RTN","HLCS2",117,0)
 ; .. D CLOSE^%ZISTCP
"RTN","HLCS2",118,0)
 ; patch HL*1.6*122 end
"RTN","HLCS2",119,0)
 Q
"RTN","HLCS2",120,0)
STRT ;Start Links
"RTN","HLCS2",121,0)
 N HLDP,HLDP0,HLDAPP,HLTYPTR,HLBGR,HLENV,HLPARAM0,HLPARM4,HLQUIT,ZTRTN,ZTDESC,ZTSK,ZTCPU
"RTN","HLCS2",122,0)
 S HLDP=0
"RTN","HLCS2",123,0)
 F  S HLDP=$O(^HLCS(870,HLDP)) Q:HLDP<1  S HLDP0=$G(^(HLDP,0)) D
"RTN","HLCS2",124,0)
 . S HLPARM4=$G(^HLCS(870,HLDP,400))
"RTN","HLCS2",125,0)
 . ;quit if no parameters or AUTOSTART is disabled
"RTN","HLCS2",126,0)
 . Q:'$P(HLDP0,U,6)
"RTN","HLCS2",127,0)
 . ;HLDAPP=LL name, HLTYPTR=LL type, HLBGR=routine, HLENV=environment check
"RTN","HLCS2",128,0)
 . S HLDAPP=$P(HLDP0,U),HLTYPTR=+$P(HLDP0,U,3),HLBGR=$G(^HLCS(869.1,HLTYPTR,100)),HLENV=$G(^(200))
"RTN","HLCS2",129,0)
 . ;quit if no LL type or no routine
"RTN","HLCS2",130,0)
 . Q:'HLTYPTR!(HLBGR="")
"RTN","HLCS2",131,0)
 . I HLENV'="" K HLQUIT X HLENV Q:$D(HLQUIT)
"RTN","HLCS2",132,0)
 . ; patch HL*1.6*122
"RTN","HLCS2",133,0)
 . ; TCP Multi listener: quit if TCP service as GT.M, DSM,
"RTN","HLCS2",134,0)
 . ; or Cache/VMS
"RTN","HLCS2",135,0)
 . ; patch HL*1.6*157
"RTN","HLCS2",136,0)
 . ; I $P(HLPARM4,U,3)="M" Q:^%ZOSF("OS")'["OpenM"  Q:$$OS^%ZOSV["VMS"
"RTN","HLCS2",137,0)
 . I $P(HLPARM4,U,3)="M" Q:^%ZOSF("OS")'["OpenM"  Q:($$OS^%ZOSV["VMS")!($$OS^%ZOSV["UNIX")
"RTN","HLCS2",138,0)
 . ;
"RTN","HLCS2",139,0)
 . I $P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4)) D  Q
"RTN","HLCS2",140,0)
 .. ;4=status 9=Time Started, 10=Time Stopped, 11=Task Number 
"RTN","HLCS2",141,0)
 .. ;14=Shutdown LLP, 3=Device Type, 18=Gross Errors
"RTN","HLCS2",142,0)
 .. N HLJ,X
"RTN","HLCS2",143,0)
 .. I $P(HLDP0,U,15)=0 Q
"RTN","HLCS2",144,0)
 .. L +^HLCS(870,HLDP,0):2
"RTN","HLCS2",145,0)
 .. E  Q
"RTN","HLCS2",146,0)
 .. S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCS2",147,0)
 .. S @X@(4)="Enabled",@X@(9)=$$NOW^XLFDT,@X@(14)=0
"RTN","HLCS2",148,0)
 .. D FILE^HLDIE("","HLJ","","STRT","HLCS2") ; HL*1.6*109
"RTN","HLCS2",149,0)
 .. L -^HLCS(870,HLDP,0)
"RTN","HLCS2",150,0)
 .. Q
"RTN","HLCS2",151,0)
 . S ZTRTN=$P(HLBGR," ",2),ZTIO="",ZTDTH=$H,HLTRACE=""
"RTN","HLCS2",152,0)
 . S ZTDESC=HLDAPP_" Low Level Protocol",ZTSAVE("HLDP")=""
"RTN","HLCS2",153,0)
 . ;get startup node
"RTN","HLCS2",154,0)
 . I $P(HLPARM4,U,6),$D(^%ZIS(14.7,+$P(HLPARM4,U,6),0)) S ZTCPU=$P(^(0),U)
"RTN","HLCS2",155,0)
 . D ^%ZTLOAD
"RTN","HLCS2",156,0)
 Q
"RTN","HLCS2",157,0)
SITEP ;Edit Site Parameters
"RTN","HLCS2",158,0)
 S DDSFILE=869.3,DA=1,DR="[HL SITE PARAMETERS]" D ^DDS
"RTN","HLCS2",159,0)
 Q
"RTN","HLCS2",160,0)
PARAM() ;Return HL7 site parameters
"RTN","HLCS2",161,0)
 ;HLPARAM=domain ien^domain name^production or test^institution ien^
"RTN","HLCS2",162,0)
 ;institution name^institution number^mail group ien^mail group name^
"RTN","HLCS2",163,0)
 ;purge completed messages^purge awaiting ack messages^purge all msgs^
"RTN","HLCS2",164,0)
 ;default retention
"RTN","HLCS2",165,0)
 N HLX,HLX4,HLX5,HLDOMP,HLDOMN,HLPROD,HLINSP,HLINSN,HLINSNM,HLMAILP,HLMAILN,HLPARAM,HLPRGAA,HLPRGALL,HLPRGCMP,HLDEFRET
"RTN","HLCS2",166,0)
 S HLX=$G(^HLCS(869.3,1,0))
"RTN","HLCS2",167,0)
 S HLX4=$G(^HLCS(869.3,1,4))
"RTN","HLCS2",168,0)
 S HLX5=$G(^HLCS(869.3,1,5))
"RTN","HLCS2",169,0)
 S HLDOMP=$P(HLX,U,2) I HLDOMP S HLDOMN=$P(^DIC(4.2,HLDOMP,0),U)
"RTN","HLCS2",170,0)
 S HLPROD=$P(HLX,U,3)
"RTN","HLCS2",171,0)
 S HLINSP=$P(HLX,U,4) I HLINSP S HLINSN=$P(^DIC(4,HLINSP,0),U),HLINSNM=$P($G(^DIC(4,HLINSP,99)),U)
"RTN","HLCS2",172,0)
 S HLMAILP=$P(HLX,U,5) I HLMAILP S HLMAILN=$P(^XMB(3.8,HLMAILP,0),U)
"RTN","HLCS2",173,0)
 S HLPRGCMP=$P(HLX4,U),HLPRGAA=$P(HLX4,U,2),HLPRGALL=$P(HLX4,U,3)
"RTN","HLCS2",174,0)
 S HLDEFRET=$P(HLX5,U)
"RTN","HLCS2",175,0)
 S HLPARAM=HLDOMP_U_$G(HLDOMN)_U_$G(HLPROD)_U_HLINSP_U_$G(HLINSN)_U_$G(HLINSNM)_U_HLMAILP_U_$G(HLMAILN)_U_HLPRGCMP_U_HLPRGAA_U_HLPRGALL_U_HLDEFRET
"RTN","HLCS2",176,0)
 Q HLPARAM
"RTN","HLCS2",177,0)
 ;
"RTN","HLCS2",178,0)
GETAPP(HLAPP) ;Function to Retrieve parameters pertaining to a specific sending or receiving application
"RTN","HLCS2",179,0)
 ;HLAPP=APPLICATION NAME OR IEN OF FILE 771
"RTN","HLCS2",180,0)
 ;Returns MAIL GROUP NAME^'a' or 'i' (active or inactive) 
"RTN","HLCS2",181,0)
 S HLAPP=$G(HLAPP)
"RTN","HLCS2",182,0)
 I HLAPP]"",'HLAPP S HLAPP=$O(^HL(771,"B",$E(HLAPP,1,30),0))
"RTN","HLCS2",183,0)
 I 'HLAPP Q ""
"RTN","HLCS2",184,0)
 I HLAPP S HLM=$P(^HL(771,HLAPP,0),U,4)
"RTN","HLCS2",185,0)
 I HLM S HLM=$P($G(^XMB(3.8,HLM,0)),U)
"RTN","HLCS2",186,0)
 Q $G(HLM)_U_$P(^HL(771,HLAPP,0),U,2)
"RTN","HLCSLNCH")
0^8^B50153575^B46750262
"RTN","HLCSLNCH",1,0)
HLCSLNCH ;ALB/MTC/JC - START AND STOP THE LLP ;08/08/2011  15:18
"RTN","HLCSLNCH",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**6,19,43,49,57,75,84,109,122,157**;Oct 13, 1995;Build 8
"RTN","HLCSLNCH",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSLNCH",4,0)
 ;
"RTN","HLCSLNCH",5,0)
 ;This program is callable from a menu
"RTN","HLCSLNCH",6,0)
 ;It allows the user to Start and Stop the Lower Layer
"RTN","HLCSLNCH",7,0)
 ;Protocol in the Background or in the foreground
"RTN","HLCSLNCH",8,0)
 ;
"RTN","HLCSLNCH",9,0)
 ;Required or Optional INPUT PARAMETERS
"RTN","HLCSLNCH",10,0)
 ;             None
"RTN","HLCSLNCH",11,0)
 ;
"RTN","HLCSLNCH",12,0)
 ;
"RTN","HLCSLNCH",13,0)
 ;Output variables
"RTN","HLCSLNCH",14,0)
 ;             HLDP=IEN of Logical Link in file #870
"RTN","HLCSLNCH",15,0)
 ;(optional)HLTRACE=if SET it launches the LLP in the Foreground
"RTN","HLCSLNCH",16,0)
 ;(optional)   ZTSK=if defined LLP was launched in the
"RTN","HLCSLNCH",17,0)
 ;background
"RTN","HLCSLNCH",18,0)
 ;
"RTN","HLCSLNCH",19,0)
 ;
"RTN","HLCSLNCH",20,0)
START ; Start up the lower level protocol
"RTN","HLCSLNCH",21,0)
 N DIC,DIRUT,DTOUT,DUOUT,HLDP,HLDAPP,HLJ,HLQUIT,HLTRACE
"RTN","HLCSLNCH",22,0)
 N HLPARM0,HLPARM4,HLTYPTR,HLBGR,X,Y,ZTCPU,ZTSK,ZTRTN,ZTDESC
"RTN","HLCSLNCH",23,0)
 W !!,"This option is used to launch the lower level protocol for the"
"RTN","HLCSLNCH",24,0)
 W !,"appropriate device.  Please select the node with which you want"
"RTN","HLCSLNCH",25,0)
 W !,"to communicate",!
"RTN","HLCSLNCH",26,0)
 ; patch HL*1.6*122
"RTN","HLCSLNCH",27,0)
 S POP=0
"RTN","HLCSLNCH",28,0)
 S DIC="^HLCS(870,",DIC(0)="QEAMZ" D ^DIC G:Y<0 STARTQ
"RTN","HLCSLNCH",29,0)
 S HLDP=+Y,HLDAPP=Y(0,0),HLTYPTR=+$P(Y(0),U,3),HLPARM0=Y(0)
"RTN","HLCSLNCH",30,0)
 ;-- check if parameter have been setup
"RTN","HLCSLNCH",31,0)
 ;-- check for LLP type
"RTN","HLCSLNCH",32,0)
 I 'HLTYPTR W !!,$C(7),"A Lower Layer Protocol must be selected before start-up can occur." G STARTQ
"RTN","HLCSLNCH",33,0)
 ;-- get TCP information
"RTN","HLCSLNCH",34,0)
 S HLPARM4=$G(^HLCS(870,HLDP,400))
"RTN","HLCSLNCH",35,0)
 ;-- get routine (background job for LLP)
"RTN","HLCSLNCH",36,0)
 S HLBGR=$G(^HLCS(869.1,HLTYPTR,100))
"RTN","HLCSLNCH",37,0)
 ;-- get environment check routine (HLQUIT should be defined in fails)
"RTN","HLCSLNCH",38,0)
 S HLENV=$G(^HLCS(869.1,HLTYPTR,200))
"RTN","HLCSLNCH",39,0)
 ;
"RTN","HLCSLNCH",40,0)
 I HLBGR="" W !!,$C(7),"No routine has been specified for this LLP." G STARTQ
"RTN","HLCSLNCH",41,0)
 ;
"RTN","HLCSLNCH",42,0)
 ;-- execute environment check routine if HLQUIT is defined then terminate
"RTN","HLCSLNCH",43,0)
 I HLENV'="" X HLENV G:$D(HLQUIT) STARTQ
"RTN","HLCSLNCH",44,0)
 ; patch HL*1.6*122 start
"RTN","HLCSLNCH",45,0)
 ; Multi-Servers: TCP service (GT.M, DSM, and Cache/VMS) is controlled
"RTN","HLCSLNCH",46,0)
 ; by the external service
"RTN","HLCSLNCH",47,0)
 ; patch HL*1.6*157, for Cache/UNIX for Linux
"RTN","HLCSLNCH",48,0)
 N HLOSYS
"RTN","HLCSLNCH",49,0)
 S HLOSYS=$$OS^%ZOSV
"RTN","HLCSLNCH",50,0)
 ; I $P(HLPARM4,U,3)="M",$S(^%ZOSF("OS")'["OpenM":1,1:$$OS^%ZOSV["VMS") D  G STARTQ
"RTN","HLCSLNCH",51,0)
 I $P(HLPARM4,U,3)="M",$S(^%ZOSF("OS")'["OpenM":1,1:(HLOSYS["VMS")!(HLOSYS["UNIX")) D  G STARTQ
"RTN","HLCSLNCH",52,0)
 . W !,$C(7),"This LLP is a multi-threaded server. It is controlled by external service, i.e. TCPIP/UCX. You must use the external service to start this LLP."
"RTN","HLCSLNCH",53,0)
 . Q
"RTN","HLCSLNCH",54,0)
 ; patch HL*1.6*122 end
"RTN","HLCSLNCH",55,0)
 ;
"RTN","HLCSLNCH",56,0)
 I $P(HLPARM0,U,10) W !,$C(7),"The LLP was last started on ",$$DAT2^HLUTIL1($P(HLPARM0,U,10)),"." G STP1:$P(HLPARM0,U,5)'="Error"
"RTN","HLCSLNCH",57,0)
 I $P(HLPARM0,U,11) W !,"The LLP was last shutdown on ",$$DAT2^HLUTIL1($P(HLPARM0,U,11)),"."
"RTN","HLCSLNCH",58,0)
 ; patch HL*1.6*122 start
"RTN","HLCSLNCH",59,0)
 ; comment out-should be taken care of by the code 2 line above
"RTN","HLCSLNCH",60,0)
 ; I $P(HLPARM0,U,5)'="Error",'($P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4))),$P(HLPARM0,U,10)]""&($P(HLPARM0,U,11)=""),$P(HLPARM0,U,12) W !,"The LLP appears to be online already !"
"RTN","HLCSLNCH",61,0)
 ; I $$TASK^HLUTIL1($P(HLPARM0,U,12)) D  G STARTQ
"RTN","HLCSLNCH",62,0)
 ; . W !,$C(7),"NOTE: The lower level protocol for this application is already running."
"RTN","HLCSLNCH",63,0)
 N HLTEMP
"RTN","HLCSLNCH",64,0)
 S HLTEMP=0
"RTN","HLCSLNCH",65,0)
 I $P(HLPARM0,U,12) D  G:HLTEMP STARTQ
"RTN","HLCSLNCH",66,0)
 . N ZTSK
"RTN","HLCSLNCH",67,0)
 . S ZTSK=$P(HLPARM0,U,12)
"RTN","HLCSLNCH",68,0)
 . D STAT^%ZTLOAD
"RTN","HLCSLNCH",69,0)
 . I "12"[ZTSK(1) D
"RTN","HLCSLNCH",70,0)
 .. W !,$C(7),"NOTE: The lower level protocol for this application is already running."
"RTN","HLCSLNCH",71,0)
 .. I '$P(^HLCS(870,HLDP,0),"^",10) S $P(^HLCS(870,HLDP,0),"^",10)=$$NOW^XLFDT
"RTN","HLCSLNCH",72,0)
 .. S HLTEMP=1
"RTN","HLCSLNCH",73,0)
 ; patch HL*1.6*122 end
"RTN","HLCSLNCH",74,0)
 I $P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4)) D  G STARTQ
"RTN","HLCSLNCH",75,0)
 .;4=status 9=Time Started, 10=Time Stopped, 11=Task Number
"RTN","HLCSLNCH",76,0)
 .;14=Shutdown LLP, 3=Device Type, 18=Gross Errors
"RTN","HLCSLNCH",77,0)
 .N HLJ,X
"RTN","HLCSLNCH",78,0)
 . ; patch HL*1.6*122-comment out
"RTN","HLCSLNCH",79,0)
 . ; I $P(HLPARM0,U,15)=0 W !,"This LLP is already enabled!" Q
"RTN","HLCSLNCH",80,0)
 .L +^HLCS(870,HLDP,0):2
"RTN","HLCSLNCH",81,0)
 .E  W !,$C(7),"Unable to enable this LLP !" Q
"RTN","HLCSLNCH",82,0)
 .S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCSLNCH",83,0)
 .S @X@(4)="Enabled",@X@(9)=$$NOW^XLFDT,@X@(14)=0
"RTN","HLCSLNCH",84,0)
 .D FILE^HLDIE("","HLJ","","START","HLCSLNCH") ;HL*1.6*109
"RTN","HLCSLNCH",85,0)
 .L -^HLCS(870,HLDP,0)
"RTN","HLCSLNCH",86,0)
 .W !,"This LLP has been enabled!"
"RTN","HLCSLNCH",87,0)
 .Q
"RTN","HLCSLNCH",88,0)
 I $P(HLPARM4,U,6),$D(^%ZIS(14.7,+$P(HLPARM4,U,6),0)) S ZTCPU=$P(^(0),U) W !,"This LLP will start on node ",ZTCPU," if it is run in the Background.",!
"RTN","HLCSLNCH",89,0)
 ;
"RTN","HLCSLNCH",90,0)
 ; patch HL*1.6*122 start, for tcp link
"RTN","HLCSLNCH",91,0)
 I HLTYPTR=4 D  Q
"RTN","HLCSLNCH",92,0)
 . S Y="B"
"RTN","HLCSLNCH",93,0)
 . D STARTJOB
"RTN","HLCSLNCH",94,0)
 ; patch HL*1.6*122 end
"RTN","HLCSLNCH",95,0)
 ;
"RTN","HLCSLNCH",96,0)
 W ! S DIR(0)="SM^F:FOREGROUND;B:BACKGROUND;Q:QUIT"
"RTN","HLCSLNCH",97,0)
 S DIR("A")="Method for running the receiver"
"RTN","HLCSLNCH",98,0)
 S DIR("B")="B"
"RTN","HLCSLNCH",99,0)
 S DIR("?",1)="Enter F for Foreground (and trace)"
"RTN","HLCSLNCH",100,0)
 S DIR("?",2)="      B for Background (normal) or"
"RTN","HLCSLNCH",101,0)
 S DIR("?")="      Q to quit without starting the receiver"
"RTN","HLCSLNCH",102,0)
 D ^DIR K DIR
"RTN","HLCSLNCH",103,0)
 Q:(Y=U)!(Y="Q")
"RTN","HLCSLNCH",104,0)
 ;
"RTN","HLCSLNCH",105,0)
STARTJOB ;
"RTN","HLCSLNCH",106,0)
 S HLX=$G(^HLCS(870,HLDP,0))
"RTN","HLCSLNCH",107,0)
 ;-- foreground
"RTN","HLCSLNCH",108,0)
 I Y="F" S HLTRACE=1 D  G STARTQ
"RTN","HLCSLNCH",109,0)
 . S $P(^HLCS(870,HLDP,0),"^",10)=$$NOW^XLFDT
"RTN","HLCSLNCH",110,0)
 . D MON^HLCSTCP("Start")
"RTN","HLCSLNCH",111,0)
 . X HLBGR
"RTN","HLCSLNCH",112,0)
 ;-- background
"RTN","HLCSLNCH",113,0)
 I Y="B" D  G STARTQ
"RTN","HLCSLNCH",114,0)
 . S ZTRTN=$P(HLBGR," ",2),HLTRACE="",ZTIO="",ZTDTH=$H
"RTN","HLCSLNCH",115,0)
 . S ZTDESC=HLDAPP_" Low Level Protocol",ZTSAVE("HLDP")=""
"RTN","HLCSLNCH",116,0)
 . D ^%ZTLOAD
"RTN","HLCSLNCH",117,0)
 . ; patch HL*1.6*122 start
"RTN","HLCSLNCH",118,0)
 . I $D(ZTSK) D
"RTN","HLCSLNCH",119,0)
 .. K HLTRACE
"RTN","HLCSLNCH",120,0)
 .. D MON^HLCSTCP("Tasked")
"RTN","HLCSLNCH",121,0)
 .. S $P(^HLCS(870,HLDP,0),"^",10)=$$NOW^XLFDT
"RTN","HLCSLNCH",122,0)
 . ; patch HL*1.6*122 end
"RTN","HLCSLNCH",123,0)
 . W !,$S($D(ZTSK):"Job was queued as "_ZTSK_".",1:"Unable to queue job.")
"RTN","HLCSLNCH",124,0)
 ;
"RTN","HLCSLNCH",125,0)
 Q
"RTN","HLCSLNCH",126,0)
 ;
"RTN","HLCSLNCH",127,0)
STARTQ ;
"RTN","HLCSLNCH",128,0)
 I $G(POP) W !,?5,"-Unable to Open the Device !",!,!,?6,"Check that Port is Logged Out, and that the",!,?6,"Lower Level Protocol is not Already Running."
"RTN","HLCSLNCH",129,0)
 Q
"RTN","HLCSLNCH",130,0)
 ;
"RTN","HLCSLNCH",131,0)
STOP ; Shut down a lower level protocol..
"RTN","HLCSLNCH",132,0)
 N DIC,DIRUT,DTOUT,DUOUT,HLDP,HLDAPP,HLJ,HLPARM0,HLPARM4,X,Y
"RTN","HLCSLNCH",133,0)
 W !!,"This option is used to shut down the lower level protocol for the"
"RTN","HLCSLNCH",134,0)
 W !,"appropriate device.  Please select the link which you would"
"RTN","HLCSLNCH",135,0)
 W !,"like to shutdown.",!
"RTN","HLCSLNCH",136,0)
 S DIC="^HLCS(870,",DIC(0)="QEAMZ" D ^DIC K DIC Q:Y<0
"RTN","HLCSLNCH",137,0)
 S HLDP=+Y,HLDAPP=Y(0,0),HLPARM0=Y(0),HLPARM4=$G(^HLCS(870,HLDP,400))
"RTN","HLCSLNCH",138,0)
 ; patch HL*1.6*122
"RTN","HLCSLNCH",139,0)
 ; Multi-Servers: TCP service (GT.M, DSM, and Cache/VMS) is controlled
"RTN","HLCSLNCH",140,0)
 ; by the external service
"RTN","HLCSLNCH",141,0)
 ; patch HL*1.6*157, for Cache/UNIX for Linux
"RTN","HLCSLNCH",142,0)
 N HLOSYS
"RTN","HLCSLNCH",143,0)
 S HLOSYS=$$OS^%ZOSV
"RTN","HLCSLNCH",144,0)
 ; I $P(HLPARM4,U,3)="M",$S(^%ZOSF("OS")'["OpenM":1,1:$$OS^%ZOSV["VMS") D  Q
"RTN","HLCSLNCH",145,0)
 I $P(HLPARM4,U,3)="M",$S(^%ZOSF("OS")'["OpenM":1,1:(HLOSYS["VMS")!(HLOSYS["UNIX")) D  Q
"RTN","HLCSLNCH",146,0)
 . W !,$C(7),"This LLP is a multi-threaded server. It is controlled by external service, i.e. TCPIP/UCX. You must use the external service to disable this LLP."
"RTN","HLCSLNCH",147,0)
 . Q
"RTN","HLCSLNCH",148,0)
 ;
"RTN","HLCSLNCH",149,0)
 I $P(HLPARM0,U,15) W !,$C(7),"The lower level protocol is already ",$P(HLPARM0,U,5),"." Q
"RTN","HLCSLNCH",150,0)
 I $P(HLPARM0,U,10) W !,$C(7),"The lower level protocol was started on ",$$DAT2^HLUTIL1($P(HLPARM0,U,10)),"."
"RTN","HLCSLNCH",151,0)
STP1 ;
"RTN","HLCSLNCH",152,0)
 W ! S DIR(0)="Y",DIR("A")="Okay to shut down this job" D ^DIR K DIR
"RTN","HLCSLNCH",153,0)
 I 'Y!($D(DIRUT))!($D(DUOUT)) W !!,"The job will not be shut down." Q
"RTN","HLCSLNCH",154,0)
S ;
"RTN","HLCSLNCH",155,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSLNCH",156,0)
 ;4=status,10=Time Stopped,9=Time Started,11=Task Number,3=Device Type,14=shutdown
"RTN","HLCSLNCH",157,0)
 S X="HLJ(870,"""_HLDP_","")",@X@(4)="Halting",@X@(10)=$$NOW^XLFDT,(@X@(11),@X@(9))="@",@X@(14)=1
"RTN","HLCSLNCH",158,0)
 I $P(HLPARM4,U,3)="C"&("N"[$P(HLPARM4,U,4)),'$P(HLPARM0,U,12) S @X@(4)="Shutdown"
"RTN","HLCSLNCH",159,0)
 D FILE^HLDIE("","HLJ","","STOP","HLCSLNCH") ; HL*1.6*109
"RTN","HLCSLNCH",160,0)
 ; patch HL*1.6*122 start
"RTN","HLCSLNCH",161,0)
 ; I ^%ZOSF("OS")["OpenM",(($P(HLPARM4,U,3)="M"&($$OS^%ZOSV'["VMS"))!($P(HLPARM4,U,3)="S")) D
"RTN","HLCSLNCH",162,0)
 ; I ^%ZOSF("OS")'["DSM",(($P(HLPARM4,U,3)="M"&($$OS^%ZOSV'["VMS"))!($P(HLPARM4,U,3)="S")) D
"RTN","HLCSLNCH",163,0)
 ; patch HL*1.6*157, for Cache/UNIX for Linux
"RTN","HLCSLNCH",164,0)
 N HLOSYS
"RTN","HLCSLNCH",165,0)
 S HLOSYS=$$OS^%ZOSV
"RTN","HLCSLNCH",166,0)
 ; I ($P(HLPARM4,U,3)="S")!(($P(HLPARM4,U,3)="M")&($S(^%ZOSF("OS")'["OpenM":0,1:$$OS^%ZOSV'["VMS"))) D
"RTN","HLCSLNCH",167,0)
 I ($P(HLPARM4,U,3)="S")!(($P(HLPARM4,U,3)="M")&($S(^%ZOSF("OS")'["OpenM":0,1:((HLOSYS'["VMS")&(HLOSYS'["UNIX"))))) D
"RTN","HLCSLNCH",168,0)
 . ; patch HL*1.6*157 end
"RTN","HLCSLNCH",169,0)
 . ;pass task number to stop listener
"RTN","HLCSLNCH",170,0)
 . S:$P(HLPARM0,U,12) X=$$ASKSTOP^%ZTLOAD(+$P(HLPARM0,U,12))
"RTN","HLCSLNCH",171,0)
 . ; D CALL^%ZISTCP($P(HLPARM4,U),$P(HLPARM4,U,2),10)
"RTN","HLCSLNCH",172,0)
 . ; I POP D HOME^%ZIS U IO W !,"Unable to shutdown logical link!!!",$C(7),$C(7) Q
"RTN","HLCSLNCH",173,0)
 . ; U IO W "**STOP**"
"RTN","HLCSLNCH",174,0)
 . ; W !
"RTN","HLCSLNCH",175,0)
 . ; D CLOSE^%ZISTCP
"RTN","HLCSLNCH",176,0)
 . ; patch HL*1.6*122 end
"RTN","HLCSLNCH",177,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSLNCH",178,0)
 W !,"The job for the "_HLDAPP_" Lower Level Protocol will be shut down."
"RTN","HLCSLNCH",179,0)
 Q
"RTN","HLCSLNCH",180,0)
 ;
"RTN","HLCSLNCH",181,0)
STOPQ Q
"RTN","HLCSTCP")
0^5^B50599894^B47334373
"RTN","HLCSTCP",1,0)
HLCSTCP ;SFIRMFO/TNV-ALB/JFP,PKE - (TCP/IP) MLLP ;08/08/2011 14:29
"RTN","HLCSTCP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,49,57,58,64,84,109,133,122,140,157**;Oct 13, 1995;Build 8
"RTN","HLCSTCP",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP",4,0)
 ;
"RTN","HLCSTCP",5,0)
 ; This is an implementation of the HL7 Minimal Lower Layer Protocol
"RTN","HLCSTCP",6,0)
 ; taskman entry/startup option, HLDP defined in menu entry.
"RTN","HLCSTCP",7,0)
 ;
"RTN","HLCSTCP",8,0)
 Q:'$D(HLDP)
"RTN","HLCSTCP",9,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP",10,0)
 L +^HLCS("HLTCPLINK",HLDP):5 I '$T D  Q
"RTN","HLCSTCP",11,0)
 . D MON^HLCSTCP("TskLcked")
"RTN","HLCSTCP",12,0)
 N HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET
"RTN","HLCSTCP",13,0)
 N HLZRULE
"RTN","HLCSTCP",14,0)
 ;HLCSOUT= 1-error
"RTN","HLCSTCP",15,0)
 I '$$INIT D EXITS("Init Error") Q
"RTN","HLCSTCP",16,0)
 S HLDP("$J")=$J
"RTN","HLCSTCP",17,0)
 S HLDP("$J",0,"LENGTH")=$L(HLDP("$J"))
"RTN","HLCSTCP",18,0)
 ; Start the client
"RTN","HLCSTCP",19,0)
 I $G(HLTCPCS)="C" D  Q
"RTN","HLCSTCP",20,0)
 . S HLDP("$J",0,"START")=HLDP("$J",0,"LENGTH")-8+$L(HLTCPORT)+$L(HLDP)
"RTN","HLCSTCP",21,0)
 . I HLDP("$J",0,"START")<1 S HLDP("$J",0,"START")=1
"RTN","HLCSTCP",22,0)
 . S HLDP("$J",0)=$E(HLDP("$J"),HLDP("$J",0,"START"),HLDP("$J",0,"LENGTH"))
"RTN","HLCSTCP",23,0)
 . ; identify process for ^%SY
"RTN","HLCSTCP",24,0)
 . ; D SETNM^%ZOSV($E("HLClnt:"_HLDP,1,15))
"RTN","HLCSTCP",25,0)
 . D SETNM^%ZOSV($E("HLc:"_HLTCPORT_"-"_HLDP_"-"_HLDP("$J",0),1,15))
"RTN","HLCSTCP",26,0)
 . K HLDP("$J",0)
"RTN","HLCSTCP",27,0)
 . D ST1
"RTN","HLCSTCP",28,0)
 . F  D ^HLCSTCP2 Q:$$STOP!$G(HLCSOUT)
"RTN","HLCSTCP",29,0)
 . ; I $G(HLCSOUT)=1 D MON("Error") H 1 Q
"RTN","HLCSTCP",30,0)
 . I $G(HLCSOUT)=1 D  Q
"RTN","HLCSTCP",31,0)
 .. D MON("Error") H 1
"RTN","HLCSTCP",32,0)
 .. L -^HLCS("HLTCPLINK",HLDP)
"RTN","HLCSTCP",33,0)
 . I $G(HLCSOUT)=2 D EXITS("Inactive") Q
"RTN","HLCSTCP",34,0)
 . D EXITS("Shutdown")
"RTN","HLCSTCP",35,0)
 ;
"RTN","HLCSTCP",36,0)
 S HLDP("$J",0,"START")=HLDP("$J",0,"LENGTH")-9+$L(HLTCPORT)
"RTN","HLCSTCP",37,0)
 I HLDP("$J",0,"START")<1 S HLDP("$J",0,"START")=1
"RTN","HLCSTCP",38,0)
 S HLDP("$J",0)=$E(HLDP("$J"),HLDP("$J",0,"START"),HLDP("$J",0,"LENGTH"))
"RTN","HLCSTCP",39,0)
 ; identify process for ^%SY
"RTN","HLCSTCP",40,0)
 ; D SETNM^%ZOSV($E("HLSrv:"_HLDP,1,15))
"RTN","HLCSTCP",41,0)
 D SETNM^%ZOSV($E("HLs:"_HLTCPORT_"-"_HLDP("$J",0),1,15))
"RTN","HLCSTCP",42,0)
 K HLDP("$J",0)
"RTN","HLCSTCP",43,0)
 ; to stop the listener via updated Kernel API, need to pass the
"RTN","HLCSTCP",44,0)
 ; listener logical link (HLDP)
"RTN","HLCSTCP",45,0)
 S HLZRULE="S HLDP="_HLDP_" S ZISQUIT=$$STOP^HLCSTCP"
"RTN","HLCSTCP",46,0)
 ;single threaded listener
"RTN","HLCSTCP",47,0)
 I $G(HLTCPCS)="S" D  Q
"RTN","HLCSTCP",48,0)
 . D ST1,MON("Listen"),LISTEN^%ZISTCP(HLTCPORT,"SERVER^HLCSTCP("""_HLDP_""")",HLZRULE)
"RTN","HLCSTCP",49,0)
 . I $$STOP D EXITS("Shutdown") Q
"RTN","HLCSTCP",50,0)
 . D EXITS("Openfail")
"RTN","HLCSTCP",51,0)
 ;
"RTN","HLCSTCP",52,0)
 ; multi-threaded listener code (for OpenM/NT)
"RTN","HLCSTCP",53,0)
 I ($G(HLTCPCS)'="M")!(^%ZOSF("OS")'["OpenM") D  Q
"RTN","HLCSTCP",54,0)
 . L -^HLCS("HLTCPLINK",HLDP)
"RTN","HLCSTCP",55,0)
 ; patch HL*1.6*157
"RTN","HLCSTCP",56,0)
 ; I $$OS^%ZOSV["VMS" L -^HLCS("HLTCPLINK",HLDP) Q
"RTN","HLCSTCP",57,0)
 I ($$OS^%ZOSV["VMS")!($$OS^%ZOSV["UNIX") L -^HLCS("HLTCPLINK",HLDP) Q
"RTN","HLCSTCP",58,0)
 D ST1,MON("Listen"),LISTEN^%ZISTCPS(HLTCPORT,"SERVERS^HLCSTCP("""_HLDP_""")",HLZRULE)
"RTN","HLCSTCP",59,0)
 ; update status of listener
"RTN","HLCSTCP",60,0)
 I $$STOP D EXITS("Shutdown") Q
"RTN","HLCSTCP",61,0)
 D EXITS("Openfail")
"RTN","HLCSTCP",62,0)
 ; HL*1.6*122 end
"RTN","HLCSTCP",63,0)
 Q
"RTN","HLCSTCP",64,0)
 ;
"RTN","HLCSTCP",65,0)
SERVER(HLDP) ; single server using Taskman
"RTN","HLCSTCP",66,0)
 I '$$INIT D EXITS("Init error") Q
"RTN","HLCSTCP",67,0)
 D ^HLCSTCP1
"RTN","HLCSTCP",68,0)
 I $$STOP D CLOSE^%ZISTCP,EXITS("Shutdown") S IO("C")="" Q
"RTN","HLCSTCP",69,0)
 Q:$G(HLCSOUT)=1
"RTN","HLCSTCP",70,0)
 D MON("Idle")
"RTN","HLCSTCP",71,0)
 Q
"RTN","HLCSTCP",72,0)
 ;
"RTN","HLCSTCP",73,0)
SERVERS(HLDP) ; Multi-threaded server using Taskman
"RTN","HLCSTCP",74,0)
 I '$$INIT D EXITS("Init error") Q
"RTN","HLCSTCP",75,0)
 G LISTEN
"RTN","HLCSTCP",76,0)
 ;
"RTN","HLCSTCP",77,0)
 ;multiple process servers, called from an external utility
"RTN","HLCSTCP",78,0)
MSM ;MSM entry point, called from User-Defined Services
"RTN","HLCSTCP",79,0)
 ;HLDP=ien in the HL LOWER LEVEL PROTOCOL PARAMETER file for the
"RTN","HLCSTCP",80,0)
 ;HL7 Multi-Threaded SERVER
"RTN","HLCSTCP",81,0)
 S (IO,IO(0))=$P
"RTN","HLCSTCP",82,0)
 G LISTEN
"RTN","HLCSTCP",83,0)
 ;
"RTN","HLCSTCP",84,0)
LISTEN ;
"RTN","HLCSTCP",85,0)
 N HLLSTN,HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT,HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET
"RTN","HLCSTCP",86,0)
 I '$$INIT D ^%ZTER Q
"RTN","HLCSTCP",87,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP",88,0)
 S HLDP("$J")=$J
"RTN","HLCSTCP",89,0)
 S HLDP("$J",0,"LENGTH")=$L(HLDP("$J"))
"RTN","HLCSTCP",90,0)
 S HLDP("$J",0,"START")=HLDP("$J",0,"LENGTH")-9+$L(HLTCPORT)
"RTN","HLCSTCP",91,0)
 I HLDP("$J",0,"START")<1 S HLDP("$J",0,"START")=1
"RTN","HLCSTCP",92,0)
 S HLDP("$J",0)=$E(HLDP("$J"),HLDP("$J",0,"START"),HLDP("$J",0,"LENGTH"))
"RTN","HLCSTCP",93,0)
 ; identify process for ^%SY
"RTN","HLCSTCP",94,0)
 ; D SETNM^%ZOSV($E("HLSrv:"_HLDP,1,15))
"RTN","HLCSTCP",95,0)
 D SETNM^%ZOSV($E("HLs:"_HLTCPORT_"-"_HLDP("$J",0),1,15))
"RTN","HLCSTCP",96,0)
 K HLDP("$J",0)
"RTN","HLCSTCP",97,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP",98,0)
 ;HLLSTN used to identify a listener to tag MON
"RTN","HLCSTCP",99,0)
 S HLLSTN=1
"RTN","HLCSTCP",100,0)
 ;increment job count, run server
"RTN","HLCSTCP",101,0)
 D UPDT(1),^HLCSTCP1,EXITM
"RTN","HLCSTCP",102,0)
 Q
"RTN","HLCSTCP",103,0)
 ;
"RTN","HLCSTCP",104,0)
DCOPEN(HLDP) ;open direct connect - called from HLMA2
"RTN","HLCSTCP",105,0)
 Q:'$$INIT 0
"RTN","HLCSTCP",106,0)
 Q:HLTCPADD=""!(HLTCPORT="") 0
"RTN","HLCSTCP",107,0)
 Q:'$$OPEN^HLCSTCP2 0
"RTN","HLCSTCP",108,0)
 Q 1
"RTN","HLCSTCP",109,0)
 ;
"RTN","HLCSTCP",110,0)
INIT() ; Initialize Variables
"RTN","HLCSTCP",111,0)
 ; HLDP should be set to the IEN or name of Logical Link, file 870
"RTN","HLCSTCP",112,0)
 ; patch HL*1.6*157
"RTN","HLCSTCP",113,0)
 ; S HLOS=$P($G(^%ZOSF("OS")),"^")
"RTN","HLCSTCP",114,0)
 S HLOS=$$OS^%ZOSV
"RTN","HLCSTCP",115,0)
 N DA,DIQUIET,DR,TMP,X,Y
"RTN","HLCSTCP",116,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP",117,0)
 ; S IOF=$$FLUSHCHR^%ZISTCP ; HL*1.6*122 set device flush character
"RTN","HLCSTCP",118,0)
 S HLTCPLNK("IOF")=$$FLUSHCHR^%ZISTCP
"RTN","HLCSTCP",119,0)
 S DIQUIET=1
"RTN","HLCSTCP",120,0)
 D DT^DICRW
"RTN","HLCSTCP",121,0)
 I 'HLDP S HLDP=$O(^HLCS(870,"B",HLDP,0)) I 'HLDP Q 0
"RTN","HLCSTCP",122,0)
 S DA=HLDP
"RTN","HLCSTCP",123,0)
 ; patch HL*1.6*122 for field 400.09
"RTN","HLCSTCP",124,0)
 S DR="200.02;200.021;200.022;200.03;200.04;200.05;200.09;400.01;400.02;400.03;400.04;400.05;400.09"
"RTN","HLCSTCP",125,0)
 D GETS^DIQ(870,DA,DR,"IN","TMP","TMP")
"RTN","HLCSTCP",126,0)
 ;
"RTN","HLCSTCP",127,0)
 I $D(TMP("DIERR")) QUIT 0
"RTN","HLCSTCP",128,0)
 ; -- re-transmit attempts
"RTN","HLCSTCP",129,0)
 S HLDRETR=+$G(TMP(870,DA_",",200.02,"I"))
"RTN","HLCSTCP",130,0)
 S HLDRETR("CLOSE")=+$G(TMP(870,DA_",",200.022,"I"))
"RTN","HLCSTCP",131,0)
 ; -- exceed re-transmit action
"RTN","HLCSTCP",132,0)
 S HLRETRA=$G(TMP(870,DA_",",200.021,"I"))
"RTN","HLCSTCP",133,0)
 ; -- block size
"RTN","HLCSTCP",134,0)
 S HLDBSIZE=+$G(TMP(870,DA_",",200.03,"I"))
"RTN","HLCSTCP",135,0)
 ; -- read timeout
"RTN","HLCSTCP",136,0)
 S HLDREAD=+$G(TMP(870,DA_",",200.04,"I"))
"RTN","HLCSTCP",137,0)
 ; -- ack timeout
"RTN","HLCSTCP",138,0)
 S HLDBACK=+$G(TMP(870,DA_",",200.05,"I"))
"RTN","HLCSTCP",139,0)
 ; -- uni-directional wait
"RTN","HLCSTCP",140,0)
 S HLDWAIT=$G(TMP(870,DA_",",200.09,"I"))
"RTN","HLCSTCP",141,0)
 ; -- tcp address
"RTN","HLCSTCP",142,0)
 S HLTCPADD=$G(TMP(870,DA_",",400.01,"I"))
"RTN","HLCSTCP",143,0)
 ; -- tcp port
"RTN","HLCSTCP",144,0)
 S HLTCPORT=$G(TMP(870,DA_",",400.02,"I"))
"RTN","HLCSTCP",145,0)
 ; -- tcp/ip service type
"RTN","HLCSTCP",146,0)
 S HLTCPCS=$G(TMP(870,DA_",",400.03,"I"))
"RTN","HLCSTCP",147,0)
 ; -- link persistence
"RTN","HLCSTCP",148,0)
 S HLTCPLNK=$G(TMP(870,DA_",",400.04,"I"))
"RTN","HLCSTCP",149,0)
 ; -- retention
"RTN","HLCSTCP",150,0)
 S HLTCPRET=$G(TMP(870,DA_",",400.05,"I"))
"RTN","HLCSTCP",151,0)
 ;
"RTN","HLCSTCP",152,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP",153,0)
 ; patch HL*1.6*122 for field 400.09
"RTN","HLCSTCP",154,0)
 ; -- tcp/ip openfail timeout
"RTN","HLCSTCP",155,0)
 ; S HLTCPLNK("TIMEOUT")=$G(TMP(870,DA_",",400.09,"I"))
"RTN","HLCSTCP",156,0)
 S HLTCPLNK("TIMEOUT")=+$G(TMP(870,DA_",",400.09,"I"))
"RTN","HLCSTCP",157,0)
 ;
"RTN","HLCSTCP",158,0)
 ; -- set defaults in case something's not set
"RTN","HLCSTCP",159,0)
 S:HLDREAD=0 HLDREAD=10
"RTN","HLCSTCP",160,0)
 S:HLDBACK=0 HLDBACK=60
"RTN","HLCSTCP",161,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP",162,0)
 ; S:HLDBSIZE=0 HLDBSIZE=245
"RTN","HLCSTCP",163,0)
 S:HLDBSIZE<245 HLDBSIZE=245
"RTN","HLCSTCP",164,0)
 S:HLDRETR=0 HLDRETR=5
"RTN","HLCSTCP",165,0)
 S:HLTCPRET="" X=$P($$PARAM^HLCS2,U,12),HLTCPRET=$S(X:X,1:15)
"RTN","HLCSTCP",166,0)
 ;
"RTN","HLCSTCP",167,0)
 ; patch HL*1.6*140, the defaut is 30
"RTN","HLCSTCP",168,0)
 ; patch HL*1.6*122 for field 400.09
"RTN","HLCSTCP",169,0)
 ; S:HLTCPLNK("TIMEOUT")=0 HLTCPLNK("TIMEOUT")=5
"RTN","HLCSTCP",170,0)
 S:(HLTCPLNK("TIMEOUT")<1) HLTCPLNK("TIMEOUT")=30
"RTN","HLCSTCP",171,0)
 ;
"RTN","HLCSTCP",172,0)
 Q 1
"RTN","HLCSTCP",173,0)
 ;
"RTN","HLCSTCP",174,0)
ST1 ;record startup in 870 for single server
"RTN","HLCSTCP",175,0)
 ;4=status 9=Time Started, 10=Time Stopped, 11=Task Number 
"RTN","HLCSTCP",176,0)
 ;14=Shutdown LLP, 3=LLP Online, 18=Gross Errors
"RTN","HLCSTCP",177,0)
 N HLJ,X
"RTN","HLCSTCP",178,0)
 ; HL*1.6*122 remove unnecessary locks
"RTN","HLCSTCP",179,0)
 ;F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",180,0)
 S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCSTCP",181,0)
 S @X@(4)="Init",(@X@(10),@X@(18))="@",@X@(14)=0
"RTN","HLCSTCP",182,0)
 I HLTCPCS["C" S @X@(3)=$S(HLTCPLNK["Y":"PC",1:"NC")
"RTN","HLCSTCP",183,0)
 E  S @X@(3)=$S(HLTCPCS["S":"SS",HLTCPCS["M":"MS",1:"")
"RTN","HLCSTCP",184,0)
 I @X@(3)'="NC" S @X@(9)=$$NOW^XLFDT
"RTN","HLCSTCP",185,0)
 S:$G(ZTSK) @X@(11)=ZTSK
"RTN","HLCSTCP",186,0)
 D FILE^HLDIE("","HLJ","","ST1","HLCSTCP") ;HL*1.6*109
"RTN","HLCSTCP",187,0)
 ;L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",188,0)
 Q
"RTN","HLCSTCP",189,0)
 ;
"RTN","HLCSTCP",190,0)
MON(Y) ;Display current state & check for shutdown
"RTN","HLCSTCP",191,0)
 ;don't display for multiple server
"RTN","HLCSTCP",192,0)
 Q:$G(HLLSTN)
"RTN","HLCSTCP",193,0)
 ; HL*1.6*122 remove unnecessary locks
"RTN","HLCSTCP",194,0)
 ;F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",195,0)
 S $P(^HLCS(870,HLDP,0),U,5)=Y
"RTN","HLCSTCP",196,0)
 ;L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",197,0)
 Q:'$D(HLTRACE)
"RTN","HLCSTCP",198,0)
 N X U IO(0)
"RTN","HLCSTCP",199,0)
 W !,"IN State: ",Y
"RTN","HLCSTCP",200,0)
 I '$$STOP D
"RTN","HLCSTCP",201,0)
 . ; patch HL*1.6*122
"RTN","HLCSTCP",202,0)
 . ; R !,"Type Q to Quit: ",X#1:1
"RTN","HLCSTCP",203,0)
 . R !,"Type Q to Quit: ",X:1
"RTN","HLCSTCP",204,0)
 . ; I $L(X),"Qq"[X S $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP",205,0)
 . I $L(X),"Qq"[$E(X) S $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP",206,0)
 . ; patch HL*1.6*122 end
"RTN","HLCSTCP",207,0)
 U IO
"RTN","HLCSTCP",208,0)
 Q
"RTN","HLCSTCP",209,0)
UPDT(Y) ;update job count for multiple servers,X=1 increment
"RTN","HLCSTCP",210,0)
 N HLJ,X
"RTN","HLCSTCP",211,0)
 ;
"RTN","HLCSTCP",212,0)
 ; HL*1.6*122 start
"RTN","HLCSTCP",213,0)
 ; F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",214,0)
 Q:'$G(HLDP)
"RTN","HLCSTCP",215,0)
 Q:'$D(^HLCS(870,"E","M",HLDP))
"RTN","HLCSTCP",216,0)
 F  L +^HLCS(870,HLDP,0):10 Q:$T  H 1
"RTN","HLCSTCP",217,0)
 ; S X=+$P(^HLCS(870,HLDP,0),U,5),$P(^(0),U,5)=$S(Y:X+1,1:X-1)_" server"
"RTN","HLCSTCP",218,0)
 S X=+$P(^HLCS(870,HLDP,0),U,5)
"RTN","HLCSTCP",219,0)
 I X<0 S X=0
"RTN","HLCSTCP",220,0)
 S $P(^HLCS(870,HLDP,0),U,5)=$S(Y:(X+1),X<1:0,1:X-1)_" server"
"RTN","HLCSTCP",221,0)
 ;if incrementing, set the Device Type field to Multi-Server
"RTN","HLCSTCP",222,0)
 ; I X S HLJ(870,HLDP_",",3)="MS" D FILE^HLDIE("","HLJ","","UPDT","HLCSTCP")
"RTN","HLCSTCP",223,0)
 I $P(^HLCS(870,HLDP,0),"^",4)']"" S $P(^HLCS(870,HLDP,0),"^",4)="MS"
"RTN","HLCSTCP",224,0)
 ; HL*1.6*122 end
"RTN","HLCSTCP",225,0)
 ;
"RTN","HLCSTCP",226,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",227,0)
 Q
"RTN","HLCSTCP",228,0)
STOP() ;stop flag set
"RTN","HLCSTCP",229,0)
 N X
"RTN","HLCSTCP",230,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",231,0)
 S X=+$P(^HLCS(870,HLDP,0),U,15)
"RTN","HLCSTCP",232,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",233,0)
 Q X
"RTN","HLCSTCP",234,0)
 ;
"RTN","HLCSTCP",235,0)
LLCNT(DP,Y,Z) ;update Logical Link counters
"RTN","HLCSTCP",236,0)
 ;DP=ien of Logical Link in file 870
"RTN","HLCSTCP",237,0)
 ;Y: 1=msg rec, 2=msg proc, 3=msg to send, 4=msg sent
"RTN","HLCSTCP",238,0)
 ;Z: ""=add to counter, 1=subtract from counter
"RTN","HLCSTCP",239,0)
 Q:'$D(^HLCS(870,+$G(DP),0))!('$G(Y))
"RTN","HLCSTCP",240,0)
 N P,X
"RTN","HLCSTCP",241,0)
 S P=$S(Y<3:"IN",1:"OUT")_" QUEUE "_$S(Y#2:"BACK",1:"FRONT")_" POINTER"
"RTN","HLCSTCP",242,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP",243,0)
 ; F  L +^HLCS(870,DP,P):2 Q:$T
"RTN","HLCSTCP",244,0)
 ; S X=+$G(^HLCS(870,DP,P)),^(P)=X+$S($G(Z):-1,1:1)
"RTN","HLCSTCP",245,0)
 ; patch HL*1.6*157 start
"RTN","HLCSTCP",246,0)
 ; adds call $$OS^%ZOSV
"RTN","HLCSTCP",247,0)
 I '$L($G(OS)) N OS S OS=$G(^%ZOSF("OS"))
"RTN","HLCSTCP",248,0)
 I '$L($G(HLOSYS)) N HLOSYS S HLOSYS=$$OS^%ZOSV
"RTN","HLCSTCP",249,0)
 ; I OS'["DSM",OS'["OpenM" D
"RTN","HLCSTCP",250,0)
 I OS'["DSM",OS'["OpenM",(OS["OpenM")&((HLOSYS'["VMS")&(HLOSYS'["UNIX")) D
"RTN","HLCSTCP",251,0)
 . ; patch HL*1.6*157 end
"RTN","HLCSTCP",252,0)
 . F  L +^HLCS(870,DP,P):10 Q:$T  H 1
"RTN","HLCSTCP",253,0)
 . S X=+$G(^HLCS(870,DP,P)),^(P)=X+$S($G(Z):-1,1:1)
"RTN","HLCSTCP",254,0)
 . L -^HLCS(870,DP,P)
"RTN","HLCSTCP",255,0)
 E  D
"RTN","HLCSTCP",256,0)
 . S X=$I(^HLCS(870,DP,P),$S($G(Z):-1,1:1))
"RTN","HLCSTCP",257,0)
 ; L -^HLCS(870,DP,P)
"RTN","HLCSTCP",258,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP",259,0)
 Q
"RTN","HLCSTCP",260,0)
SDFLD ; set Shutdown? field to yes
"RTN","HLCSTCP",261,0)
 Q:'$G(HLDP)
"RTN","HLCSTCP",262,0)
 ; HL*1.6*122 remove unnecessary lock and call to FM
"RTN","HLCSTCP",263,0)
 S $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP",264,0)
 ;N HLJ,X
"RTN","HLCSTCP",265,0)
 ;F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",266,0)
 ;14=Shutdown LLP?
"RTN","HLCSTCP",267,0)
 ;S HLJ(870,HLDP_",",14)=1
"RTN","HLCSTCP",268,0)
 ;D FILE^HLDIE("","HLJ","","SDFLD","HLCSTCP") ;HL*1.6*109
"RTN","HLCSTCP",269,0)
 ;L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",270,0)
 Q
"RTN","HLCSTCP",271,0)
 ;
"RTN","HLCSTCP",272,0)
EXITS(Y) ; shutdown and clean up the listener process for either
"RTN","HLCSTCP",273,0)
 ; single-threaded or multi-threaded
"RTN","HLCSTCP",274,0)
 N HLJ,X
"RTN","HLCSTCP",275,0)
 F  L +^HLCS(870,HLDP,0):2 Q:$T
"RTN","HLCSTCP",276,0)
 ;4=status,10=Time Stopped,9=Time Started,11=Task Number
"RTN","HLCSTCP",277,0)
 S X="HLJ(870,"""_HLDP_","")"
"RTN","HLCSTCP",278,0)
 S @X@(4)=Y,@X@(11)="@"
"RTN","HLCSTCP",279,0)
 S:$G(HLCSOUT)'=2 @X@(10)=$$NOW^XLFDT,@X@(9)="@"
"RTN","HLCSTCP",280,0)
 D FILE^HLDIE("","HLJ","","EXITS","HLCSTCP") ; HL*1.6*109
"RTN","HLCSTCP",281,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSTCP",282,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLCSTCP",283,0)
 ; HL*1.6*122
"RTN","HLCSTCP",284,0)
 L -^HLCS("HLTCPLINK",HLDP)
"RTN","HLCSTCP",285,0)
 Q
"RTN","HLCSTCP",286,0)
 ;
"RTN","HLCSTCP",287,0)
EXITM ;Multiple service shutdown and clean up
"RTN","HLCSTCP",288,0)
 ; shutdown and clean up a connection spawned by the listener
"RTN","HLCSTCP",289,0)
 ; process for a multi-threaded listener
"RTN","HLCSTCP",290,0)
 D UPDT(0)
"RTN","HLCSTCP",291,0)
 I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLCSTCP",292,0)
 Q
"RTN","HLCSTCP2")
0^7^B87468876^B83851505
"RTN","HLCSTCP2",1,0)
HLCSTCP2 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;08/04/2011 16:27
"RTN","HLCSTCP2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,49,57,63,64,66,67,76,77,87,109,133,122,140,142,145,153,157**;Oct 13,1995;Build 8
"RTN","HLCSTCP2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP2",4,0)
 ;Sender 
"RTN","HLCSTCP2",5,0)
 ;Request connection, send outbound message(s) delimited by MLLP
"RTN","HLCSTCP2",6,0)
 ;Input : HLDP=Logical Link to use
"RTN","HLCSTCP2",7,0)
 ; Set up error trap
"RTN","HLCSTCP2",8,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",9,0)
 N HLMSG,HLPORT,HLRETRY,HLRETMG,HLTCPO,POP
"RTN","HLCSTCP2",10,0)
 ;HLRETRY=number of retranmission for this link,HLRETMG=alert sent
"RTN","HLCSTCP2",11,0)
 S HLTCPO=HLDP,HLMSG="",(HLRETRY,HLRETMG)=0
"RTN","HLCSTCP2",12,0)
 ;
"RTN","HLCSTCP2",13,0)
 ; patch 122
"RTN","HLCSTCP2",14,0)
 ; patch 133
"RTN","HLCSTCP2",15,0)
 ; set IO(0) to the null device
"RTN","HLCSTCP2",16,0)
 I $G(^%ZOSF("OS"))]"",^%ZOSF("OS")'["GT.M" D
"RTN","HLCSTCP2",17,0)
 . S IO(0)=$S(^%ZOSF("OS")["OpenM":$S($$OS^%ZOSV()["VMS":"_NLA0:",$$OS^%ZOSV()["UNIX":"/dev/null",1:$P),^%ZOSF("OS")["DSM":"_NLA0:",1:$P)
"RTN","HLCSTCP2",18,0)
 . O IO(0) U IO(0)
"RTN","HLCSTCP2",19,0)
 ;
"RTN","HLCSTCP2",20,0)
 ;persistent conection, open connection first, HLPORT=open port
"RTN","HLCSTCP2",21,0)
 I $G(HLTCPLNK)["Y" F  Q:$$OPEN  G EXIT:$$STOP^HLCSTCP H 1
"RTN","HLCSTCP2",22,0)
 F  D QUE Q:$$STOP^HLCSTCP  D:'HLMSG  Q:$G(HLCSOUT)
"RTN","HLCSTCP2",23,0)
 . ;no messages to send
"RTN","HLCSTCP2",24,0)
 . D MON^HLCSTCP("Idle") H 3
"RTN","HLCSTCP2",25,0)
 . ;persistent connection, no retention
"RTN","HLCSTCP2",26,0)
 . Q:$G(HLTCPLNK)["Y"
"RTN","HLCSTCP2",27,0)
 . D MON^HLCSTCP("Retention")
"RTN","HLCSTCP2",28,0)
 . N % I 0
"RTN","HLCSTCP2",29,0)
 . ;if message comes in or ask to stop
"RTN","HLCSTCP2",30,0)
 . F %=1:1:HLTCPRET H 1 I $$STOP^HLCSTCP!$O(^HLMA("AC","O",HLDP,0)) Q
"RTN","HLCSTCP2",31,0)
 . E  S HLCSOUT=2 Q
"RTN","HLCSTCP2",32,0)
 . Q:$$STOP^HLCSTCP
"RTN","HLCSTCP2",33,0)
 . D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",34,0)
 ;Close port
"RTN","HLCSTCP2",35,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",36,0)
EXIT Q
"RTN","HLCSTCP2",37,0)
 ;
"RTN","HLCSTCP2",38,0)
QUE ; -- Check "OUT" queue for processing IF there is a message do it
"RTN","HLCSTCP2",39,0)
 ; and then check the link if it open or not
"RTN","HLCSTCP2",40,0)
 N HL,HLN,HLARR,HLHDR,HLI,HLJ,HLMSA,HLRESP,HLRESLT,HLRETRM,HLTCP,HLTCPI,X,Z,HLREREAD
"RTN","HLCSTCP2",41,0)
 N HLTMBUF
"RTN","HLCSTCP2",42,0)
 D MON^HLCSTCP("CheckOut")
"RTN","HLCSTCP2",43,0)
 ;HLMSG=next msg, set at tag DONE
"RTN","HLCSTCP2",44,0)
 I 'HLMSG S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0 Q:'HLMSG
"RTN","HLCSTCP2",45,0)
 ;
"RTN","HLCSTCP2",46,0)
 S HLI=+$G(^HLMA(HLMSG,0)),HLJ=$O(^("MSH",0)),HLTCP=""
"RTN","HLCSTCP2",47,0)
 ;don't have message text or MSH, kill x-ref and decrement 'to send'
"RTN","HLCSTCP2",48,0)
 ;
"RTN","HLCSTCP2",49,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLCSTCP2",50,0)
 ; I 'HLI!'HLJ K ^HLMA("AC","O",HLDP,HLMSG) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",51,0)
 I 'HLI!'HLJ D  Q
"RTN","HLCSTCP2",52,0)
 . F  L +^HLMA("AC","O",HLDP,HLMSG):10 Q:$T  H 1
"RTN","HLCSTCP2",53,0)
 . K ^HLMA("AC","O",HLDP,HLMSG)
"RTN","HLCSTCP2",54,0)
 . L -^HLMA("AC","O",HLDP,HLMSG)
"RTN","HLCSTCP2",55,0)
 . D LLCNT^HLCSTCP(HLDP,3,1)
"RTN","HLCSTCP2",56,0)
 . S HLMSG=0
"RTN","HLCSTCP2",57,0)
 ;
"RTN","HLCSTCP2",58,0)
 ; patch HL*1.6*142 start
"RTN","HLCSTCP2",59,0)
 ; to prevent data contention of end-user from competing with the link
"RTN","HLCSTCP2",60,0)
 ; processes sending data to backup workstations (for BCBU application)
"RTN","HLCSTCP2",61,0)
 I ($P(^HLMA(HLMSG,0),4)="D"),'$P($G(^HL(772,HLI,"P")),"^",2) D
"RTN","HLCSTCP2",62,0)
 . N COUNT
"RTN","HLCSTCP2",63,0)
 . F COUNT=1:1:15 Q:$P($G(^HL(772,HLI,"P")),"^",2)  H COUNT
"RTN","HLCSTCP2",64,0)
 ; patch HL*1.6*142 end
"RTN","HLCSTCP2",65,0)
 ;
"RTN","HLCSTCP2",66,0)
 ;update msg status to 'being transmitted'; if cancelled decrement link and quit
"RTN","HLCSTCP2",67,0)
 I '$$CHKMSG(1.5) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",68,0)
 ;number of retransmissions for message
"RTN","HLCSTCP2",69,0)
 S HLRETRM=+$P(^HLMA(HLMSG,"P"),U,5)
"RTN","HLCSTCP2",70,0)
 ;retries exceeded, HLRETRA:action i=ignore, r=restart, s=shutdown
"RTN","HLCSTCP2",71,0)
 ;quit if restart or shutdown, link is going down
"RTN","HLCSTCP2",72,0)
 I HLRETRY>HLDRETR D  Q:"I"'[HLRETRA
"RTN","HLCSTCP2",73,0)
 . D MON^HLCSTCP("Error")
"RTN","HLCSTCP2",74,0)
 . ;only 1 alert per link up time, don't send if restart
"RTN","HLCSTCP2",75,0)
 . D:'HLRETMG&(HLRETRA'="R")
"RTN","HLCSTCP2",76,0)
 .. ;send alert
"RTN","HLCSTCP2",77,0)
 .. N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
"RTN","HLCSTCP2",78,0)
 .. ;get mailgroup from file 869.3
"RTN","HLCSTCP2",79,0)
 .. S HLRETMG=1,Z=$P($$PARAM^HLCS2,U,8) Q:Z=""
"RTN","HLCSTCP2",80,0)
 .. S XQA("G."_Z)="",XQAMSG=$$HTE^XLFDT($H,2)_" HL7 LL "_$P(^HLCS(870,HLDP,0),U)_" exceeded retries. LL will "_$S(HLRETRA="S":"shutdown.",HLRETRA="R":"restart.",1:"keep trying.")
"RTN","HLCSTCP2",81,0)
 .. D SETUP^XQALERT
"RTN","HLCSTCP2",82,0)
 . ;quit if action is ignore
"RTN","HLCSTCP2",83,0)
 . Q:"I"[HLRETRA
"RTN","HLCSTCP2",84,0)
 . ;this will shutdown this link
"RTN","HLCSTCP2",85,0)
 . S HLCSOUT=1
"RTN","HLCSTCP2",86,0)
 . ;action is shutdown, set shutdown flag so LM won't restart
"RTN","HLCSTCP2",87,0)
 . S:HLRETRA="S" $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP2",88,0)
 . D STATUS^HLTF0(HLMSG,4,103,"LLP Exceeded Retry Param")
"RTN","HLCSTCP2",89,0)
 I '$$OPEN Q
"RTN","HLCSTCP2",90,0)
 D MON^HLCSTCP("Send")
"RTN","HLCSTCP2",91,0)
 ; -- data passed in global array, success=1
"RTN","HLCSTCP2",92,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",93,0)
 ; time: starts to send this message
"RTN","HLCSTCP2",94,0)
 S $P(^HLMA(HLMSG,"S"),"^",2)=$$NOW^XLFDT
"RTN","HLCSTCP2",95,0)
 I $$WRITE(HLMSG)<0 Q
"RTN","HLCSTCP2",96,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",97,0)
 ; time: this message has been sent
"RTN","HLCSTCP2",98,0)
 S $P(^HLMA(HLMSG,"S"),"^",3)=$$NOW^XLFDT
"RTN","HLCSTCP2",99,0)
 S (HLTCP,HLTCPI)=HLMSG,HLRETRY=HLRETRY+1,HLRETRM=HLRETRM+1
"RTN","HLCSTCP2",100,0)
 ;update status to awaiting response, decrement link if cancelled
"RTN","HLCSTCP2",101,0)
 I '$$CHKMSG(1.7) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",102,0)
 ;set transmission count, get ACKTIMEOUT override
"RTN","HLCSTCP2",103,0)
 S $P(^HLMA(HLMSG,"P"),U,5)=HLRETRM I $P(^("P"),U,7) S HLN("ACKTIME")=+$P(^("P"),U,7)
"RTN","HLCSTCP2",104,0)
 ;get header of message just sent
"RTN","HLCSTCP2",105,0)
 K HLJ M HLJ=^HLMA(HLMSG,"MSH")
"RTN","HLCSTCP2",106,0)
 ;first component of sending app.
"RTN","HLCSTCP2",107,0)
 S HLN("ECH")=$$P^HLTPCK2(.HLJ,2),HLN("SAN")=$P($$P^HLTPCK2(.HLJ,3),$E(HLN("ECH")))
"RTN","HLCSTCP2",108,0)
 ;msg type, msg. id, commit ack, and app. ack parameter
"RTN","HLCSTCP2",109,0)
 S HLN("TYPE")=$$P^HLTPCK2(.HLJ,1),HLN("MID")=$$P^HLTPCK2(.HLJ,10),HLN("ACAT")=$$P^HLTPCK2(.HLJ,15),HLN("APAT")=$$P^HLTPCK2(.HLJ,16)
"RTN","HLCSTCP2",110,0)
 ;MSA segment, message is a response, can't have an a. ack.
"RTN","HLCSTCP2",111,0)
 S Z=$$MSA^HLTP3(+^HLMA(HLMSG,0)) I Z]"" S:HLN("ACAT")="" HLN("ACAT")="NE" S HLN("APAT")="NE"
"RTN","HLCSTCP2",112,0)
 ;for batch/file with commit ack, reset c. ack and a. ack variables
"RTN","HLCSTCP2",113,0)
 I "BHS,FHS"[HLN("TYPE") S Z=$E(HLJ(1,0),5),X=$$P^HLTPCK2(.HLJ,9),HLN("ACAT")=$P(X,Z,5),HLN("APAT")=$P(X,Z,6),HLN("MID")=$$P^HLTPCK2(.HLJ,11)
"RTN","HLCSTCP2",114,0)
 ;get event protocol
"RTN","HLCSTCP2",115,0)
 S HLN("EID")=+$P(^HLMA(HLMSG,0),U,8),X=$G(^ORD(101,HLN("EID"),770))
"RTN","HLCSTCP2",116,0)
 ;set link counter to msg sent
"RTN","HLCSTCP2",117,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",118,0)
 ;commit and app. ack is never, update status to complete and hang UNI-DIRECTIONAL WAIT
"RTN","HLCSTCP2",119,0)
 I HLN("ACAT")="NE",HLN("APAT")="NE" D  Q
"RTN","HLCSTCP2",120,0)
 .D DONE(3)
"RTN","HLCSTCP2",121,0)
 .;
"RTN","HLCSTCP2",122,0)
 .;
"RTN","HLCSTCP2",123,0)
 .H $G(HLDWAIT)
"RTN","HLCSTCP2",124,0)
 ;
"RTN","HLCSTCP2",125,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",126,0)
 D
"RTN","HLCSTCP2",127,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",128,0)
 . ;HL*1.6*87: Read acknowledgement.  
"RTN","HLCSTCP2",129,0)
 . ;Loop to re-read from buffer when receiving incorrect ack.
"RTN","HLCSTCP2",130,0)
 . F  D  Q:'+$G(HLREREAD)
"RTN","HLCSTCP2",131,0)
 .. S HLREREAD=1
"RTN","HLCSTCP2",132,0)
 .. ;override ack timeout
"RTN","HLCSTCP2",133,0)
 .. I $G(HLN("ACKTIME")) N HLDBACK S HLDBACK=HLN("ACKTIME")
"RTN","HLCSTCP2",134,0)
 .. ;check for response, quit if no-response, msg will be resent
"RTN","HLCSTCP2",135,0)
 .. ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",136,0)
 .. S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",137,0)
 .. ;if no response, decrement counter and quit
"RTN","HLCSTCP2",138,0)
 .. I 'HLRESP D  Q
"RTN","HLCSTCP2",139,0)
 ...D LLCNT^HLCSTCP(HLDP,4,1)
"RTN","HLCSTCP2",140,0)
 ...S HLREREAD="0^No Response"
"RTN","HLCSTCP2",141,0)
 ...;check if the port needs to be closed and re-opened before the next re-transmission attempt
"RTN","HLCSTCP2",142,0)
 ...I $G(HLDRETR("CLOSE")) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",143,0)
 .. ;X 0=re-read msg, 1=commit ack, 3=app ack success, 4=error
"RTN","HLCSTCP2",144,0)
 .. S X=$$RSP^HLTP31(HLRESP,.HLN)
"RTN","HLCSTCP2",145,0)
 .. ;X=0, re-read msg. Incorrect ack (bad MSH,MSA,msg id,or sending app)
"RTN","HLCSTCP2",146,0)
 .. Q:'X 
"RTN","HLCSTCP2",147,0)
 .. ;commit ack - done
"RTN","HLCSTCP2",148,0)
 .. ; patch HL*1.6*142
"RTN","HLCSTCP2",149,0)
 .. ; time: this message has received commit ACK
"RTN","HLCSTCP2",150,0)
 .. S $P(^HLMA(HLMSG,"S"),"^",4)=$$NOW^XLFDT
"RTN","HLCSTCP2",151,0)
 .. I X=1 D  S HLREREAD="0^Commit Ack" Q
"RTN","HLCSTCP2",152,0)
 ... ;don't need app. ack, set status to complete
"RTN","HLCSTCP2",153,0)
 ... I "NE"[HLN("APAT") D  Q
"RTN","HLCSTCP2",154,0)
 ....D DONE(3)
"RTN","HLCSTCP2",155,0)
 ....;
"RTN","HLCSTCP2",156,0)
 ... ;response is deferred, set status to awaiting ack
"RTN","HLCSTCP2",157,0)
 ... D DONE(2)
"RTN","HLCSTCP2",158,0)
 ...;
"RTN","HLCSTCP2",159,0)
 .. ;Error, HLRESLT=error number^error message from HLTP3
"RTN","HLCSTCP2",160,0)
 .. I X=4 D  Q
"RTN","HLCSTCP2",161,0)
 ... D DONE(4,+$G(HLRESLT),$P($G(HLRESLT),U,2))
"RTN","HLCSTCP2",162,0)
 ...;
"RTN","HLCSTCP2",163,0)
 ... S HLREREAD="0^Error"
"RTN","HLCSTCP2",164,0)
 .. ;app ack was successful
"RTN","HLCSTCP2",165,0)
 .. D DONE(3) S HLREREAD="0^App Ack"
"RTN","HLCSTCP2",166,0)
 ..;
"RTN","HLCSTCP2",167,0)
 Q
"RTN","HLCSTCP2",168,0)
 ;
"RTN","HLCSTCP2",169,0)
DCSEND ;direct connect
"RTN","HLCSTCP2",170,0)
 ; Set up error trap
"RTN","HLCSTCP2",171,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",172,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP2",173,0)
 N HLTMBUF
"RTN","HLCSTCP2",174,0)
 ;override ack timeout
"RTN","HLCSTCP2",175,0)
 I $G(HLP("ACKTIME")) N HLDBACK S HLDBACK=HLP("ACKTIME")
"RTN","HLCSTCP2",176,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",177,0)
 ; time: starts to send this message
"RTN","HLCSTCP2",178,0)
 S $P(^HLMA(HLMSG,"S"),"^",2)=$$NOW^XLFDT
"RTN","HLCSTCP2",179,0)
 I $$WRITE(HLMSG)<0 D:$G(HLERROR)]""  Q  ;HL*1.6*77
"RTN","HLCSTCP2",180,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,"^"),$P(HLERROR,"^",2),1) ;HL*1.6*77
"RTN","HLCSTCP2",181,0)
 .  D LLCNT^HLCSTCP(HLDP,3,1)
"RTN","HLCSTCP2",182,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",183,0)
 ; time: this message has been sent
"RTN","HLCSTCP2",184,0)
 S $P(^HLMA(HLMSG,"S"),"^",3)=$$NOW^XLFDT
"RTN","HLCSTCP2",185,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",186,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",187,0)
 D
"RTN","HLCSTCP2",188,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",189,0)
 . ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",190,0)
 . S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",191,0)
 ;
"RTN","HLCSTCP2",192,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",193,0)
 ; time: this message has received app ACK
"RTN","HLCSTCP2",194,0)
 S $P(^HLMA(HLMSG,"S"),"^",4)=$$NOW^XLFDT
"RTN","HLCSTCP2",195,0)
 D DONE(3):$G(HLRESP),DONE(4,108,$S($G(HLERROR)]"":$P(HLERROR,"^",2),1:"No response")):'$G(HLRESP)
"RTN","HLCSTCP2",196,0)
 I $G(HLERROR)']"" D
"RTN","HLCSTCP2",197,0)
 .D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",198,0)
 .I '$G(HLRESP) S HLERROR="108^No response"
"RTN","HLCSTCP2",199,0)
 ;Close port
"RTN","HLCSTCP2",200,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",201,0)
 Q
"RTN","HLCSTCP2",202,0)
 ;
"RTN","HLCSTCP2",203,0)
DONE(ST,ERR,ERRMSG) ;set status to complete
"RTN","HLCSTCP2",204,0)
 ;ST=status, ERR=error ien, ERRMSG=error msg
"RTN","HLCSTCP2",205,0)
 D STATUS^HLTF0(HLMSG,ST,$G(ERR),$G(ERRMSG),1)
"RTN","HLCSTCP2",206,0)
 ;
"RTN","HLCSTCP2",207,0)
 D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",208,0)
 ;
"RTN","HLCSTCP2",209,0)
 ;check for more msg.
"RTN","HLCSTCP2",210,0)
 I $G(HLPRIO)'="I" S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0
"RTN","HLCSTCP2",211,0)
 Q
"RTN","HLCSTCP2",212,0)
 ;
"RTN","HLCSTCP2",213,0)
CHKMSG(HLI) ;check status of message and update if not cancelled
"RTN","HLCSTCP2",214,0)
 ;input: HLI=new status, HLMSG=ien of msg in 773
"RTN","HLCSTCP2",215,0)
 ;returns 1=msg was updated, 0=msg has been canceled
"RTN","HLCSTCP2",216,0)
 N X
"RTN","HLCSTCP2",217,0)
 ;
"RTN","HLCSTCP2",218,0)
 ; New HL*1.6*77 code starting here...
"RTN","HLCSTCP2",219,0)
 I '$D(^HLMA(HLMSG,"P")) D  Q 0
"RTN","HLCSTCP2",220,0)
 .  S HLERROR="2^Missing status field"
"RTN","HLCSTCP2",221,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,U),$P(HLERROR,U,2),1)
"RTN","HLCSTCP2",222,0)
 .;
"RTN","HLCSTCP2",223,0)
 . D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",224,0)
 ;
"RTN","HLCSTCP2",225,0)
 ; End of HL*1.6*77
"RTN","HLCSTCP2",226,0)
 ;
"RTN","HLCSTCP2",227,0)
 ;get status, quit if msg was cancelled
"RTN","HLCSTCP2",228,0)
 ;
"RTN","HLCSTCP2",229,0)
 ; patch HL*1.6*145
"RTN","HLCSTCP2",230,0)
 ; S X=+^HLMA(HLMSG,"P") Q:X=3 0
"RTN","HLCSTCP2",231,0)
 S X=+^HLMA(HLMSG,"P")
"RTN","HLCSTCP2",232,0)
 ;
"RTN","HLCSTCP2",233,0)
 ;update status if it is different
"RTN","HLCSTCP2",234,0)
 I $G(HLI),HLI'=X D STATUS^HLTF0(HLMSG,HLI)
"RTN","HLCSTCP2",235,0)
 ;
"RTN","HLCSTCP2",236,0)
 Q 1
"RTN","HLCSTCP2",237,0)
 ;
"RTN","HLCSTCP2",238,0)
WRITE(HLDA) ; write message in HL7 format
"RTN","HLCSTCP2",239,0)
 ;  HLDA       - ien of message in 773
"RTN","HLCSTCP2",240,0)
 ;             - start block $C(11)
"RTN","HLCSTCP2",241,0)
 ;             - end block $C(28)
"RTN","HLCSTCP2",242,0)
 ;             - record separator $C(13)
"RTN","HLCSTCP2",243,0)
 ;Output(s): 1 - Successful
"RTN","HLCSTCP2",244,0)
 ;           -1 - Unsuccessful
"RTN","HLCSTCP2",245,0)
 ;
"RTN","HLCSTCP2",246,0)
 N HLDA2,HLAR,HLI,LINENO,X,CRCOUNT
"RTN","HLCSTCP2",247,0)
 S CRCOUNT=0
"RTN","HLCSTCP2",248,0)
 ;set error trap, used when called from HLTP3
"RTN","HLCSTCP2",249,0)
 ;
"RTN","HLCSTCP2",250,0)
 ; New HL*1.6*77 code starts here...
"RTN","HLCSTCP2",251,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",252,0)
 I $G(^HLMA(HLDA,0))'>0 D  Q -1
"RTN","HLCSTCP2",253,0)
 .  S HLERROR="2^Message Text pointer missing"
"RTN","HLCSTCP2",254,0)
 S HLDA2=+$G(^HLMA(HLDA,0))
"RTN","HLCSTCP2",255,0)
 ; End of HL*1.6*77 modifications...
"RTN","HLCSTCP2",256,0)
 ;
"RTN","HLCSTCP2",257,0)
 Q:'$G(^HLMA(HLDA,0)) -1 ;HL*1.6*77
"RTN","HLCSTCP2",258,0)
 ; header is in ^HLMA(, message is in ^HL(772,
"RTN","HLCSTCP2",259,0)
 S LINENO=1,HLI=0,HLAR="^HLMA(HLDA,""MSH"")"
"RTN","HLCSTCP2",260,0)
 U IO
"RTN","HLCSTCP2",261,0)
 D  W $C(13) S HLAR="^HL(772,HLDA2,""IN"")",HLI=0 D
"RTN","HLCSTCP2",262,0)
 . F  S HLI=$O(@HLAR@(HLI)) Q:'HLI  S X=$G(^(HLI,0)) D
"RTN","HLCSTCP2",263,0)
 .. ;first line, need start block char.
"RTN","HLCSTCP2",264,0)
 .. S:LINENO=1 X=$C(11)_X
"RTN","HLCSTCP2",265,0)
 .. ; HL*1.6*122
"RTN","HLCSTCP2",266,0)
 .. ; I X]"" W X,!
"RTN","HLCSTCP2",267,0)
 .. N LENGTH
"RTN","HLCSTCP2",268,0)
 .. S LENGTH=$L(X)
"RTN","HLCSTCP2",269,0)
 .. ; patch HL*1.6*142 start
"RTN","HLCSTCP2",270,0)
 .. ; buffer should be limited to 510
"RTN","HLCSTCP2",271,0)
 .. ; I LENGTH>512 D
"RTN","HLCSTCP2",272,0)
 .. I LENGTH>510 D
"RTN","HLCSTCP2",273,0)
 ... N X1
"RTN","HLCSTCP2",274,0)
 ... ; F  Q:LENGTH<512  D
"RTN","HLCSTCP2",275,0)
 ... F  Q:LENGTH<511  D
"RTN","HLCSTCP2",276,0)
 .... ; S X1=$E(X,1,512),X=$E(X,513,999999)
"RTN","HLCSTCP2",277,0)
 .... S X1=$E(X,1,510),X=$E(X,511,999999)
"RTN","HLCSTCP2",278,0)
 .... S LENGTH=$L(X)
"RTN","HLCSTCP2",279,0)
 .... ; patch HL*1.6*140
"RTN","HLCSTCP2",280,0)
 .... ; W X1,@IOF
"RTN","HLCSTCP2",281,0)
 .... W X1,@HLTCPLNK("IOF")
"RTN","HLCSTCP2",282,0)
 .. ; patch HL*1.6*142 end
"RTN","HLCSTCP2",283,0)
 .. ;
"RTN","HLCSTCP2",284,0)
 .. ; @HLTCPLNK("IOF") (! or #) for flush character
"RTN","HLCSTCP2",285,0)
 .. I X]"" W X,@HLTCPLNK("IOF") S CRCOUNT=0
"RTN","HLCSTCP2",286,0)
 .. ;send CR
"RTN","HLCSTCP2",287,0)
 .. I X="" W $C(13) S CRCOUNT=CRCOUNT+1
"RTN","HLCSTCP2",288,0)
 .. ; prevent from maxstring error
"RTN","HLCSTCP2",289,0)
 .. I CRCOUNT>200 W @HLTCPLNK("IOF") S CRCOUNT=0
"RTN","HLCSTCP2",290,0)
 .. S LINENO=LINENO+1
"RTN","HLCSTCP2",291,0)
 ; Sends end block for this message
"RTN","HLCSTCP2",292,0)
 S X=$C(28)_$C(13)
"RTN","HLCSTCP2",293,0)
 ; U IO W X,!
"RTN","HLCSTCP2",294,0)
 U IO W X,@HLTCPLNK("IOF")
"RTN","HLCSTCP2",295,0)
 ;switch to null device
"RTN","HLCSTCP2",296,0)
 I $G(IO(0))'="",$G(IO(0))'=IO U IO(0)
"RTN","HLCSTCP2",297,0)
 Q 1
"RTN","HLCSTCP2",298,0)
 ;
"RTN","HLCSTCP2",299,0)
OPEN() ; -- Open TCP/IP device (Client)
"RTN","HLCSTCP2",300,0)
 ;HLPORT=port, defined only if port is open
"RTN","HLCSTCP2",301,0)
 ;HLPORTA=number of attempted opens
"RTN","HLCSTCP2",302,0)
 I $D(HLPORT) S IO=HLPORT D  Q 1
"RTN","HLCSTCP2",303,0)
 . U IO
"RTN","HLCSTCP2",304,0)
 . ; patch HL*1.6*157: HLOS is from calling $$OS^%ZOSV
"RTN","HLCSTCP2",305,0)
 . ; use packet mode on Cache'
"RTN","HLCSTCP2",306,0)
 . ; I HLOS["OpenM" X "U IO:(::""-M"")" ;use packet mode on Cache'
"RTN","HLCSTCP2",307,0)
 . I (HLOS["VMS")!(HLOS["UNIX"),^%ZOSF("OS")'["GT.M"  X "U IO:(::""-M"")"
"RTN","HLCSTCP2",308,0)
 N HLDOM,HLI,HLIP,HLPORTA
"RTN","HLCSTCP2",309,0)
 G OPENA^HLCSTCP3
"RTN","HLCSTCP2",310,0)
 ;
"RTN","HLCSTCP2",311,0)
RDERR D RDERR^HLCSTCP4 Q
"RTN","HLCSTCP2",312,0)
ERROR D ERROR^HLCSTCP4 Q
"RTN","HLCSTCP2",313,0)
 ;
"RTN","HLCSTCP2",314,0)
CC(X) ;cleanup and close
"RTN","HLCSTCP2",315,0)
 D MON^HLCSTCP(X)
"RTN","HLCSTCP2",316,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",317,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP2",318,0)
 ; H 2
"RTN","HLCSTCP2",319,0)
 H 1
"RTN","HLCSTCP2",320,0)
 Q
"RTN","HLCSTCP3")
0^6^B15347449^B14207498
"RTN","HLCSTCP3",1,0)
HLCSTCP3 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;08/03/2011
"RTN","HLCSTCP3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**76,77,133,122,153,157**;OCT 13, 1995;Build 8
"RTN","HLCSTCP3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP3",4,0)
 ;
"RTN","HLCSTCP3",5,0)
OPENA ;
"RTN","HLCSTCP3",6,0)
 ; called from $$OPEN^HLCSTCP2 and this sub-routine OPENA
"RTN","HLCSTCP3",7,0)
 ;
"RTN","HLCSTCP3",8,0)
 ; **P153 START CJM
"RTN","HLCSTCP3",9,0)
 ; Reset the TCP Address incase DNS changed it without a successful connection
"RTN","HLCSTCP3",10,0)
 K HLDOM
"RTN","HLCSTCP3",11,0)
 S HLTCPADD=$P(^HLCS(870,HLDP,400),U)
"RTN","HLCSTCP3",12,0)
 ;
"RTN","HLCSTCP3",13,0)
RETRY ;
"RTN","HLCSTCP3",14,0)
 ; **P153 END CJM
"RTN","HLCSTCP3",15,0)
 ;
"RTN","HLCSTCP3",16,0)
 I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S HLPORTA=+$P(^("P"),U,6)
"RTN","HLCSTCP3",17,0)
 S POP=1
"RTN","HLCSTCP3",18,0)
 ;
"RTN","HLCSTCP3",19,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP3",20,0)
 ; variable HLDRETR=re-transmit attemps (#870,200.02)
"RTN","HLCSTCP3",21,0)
 ; variable HLTCPLNK("TIMEOUT")=timeout for 3rd parameter of CALL^%ZISTCP()
"RTN","HLCSTCP3",22,0)
 ; defined in HLCSTCP routine
"RTN","HLCSTCP3",23,0)
 ;
"RTN","HLCSTCP3",24,0)
 I '$G(HLDRETR("COUNT")) S HLDRETR("COUNT")=1
"RTN","HLCSTCP3",25,0)
 I '$G(HLTCPLNK("TIMEOUT")) S HLTCPLNK("TIMEOUT")=5
"RTN","HLCSTCP3",26,0)
 S HLDRETR("COUNT-2")=HLDRETR("COUNT")+HLDRETR
"RTN","HLCSTCP3",27,0)
 ; patch 133
"RTN","HLCSTCP3",28,0)
 ; I $G(HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",29,0)
 ; .S HLI=1
"RTN","HLCSTCP3",30,0)
 ; .D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLDIRECT("OPEN TIMEOUT"))
"RTN","HLCSTCP3",31,0)
 ; E  D
"RTN","HLCSTCP3",32,0)
 ; .F HLI=1:1:HLDRETR D CALL^%ZISTCP(HLTCPADD,HLTCPORT) Q:'POP
"RTN","HLCSTCP3",33,0)
 I $G(HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",34,0)
 . D MON^HLCSTCP("Open")
"RTN","HLCSTCP3",35,0)
 . D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLDIRECT("OPEN TIMEOUT"))
"RTN","HLCSTCP3",36,0)
 . ; give site one more chance to override the application setup
"RTN","HLCSTCP3",37,0)
 . I $G(POP),(HLTCPLNK("TIMEOUT")>HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",38,0)
 .. D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLTCPLNK("TIMEOUT"))
"RTN","HLCSTCP3",39,0)
 E  D
"RTN","HLCSTCP3",40,0)
 . N COUNT
"RTN","HLCSTCP3",41,0)
 . ; try to connect HLDRETR times
"RTN","HLCSTCP3",42,0)
 . F HLDRETR("COUNT")=HLDRETR("COUNT"):1:HLDRETR("COUNT-2") D  Q:('POP)!($$STOP^HLCSTCP)
"RTN","HLCSTCP3",43,0)
 .. D MON^HLCSTCP("Open")
"RTN","HLCSTCP3",44,0)
 .. ; D CALL^%ZISTCP(HLTCPADD,HLTCPORT)
"RTN","HLCSTCP3",45,0)
 .. D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLTCPLNK("TIMEOUT"))
"RTN","HLCSTCP3",46,0)
 .. ;open error
"RTN","HLCSTCP3",47,0)
 .. I POP D
"RTN","HLCSTCP3",48,0)
 ... D CC^HLCSTCP2("Openfail")
"RTN","HLCSTCP3",49,0)
 ... H $S(HLDRETR("COUNT")=1:0,HLDRETR("COUNT")<10:1,1:8)
"RTN","HLCSTCP3",50,0)
 ... I '$D(^XTMP("HL7-Openfail",$J)) D
"RTN","HLCSTCP3",51,0)
 .... S ^XTMP("HL7-Openfail",0)=$$FMADD^XLFDT($$NOW^XLFDT,3)_"^"_$$NOW^XLFDT
"RTN","HLCSTCP3",52,0)
 .... S ^XTMP("HL7-Openfail",$J,"COUNT","FIRST")=HLDRETR("COUNT")_"^"_$$NOW^XLFDT
"RTN","HLCSTCP3",53,0)
 ... S COUNT=$P($G(^XTMP("HL7-Openfail",$J,"COUNT","LAST")),"^")+1
"RTN","HLCSTCP3",54,0)
 ... S ^XTMP("HL7-Openfail",$J,"COUNT","LAST")=COUNT_"^"_$$NOW^XLFDT
"RTN","HLCSTCP3",55,0)
 ;
"RTN","HLCSTCP3",56,0)
 ;set # of opens back in msg
"RTN","HLCSTCP3",57,0)
 ; I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S $P(^("P"),U,6)=HLPORTA+HLI
"RTN","HLCSTCP3",58,0)
 I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S $P(^("P"),U,6)=HLDRETR("COUNT")
"RTN","HLCSTCP3",59,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP3",60,0)
 ;
"RTN","HLCSTCP3",61,0)
 ;device open
"RTN","HLCSTCP3",62,0)
 I 'POP S HLPORT=IO D  Q $S($G(HLERROR)]"":0,1:1)
"RTN","HLCSTCP3",63,0)
 . N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2" ;HL*1.6*77
"RTN","HLCSTCP3",64,0)
 . ;if address came from DNS, set back into LL
"RTN","HLCSTCP3",65,0)
 . I $D(HLIP) S $P(^HLCS(870,HLDP,400),U)=HLTCPADD
"RTN","HLCSTCP3",66,0)
 . ; write and read to check if still open
"RTN","HLCSTCP3",67,0)
 . ; patch HL*1.6*157: HLOS is from calling $$OS^%ZOSV
"RTN","HLCSTCP3",68,0)
 . ; Q:HLOS'["OpenM"  X "U IO:(::""-M"")" ; must be Cache/NT + use packet mode
"RTN","HLCSTCP3",69,0)
 . Q:(HLOS'["VMS")&(HLOS'["UNIX")  X "U IO:(::""-M"")" ; must be Cache + packet mode
"RTN","HLCSTCP3",70,0)
 . Q:$P(^HLCS(870,HLDP,400),U,7)'="Y"  ; must want to SAY HELO
"RTN","HLCSTCP3",71,0)
 . U IO W "HELO "_$$KSP^XUPARAM("WHERE"),! R X:1
"RTN","HLCSTCP3",72,0)
 ;openfail-try DNS lookup
"RTN","HLCSTCP3",73,0)
 ;
"RTN","HLCSTCP3",74,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP3",75,0)
 ;I '$D(HLDOM) S HLDOM=+$P(^HLCS(870,HLDP,0),U,7),HLDOM=$P($G(^DIC(4.2,HLDOM,0)),U) D:HLDOM]"" DNS
"RTN","HLCSTCP3",76,0)
 I '$D(HLDOM) D
"RTN","HLCSTCP3",77,0)
 . S HLDOM=+$P(^HLCS(870,HLDP,0),U,7),HLDOM=$P($G(^DIC(4.2,HLDOM,0)),U)
"RTN","HLCSTCP3",78,0)
 . S HLDOM("DNS")=$P($G(^HLCS(870,+$G(HLDP),0)),"^",8)
"RTN","HLCSTCP3",79,0)
 . D:HLDOM]""!($L(HLDOM("DNS"),".")>2) DNS
"RTN","HLCSTCP3",80,0)
 ;
"RTN","HLCSTCP3",81,0)
 Q:$$STOP^HLCSTCP 0
"RTN","HLCSTCP3",82,0)
 ;HLIP=ip add. from DNS call, get first one and try open again
"RTN","HLCSTCP3",83,0)
 ;
"RTN","HLCSTCP3",84,0)
 ; **P153 START CJM
"RTN","HLCSTCP3",85,0)
 ;I $D(HLIP) S HLTCPADD=$P(HLIP,","),HLIP=$P(HLIP,",",2,99) G:HLTCPADD OPENA
"RTN","HLCSTCP3",86,0)
 I $D(HLIP) S HLTCPADD=$P(HLIP,","),HLIP=$P(HLIP,",",2,99) G:HLTCPADD RETRY
"RTN","HLCSTCP3",87,0)
 ; **P153 END CJM
"RTN","HLCSTCP3",88,0)
 ;
"RTN","HLCSTCP3",89,0)
 ; open error
"RTN","HLCSTCP3",90,0)
 ;cleanup and close
"RTN","HLCSTCP3",91,0)
 ; patch 133
"RTN","HLCSTCP3",92,0)
 I $G(HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",93,0)
 . D MON^HLCSTCP("Openfail")
"RTN","HLCSTCP3",94,0)
 . I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP3",95,0)
 E  D
"RTN","HLCSTCP3",96,0)
 . D CC^HLCSTCP2("Openfail")
"RTN","HLCSTCP3",97,0)
 Q 0
"RTN","HLCSTCP3",98,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP3",99,0)
 ;
"RTN","HLCSTCP3",100,0)
 ;
"RTN","HLCSTCP3",101,0)
 ;following code was removed, site's complained of to many alerts
"RTN","HLCSTCP3",102,0)
 ;couldn't open, send 1 alert
"RTN","HLCSTCP3",103,0)
 ;I '$G(HLPORTA) D
"RTN","HLCSTCP3",104,0)
 ;. ;send alert
"RTN","HLCSTCP3",105,0)
 ;. N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
"RTN","HLCSTCP3",106,0)
 ;. ;get mailgroup from file 869.3
"RTN","HLCSTCP3",107,0)
 ;. S Z=$P($$PARAM^HLCS2,U,8),HLPORTA="" Q:Z=""
"RTN","HLCSTCP3",108,0)
 ;. S XQA("G."_Z)="",XQAMSG=$$HTE^XLFDT($H,2)_" Logical Link "_$P(^HLCS(870,HLDP,0),U)_" exceeded Open Retries."
"RTN","HLCSTCP3",109,0)
 ;. D SETUP^XQALERT
"RTN","HLCSTCP3",110,0)
 ;open error
"RTN","HLCSTCP3",111,0)
 ;D CC("Openfail") H 3
"RTN","HLCSTCP3",112,0)
 ;Q 0
"RTN","HLCSTCP3",113,0)
 ;
"RTN","HLCSTCP3",114,0)
 ;
"RTN","HLCSTCP3",115,0)
DNS ;VA domains must have "med" inserted.
"RTN","HLCSTCP3",116,0)
 ;All domains must use port 5000 and are prepended with "HL7"
"RTN","HLCSTCP3",117,0)
 ;non-VA DNS lookups will succeed if site uses port 5000 and 
"RTN","HLCSTCP3",118,0)
 ;configure their local DNS with "HL7.yourdomain.com" and entries
"RTN","HLCSTCP3",119,0)
 ;are created in the logical link file and domain file.
"RTN","HLCSTCP3",120,0)
 D MON^HLCSTCP("DNS Lkup")
"RTN","HLCSTCP3",121,0)
 I HLDOM["VA.GOV"&(HLDOM'[".MED.") S HLDOM=$P(HLDOM,".VA.GOV")_".MED.VA.GOV"
"RTN","HLCSTCP3",122,0)
 I HLTCPORT=5000 S HLDOM="HL7."_HLDOM
"RTN","HLCSTCP3",123,0)
 I HLTCPORT=5500 S HLDOM="MPI."_HLDOM
"RTN","HLCSTCP3",124,0)
 ;
"RTN","HLCSTCP3",125,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP3",126,0)
 I $L($G(HLDOM("DNS")),".")>2 D
"RTN","HLCSTCP3",127,0)
 . S HLDOM=HLDOM("DNS")
"RTN","HLCSTCP3",128,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP3",129,0)
 ;
"RTN","HLCSTCP3",130,0)
 S HLIP=$$ADDRESS^XLFNSLK(HLDOM)
"RTN","HLCSTCP3",131,0)
 K:HLIP="" HLIP
"RTN","HLCSTCP3",132,0)
 Q
"RTN","HLCSTCP3",133,0)
 ;
"RTN","HLCSTCP4")
0^4^B51177330^B45823270
"RTN","HLCSTCP4",1,0)
HLCSTCP4 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;08/03/2011  13:29
"RTN","HLCSTCP4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109,122,140,157**;Oct 13,1995;Build 8
"RTN","HLCSTCP4",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP4",4,0)
 ;
"RTN","HLCSTCP4",5,0)
 Q
"RTN","HLCSTCP4",6,0)
 ; RDERR & ERROR moved from HLCSTCP2 on 12/2/2003 - LJA
"RTN","HLCSTCP4",7,0)
 ;
"RTN","HLCSTCP4",8,0)
RDERR ; Error during read process, decrement counter
"RTN","HLCSTCP4",9,0)
 D LLCNT^HLCSTCP(HLDP,4,1)
"RTN","HLCSTCP4",10,0)
ERROR ; Error trap
"RTN","HLCSTCP4",11,0)
 ; OPEN ERROR-retry.
"RTN","HLCSTCP4",12,0)
 ; WRITE ERROR (SERVER DISCONNECT)-close channel, retry
"RTN","HLCSTCP4",13,0)
 ;
"RTN","HLCSTCP4",14,0)
 ;**109**
"RTN","HLCSTCP4",15,0)
 ;I $G(HLMSG) L -^HLMA(HLMSG)
"RTN","HLCSTCP4",16,0)
 ;
"RTN","HLCSTCP4",17,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP4",18,0)
 N STOP
"RTN","HLCSTCP4",19,0)
 S STOP=0
"RTN","HLCSTCP4",20,0)
 I $G(HLDP) S STOP=$$STOP^HLCSTCP
"RTN","HLCSTCP4",21,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP4",22,0)
 S $ETRAP="D HALT^ZU" ;RWF
"RTN","HLCSTCP4",23,0)
 S HLTCP("$ZA\8192#2")=""
"RTN","HLCSTCP4",24,0)
 ;
"RTN","HLCSTCP4",25,0)
 ; patch HL*1.6*157 start
"RTN","HLCSTCP4",26,0)
 N HLOSYS
"RTN","HLCSTCP4",27,0)
 S HLOSYS=$$OS^%ZOSV
"RTN","HLCSTCP4",28,0)
 ; I (^%ZOSF("OS")["OpenM") D
"RTN","HLCSTCP4",29,0)
 I (HLOSYS["UNIX")!(HLOSYS["VMS") D
"RTN","HLCSTCP4",30,0)
 . ; patch HL*1.6*157 end
"RTN","HLCSTCP4",31,0)
 . S HLTCP("$ZA")=$ZA
"RTN","HLCSTCP4",32,0)
 . ; For TCP devices $ZA\8192#2: the device is currently in the
"RTN","HLCSTCP4",33,0)
 . ; Connected state talking to a remote host.
"RTN","HLCSTCP4",34,0)
 . S HLTCP("$ZA\8192#2")=$ZA\8192#2
"RTN","HLCSTCP4",35,0)
 ;
"RTN","HLCSTCP4",36,0)
 S HLTCPERR("ERR-$ZE")=$$EC^%ZOSV
"RTN","HLCSTCP4",37,0)
 ; I $$EC^%ZOSV["OPENERR"!($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D CC^HLCSTCP2("Op-err") S:$G(HLPRIO)="I" HLERROR="15^Open Related Error" D UNWIND^%ZTER Q
"RTN","HLCSTCP4",38,0)
 I $$EC^%ZOSV["OPENERR"!($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D  G:STOP H2^XUSCLEAN Q
"RTN","HLCSTCP4",39,0)
 . D CC^HLCSTCP2("Op-err")
"RTN","HLCSTCP4",40,0)
 . S:$G(HLPRIO)="I" HLERROR="15^Open Related Error"
"RTN","HLCSTCP4",41,0)
 . I STOP D  Q
"RTN","HLCSTCP4",42,0)
 .. D CC^HLCSTCP2("Shutdown: (with 'Op-err')")
"RTN","HLCSTCP4",43,0)
 . I 'STOP D UNWIND^%ZTER
"RTN","HLCSTCP4",44,0)
 ; patch HL*1.6*140 start
"RTN","HLCSTCP4",45,0)
 ; I $$EC^%ZOSV["WRITE" D  G:STOP!(HLTCP("$ZA\8192#2")=0) H2^XUSCLEAN Q
"RTN","HLCSTCP4",46,0)
 I $$EC^%ZOSV["WRITE" D  G:STOP!(HLTCP("$ZA\8192#2")) H2^XUSCLEAN Q
"RTN","HLCSTCP4",47,0)
 . ; S:$G(HLPRIO)="I" HLERROR="108^Write Error"
"RTN","HLCSTCP4",48,0)
 . I $G(HLPRIO)="I" D  Q
"RTN","HLCSTCP4",49,0)
 .. S HLERROR="108^Write Error"
"RTN","HLCSTCP4",50,0)
 .. D CC^HLCSTCP2("Wr-err")
"RTN","HLCSTCP4",51,0)
 .. D UNWIND^%ZTER
"RTN","HLCSTCP4",52,0)
 . ;
"RTN","HLCSTCP4",53,0)
 . I STOP D  Q
"RTN","HLCSTCP4",54,0)
 .. D ^%ZTER,CC^HLCSTCP2("Shutdown: (with 'Wr-err')")
"RTN","HLCSTCP4",55,0)
 . E  D  Q
"RTN","HLCSTCP4",56,0)
 .. I HLTCP("$ZA\8192#2") D ^%ZTER,CC^HLCSTCP2("Wr-err") Q
"RTN","HLCSTCP4",57,0)
 .. E  D  Q
"RTN","HLCSTCP4",58,0)
 ... D CC^HLCSTCP2("Halt (Wr): (Disconnected with 'Wr-err')")
"RTN","HLCSTCP4",59,0)
 ... D UNWIND^%ZTER
"RTN","HLCSTCP4",60,0)
 ;
"RTN","HLCSTCP4",61,0)
 ; I $$EC^%ZOSV["READ" D CC^HLCSTCP2("Rd-err") S:$G(HLPRIO)="I" HLERROR="108^Read Error" D UNWIND^%ZTER Q
"RTN","HLCSTCP4",62,0)
 ; I $$EC^%ZOSV["READ" D  G:STOP!(HLTCP("$ZA\8192#2")=0) H2^XUSCLEAN Q
"RTN","HLCSTCP4",63,0)
 I $$EC^%ZOSV["READ" D  G:STOP!(HLTCP("$ZA\8192#2")) H2^XUSCLEAN Q
"RTN","HLCSTCP4",64,0)
 . ; S:$G(HLPRIO)="I" HLERROR="108^Read Error"
"RTN","HLCSTCP4",65,0)
 . I $G(HLPRIO)="I" D  Q
"RTN","HLCSTCP4",66,0)
 .. S HLERROR="108^Read Error"
"RTN","HLCSTCP4",67,0)
 .. D CC^HLCSTCP2("Rd-err")
"RTN","HLCSTCP4",68,0)
 .. D UNWIND^%ZTER
"RTN","HLCSTCP4",69,0)
 . ;
"RTN","HLCSTCP4",70,0)
 . I STOP D  Q
"RTN","HLCSTCP4",71,0)
 .. D ^%ZTER,CC^HLCSTCP2("Shutdown: (with 'Rd-err')")
"RTN","HLCSTCP4",72,0)
 . E  D  Q
"RTN","HLCSTCP4",73,0)
 .. I HLTCP("$ZA\8192#2") D ^%ZTER,CC^HLCSTCP2("Rd-err") Q
"RTN","HLCSTCP4",74,0)
 .. E  D  Q
"RTN","HLCSTCP4",75,0)
 ... D CC^HLCSTCP2("Halt (Rd): (Disconnected with 'Rd-err')")
"RTN","HLCSTCP4",76,0)
 ... D UNWIND^%ZTER
"RTN","HLCSTCP4",77,0)
 ;
"RTN","HLCSTCP4",78,0)
 ; S HLCSOUT=1 D ^%ZTER,CC^HLCSTCP2("Error"),SDFLD^HLCSTCP
"RTN","HLCSTCP4",79,0)
 ; S:$G(HLPRIO)="I" HLERROR="9^Error"
"RTN","HLCSTCP4",80,0)
 D ^%ZTER
"RTN","HLCSTCP4",81,0)
 I $G(HLPRIO)="I" D  Q
"RTN","HLCSTCP4",82,0)
 . S HLERROR="9^Error"
"RTN","HLCSTCP4",83,0)
 . D CC^HLCSTCP2("Error")
"RTN","HLCSTCP4",84,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",85,0)
 ;
"RTN","HLCSTCP4",86,0)
 I STOP D  Q
"RTN","HLCSTCP4",87,0)
 . D CC^HLCSTCP2("Shutdown: (with 'Error')")
"RTN","HLCSTCP4",88,0)
 . D H2^XUSCLEAN
"RTN","HLCSTCP4",89,0)
 ;
"RTN","HLCSTCP4",90,0)
 D CC^HLCSTCP2("Error")
"RTN","HLCSTCP4",91,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP4",92,0)
 D H2^XUSCLEAN
"RTN","HLCSTCP4",93,0)
 ; patch HL*1.6*140 end
"RTN","HLCSTCP4",94,0)
 Q
"RTN","HLCSTCP4",95,0)
 ;
"RTN","HLCSTCP4",96,0)
PROXY ; set DUZ for application proxy user
"RTN","HLCSTCP4",97,0)
 ;
"RTN","HLCSTCP4",98,0)
 ; removed the execution: patch 122 TEST v2
"RTN","HLCSTCP4",99,0)
 Q
"RTN","HLCSTCP4",100,0)
 ;
"RTN","HLCSTCP4",101,0)
 ;; S HLDUZ=+$$APFIND^XUSAP("HLSEVEN,APPLICATION PROXY")
"RTN","HLCSTCP4",102,0)
 ;; S DUZ=HLDUZ
"RTN","HLCSTCP4",103,0)
 ;; D DUZ^XUP(DUZ)
"RTN","HLCSTCP4",104,0)
 ;; Q
"RTN","HLCSTCP4",105,0)
 ;
"RTN","HLCSTCP4",106,0)
HLDUZ ; compare DUZ and set DUZ to application proxy user
"RTN","HLCSTCP4",107,0)
 ;
"RTN","HLCSTCP4",108,0)
 ; removed the execution: patch 122 TEST v2
"RTN","HLCSTCP4",109,0)
 Q
"RTN","HLCSTCP4",110,0)
 ;
"RTN","HLCSTCP4",111,0)
 ;; I '$G(HLDUZ) D PROXY
"RTN","HLCSTCP4",112,0)
 ;
"RTN","HLCSTCP4",113,0)
HLDUZ2 ; compare DUZ and HLDUZ
"RTN","HLCSTCP4",114,0)
 I $G(DUZ)'=HLDUZ D
"RTN","HLCSTCP4",115,0)
 . S DUZ=HLDUZ
"RTN","HLCSTCP4",116,0)
 . D DUZ^XUP(DUZ)
"RTN","HLCSTCP4",117,0)
 Q
"RTN","HLCSTCP4",118,0)
 ;
"RTN","HLCSTCP4",119,0)
CLEANVAR ; clean variables for server, called from HLCSTCP1
"RTN","HLCSTCP4",120,0)
 ;
"RTN","HLCSTCP4",121,0)
 ; clean variables except Kernel related variables
"RTN","HLCSTCP4",122,0)
 ; protect variables defined in HLCSTCP
"RTN","HLCSTCP4",123,0)
 N HLDP
"RTN","HLCSTCP4",124,0)
 N HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT,HLOS
"RTN","HLCSTCP4",125,0)
 N HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL,HLZRULE
"RTN","HLCSTCP4",126,0)
 ;
"RTN","HLCSTCP4",127,0)
 ; protect variables defined in LISTEN^HLCSTCP
"RTN","HLCSTCP4",128,0)
 ; N HLLSTN,HLCSOUT,HLDBACK,HLDBSIZE,HLDREAD,HLDRETR,HLRETRA,HLDWAIT
"RTN","HLCSTCP4",129,0)
 ; N HLOS,HLTCPADD,HLTCPCS,HLTCPLNK,HLTCPORT,HLTCPRET,HLCSFAIL
"RTN","HLCSTCP4",130,0)
 N HLLSTN
"RTN","HLCSTCP4",131,0)
 ;
"RTN","HLCSTCP4",132,0)
 ; protect variables defined in CACHEVMS^HLCSTCP and EN^HLCSTCP
"RTN","HLCSTCP4",133,0)
 N %
"RTN","HLCSTCP4",134,0)
 ; protect variables defined in this routine HLCSTCP1
"RTN","HLCSTCP4",135,0)
 N $ETRAP,$ESTACK
"RTN","HLCSTCP4",136,0)
 N HLMIEN,HLASTMSG
"RTN","HLCSTCP4",137,0)
 N HLTMBUF
"RTN","HLCSTCP4",138,0)
 N HLDUZ,DUZ
"RTN","HLCSTCP4",139,0)
 ; Kernel variables for single listener
"RTN","HLCSTCP4",140,0)
 N ZISOS,ZRULE
"RTN","HLCSTCP4",141,0)
 ;
"RTN","HLCSTCP4",142,0)
 D KILL^XUSCLEAN
"RTN","HLCSTCP4",143,0)
 Q
"RTN","HLCSTCP4",144,0)
MIEN ; sets HLIND1=ien in 773^ien in 772 for message
"RTN","HLCSTCP4",145,0)
 N HLMID,X
"RTN","HLCSTCP4",146,0)
 I HLIND1 D
"RTN","HLCSTCP4",147,0)
 . S:'$G(^HLMA(+HLIND1,0)) HLIND1=0
"RTN","HLCSTCP4",148,0)
 . S:'$G(^HL(772,+$P(HLIND1,U,2),0)) HLIND1=0
"RTN","HLCSTCP4",149,0)
 ;msg. id is 10th of MSH & 11th for BSH or FSH
"RTN","HLCSTCP4",150,0)
 S X=10+($E(HLMSG(1,0),1,3)'="MSH"),HLMID=$$PMSH(.HLMSG,X)
"RTN","HLCSTCP4",151,0)
 ;if HLIND1 is set, kill old message, use HLIND1 for new
"RTN","HLCSTCP4",152,0)
 ;message, it means we never got end block for 1st msg.
"RTN","HLCSTCP4",153,0)
 I HLIND1 D  Q
"RTN","HLCSTCP4",154,0)
 . ;get pointer to 772, kill header
"RTN","HLCSTCP4",155,0)
 . ;
"RTN","HLCSTCP4",156,0)
 . ; patch HL*1.6*122: MPI-client/server
"RTN","HLCSTCP4",157,0)
 . F  L +^HLMA(+HLIND1):10 Q:$T  H 1
"RTN","HLCSTCP4",158,0)
 . K ^HLMA(+HLIND1,"MSH")
"RTN","HLCSTCP4",159,0)
 . L -^HLMA(+HLIND1)
"RTN","HLCSTCP4",160,0)
 . ;
"RTN","HLCSTCP4",161,0)
 . I $D(^HL(772,+$P(HLIND1,U,2),"IN")) K ^("IN")
"RTN","HLCSTCP4",162,0)
 . S X=$$MAID^HLTF(+HLIND1,HLMID)
"RTN","HLCSTCP4",163,0)
 . D SAVE^HLCSTCP1(.HLMSG,"^HLMA("_+HLIND1_",""MSH"")")
"RTN","HLCSTCP4",164,0)
 . S:$P(HLIND1,U,3) $P(HLIND1,U,3)=""
"RTN","HLCSTCP4",165,0)
 D TCP^HLTF(.HLMID,.X,.HLDT)
"RTN","HLCSTCP4",166,0)
 S HLBUFF("IEN773")=X
"RTN","HLCSTCP4",167,0)
 I 'X D  Q
"RTN","HLCSTCP4",168,0)
 . ;error - record and reset array
"RTN","HLCSTCP4",169,0)
 . ;killing HLLSTN will allow MON^HLCSTCP to work with multi-server
"RTN","HLCSTCP4",170,0)
 . D CLEAN^HLCSTCP1 K HLLSTN
"RTN","HLCSTCP4",171,0)
 . ;error 100=LLP could not en-queue the message, reset array
"RTN","HLCSTCP4",172,0)
 . D MONITOR^HLCSDR2(100,19,HLDP),MON^HLCSTCP("ERROR") H 30
"RTN","HLCSTCP4",173,0)
 ;HLIND1=ien in 773^ien in 772
"RTN","HLCSTCP4",174,0)
 S HLIND1=X_U_+$G(^HLMA(X,0))
"RTN","HLCSTCP4",175,0)
 S HLBUFF("HLIND1")=HLIND1
"RTN","HLCSTCP4",176,0)
 ;save MSH into 773
"RTN","HLCSTCP4",177,0)
 D SAVE^HLCSTCP1(.HLMSG,"^HLMA("_+HLIND1_",""MSH"")")
"RTN","HLCSTCP4",178,0)
 Q
"RTN","HLCSTCP4",179,0)
 ;
"RTN","HLCSTCP4",180,0)
PMSH(MSH,P) ;get piece P from MSH array (passed by ref.)
"RTN","HLCSTCP4",181,0)
 N FS,I,L,L1,L2,X,Y
"RTN","HLCSTCP4",182,0)
 S FS=$E(MSH(1,0),4),(L2,Y)=0,X=""
"RTN","HLCSTCP4",183,0)
 F I=1:1 S L1=$L($G(MSH(I,0)),FS),L=L1+Y-1 D  Q:$L(X)!'$D(MSH(I,0))
"RTN","HLCSTCP4",184,0)
 . S:L1=1 L=L+1
"RTN","HLCSTCP4",185,0)
 . S:P'>L X=$P($G(MSH(I-1,0)),FS,P-L2)_$P($G(MSH(I,0)),FS,(P-Y))
"RTN","HLCSTCP4",186,0)
 . S L2=Y,Y=L
"RTN","HLCSTCP4",187,0)
 Q X
"RTN","HLCSTCP4",188,0)
 ;
"RTN","HLCSTCP4",189,0)
ERROR1 ;
"RTN","HLCSTCP4",190,0)
 ; moved from ERROR^HLCSTCP1
"RTN","HLCSTCP4",191,0)
 ; Error trap for disconnect error and return back to the read loop.
"RTN","HLCSTCP4",192,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP4",193,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP4",194,0)
 ; S $ETRAP="D HALT^ZU" ;RWF
"RTN","HLCSTCP4",195,0)
 S $ETRAP="H 1 D HALT^ZU" ;RWF
"RTN","HLCSTCP4",196,0)
 ; patch HL*1.6*157 start
"RTN","HLCSTCP4",197,0)
 N HLOSYS
"RTN","HLCSTCP4",198,0)
 S HLOSYS=$$OS^%ZOSV
"RTN","HLCSTCP4",199,0)
 ; I (^%ZOSF("OS")["OpenM") D
"RTN","HLCSTCP4",200,0)
 I (HLOSYS["UNIX")!(HLOSYS["VMS") D
"RTN","HLCSTCP4",201,0)
 . ; patch HL*1.6*157 end
"RTN","HLCSTCP4",202,0)
 . S HLTCP("$ZA")=$ZA
"RTN","HLCSTCP4",203,0)
 . ; For TCP devices $ZA\8192#2: the device is currently in the
"RTN","HLCSTCP4",204,0)
 . ; Connected state talking to a remote host.
"RTN","HLCSTCP4",205,0)
 . S HLTCP("$ZA\8192#2")=$ZA\8192#2
"RTN","HLCSTCP4",206,0)
 . ; patch HL*1.6*157 to include <DSCON>: disconnected by client
"RTN","HLCSTCP4",207,0)
 . ; I HLTCP("$ZA\8192#2")=0 D
"RTN","HLCSTCP4",208,0)
 . I (HLTCP("$ZA\8192#2")=0)!($$EC^%ZOSV["DSCON") D
"RTN","HLCSTCP4",209,0)
 .. ; decrement counter of multi-listener
"RTN","HLCSTCP4",210,0)
 .. I $D(^HLCS(870,"E","M",+$G(HLDP))) D EXITM^HLCSTCP
"RTN","HLCSTCP4",211,0)
 .. ; process terminated
"RTN","HLCSTCP4",212,0)
 .. D H2^XUSCLEAN
"RTN","HLCSTCP4",213,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP4",214,0)
 ;S $ETRAP="D UNWIND^%ZTER" ;RWF
"RTN","HLCSTCP4",215,0)
 ; I $$EC^%ZOSV["READ"!($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D UNWIND^%ZTER Q
"RTN","HLCSTCP4",216,0)
 I ($$EC^%ZOSV["NOTOPEN")!($$EC^%ZOSV["DEVNOTOPN") D  Q
"RTN","HLCSTCP4",217,0)
 . ; if it is not a multi-listener
"RTN","HLCSTCP4",218,0)
 . I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Open-err")
"RTN","HLCSTCP4",219,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",220,0)
 I $$EC^%ZOSV["READ" D  Q
"RTN","HLCSTCP4",221,0)
 . ; if it is not a multi-listener
"RTN","HLCSTCP4",222,0)
 . I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Rd-err")
"RTN","HLCSTCP4",223,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",224,0)
 ;
"RTN","HLCSTCP4",225,0)
 ; I $$EC^%ZOSV["WRITE" D CC("Wr-err") D UNWIND^%ZTER Q
"RTN","HLCSTCP4",226,0)
 I $$EC^%ZOSV["WRITE" D  Q
"RTN","HLCSTCP4",227,0)
 . ; if it is not a multi-listener
"RTN","HLCSTCP4",228,0)
 . I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Wr-err")
"RTN","HLCSTCP4",229,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",230,0)
 ;
"RTN","HLCSTCP4",231,0)
 ; for GT.M
"RTN","HLCSTCP4",232,0)
 I $ECODE["UREAD" D  Q
"RTN","HLCSTCP4",233,0)
 . ; if it is not a multi-listener
"RTN","HLCSTCP4",234,0)
 . I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Rd-err")
"RTN","HLCSTCP4",235,0)
 . D UNWIND^%ZTER
"RTN","HLCSTCP4",236,0)
 ;
"RTN","HLCSTCP4",237,0)
 ; S HLCSOUT=1 D ^%ZTER,CC("Error")
"RTN","HLCSTCP4",238,0)
 S HLCSOUT=1
"RTN","HLCSTCP4",239,0)
 D ^%ZTER
"RTN","HLCSTCP4",240,0)
 ; if it is not a multi-listener
"RTN","HLCSTCP4",241,0)
 I '$D(^HLCS(870,"E","M",+$G(HLDP))) D CC^HLCSTCP1("Error")
"RTN","HLCSTCP4",242,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP4",243,0)
 ;
"RTN","HLCSTCP4",244,0)
 D UNWIND^%ZTER
"RTN","HLCSTCP4",245,0)
 Q
"RTN","HLCSTCP4",246,0)
 ;
"RTN","HLCSTCP4",247,0)
CLRMCNTR ;
"RTN","HLCSTCP4",248,0)
 ; clear the counter to set as "0 server" for multi-listener
"RTN","HLCSTCP4",249,0)
 ; HL*1.6*122 start
"RTN","HLCSTCP4",250,0)
 Q:'$G(HLDP)
"RTN","HLCSTCP4",251,0)
 Q:'$D(^HLCS(870,"E","M",HLDP))
"RTN","HLCSTCP4",252,0)
 S $P(^HLCS(870,HLDP,0),"^",4)="MS"
"RTN","HLCSTCP4",253,0)
 S $P(^HLCS(870,HLDP,0),U,5)="0 server"
"RTN","HLCSTCP4",254,0)
 Q
"RTN","HLCSTCP4",255,0)
 ;
"RTN","HLCSTCP4",256,0)
CREATUSR ;
"RTN","HLCSTCP4",257,0)
 ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSTCP4",258,0)
 ; create application proxy users for listeners and incoming filer
"RTN","HLCSTCP4",259,0)
 ;; N HLTEMP
"RTN","HLCSTCP4",260,0)
 ;; S HLTEMP=$$CREATE^XUSAP("HLSEVEN,APPLICATION PROXY","#")
"RTN","HLCSTCP4",261,0)
 Q
"RTN","HLCSTCPA")
0^3^B13412536^B6096093
"RTN","HLCSTCPA",1,0)
HLCSTCPA ;OI&T-OAKLAND/RJH  TCP/IP FOR VMS/LINUX(UNIX) ;08/02/2011  16:31
"RTN","HLCSTCPA",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**84,122,157**;Oct 13, 1995;Build 8
"RTN","HLCSTCPA",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCPA",4,0)
 ;
"RTN","HLCSTCPA",5,0)
 ; 1. port number is input from VMS COM file, or Linux/UNIX xinetd service file.
"RTN","HLCSTCPA",6,0)
 ;    example: (file: /etc/xinetd.d/fey_hlot)
"RTN","HLCSTCPA",7,0)
 ;     #default: on
"RTN","HLCSTCPA",8,0)
 ;     #description: VA HL7 Listener for DEVFEY - port 5000
"RTN","HLCSTCPA",9,0)
 ;     #
"RTN","HLCSTCPA",10,0)
 ;     service fey_hlst
"RTN","HLCSTCPA",11,0)
 ;     {
"RTN","HLCSTCPA",12,0)
 ;         type = UNLISTED
"RTN","HLCSTCPA",13,0)
 ;         disable = no
"RTN","HLCSTCPA",14,0)
 ;         flags = REUSE
"RTN","HLCSTCPA",15,0)
 ;         socket_type = stream
"RTN","HLCSTCPA",16,0)
 ;         protocol = tcp
"RTN","HLCSTCPA",17,0)
 ;         port = 5000
"RTN","HLCSTCPA",18,0)
 ;         wait = no
"RTN","HLCSTCPA",19,0)
 ;         user = feytcpip
"RTN","HLCSTCPA",20,0)
 ;         env = TZ=/usr/share/zoneinfo/US/Eastern
"RTN","HLCSTCPA",21,0)
 ;         env += port=5000
"RTN","HLCSTCPA",22,0)
 ;         server = /usr/local/cachesys/devfey/bin/csession
"RTN","HLCSTCPA",23,0)
 ;         server_args = devfey -ci -U DEVFEY PORT^HLCSTCPA
"RTN","HLCSTCPA",24,0)
 ;         instances = UNLIMITED
"RTN","HLCSTCPA",25,0)
 ;         per_source = UNLIMITED
"RTN","HLCSTCPA",26,0)
 ;     }
"RTN","HLCSTCPA",27,0)
 ;     #end
"RTN","HLCSTCPA",28,0)
 ;
"RTN","HLCSTCPA",29,0)
 ; 2. find the ien of #870(logical link file) for the multi-listener
"RTN","HLCSTCPA",30,0)
 Q
"RTN","HLCSTCPA",31,0)
 ;
"RTN","HLCSTCPA",32,0)
GTMPORT(%) ; From tcpip ZFOO for GT.M
"RTN","HLCSTCPA",33,0)
 ; %: device^port number
"RTN","HLCSTCPA",34,0)
 N HLPORT
"RTN","HLCSTCPA",35,0)
 S HLPORT=$P($G(%),"^",2)
"RTN","HLCSTCPA",36,0)
 I $G(^%ZOSF("OS"))'["GT.M" D ^%ZTER Q
"RTN","HLCSTCPA",37,0)
 D IEN
"RTN","HLCSTCPA",38,0)
 Q
"RTN","HLCSTCPA",39,0)
 ;
"RTN","HLCSTCPA",40,0)
PORT ;
"RTN","HLCSTCPA",41,0)
 ; HLPORT: port number of multi-listener
"RTN","HLCSTCPA",42,0)
 ; input of DSM: % = device^port number of multi-listener
"RTN","HLCSTCPA",43,0)
 ; input of Cache: port number of TCPIP
"RTN","HLCSTCPA",44,0)
 ;
"RTN","HLCSTCPA",45,0)
 N HLPORT
"RTN","HLCSTCPA",46,0)
 S HLPORT=0
"RTN","HLCSTCPA",47,0)
 ; patch HL*1.6*157 start, supports both OpenVMS/TCPIP and Linux/xinetd
"RTN","HLCSTCPA",48,0)
 ; I ^%ZOSF("OS")["OpenM" D
"RTN","HLCSTCPA",49,0)
 N HLOSYS
"RTN","HLCSTCPA",50,0)
 S HLOSYS=$$OS^%ZOSV
"RTN","HLCSTCPA",51,0)
 I HLOSYS["UNIX" D  G IEN
"RTN","HLCSTCPA",52,0)
 . ; Cache system call
"RTN","HLCSTCPA",53,0)
 . S HLPORT=$System.Util.GetEnviron("port")
"RTN","HLCSTCPA",54,0)
 . Q:HLPORT
"RTN","HLCSTCPA",55,0)
 . I 'HLPORT S HLPORT=$System.Util.GetEnviron("PORT")
"RTN","HLCSTCPA",56,0)
 . Q:HLPORT
"RTN","HLCSTCPA",57,0)
 . S ^XTMP("HL7-LINUX: No port from O.S.",0)=$$FMADD^XLFDT($$NOW^XLFDT,30)_"^"_$$NOW^XLFDT
"RTN","HLCSTCPA",58,0)
 ;
"RTN","HLCSTCPA",59,0)
 I HLOSYS["VMS" D  G IEN
"RTN","HLCSTCPA",60,0)
 . S HLPORT=$ZF("GETSYM","PORT")
"RTN","HLCSTCPA",61,0)
 ; patch HL*1.6*157 end
"RTN","HLCSTCPA",62,0)
 ;
"RTN","HLCSTCPA",63,0)
 I ^%ZOSF("OS")["DSM" D
"RTN","HLCSTCPA",64,0)
 . S HLPORT=$P(%,"^",2)
"RTN","HLCSTCPA",65,0)
 ;
"RTN","HLCSTCPA",66,0)
IEN ;
"RTN","HLCSTCPA",67,0)
 ; HLIEN870: ien in #870 (logical link file)
"RTN","HLCSTCPA",68,0)
 ; HLPRTS: port number in entry to be tested
"RTN","HLCSTCPA",69,0)
 ;
"RTN","HLCSTCPA",70,0)
 N HLIEN870
"RTN","HLCSTCPA",71,0)
 I 'HLPORT D ^%ZTER Q
"RTN","HLCSTCPA",72,0)
 S HLIEN870=0
"RTN","HLCSTCPA",73,0)
 F  S HLIEN870=$O(^HLCS(870,"E","M",HLIEN870)) Q:'HLIEN870  D  Q:(HLPRTS=HLPORT)
"RTN","HLCSTCPA",74,0)
 . S HLPRTS=$P(^HLCS(870,HLIEN870,400),"^",2)
"RTN","HLCSTCPA",75,0)
 ;
"RTN","HLCSTCPA",76,0)
 I 'HLIEN870 D ^%ZTER Q
"RTN","HLCSTCPA",77,0)
 ;
"RTN","HLCSTCPA",78,0)
 K HLPORT,HLPRTS
"RTN","HLCSTCPA",79,0)
 ; patch 122
"RTN","HLCSTCPA",80,0)
 S U="^"
"RTN","HLCSTCPA",81,0)
 ;
"RTN","HLCSTCPA",82,0)
 ; patch HL*1.6*157 start, supports both OpenVMS/TCPIP and Linux/xinetd
"RTN","HLCSTCPA",83,0)
 ; I ^%ZOSF("OS")["OpenM" D  Q
"RTN","HLCSTCPA",84,0)
 I $G(HLOSYS)="" S HLOSYS=""
"RTN","HLCSTCPA",85,0)
 I (HLOSYS["UNIX") D  Q
"RTN","HLCSTCPA",86,0)
 . D LINUX(HLIEN870)
"RTN","HLCSTCPA",87,0)
 I (HLOSYS["VMS") D  Q
"RTN","HLCSTCPA",88,0)
 . D CACHEVMS(HLIEN870)
"RTN","HLCSTCPA",89,0)
 ; patch HL*1.6*157 end
"RTN","HLCSTCPA",90,0)
 ;
"RTN","HLCSTCPA",91,0)
 ;for DSM
"RTN","HLCSTCPA",92,0)
 I ^%ZOSF("OS")["DSM" D  Q
"RTN","HLCSTCPA",93,0)
 . S $P(%,"^",2)=HLIEN870   ;set % = device^ien of #870
"RTN","HLCSTCPA",94,0)
 . K HLIEN870
"RTN","HLCSTCPA",95,0)
 . D EN
"RTN","HLCSTCPA",96,0)
 ;
"RTN","HLCSTCPA",97,0)
 ;for GT.M
"RTN","HLCSTCPA",98,0)
 I ^%ZOSF("OS")["GT.M" D  Q
"RTN","HLCSTCPA",99,0)
 . S HLDP=HLIEN870   ;set HLDP = ien of #870
"RTN","HLCSTCPA",100,0)
 . K HLIEN870
"RTN","HLCSTCPA",101,0)
 . D GTMUCX
"RTN","HLCSTCPA",102,0)
 ;
"RTN","HLCSTCPA",103,0)
 D ^%ZTER
"RTN","HLCSTCPA",104,0)
 Q
"RTN","HLCSTCPA",105,0)
GTMUCX ; GT.M /VMS tcpip
"RTN","HLCSTCPA",106,0)
 ;listener,  % = device^port
"RTN","HLCSTCPA",107,0)
 S U="^",IO=$P(%,U)
"RTN","HLCSTCPA",108,0)
 ; S IO(0)=$P O IO(0) ;Setup null device
"RTN","HLCSTCPA",109,0)
 ; GTM specific code
"RTN","HLCSTCPA",110,0)
 S @("$ZINTERRUPT=""I $$JOBEXAM^ZU($ZPOSITION)""")
"RTN","HLCSTCPA",111,0)
 X "O IO:(RECORDSIZE=512)"
"RTN","HLCSTCPA",112,0)
 D LISTEN^HLCSTCP
"RTN","HLCSTCPA",113,0)
 C IO
"RTN","HLCSTCPA",114,0)
 Q
"RTN","HLCSTCPA",115,0)
 ;
"RTN","HLCSTCPA",116,0)
 ; $ x=f$trnlnm("sys$net")  !This is our MBX device
"RTN","HLCSTCPA",117,0)
 ; $!
"RTN","HLCSTCPA",118,0)
 ; $! for GT.M
"RTN","HLCSTCPA",119,0)
 ; $ assign 'f$trnlnm("SYS$NET")' SYS$NET
"RTN","HLCSTCPA",120,0)
 ; $! Depending on how your command files are set up, you may need to
"RTN","HLCSTCPA",121,0)
 ; $! run the GT.M profile file.
"RTN","HLCSTCPA",122,0)
 ; $ @<user$:[gtmmgr]>gtmprofile.com
"RTN","HLCSTCPA",123,0)
 ; $ forfoo="$" + f$parse("user$:[gtmmgr.r]ZFOO.exe")
"RTN","HLCSTCPA",124,0)
 ; $ PORT=5000
"RTN","HLCSTCPA",125,0)
 ; $ data="''x'^''PORT'"
"RTN","HLCSTCPA",126,0)
 ; $ forfoo GTMPORT^HLCSTCPA("''data'")
"RTN","HLCSTCPA",127,0)
 ;
"RTN","HLCSTCPA",128,0)
CACHEVMS(%) ;Cache'/VMS tcpip
"RTN","HLCSTCPA",129,0)
 ;listener,  % = HLDP
"RTN","HLCSTCPA",130,0)
 I $G(%)="" D ^%ZTER Q
"RTN","HLCSTCPA",131,0)
 ; patch 133
"RTN","HLCSTCPA",132,0)
 S IO="SYS$NET",U="^",HLDP=%
"RTN","HLCSTCPA",133,0)
 S IO(0)="_NLA0:" O IO(0) ;Setup null device
"RTN","HLCSTCPA",134,0)
 ; **Cache'/VMS specific code**
"RTN","HLCSTCPA",135,0)
 O IO::5 E  D MON^HLCSTCP("Openfail") Q
"RTN","HLCSTCPA",136,0)
 X "U IO:(::""-M"")" ;Packet mode like DSM
"RTN","HLCSTCPA",137,0)
 D LISTEN^HLCSTCP
"RTN","HLCSTCPA",138,0)
 C IO
"RTN","HLCSTCPA",139,0)
 Q
"RTN","HLCSTCPA",140,0)
 ;
"RTN","HLCSTCPA",141,0)
LINUX(%) ;
"RTN","HLCSTCPA",142,0)
 ; patch HL*1.6*157, Cache/UNIX for Linux
"RTN","HLCSTCPA",143,0)
 ; listener,  % = HLDP
"RTN","HLCSTCPA",144,0)
 I $G(%)="" D ^%ZTER Q
"RTN","HLCSTCPA",145,0)
 S IO=$P,U="^",HLDP=%
"RTN","HLCSTCPA",146,0)
 S IO(0)="/dev/null" O IO(0) ;Setup null device
"RTN","HLCSTCPA",147,0)
 ; 
"RTN","HLCSTCPA",148,0)
 O IO::5 E  D MON^HLCSTCP("Openfail") Q
"RTN","HLCSTCPA",149,0)
 X "U IO:(::""-M"")" ;Packet mode like DSM
"RTN","HLCSTCPA",150,0)
 D LISTEN^HLCSTCP
"RTN","HLCSTCPA",151,0)
 C IO
"RTN","HLCSTCPA",152,0)
 Q
"RTN","HLCSTCPA",153,0)
 ;
"RTN","HLCSTCPA",154,0)
EN ; DSM/VMS tcpip
"RTN","HLCSTCPA",155,0)
 ;listener,  % = device^HLDP
"RTN","HLCSTCPA",156,0)
 I $G(%)="" D ^%ZTER Q
"RTN","HLCSTCPA",157,0)
 ; patch 122
"RTN","HLCSTCPA",158,0)
 ; S IO="SYS$NET",U="^",HLDP=$P(%,U,2)
"RTN","HLCSTCPA",159,0)
 S U="^",IO=$P(%,U),HLDP=$P(%,U,2)
"RTN","HLCSTCPA",160,0)
 ; patch 133
"RTN","HLCSTCPA",161,0)
 S IO(0)="_NLA0:" O IO(0) ;Setup null device
"RTN","HLCSTCPA",162,0)
 ; **VMS specific code, need to share device**
"RTN","HLCSTCPA",163,0)
 O IO:(TCPDEV):60 E  D MON^HLCSTCP("Openfail") Q
"RTN","HLCSTCPA",164,0)
 ; patch 122
"RTN","HLCSTCPA",165,0)
 D LISTEN^HLCSTCP
"RTN","HLCSTCPA",166,0)
 C IO
"RTN","HLCSTCPA",167,0)
 Q
"RTN","HLOSRVR")
0^1^B95024776^B84093197
"RTN","HLOSRVR",1,0)
HLOSRVR ;ALB/CJM/OAK/PIJ- Server for receiving messages - 10/4/94 1pm ;08/02/2011
"RTN","HLOSRVR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134,137,138,139,143,147,157**;Oct 13, 1995;Build 8
"RTN","HLOSRVR",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR",4,0)
 ;
"RTN","HLOSRVR",5,0)
GETWORK(WORK) ;
"RTN","HLOSRVR",6,0)
 ;GET WORK function for a single server or a Taskman multi-server
"RTN","HLOSRVR",7,0)
 N LINK
"RTN","HLOSRVR",8,0)
 I '$$CHKSTOP^HLOPROC,$G(WORK("LINK"))]"",$$GETLINK^HLOTLNK(WORK("LINK"),.LINK),+LINK("SERVER") S WORK("PORT")=LINK("PORT") Q 1
"RTN","HLOSRVR",9,0)
 Q 0
"RTN","HLOSRVR",10,0)
 ;
"RTN","HLOSRVR",11,0)
DOWORKS(WORK) ;
"RTN","HLOSRVR",12,0)
 ;DO WORK rtn for a single server (non-concurrent)
"RTN","HLOSRVR",13,0)
 N $ETRAP,$ESTACK
"RTN","HLOSRVR",14,0)
 S $ETRAP="G ERROR^HLOSRVR3"
"RTN","HLOSRVR",15,0)
 D SERVER(WORK("LINK"))
"RTN","HLOSRVR",16,0)
 Q
"RTN","HLOSRVR",17,0)
DOWORKM(WORK) ;
"RTN","HLOSRVR",18,0)
 ;DO WORK rtn for a Taskman multi-server (Cache systems only)
"RTN","HLOSRVR",19,0)
 D LISTEN^%ZISTCPS(WORK("PORT"),"SERVER^HLOSRVR("""_WORK("LINK")_""")")
"RTN","HLOSRVR",20,0)
 Q
"RTN","HLOSRVR",21,0)
 ;
"RTN","HLOSRVR",22,0)
VMS2(LINKNAME) ;called from a VMS TCP Service once a connection request has been received.  This entry point should be used only if an additional VMS TCPIP Services are being created for HLO.
"RTN","HLOSRVR",23,0)
 ;Input:
"RTN","HLOSRVR",24,0)
 ;   LINKNAME - only pass it in if an additional service is being created on a different port
"RTN","HLOSRVR",25,0)
 Q:'$L(LINKNAME)
"RTN","HLOSRVR",26,0)
 D VMS
"RTN","HLOSRVR",27,0)
 Q
"RTN","HLOSRVR",28,0)
 ;
"RTN","HLOSRVR",29,0)
VMS ;Called from VMS TCP Service once a connection request has been received. This entry point should be used only by the standard HLO service that runs on the standard HLO port.
"RTN","HLOSRVR",30,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",31,0)
 D
"RTN","HLOSRVR",32,0)
 .Q:$L($G(LINKNAME))
"RTN","HLOSRVR",33,0)
 .;
"RTN","HLOSRVR",34,0)
 .N PROC,NODE
"RTN","HLOSRVR",35,0)
 .S PROC=$O(^HLD(779.3,"B","VMS TCP LISTENER",0))
"RTN","HLOSRVR",36,0)
 .I PROC S LINKNAME=$P($G(^HLD(779.3,PROC,0)),"^",14) Q:$L(LINKNAME)
"RTN","HLOSRVR",37,0)
 .S NODE=$G(^HLD(779.1,1,0)) I $P(NODE,"^",10) S LINKNAME=$P($G(^HLCS(870,$P(NODE,"^",10),0)),"^") Q:$L(LINKNAME) 
"RTN","HLOSRVR",38,0)
 .S LINKNAME="HLO DEFAULT LISTENER"
"RTN","HLOSRVR",39,0)
 ;
"RTN","HLOSRVR",40,0)
 D SERVER(LINKNAME,"SYS$NET")
"RTN","HLOSRVR",41,0)
 Q
"RTN","HLOSRVR",42,0)
LINUX1 ;The listener entry point on Linux systems.  The HL LOGICAL LINK should
"RTN","HLOSRVR",43,0)
 ;be specified in the xinetd configuration file as the variable
"RTN","HLOSRVR",44,0)
 ;HLOLINK or otherwise in the HLO SYSTEM PARAMETERS file 
"RTN","HLOSRVR",45,0)
 ;
"RTN","HLOSRVR",46,0)
 N LINKNAME,NODE
"RTN","HLOSRVR",47,0)
 S LINKNAME=$System.Util.GetEnviron("HLOLINK")
"RTN","HLOSRVR",48,0)
 I '$L(LINKNAME) S NODE=$G(^HLD(779.1,1,0)) I $P(NODE,"^",10) S LINKNAME=$P($G(^HLCS(870,$P(NODE,"^",10),0)),"^")
"RTN","HLOSRVR",49,0)
 S:'$L(LINKNAME) LINKNAME="HLO DEFAULT LISTENER"
"RTN","HLOSRVR",50,0)
 D LINUX(LINKNAME)
"RTN","HLOSRVR",51,0)
 Q
"RTN","HLOSRVR",52,0)
 ;
"RTN","HLOSRVR",53,0)
LINUX(LINKNAME) ;Listener for Linux systems running under Xinetd.
"RTN","HLOSRVR",54,0)
 ;Input:
"RTN","HLOSRVR",55,0)
 ;  LINKNAME - name of the HL LOGICAL LINK for the listener
"RTN","HLOSRVR",56,0)
 ;
"RTN","HLOSRVR",57,0)
 Q:'$L($G(LINKNAME))
"RTN","HLOSRVR",58,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",59,0)
 ;
"RTN","HLOSRVR",60,0)
 D $ZU(68,15,1) ;need error on disconnect
"RTN","HLOSRVR",61,0)
 D SERVER(LINKNAME,$PRINCIPAL)
"RTN","HLOSRVR",62,0)
 Q
"RTN","HLOSRVR",63,0)
 ;
"RTN","HLOSRVR",64,0)
SERVER(LINKNAME,LOGICAL) ; LINKNAME identifies the logical link, which describes the communication channel to be used
"RTN","HLOSRVR",65,0)
 ;;Start HL*1.6*138 PIJ
"RTN","HLOSRVR",66,0)
 ;;N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR1"
"RTN","HLOSRVR",67,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR3"
"RTN","HLOSRVR",68,0)
 ;;End HL*1.6*138 PIJ
"RTN","HLOSRVR",69,0)
 N HLCSTATE,INQUE
"RTN","HLOSRVR",70,0)
 S INQUE=0
"RTN","HLOSRVR",71,0)
 ;
"RTN","HLOSRVR",72,0)
ZB1 ;
"RTN","HLOSRVR",73,0)
 ;
"RTN","HLOSRVR",74,0)
 Q:'$$CONNECT(.HLCSTATE,LINKNAME,.LOGICAL)
"RTN","HLOSRVR",75,0)
 ;
"RTN","HLOSRVR",76,0)
 K LINKNAME
"RTN","HLOSRVR",77,0)
 F  Q:'HLCSTATE("CONNECTED")  D  Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",78,0)
 .N HLMSTATE,SENT
"RTN","HLOSRVR",79,0)
 .;read msg and parse the hdr
"RTN","HLOSRVR",80,0)
 .;HLMSTATE("MSA",1) is set with type of ack to return
"RTN","HLOSRVR",81,0)
 .;
"RTN","HLOSRVR",82,0)
 .I $$READMSG^HLOSRVR1(.HLCSTATE,.HLMSTATE) D
"RTN","HLOSRVR",83,0)
 ..I (HLMSTATE("MSA",1)]"") S SENT=$$WRITEACK(.HLCSTATE,.HLMSTATE) D:HLMSTATE("IEN") SAVEACK(.HLMSTATE,SENT)
"RTN","HLOSRVR",84,0)
 ..;
"RTN","HLOSRVR",85,0)
 ..;** P143 START CJM **
"RTN","HLOSRVR",86,0)
 ..I HLMSTATE("ID")'="" L -HLO("MSGID",HLMSTATE("ID"))
"RTN","HLOSRVR",87,0)
 ..;** P143 END CJM **
"RTN","HLOSRVR",88,0)
 ..;
"RTN","HLOSRVR",89,0)
 ..D:HLMSTATE("IEN") UPDATE(.HLMSTATE,.HLCSTATE)
"RTN","HLOSRVR",90,0)
 ..D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",91,0)
 ..I $G(HLMSTATE("ACK TO","IEN")),$L($G(HLMSTATE("ACK TO","SEQUENCE QUEUE"))) D ADVANCE^HLOQUE(HLMSTATE("ACK TO","SEQUENCE QUEUE"),+HLMSTATE("ACK TO","IEN"))
"RTN","HLOSRVR",92,0)
 .E  D
"RTN","HLOSRVR",93,0)
 ..;** P143 START CJM **
"RTN","HLOSRVR",94,0)
 ..I $G(HLMSTATE("ID"))'="" L -HLO("MSGID",HLMSTATE("ID"))
"RTN","HLOSRVR",95,0)
 ..;** P143 END CJM **
"RTN","HLOSRVR",96,0)
 ..D INQUE() H:HLCSTATE("CONNECTED") 1
"RTN","HLOSRVR",97,0)
 ;
"RTN","HLOSRVR",98,0)
END D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR",99,0)
 D INQUE()
"RTN","HLOSRVR",100,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",101,0)
 Q
"RTN","HLOSRVR",102,0)
 ;
"RTN","HLOSRVR",103,0)
CONNECT(HLCSTATE,LINKNAME,LOGICAL) ;
"RTN","HLOSRVR",104,0)
 ;sets up HLCSTATE() and opens a server connection
"RTN","HLOSRVR",105,0)
 ;
"RTN","HLOSRVR",106,0)
 N LINK,NODE
"RTN","HLOSRVR",107,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOSRVR",108,0)
 Q:'$$GETLINK^HLOTLNK(LINKNAME,.LINK) 0
"RTN","HLOSRVR",109,0)
ZB999 ; 
"RTN","HLOSRVR",110,0)
 Q:+LINK("SERVER")'=1 0
"RTN","HLOSRVR",111,0)
 S HLCSTATE("SERVER")=LINK("SERVER")
"RTN","HLOSRVR",112,0)
 M HLCSTATE("LINK")=LINK
"RTN","HLOSRVR",113,0)
 S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOSRVR",114,0)
 S HLCSTATE("OPEN TIMEOUT")=30
"RTN","HLOSRVR",115,0)
 S HLCSTATE("READ")="" ;buffer for reads
"RTN","HLOSRVR",116,0)
 ;
"RTN","HLOSRVR",117,0)
 ;HLCSTATE("BUFFER",<seg>,<line>)  write buffer
"RTN","HLOSRVR",118,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of bytes in buffer
"RTN","HLOSRVR",119,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOSRVR",120,0)
 ;
"RTN","HLOSRVR",121,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOSRVR",122,0)
 S HLCSTATE("MESSAGE STARTED")=0 ;start of message flag
"RTN","HLOSRVR",123,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOSRVR",124,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOSRVR",125,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOSRVR",126,0)
 Q:HLCSTATE("SYSTEM","OS")="" 0
"RTN","HLOSRVR",127,0)
 D  ;get necessary system parameters
"RTN","HLOSRVR",128,0)
 .N SYS,SUB
"RTN","HLOSRVR",129,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOSRVR",130,0)
 .F SUB="MAXSTRING","DOMAIN","STATION","PROCESSING ID","NORMAL PURGE","ERROR PURGE" S HLCSTATE("SYSTEM",SUB)=SYS(SUB)
"RTN","HLOSRVR",131,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOSRVR",132,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOSRVR",133,0)
 .D OPEN^HLOTCP(.HLCSTATE,.LOGICAL)
"RTN","HLOSRVR",134,0)
 E  ;no other LLP implemented
"RTN","HLOSRVR",135,0)
 ;
"RTN","HLOSRVR",136,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOSRVR",137,0)
 ;
"RTN","HLOSRVR",138,0)
INQUE(MSGIEN,PARMS) ;
"RTN","HLOSRVR",139,0)
 ;
"RTN","HLOSRVR",140,0)
 ;** do not implement the Pass Immediate parameter **
"RTN","HLOSRVR",141,0)
 ;INQUE(MSGIEN,PARMS,IMMEDIATE);
"RTN","HLOSRVR",142,0)
 ;
"RTN","HLOSRVR",143,0)
 ;puts received messages on the incoming queue and sets the B x-ref
"RTN","HLOSRVR",144,0)
 I $G(MSGIEN) S INQUE=INQUE+1 M INQUE(MSGIEN)=PARMS
"RTN","HLOSRVR",145,0)
 ;
"RTN","HLOSRVR",146,0)
 ;** do not implement the Pass Immediate parameter **
"RTN","HLOSRVR",147,0)
 ;I ('$G(MSGIEN))!(INQUE>20)!($G(IMMEDIATE)) S MSGIEN=0 D
"RTN","HLOSRVR",148,0)
 ;
"RTN","HLOSRVR",149,0)
 I ('$G(MSGIEN))!(INQUE>20) S MSGIEN=0 D
"RTN","HLOSRVR",150,0)
 .F  S MSGIEN=$O(INQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOSRVR",151,0)
 ..S ^HLB("B",INQUE(MSGIEN,"MSGID"),MSGIEN)=""
"RTN","HLOSRVR",152,0)
 ..S ^HLA("B",INQUE(MSGIEN,"DT/TM"),INQUE(MSGIEN,"BODY"))=""
"RTN","HLOSRVR",153,0)
 ..D:INQUE(MSGIEN,"PASS")
"RTN","HLOSRVR",154,0)
 ...N PURGE
"RTN","HLOSRVR",155,0)
 ...S PURGE=+$G(INQUE(MSGIEN,"PURGE"))
"RTN","HLOSRVR",156,0)
 ...S PURGE("ACKTOIEN")=$G(INQUE(MSGIEN,"ACKTOIEN"))
"RTN","HLOSRVR",157,0)
 ...D INQUE^HLOQUE(INQUE(MSGIEN,"FROM"),INQUE(MSGIEN,"QUEUE"),MSGIEN,INQUE(MSGIEN,"ACTION"),.PURGE)
"RTN","HLOSRVR",158,0)
 .K INQUE S INQUE=0
"RTN","HLOSRVR",159,0)
 Q
"RTN","HLOSRVR",160,0)
 ;
"RTN","HLOSRVR",161,0)
SAVEACK(HLMSTATE,SENT) ;
"RTN","HLOSRVR",162,0)
 ;Input:
"RTN","HLOSRVR",163,0)
 ;  SENT - flag = 1 if transmission of ack succeeded, 0 otherwise
"RTN","HLOSRVR",164,0)
 ;
"RTN","HLOSRVR",165,0)
 N NODE,I,XX
"RTN","HLOSRVR",166,0)
 S $P(NODE,"^")=HLMSTATE("MSA","DT/TM OF MESSAGE")
"RTN","HLOSRVR",167,0)
 S $P(NODE,"^",2)=HLMSTATE("MSA","MESSAGE CONTROL ID")
"RTN","HLOSRVR",168,0)
 S $P(NODE,"^",3)="MSA"
"RTN","HLOSRVR",169,0)
 F I=1:1:3 S NODE=NODE_"|"_$G(HLMSTATE("MSA",I))
"RTN","HLOSRVR",170,0)
 S ^HLB(HLMSTATE("IEN"),4)=NODE
"RTN","HLOSRVR",171,0)
 S:SENT $P(^HLB(HLMSTATE("IEN"),0),"^",$S($E(HLMSTATE("MSA",1))="A":18,1:17))=1
"RTN","HLOSRVR",172,0)
 Q
"RTN","HLOSRVR",173,0)
 ;
"RTN","HLOSRVR",174,0)
UPDATE(HLMSTATE,HLCSTATE) ;
"RTN","HLOSRVR",175,0)
 ;Updates status and purge date when appropriate
"RTN","HLOSRVR",176,0)
 ;Also, sets the "B" xrefs, files 777,778, and places message on the incoming queue
"RTN","HLOSRVR",177,0)
 ;
"RTN","HLOSRVR",178,0)
 N PARMS,PURGE,WAIT
"RTN","HLOSRVR",179,0)
 S PARMS("PASS")=0
"RTN","HLOSRVR",180,0)
 I HLMSTATE("STATUS","ACTION")]"",HLMSTATE("STATUS")'="ER" D
"RTN","HLOSRVR",181,0)
 .N IEN
"RTN","HLOSRVR",182,0)
 .S IEN=HLMSTATE("IEN")
"RTN","HLOSRVR",183,0)
 .S PARMS("PASS")=1,$P(^HLB(IEN,0),"^",6)=HLMSTATE("STATUS","QUEUE"),$P(^HLB(IEN,0),"^",10)=$P(HLMSTATE("STATUS","ACTION"),"^"),$P(^HLB(IEN,0),"^",11)=$P(HLMSTATE("STATUS","ACTION"),"^",2)
"RTN","HLOSRVR",184,0)
 D:'PARMS("PASS")  ;if not passing to the app, set the purge date
"RTN","HLOSRVR",185,0)
 .I HLMSTATE("STATUS")="" S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",186,0)
 .S:HLMSTATE("BATCH") WAIT=HLCSTATE("SYSTEM","ERROR PURGE")
"RTN","HLOSRVR",187,0)
 .S:'HLMSTATE("BATCH") WAIT=$S(($G(HLMSTATE("ACK TO","STATUS"))="ER"):24*HLCSTATE("SYSTEM","ERROR PURGE"),HLMSTATE("STATUS")="ER":24*HLCSTATE("SYSTEM","ERROR PURGE"),1:HLCSTATE("SYSTEM","NORMAL PURGE"))
"RTN","HLOSRVR",188,0)
 .S PURGE=$$FMADD^XLFDT($$NOW^XLFDT,,WAIT)
"RTN","HLOSRVR",189,0)
 .S $P(^HLB(HLMSTATE("IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",190,0)
 .S ^HLB("AD","IN",PURGE,HLMSTATE("IEN"))=""
"RTN","HLOSRVR",191,0)
 .;if this is an app ack, purge the original message at the same time
"RTN","HLOSRVR",192,0)
 .I $G(HLMSTATE("ACK TO","IEN")),'HLMSTATE("BATCH") D
"RTN","HLOSRVR",193,0)
 ..S $P(^HLB(+HLMSTATE("ACK TO","IEN"),0),"^",9)=PURGE
"RTN","HLOSRVR",194,0)
 ..S ^HLB("AD","IN",PURGE,+HLMSTATE("ACK TO","IEN"))=""
"RTN","HLOSRVR",195,0)
 ;
"RTN","HLOSRVR",196,0)
 ;if not waiting for an application ack, set the status now even if passing to the app - but don't set the purge until the infiler passes the message
"RTN","HLOSRVR",197,0)
 I HLMSTATE("STATUS")="",($G(HLMSTATE("ACK TO","IEN"))!HLMSTATE("HDR","APP ACK TYPE")'="AL") S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",198,0)
 I HLMSTATE("STATUS")'="" S $P(^HLB(HLMSTATE("IEN"),0),"^",20)=HLMSTATE("STATUS") S:$G(HLMSTATE("MSA",3))]"" $P(^HLB(HLMSTATE("IEN"),0),"^",21)=HLMSTATE("MSA",3) D:HLMSTATE("STATUS")'="SU"
"RTN","HLOSRVR",199,0)
 .N APP
"RTN","HLOSRVR",200,0)
 .S APP=HLMSTATE("HDR","RECEIVING APPLICATION") S:APP="" APP="UNKNOWN" S ^HLB("ERRORS",APP,HLMSTATE("DT/TM"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR",201,0)
 .D COUNT^HLOESTAT("IN",$G(HLMSTATE("HDR","RECEIVING APPLICATION")),$G(HLMSTATE("HDR","SENDING APPLICATION")),$S(HLMSTATE("BATCH"):"BATCH",1:$G(HLMSTATE("HDR","MESSAGE TYPE"))),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR",202,0)
 ;
"RTN","HLOSRVR",203,0)
 ;set the necessary parms for passing the msg to the app via the infiler
"RTN","HLOSRVR",204,0)
 D:PARMS("PASS")
"RTN","HLOSRVR",205,0)
 .N I,FROM
"RTN","HLOSRVR",206,0)
 .S FROM=HLMSTATE("HDR","SENDING FACILITY",1)
"RTN","HLOSRVR",207,0)
 .I HLMSTATE("HDR","SENDING FACILITY",2)]"" S FROM=FROM_"~"_HLMSTATE("HDR","SENDING FACILITY",2)_"~"_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",208,0)
 .I FROM="" S FROM="UNKNOWN SENDING FACILITY"
"RTN","HLOSRVR",209,0)
 .S PARMS("FROM")=FROM,PARMS("QUEUE")=HLMSTATE("STATUS","QUEUE"),PARMS("ACTION")=HLMSTATE("STATUS","ACTION")
"RTN","HLOSRVR",210,0)
 .I HLMSTATE("STATUS")'="" S PARMS("PURGE")=$S(HLMSTATE("STATUS")="ER":2,$G(HLMSTATE("ACK TO","STATUS"))="ER":2,1:1)
"RTN","HLOSRVR",211,0)
 .S:$G(HLMSTATE("ACK TO","IEN")) PARMS("ACKTOIEN")=HLMSTATE("ACK TO","IEN") ;to insure that the infiler will know to set the purge date at the same time as the initial message
"RTN","HLOSRVR",212,0)
 ;
"RTN","HLOSRVR",213,0)
 S PARMS("BODY")=HLMSTATE("BODY")
"RTN","HLOSRVR",214,0)
 S PARMS("DT/TM")=HLMSTATE("DT/TM")
"RTN","HLOSRVR",215,0)
 S PARMS("MSGID")=HLMSTATE("ID")
"RTN","HLOSRVR",216,0)
 ;
"RTN","HLOSRVR",217,0)
 ;** do not implement the Pass Immediate parameter **
"RTN","HLOSRVR",218,0)
 ;D INQUE(HLMSTATE("IEN"),.PARMS,$G(HLMSTATE("STATUS","PASS IMMEDIATE")))
"RTN","HLOSRVR",219,0)
 ;
"RTN","HLOSRVR",220,0)
 D INQUE(HLMSTATE("IEN"),.PARMS)
"RTN","HLOSRVR",221,0)
 Q
"RTN","HLOSRVR",222,0)
 ;
"RTN","HLOSRVR",223,0)
WRITEACK(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR",224,0)
 ;Sends an accept ack
"RTN","HLOSRVR",225,0)
 ;
"RTN","HLOSRVR",226,0)
 ;Input:
"RTN","HLOSRVR",227,0)
 ;  HLCSTATE (pass by reference) defines the communication channel
"RTN","HLOSRVR",228,0)
 ;  HLMSTATE (pass by reference) the message being acked
"RTN","HLOSRVR",229,0)
 ;     ("MSA",1) - value for MSA-1
"RTN","HLOSRVR",230,0)
 ;     ("MSA",2) - value for MSA-2
"RTN","HLOSRVR",231,0)
 ;     ("MSA",3) - value for MSA-3
"RTN","HLOSRVR",232,0)
 ;     ("HDR") - parsed values for the message being ack'd
"RTN","HLOSRVR",233,0)
 ;Output:
"RTN","HLOSRVR",234,0)
 ;  Function returns 1 if successful, 0 otherwise
"RTN","HLOSRVR",235,0)
 ;  HLMSTATE("MSA","MESSAGE CONTROL ID") - the msg id of the ack
"RTN","HLOSRVR",236,0)
 ;  HLMSTATE(,"MSA","DT/TM OF MESSAGE") - from the ack header
"RTN","HLOSRVR",237,0)
 ; 
"RTN","HLOSRVR",238,0)
 N HDR,SUB,FS,CS,MSA,ACKID,TIME
"RTN","HLOSRVR",239,0)
 ;Hard-code the delimiters, the standard requires that the receiving system accept the delimiters listed in the header
"RTN","HLOSRVR",240,0)
 S FS="|"
"RTN","HLOSRVR",241,0)
 S CS="^"
"RTN","HLOSRVR",242,0)
 S TIME=$$NOW^XLFDT
"RTN","HLOSRVR",243,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=TIME
"RTN","HLOSRVR",244,0)
 S ACKID=HLCSTATE("SYSTEM","STATION")_" "_$$NEWIEN^HLOF778A("OUT")
"RTN","HLOSRVR",245,0)
 S HLMSTATE("MSA","MESSAGE CONTROL ID")=ACKID
"RTN","HLOSRVR",246,0)
 ;
"RTN","HLOSRVR",247,0)
 S HDR(1)="MSH"_FS_"^~\&"_FS_HLMSTATE("HDR","RECEIVING APPLICATION")_FS_HLCSTATE("SYSTEM","STATION")_CS_HLCSTATE("SYSTEM","DOMAIN")_CS_"DNS"_FS
"RTN","HLOSRVR",248,0)
 S HDR(1)=HDR(1)_HLMSTATE("HDR","SENDING APPLICATION")_FS_HLMSTATE("HDR","SENDING FACILITY",1)_CS_HLMSTATE("HDR","SENDING FACILITY",2)_CS_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",249,0)
 ;
"RTN","HLOSRVR",250,0)
 S HDR(2)=FS_$$HLDATE^HLFNC(TIME,"TS")_FS_FS_"ACK"_FS_ACKID_FS_HLMSTATE("HDR","PROCESSING ID")_FS_"2.4"_FS_FS_FS_"NE"_FS_"NE"
"RTN","HLOSRVR",251,0)
 ;
"RTN","HLOSRVR",252,0)
 S MSA(1)="MSA"_FS
"RTN","HLOSRVR",253,0)
 F SUB=1:1:3 S MSA(1)=MSA(1)_HLMSTATE("MSA",SUB)_FS
"RTN","HLOSRVR",254,0)
 I $$WRITEHDR^HLOT(.HLCSTATE,.HDR),$$WRITESEG^HLOT(.HLCSTATE,.MSA),$$ENDMSG^HLOT(.HLCSTATE) S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1 Q 1
"RTN","HLOSRVR",255,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=""
"RTN","HLOSRVR",256,0)
 Q 0
"RTN","HLOSRVR3")
0^2^B1207898^B1081356
"RTN","HLOSRVR3",1,0)
HLOSRVR3 ;IRMFO/OAK/CJM - Reading messages, sending acks;03/24/2004  14:43 ;08/16/2011
"RTN","HLOSRVR3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**138,147,157**;Oct 13, 1995;Build 8
"RTN","HLOSRVR3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR3",4,0)
 ;
"RTN","HLOSRVR3",5,0)
ERROR ;error trap
"RTN","HLOSRVR3",6,0)
 ;
"RTN","HLOSRVR3",7,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOSRVR3",8,0)
 D END^HLOSRVR
"RTN","HLOSRVR3",9,0)
 ;
"RTN","HLOSRVR3",10,0)
 I ($ECODE["TOOMANYFILES")!($ECODE["EDITED") Q:$QUIT "" Q
"RTN","HLOSRVR3",11,0)
 ;
"RTN","HLOSRVR3",12,0)
 ;multi-listener should stop execution, only a single server may continue
"RTN","HLOSRVR3",13,0)
 I $P($G(HLCSTATE("LINK","SERVER")),"^",2)'="S" D  Q:$QUIT "" Q
"RTN","HLOSRVR3",14,0)
 .;don't log these errors unless logging is turned on
"RTN","HLOSRVR3",15,0)
 .I $G(^HLTMP("LOG ALL ERRORS")) D ^%ZTER Q
"RTN","HLOSRVR3",16,0)
 .I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR")!($ECODE["DSCON") Q
"RTN","HLOSRVR3",17,0)
 .D ^%ZTER
"RTN","HLOSRVR3",18,0)
 .Q
"RTN","HLOSRVR3",19,0)
 ;
"RTN","HLOSRVR3",20,0)
 ;single listener should return to the process manager
"RTN","HLOSRVR3",21,0)
 Q:$Q "" Q
"RTN","HLTF")
0^10^B26864166^B24387774
"RTN","HLTF",1,0)
HLTF ;AISC/SAW,JRP-Create/Process Message Text File Entries ;08/05/2011  14:37
"RTN","HLTF",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**1,19,43,55,109,120,122,142,157**;Oct 13, 1995;Build 8
"RTN","HLTF",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLTF",4,0)
 ;
"RTN","HLTF",5,0)
 Q
"RTN","HLTF",6,0)
 ;
"RTN","HLTF",7,0)
FILE ;Create Entries in files 772 and 773 for Version 1.5 Interface Only
"RTN","HLTF",8,0)
 D CREATE(,.HLDA,.HLDT,.HLDT1)
"RTN","HLTF",9,0)
 Q
"RTN","HLTF",10,0)
CREATE(HLMID,MTIEN,HLDT,HLDT1) ;Create entries in Message Text (#772)
"RTN","HLTF",11,0)
 ;
"RTN","HLTF",12,0)
 ;Input  : HLMID = Variable in which value of message ID will be
"RTN","HLTF",13,0)
 ;                 returned (pass by reference)
"RTN","HLTF",14,0)
 ;         MTIEN = Variable in which IEN of Message Text file entry
"RTN","HLTF",15,0)
 ;                 will be returned (pass by reference)
"RTN","HLTF",16,0)
 ;         HLDT = Variable in which current date/time in FM internal
"RTN","HLTF",17,0)
 ;                format will be returned (pass by reference)
"RTN","HLTF",18,0)
 ;         HLDT1 = Variable in which current date/time in HL7 format
"RTN","HLTF",19,0)
 ;                 will be returned (pass by reference)
"RTN","HLTF",20,0)
 ;
"RTN","HLTF",21,0)
 ;Output : See above
"RTN","HLTF",22,0)
 ;
"RTN","HLTF",23,0)
 ;Notes  : If HLDT has a value [upon entry], the created entries will
"RTN","HLTF",24,0)
 ;         be given that value for their date/time (value of .01)
"RTN","HLTF",25,0)
 ;       : Current date/time used if HLDT is not passed or invalid
"RTN","HLTF",26,0)
 ;
"RTN","HLTF",27,0)
 ;Make entry in Message Administration file
"RTN","HLTF",28,0)
 N Y
"RTN","HLTF",29,0)
 S HLDT=$G(HLDT)
"RTN","HLTF",30,0)
 D MT(.HLDT)
"RTN","HLTF",31,0)
 S Y=$$CHNGMID(MTIEN,.HLMID),HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLTF",32,0)
 Q
"RTN","HLTF",33,0)
TCP(HLMID,MTIEN,HLDT) ;create new message in 772 & 773 entries
"RTN","HLTF",34,0)
 ;used for incoming messages and outgoing responses
"RTN","HLTF",35,0)
 ;Input  : HLMID = Variable in which value of message ID will be
"RTN","HLTF",36,0)
 ;                 returned (pass by reference)
"RTN","HLTF",37,0)
 ;         MTIEN = Variable in which IEN of file 773 entry
"RTN","HLTF",38,0)
 ;                 will be returned (pass by reference)
"RTN","HLTF",39,0)
 ;         HLDT = Variable in which current date/time in FM internal
"RTN","HLTF",40,0)
 ;                format will be returned (pass by reference)
"RTN","HLTF",41,0)
 ;
"RTN","HLTF",42,0)
 S HLDT=$G(HLDT),HLMID=$G(HLMID)
"RTN","HLTF",43,0)
 D MT(.HLDT)
"RTN","HLTF",44,0)
 S MTIEN=$$MA(MTIEN,.HLMID)
"RTN","HLTF",45,0)
 Q
"RTN","HLTF",46,0)
 ;
"RTN","HLTF",47,0)
MT(HLX) ;Create entry in Message Text file (#772)
"RTN","HLTF",48,0)
 ;
"RTN","HLTF",49,0)
 ;Input  : HLX = Date/time entry in file should be given (value of .01)
"RTN","HLTF",50,0)
 ;               Defaults to current date/time
"RTN","HLTF",51,0)
 ;
"RTN","HLTF",52,0)
 ;Output : HLDT = Date/time of created entry (value of .01)
"RTN","HLTF",53,0)
 ;       : HLDT1 = HLDT in HL7 format
"RTN","HLTF",54,0)
 ;
"RTN","HLTF",55,0)
 ;Notes  : HLX must be in FileMan format (default value used if not)
"RTN","HLTF",56,0)
 ;       : HLDT will be in FileMan format
"RTN","HLTF",57,0)
 ;       : MTIEN is ien in file 772
"RTN","HLTF",58,0)
 ;
"RTN","HLTF",59,0)
 ;Check for input
"RTN","HLTF",60,0)
 S HLX=$G(HLX)
"RTN","HLTF",61,0)
 ;Declare variables
"RTN","HLTF",62,0)
 N DIC,DD,DO,HLCNT,HLJ,X,Y
"RTN","HLTF",63,0)
 F HLCNT=0:1 D  Q:Y>0  H HLCNT
"RTN","HLTF",64,0)
 . I (HLX'?7N.1".".6N) S HLX=$$NOW^XLFDT
"RTN","HLTF",65,0)
 . S DIC="^HL(772,",DIC(0)="L",(HLDT,X)=HLX
"RTN","HLTF",66,0)
 . S Y=$$STUB772(X) ; This call substituted for D FILE^DICN by HL*1.6*109
"RTN","HLTF",67,0)
 . ;Entry not created - try again
"RTN","HLTF",68,0)
 . I Y<0 S HLX="" Q
"RTN","HLTF",69,0)
 . S MTIEN=+Y
"RTN","HLTF",70,0)
 ;***If we didn't get a record in 772, need to do something
"RTN","HLTF",71,0)
 I Y<0 Q
"RTN","HLTF",72,0)
 S HLDT1=$$HLDATE^HLFNC(HLDT)
"RTN","HLTF",73,0)
 Q
"RTN","HLTF",74,0)
 ;add to Message Admin file #773
"RTN","HLTF",75,0)
MA(X,HLMID) ;X=ien in file 772, HLMID=msg. id (passed by ref.)
"RTN","HLTF",76,0)
 ;return ien in file 773
"RTN","HLTF",77,0)
 ;
"RTN","HLTF",78,0)
 ; patch HL*1.6*122: MPI-client/server start
"RTN","HLTF",79,0)
 F  L +^HL(772,+$G(X)):10 Q:$T  H 1
"RTN","HLTF",80,0)
 ; patch HL*1.6*142: MPI-client/server start
"RTN","HLTF",81,0)
 N COUNT,FLAG
"RTN","HLTF",82,0)
 S FLAG=0
"RTN","HLTF",83,0)
 F COUNT=1:1:15 D  Q:FLAG  H COUNT
"RTN","HLTF",84,0)
 . Q:'($D(^HL(772,X,0))#2)
"RTN","HLTF",85,0)
 . Q:($G(^HL(772,X,0))']"")
"RTN","HLTF",86,0)
 . S FLAG=1
"RTN","HLTF",87,0)
 ; patch HL*1.6*142: MPI-client/server end
"RTN","HLTF",88,0)
 Q:'$G(^HL(772,X,0)) 0
"RTN","HLTF",89,0)
 L -^HL(772,+$G(X))
"RTN","HLTF",90,0)
 ; patch HL*1.6*122: MPI-client/server end
"RTN","HLTF",91,0)
 ;
"RTN","HLTF",92,0)
 N DA,DD,DO,DIC,DIE,DR,HLDA,HLCNT,HLJ,Y
"RTN","HLTF",93,0)
 S DIC="^HLMA(",DIC(0)="L"
"RTN","HLTF",94,0)
 F HLCNT=0:1 D  Q:Y>0  H HLCNT
"RTN","HLTF",95,0)
 . S Y=$$STUB773(X) ; This call substituted for D FILE^DICN by HL*1.6*109
"RTN","HLTF",96,0)
 ;***If we didn't get a record in 773, need to do something
"RTN","HLTF",97,0)
 I Y<0 Q 0
"RTN","HLTF",98,0)
 S HLDA=+Y,HLMID=$$MAID(HLDA,$G(HLMID))
"RTN","HLTF",99,0)
 Q HLDA
"RTN","HLTF",100,0)
 ;
"RTN","HLTF",101,0)
MAID(Y,HLMID) ;Determine message ID (if needed) & store message ID
"RTN","HLTF",102,0)
 ;Y=ien in 773, HLMID=id,  Output message id
"RTN","HLTF",103,0)
 N HLJ
"RTN","HLTF",104,0)
 ;need to have id contain institution number to make unique
"RTN","HLTF",105,0)
 S:$G(HLMID)="" HLMID=+$P($$PARAM^HLCS2,U,6)_Y
"RTN","HLTF",106,0)
 S HLJ(773,Y_",",2)=HLMID
"RTN","HLTF",107,0)
 D FILE^HLDIE("","HLJ","","MAID","HLTF") ;HL*1.6*109
"RTN","HLTF",108,0)
 Q HLMID
"RTN","HLTF",109,0)
 ;
"RTN","HLTF",110,0)
CHNGMID(PTRMT,NEWID) ;Change message ID for entry in Message Text file
"RTN","HLTF",111,0)
 ;Input  : PTRMT - Pointer to entry in Message Text file (#772)
"RTN","HLTF",112,0)
 ;         NEWID - New message ID
"RTN","HLTF",113,0)
 ;Output : 0 = Success
"RTN","HLTF",114,0)
 ;         -1^ErrorText = Error/Bad input
"RTN","HLTF",115,0)
 ;
"RTN","HLTF",116,0)
 ;Check input
"RTN","HLTF",117,0)
 S PTRMT=+$G(PTRMT)
"RTN","HLTF",118,0)
 S NEWID=$G(NEWID)
"RTN","HLTF",119,0)
 Q:('$D(^HL(772,PTRMT,0))) "-1^Did not pass valid pointer to Message Text file (#772)"
"RTN","HLTF",120,0)
 N HLJ
"RTN","HLTF",121,0)
 I $G(NEWID)="" S NEWID=+$P($$PARAM^HLCS2,U,6)_PTRMT
"RTN","HLTF",122,0)
 S HLJ(772,PTRMT_",",6)=NEWID
"RTN","HLTF",123,0)
 D FILE^HLDIE("","HLJ","","CHNGMID","HLTF") ; HL*1.6*109
"RTN","HLTF",124,0)
 Q 0
"RTN","HLTF",125,0)
 ;
"RTN","HLTF",126,0)
OUT(HLDA,HLMID,HLMTN) ;File Data in Message Text File for Outgoing Message
"RTN","HLTF",127,0)
 ;Version 1.5 Interface Only
"RTN","HLTF",128,0)
 ;
"RTN","HLTF",129,0)
 ; patch HL*1.6*122: HLTF routine splitted, moves sub-routines,
"RTN","HLTF",130,0)
 ; OUT, IN, and ACK to HLTF2 routine.
"RTN","HLTF",131,0)
 ;
"RTN","HLTF",132,0)
 D OUT^HLTF2($G(HLDA),$G(HLMID),$G(HLMTN))
"RTN","HLTF",133,0)
 Q
"RTN","HLTF",134,0)
 ;
"RTN","HLTF",135,0)
IN(HLMTN,HLMID,HLTIME) ;File Data in Message Text File for Incoming Message
"RTN","HLTF",136,0)
 ;Version 1.5 Interface Only
"RTN","HLTF",137,0)
 ;
"RTN","HLTF",138,0)
 ; patch HL*1.6*122: HLTF routine splitted, moves sub-routines,
"RTN","HLTF",139,0)
 ; OUT, IN, and ACK to HLTF2 routine.
"RTN","HLTF",140,0)
 ;
"RTN","HLTF",141,0)
 D IN^HLTF2($G(HLMTN),$G(HLMID),$G(HLTIME))
"RTN","HLTF",142,0)
 Q
"RTN","HLTF",143,0)
 ;
"RTN","HLTF",144,0)
ACK(HLMSA,HLIO,HLDA) ;Process 'ACK' Message Type - Version 1.5 Interface Only
"RTN","HLTF",145,0)
 ;
"RTN","HLTF",146,0)
 ; patch HL*1.6*122: HLTF routine splitted, moves sub-routines,
"RTN","HLTF",147,0)
 ; OUT, IN, and ACK to HLTF2 routine.
"RTN","HLTF",148,0)
 ;
"RTN","HLTF",149,0)
 D ACK^HLTF2($G(HLMSA),$G(HLIO),$G(HLDA))
"RTN","HLTF",150,0)
 Q
"RTN","HLTF",151,0)
 ;
"RTN","HLTF",152,0)
STUB772(FLD01,OS) ;
"RTN","HLTF",153,0)
 ;This function creates a new stub record in file 772. The Stub record may consist of only the 0 node with a value of "^". If a value is passed in for the .01 field it will be included in the 0 node and its "B" x-ref set.
"RTN","HLTF",154,0)
 ;Inputs:
"RTN","HLTF",155,0)
 ;  OS (optional), the value of ^%ZOSF("OS")
"RTN","HLTF",156,0)
 ;  FLD01 (optional), the value for the .01 field
"RTN","HLTF",157,0)
 ;Output - the function returns the ien of the newly created record
"RTN","HLTF",158,0)
 ;
"RTN","HLTF",159,0)
 N IEN
"RTN","HLTF",160,0)
 I '$L($G(OS)) N OS S OS=$G(^%ZOSF("OS"))
"RTN","HLTF",161,0)
 ; patch HL*1.6*157 start, supports Linux/xinetd
"RTN","HLTF",162,0)
 N HLOSYS
"RTN","HLTF",163,0)
 S HLOSYS=$$OS^%ZOSV
"RTN","HLTF",164,0)
 ; I OS'["DSM",OS'["OpenM" D
"RTN","HLTF",165,0)
 I OS'["DSM",(OS'["OpenM")!((OS["OpenM")&(HLOSYS'["VMS")&(HLOSYS'["UNIX")) D
"RTN","HLTF",166,0)
 .F  L +^HLCS(869.3,1,772):10 S IEN=+$G(^HLCS(869.3,1,772))+1,^HLCS(869.3,1,772)=IEN S:$D(^HL(772,IEN)) IEN=0,^HLCS(869.3,1,772)=($O(^HL(772,":"),-1)\1) L -^HLCS(869.3,1,772) Q:IEN
"RTN","HLTF",167,0)
 E  D
"RTN","HLTF",168,0)
 .F  S IEN=$I(^HLCS(869.3,1,772),1) S:$D(^HL(772,IEN)) IEN=0,^HLCS(869.3,1,772)=($O(^HL(772,":"),-1)\1) Q:IEN
"RTN","HLTF",169,0)
 ;
"RTN","HLTF",170,0)
 ; patch HL*1.6*122: MPI-client/server start
"RTN","HLTF",171,0)
 F  L +^HL(772,IEN):10 Q:$T  H 1
"RTN","HLTF",172,0)
 S ^HL(772,IEN,0)=$G(FLD01)_"^"
"RTN","HLTF",173,0)
 I $L($G(FLD01)) S ^HL(772,"B",FLD01,IEN)=""
"RTN","HLTF",174,0)
 L -^HL(772,IEN)
"RTN","HLTF",175,0)
 ; patch HL*1.6*122: MPI-client/server end
"RTN","HLTF",176,0)
 ;
"RTN","HLTF",177,0)
 Q IEN
"RTN","HLTF",178,0)
 ;
"RTN","HLTF",179,0)
STUB773(FLD01,OS) ;
"RTN","HLTF",180,0)
 ;This function creates a new stub record in file 772. The Stub record may consist of only the 0 node with a value of "^". If a value is passed in for the .01 field it will be included in the 0 node and its "B" x-ref set.
"RTN","HLTF",181,0)
 ;Inputs:
"RTN","HLTF",182,0)
 ;  OS (optional), the value of ^%ZOSF("OS")
"RTN","HLTF",183,0)
 ;  FLD01 (optional), the value for the .01 field
"RTN","HLTF",184,0)
 ;Output - the function returns the ien of the newly created record
"RTN","HLTF",185,0)
 ;
"RTN","HLTF",186,0)
 N IEN
"RTN","HLTF",187,0)
 I '$L($G(OS)) N OS S OS=$G(^%ZOSF("OS"))
"RTN","HLTF",188,0)
 ; patch HL*1.6*157 start, supports Linux/xinetd
"RTN","HLTF",189,0)
 N HLOSYS
"RTN","HLTF",190,0)
 S HLOSYS=$$OS^%ZOSV
"RTN","HLTF",191,0)
 ; I OS'["DSM",OS'["OpenM" D
"RTN","HLTF",192,0)
 I OS'["DSM",(OS'["OpenM")!((OS["OpenM")&(HLOSYS'["VMS")&(HLOSYS'["UNIX")) D
"RTN","HLTF",193,0)
 .F  L +^HLCS(869.3,1,773):10 S IEN=+$G(^HLCS(869.3,1,773))+1,^HLCS(869.3,1,773)=IEN S:$D(^HLMA(IEN)) IEN=0,^HLCS(869.3,1,773)=($O(^HLMA(":"),-1)\1) L -^HLCS(869.3,1,773) Q:IEN
"RTN","HLTF",194,0)
 E  D
"RTN","HLTF",195,0)
 .F  S IEN=$I(^HLCS(869.3,1,773),1) S:$D(^HLMA(IEN)) IEN=0,^HLCS(869.3,1,773)=($O(^HLMA(":"),-1)\1) Q:IEN
"RTN","HLTF",196,0)
 ;
"RTN","HLTF",197,0)
 ; patch HL*1.6*122: MPI-client/server start
"RTN","HLTF",198,0)
 F  L +^HLMA(IEN):10 Q:$T  H 1
"RTN","HLTF",199,0)
 S ^HLMA(IEN,0)=$G(FLD01)_"^"
"RTN","HLTF",200,0)
 I $L($G(FLD01)) S ^HLMA("B",FLD01,IEN)=""
"RTN","HLTF",201,0)
 L -^HLMA(IEN)
"RTN","HLTF",202,0)
 ; patch HL*1.6*122: MPI-client/server end
"RTN","HLTF",203,0)
 ;
"RTN","HLTF",204,0)
 Q IEN
"VER")
8.0^22.0
"BLD",1552,6)
^125
**END**
**END**
