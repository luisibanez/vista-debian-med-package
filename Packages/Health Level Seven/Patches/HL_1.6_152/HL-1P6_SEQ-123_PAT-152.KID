Released HL*1.6*152 SEQ #123
Extracted from mail message
**KIDS**:HL*1.6*152^

**INSTALL NAME**
HL*1.6*152
"BLD",1523,0)
HL*1.6*152^HEALTH LEVEL SEVEN^0^3110526^y
"BLD",1523,1,0)
^^2^2^3110408^
"BLD",1523,1,1,0)
Please see the National Patch Module on Forum for a complete description.
"BLD",1523,1,2,0)

"BLD",1523,4,0)
^9.64PA^^
"BLD",1523,6.3)
3
"BLD",1523,"ABPKG")
n
"BLD",1523,"KRN",0)
^9.67PA^9002226^21
"BLD",1523,"KRN",.4,0)
.4
"BLD",1523,"KRN",.401,0)
.401
"BLD",1523,"KRN",.402,0)
.402
"BLD",1523,"KRN",.403,0)
.403
"BLD",1523,"KRN",.5,0)
.5
"BLD",1523,"KRN",.84,0)
.84
"BLD",1523,"KRN",3.6,0)
3.6
"BLD",1523,"KRN",3.8,0)
3.8
"BLD",1523,"KRN",9.2,0)
9.2
"BLD",1523,"KRN",9.8,0)
9.8
"BLD",1523,"KRN",9.8,"NM",0)
^9.68A^2^2
"BLD",1523,"KRN",9.8,"NM",1,0)
HLOSRVR1^^0^B90167265
"BLD",1523,"KRN",9.8,"NM",2,0)
HLOFILER^^0^B29094813
"BLD",1523,"KRN",9.8,"NM","B","HLOFILER",2)

"BLD",1523,"KRN",9.8,"NM","B","HLOSRVR1",1)

"BLD",1523,"KRN",19,0)
19
"BLD",1523,"KRN",19.1,0)
19.1
"BLD",1523,"KRN",101,0)
101
"BLD",1523,"KRN",409.61,0)
409.61
"BLD",1523,"KRN",771,0)
771
"BLD",1523,"KRN",779.2,0)
779.2
"BLD",1523,"KRN",870,0)
870
"BLD",1523,"KRN",8989.51,0)
8989.51
"BLD",1523,"KRN",8989.52,0)
8989.52
"BLD",1523,"KRN",8994,0)
8994
"BLD",1523,"KRN",9002226,0)
9002226
"BLD",1523,"KRN","B",.4,.4)

"BLD",1523,"KRN","B",.401,.401)

"BLD",1523,"KRN","B",.402,.402)

"BLD",1523,"KRN","B",.403,.403)

"BLD",1523,"KRN","B",.5,.5)

"BLD",1523,"KRN","B",.84,.84)

"BLD",1523,"KRN","B",3.6,3.6)

"BLD",1523,"KRN","B",3.8,3.8)

"BLD",1523,"KRN","B",9.2,9.2)

"BLD",1523,"KRN","B",9.8,9.8)

"BLD",1523,"KRN","B",19,19)

"BLD",1523,"KRN","B",19.1,19.1)

"BLD",1523,"KRN","B",101,101)

"BLD",1523,"KRN","B",409.61,409.61)

"BLD",1523,"KRN","B",771,771)

"BLD",1523,"KRN","B",779.2,779.2)

"BLD",1523,"KRN","B",870,870)

"BLD",1523,"KRN","B",8989.51,8989.51)

"BLD",1523,"KRN","B",8989.52,8989.52)

"BLD",1523,"KRN","B",8994,8994)

"BLD",1523,"KRN","B",9002226,9002226)

"BLD",1523,"QUES",0)
^9.62^^
"BLD",1523,"REQB",0)
^9.611^1^1
"BLD",1523,"REQB",1,0)
HL*1.6*147^2
"BLD",1523,"REQB","B","HL*1.6*147",1)

"MBREQ")
0
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
152^3110526
"PKG",9,22,1,"PAH",1,1,0)
^^2^2^3110526
"PKG",9,22,1,"PAH",1,1,1,0)
Please see the National Patch Module on Forum for a complete description.
"PKG",9,22,1,"PAH",1,1,2,0)

"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
2
"RTN","HLOFILER")
0^2^B29094813^B28701660
"RTN","HLOFILER",1,0)
HLOFILER ;ALB/CJM- Passes messages on the incoming queue to the applications - 10/4/94 1pm ;05/26/2011
"RTN","HLOFILER",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131,134,137,152**;Oct 13, 1995;Build 3
"RTN","HLOFILER",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOFILER",4,0)
 ;
"RTN","HLOFILER",5,0)
 ;GET WORK function for the process running under the Process Manager
"RTN","HLOFILER",6,0)
GETWORK(QUE) ;
"RTN","HLOFILER",7,0)
 ;Input:
"RTN","HLOFILER",8,0)
 ;  QUE - (pass by reference) These subscripts are used:
"RTN","HLOFILER",9,0)
 ;    ("FROM") - sending facility last obtained
"RTN","HLOFILER",10,0)
 ;    ("QUEUE") - name of the queue last obtained
"RTN","HLOFILER",11,0)
 ;Output:
"RTN","HLOFILER",12,0)
 ;  Function returns 1 if success, 0 if no more work
"RTN","HLOFILER",13,0)
 ;  QUE-  updated to identify next queu of messages to process.
"RTN","HLOFILER",14,0)
 ;
"RTN","HLOFILER",15,0)
 N FROM,QUEUE
"RTN","HLOFILER",16,0)
 I '$D(QUE("SYSTEM")) D
"RTN","HLOFILER",17,0)
 .N SYS
"RTN","HLOFILER",18,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOFILER",19,0)
 .S QUE("SYSTEM","NORMAL PURGE")=SYS("NORMAL PURGE")
"RTN","HLOFILER",20,0)
 .S QUE("SYSTEM","ERROR PURGE")=SYS("ERROR PURGE")
"RTN","HLOFILER",21,0)
 S FROM=$G(QUE("FROM")),QUEUE=$G(QUE("QUEUE"))
"RTN","HLOFILER",22,0)
 I ($G(FROM)]""),($G(QUEUE)]"") D
"RTN","HLOFILER",23,0)
 .L -^HLB("QUEUE","IN",FROM,QUEUE)
"RTN","HLOFILER",24,0)
 .F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0  Q:$T
"RTN","HLOFILER",25,0)
 I ($G(FROM)]""),($G(QUEUE)="") D
"RTN","HLOFILER",26,0)
 .F  S FROM=$O(^HLB("QUEUE","IN",FROM)) Q:FROM=""  D  Q:($G(QUEUE)]"")
"RTN","HLOFILER",27,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0 Q:$T
"RTN","HLOFILER",28,0)
 I FROM="" D
"RTN","HLOFILER",29,0)
 .F  S FROM=$O(^HLB("QUEUE","IN",FROM)) Q:FROM=""  D  Q:($G(QUEUE)]"")
"RTN","HLOFILER",30,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0 Q:$T
"RTN","HLOFILER",31,0)
 S QUE("FROM")=FROM,QUE("QUEUE")=QUEUE
"RTN","HLOFILER",32,0)
 Q:(QUEUE]"") 1
"RTN","HLOFILER",33,0)
 Q 0
"RTN","HLOFILER",34,0)
 ;
"RTN","HLOFILER",35,0)
DOWORK(QUEUE) ;passes the messages on the queue to the application
"RTN","HLOFILER",36,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOFILER"
"RTN","HLOFILER",37,0)
 ;
"RTN","HLOFILER",38,0)
 N MSGIEN,DEQUE,QUE,COUNT
"RTN","HLOFILER",39,0)
 M QUE=QUEUE
"RTN","HLOFILER",40,0)
 S (DEQUE,COUNT)=0
"RTN","HLOFILER",41,0)
 S MSGIEN=0
"RTN","HLOFILER",42,0)
 ;
"RTN","HLOFILER",43,0)
 F  S MSGIEN=$O(^HLB("QUEUE","IN",QUEUE("FROM"),QUEUE("QUEUE"),MSGIEN)) Q:'MSGIEN  S COUNT=COUNT+1 Q:COUNT>1000  D  M QUEUE=QUE
"RTN","HLOFILER",44,0)
 .N MCODE,ACTION,QUE,PURGE,ACKTOIEN,NODE,COUNT
"RTN","HLOFILER",45,0)
 .N $ETRAP,$ESTACK S $ETRAP="G ERROR2^HLOFILER"
"RTN","HLOFILER",46,0)
 .S NODE=$G(^HLB("QUEUE","IN",QUEUE("FROM"),QUEUE("QUEUE"),MSGIEN))
"RTN","HLOFILER",47,0)
 .S ACTION=$P(NODE,"^",1,2)
"RTN","HLOFILER",48,0)
 .S PURGE=$P(NODE,"^",3)
"RTN","HLOFILER",49,0)
 .S ACKTOIEN=$P(NODE,"^",4)
"RTN","HLOFILER",50,0)
 .D DEQUE(MSGIEN,PURGE,ACKTOIEN)
"RTN","HLOFILER",51,0)
 .I ACTION]"" D
"RTN","HLOFILER",52,0)
 ..N HLMSGIEN,MCODE,DEQUE,DUZ
"RTN","HLOFILER",53,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR3^HLOFILER"
"RTN","HLOFILER",54,0)
 ..S HLMSGIEN=MSGIEN
"RTN","HLOFILER",55,0)
 ..S MCODE="D "_ACTION
"RTN","HLOFILER",56,0)
 ..N MSGIEN,X
"RTN","HLOFILER",57,0)
 ..D DUZ^XUP(.5)
"RTN","HLOFILER",58,0)
 ..X MCODE
"RTN","HLOFILER",59,0)
 ..;kill the apps variables
"RTN","HLOFILER",60,0)
 ..D
"RTN","HLOFILER",61,0)
 ...N ZTSK
"RTN","HLOFILER",62,0)
 ...D KILL^XUSCLEAN
"RTN","HLOFILER",63,0)
 ;
"RTN","HLOFILER",64,0)
ENDWORK ;where the execution resumes upon an error
"RTN","HLOFILER",65,0)
 D DEQUE()
"RTN","HLOFILER",66,0)
 Q
"RTN","HLOFILER",67,0)
 ;
"RTN","HLOFILER",68,0)
DEQUE(MSGIEN,PURGE,ACKTOIEN) ;
"RTN","HLOFILER",69,0)
 ;Dequeues the message.  Also sets up the purge dt/tm and the completion status.
"RTN","HLOFILER",70,0)
 S:$G(MSGIEN) DEQUE=$G(DEQUE)+1,DEQUE(MSGIEN)=PURGE_"^"_ACKTOIEN
"RTN","HLOFILER",71,0)
 I '$G(MSGIEN)!($G(DEQUE)>25) S MSGIEN=0 D
"RTN","HLOFILER",72,0)
 .F  S MSGIEN=$O(DEQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOFILER",73,0)
 ..N NODE,PURGE,ACKTOIEN
"RTN","HLOFILER",74,0)
 ..S NODE=DEQUE(MSGIEN)
"RTN","HLOFILER",75,0)
 ..S PURGE=$P(NODE,"^"),ACKTOIEN=$P(NODE,"^",2)
"RTN","HLOFILER",76,0)
 ..D DEQUE^HLOQUE(QUEUE("FROM"),QUEUE("QUEUE"),"IN",MSGIEN)
"RTN","HLOFILER",77,0)
 ..S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOFILER",78,0)
 ..Q:NODE=""
"RTN","HLOFILER",79,0)
 ..S $P(NODE,"^",19)=1 ;sets the flag to show that the app handoff was done
"RTN","HLOFILER",80,0)
 ..D:PURGE
"RTN","HLOFILER",81,0)
 ...N STATUS
"RTN","HLOFILER",82,0)
 ...S STATUS=$P(NODE,"^",20)
"RTN","HLOFILER",83,0)
 ...S:STATUS="" $P(NODE,"^",20)="SU",STATUS="SU"
"RTN","HLOFILER",84,0)
 ...S $P(NODE,"^",9)=$$FMADD^XLFDT($$NOW^XLFDT,,$S(PURGE=2:24*QUEUE("SYSTEM","ERROR PURGE"),$D(^HLB(MSGIEN,3,1,0)):24*QUEUE("SYSTEM","ERROR PURGE"),1:QUEUE("SYSTEM","NORMAL PURGE")))
"RTN","HLOFILER",85,0)
 ...S ^HLB("AD",$S($E($P(NODE,"^",4))="I":"IN",1:"OUT"),$P(NODE,"^",9),MSGIEN)=""
"RTN","HLOFILER",86,0)
 ...I ACKTOIEN,$D(^HLB(ACKTOIEN,0)) S $P(^HLB(ACKTOIEN,0),"^",9)=$P(NODE,"^",9),^HLB("AD",$S($E($P(NODE,"^",4))="I":"OUT",1:"IN"),$P(NODE,"^",9),ACKTOIEN)=""
"RTN","HLOFILER",87,0)
 ..S ^HLB(MSGIEN,0)=NODE
"RTN","HLOFILER",88,0)
 .K DEQUE S DEQUE=0
"RTN","HLOFILER",89,0)
 Q
"RTN","HLOFILER",90,0)
 ;
"RTN","HLOFILER",91,0)
ERROR ;error trap
"RTN","HLOFILER",92,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOFILER",93,0)
 N HOUR
"RTN","HLOFILER",94,0)
 S HOUR=$E($$NOW^XLFDT,1,10)
"RTN","HLOFILER",95,0)
 S ^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2))=$G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))+1
"RTN","HLOFILER",96,0)
 ;
"RTN","HLOFILER",97,0)
 D DEQUE()
"RTN","HLOFILER",98,0)
 ;
"RTN","HLOFILER",99,0)
 ;a lot of errors of the same type may indicate an endless loop
"RTN","HLOFILER",100,0)
 ;return to the Process Manager error trap
"RTN","HLOFILER",101,0)
 I ($G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))>30) Q:$QUIT "" Q
"RTN","HLOFILER",102,0)
 ;
"RTN","HLOFILER",103,0)
 ;while debugging quit on all errors - returns to the Process Manager error trap
"RTN","HLOFILER",104,0)
 I $G(^HLTMP("LOG ALL ERRORS")) Q:$QUIT "" Q
"RTN","HLOFILER",105,0)
 I $ECODE["EDITED" Q:$QUIT "" Q
"RTN","HLOFILER",106,0)
 ;
"RTN","HLOFILER",107,0)
 D ^%ZTER
"RTN","HLOFILER",108,0)
 D UNWIND^%ZTER
"RTN","HLOFILER",109,0)
 Q:$QUIT ""
"RTN","HLOFILER",110,0)
 Q
"RTN","HLOFILER",111,0)
 ;
"RTN","HLOFILER",112,0)
ERROR2 ;
"RTN","HLOFILER",113,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOFILER",114,0)
 ;
"RTN","HLOFILER",115,0)
 D DEQUE()
"RTN","HLOFILER",116,0)
 ;
"RTN","HLOFILER",117,0)
 ;may need to change the status to Error
"RTN","HLOFILER",118,0)
 D
"RTN","HLOFILER",119,0)
 .N NODE,RAPP,SAPP,FS,CS,REP,ESCAPE,SUBCOMP,HDR,DIR,NOW
"RTN","HLOFILER",120,0)
 .S NOW=$$NOW^XLFDT
"RTN","HLOFILER",121,0)
 .S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOFILER",122,0)
 .Q:NODE=""
"RTN","HLOFILER",123,0)
 .Q:$P(NODE,"^",20)="ER"
"RTN","HLOFILER",124,0)
 .S $P(NODE,"^",20)="ER",$P(NODE,"^",21)="APPLICATION ROUTINE ERROR"
"RTN","HLOFILER",125,0)
 .S DIR=$S($E($P(NODE,"^",4))="I":"IN",1:"OUT")
"RTN","HLOFILER",126,0)
 .I $P(NODE,"^",9) K ^HLB("AD",DIR,$P(NODE,"^",9),MSGIEN)
"RTN","HLOFILER",127,0)
 .S $P(NODE,"^",9)=$$FMADD^XLFDT(NOW,,24*QUEUE("SYSTEM","ERROR PURGE"))
"RTN","HLOFILER",128,0)
 .S ^HLB(MSGIEN,0)=NODE
"RTN","HLOFILER",129,0)
 .S ^HLB("AD",DIR,$P(NODE,"^",9),MSGIEN)=""
"RTN","HLOFILER",130,0)
 .S HDR=$G(^HLB(MSGIEN,1))
"RTN","HLOFILER",131,0)
 .S FS=$E(HDR,4)
"RTN","HLOFILER",132,0)
 .Q:FS=""
"RTN","HLOFILER",133,0)
 .S CS=$E(HDR,5)
"RTN","HLOFILER",134,0)
 .S REP=$E(HDR,6)
"RTN","HLOFILER",135,0)
 .S ESCAPE=$E(HDR,7)
"RTN","HLOFILER",136,0)
 .S SUBCOMP=$E(HDR,8)
"RTN","HLOFILER",137,0)
 .S RAPP=$$DESCAPE^HLOPRS1($P($P(HDR,FS,5),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOFILER",138,0)
 .I RAPP="" S RAPP="UNKNOWN"
"RTN","HLOFILER",139,0)
 .S SAPP=$$DESCAPE^HLOPRS1($P($P(HDR,FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOFILER",140,0)
 .S ^HLB("ERRORS",RAPP,NOW,MSGIEN)=""
"RTN","HLOFILER",141,0)
 .D COUNT^HLOESTAT(DIR,RAPP,SAPP,"UNKNOWN")
"RTN","HLOFILER",142,0)
 ;
"RTN","HLOFILER",143,0)
 ;kill the apps variables
"RTN","HLOFILER",144,0)
 D
"RTN","HLOFILER",145,0)
 .N ZTSK,MSGIEN,QUEUE
"RTN","HLOFILER",146,0)
 .D KILL^XUSCLEAN
"RTN","HLOFILER",147,0)
 ;
"RTN","HLOFILER",148,0)
 ;release all the locks the app may have set, except Taskman lock
"RTN","HLOFILER",149,0)
 L:$D(ZTSK) ^%ZTSCH("TASK",ZTSK):1
"RTN","HLOFILER",150,0)
 L:'$D(ZTSK)
"RTN","HLOFILER",151,0)
 ;reset HLO's lock
"RTN","HLOFILER",152,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOFILER",153,0)
 ;return to processing the next message on the queue
"RTN","HLOFILER",154,0)
 S $ECODE=""
"RTN","HLOFILER",155,0)
 ;
"RTN","HLOFILER",156,0)
 Q:$QUIT ""
"RTN","HLOFILER",157,0)
 Q
"RTN","HLOFILER",158,0)
ERROR3 ;error trap for application context
"RTN","HLOFILER",159,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOFILER",160,0)
 D ^%ZTER
"RTN","HLOFILER",161,0)
 S $ECODE=",UAPPLICATION ERROR,"
"RTN","HLOFILER",162,0)
 ;
"RTN","HLOFILER",163,0)
 ;drop to the ERROR2 error handler
"RTN","HLOFILER",164,0)
 Q:$QUIT ""
"RTN","HLOFILER",165,0)
 Q
"RTN","HLOSRVR1")
0^1^B90167265^B86348500
"RTN","HLOSRVR1",1,0)
HLOSRVR1 ;IRMFO-ALB/CJM/OAK/PIJ - Reading messages, sending acks;03/24/2004  14:43 ;04/11/2011
"RTN","HLOSRVR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,133,134,137,138,139,143,146,147,152**;Oct 13, 1995;Build 3
"RTN","HLOSRVR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR1",4,0)
 ;
"RTN","HLOSRVR1",5,0)
READMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR1",6,0)
 ;Reads a message.  The header is parsed. Does these checks:
"RTN","HLOSRVR1",7,0)
 ; 1) Duplicate?
"RTN","HLOSRVR1",8,0)
 ; 2) Wrong Receiving Facility?
"RTN","HLOSRVR1",9,0)
 ; 3) Can the Receiving App accept this message, based message type & event?
"RTN","HLOSRVR1",10,0)
 ; 4) Processing ID must match the receiving system
"RTN","HLOSRVR1",11,0)
 ; 5) Must have an ID
"RTN","HLOSRVR1",12,0)
 ; 6) Header must be BHS or MSH
"RTN","HLOSRVR1",13,0)
 ;
"RTN","HLOSRVR1",14,0)
 ;Output:
"RTN","HLOSRVR1",15,0)
 ;  Function returns 1 if the message was read fully, 0 otherwise
"RTN","HLOSRVR1",16,0)
 ;  HLMSTATE (pass by reference) the message.  It will include the fields for the return ack in HLMSTATE("MSA")
"RTN","HLOSRVR1",17,0)
 ;
"RTN","HLOSRVR1",18,0)
 N ACK,SEG,STORE,I
"RTN","HLOSRVR1",19,0)
 ;
"RTN","HLOSRVR1",20,0)
 S STORE=1
"RTN","HLOSRVR1",21,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.SEG) 0
"RTN","HLOSRVR1",22,0)
 D SPLITHDR(.SEG)
"RTN","HLOSRVR1",23,0)
 ;
"RTN","HLOSRVR1",24,0)
 ;parse the header, stop if unsuccessful because the server cannot know what to do next
"RTN","HLOSRVR1",25,0)
 I '$$PARSEHDR^HLOPRS(.SEG) D  Q 0
"RTN","HLOSRVR1",26,0)
ZB29 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",27,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",28,0)
 ;
"RTN","HLOSRVR1",29,0)
 ;** P143 START CJM**
"RTN","HLOSRVR1",30,0)
 S I=$S(SEG("SEGMENT TYPE")="MSH":$G(SEG("MESSAGE CONTROL ID")),1:$G(SEG("BATCH CONTROL ID")))
"RTN","HLOSRVR1",31,0)
 I I'="" L +HLO("MSGID",I):5 I '$T D  Q 0
"RTN","HLOSRVR1",32,0)
 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",33,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",34,0)
 ;** P143 END CJM
"RTN","HLOSRVR1",35,0)
 ;
"RTN","HLOSRVR1",36,0)
 D NEWMSG^HLOSRVR2(.HLCSTATE,.HLMSTATE,.SEG)
"RTN","HLOSRVR1",37,0)
 I HLMSTATE("ID")="" D
"RTN","HLOSRVR1",38,0)
 .S STORE=0
"RTN","HLOSRVR1",39,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" S HLMSTATE("MSA",1)="CE",HLMSTATE("MSA",3)="CONTROL ID MISSING"
"RTN","HLOSRVR1",40,0)
 I STORE,$$DUP(.HLMSTATE) D
"RTN","HLOSRVR1",41,0)
ZB30 .S STORE=0
"RTN","HLOSRVR1",42,0)
 ;
"RTN","HLOSRVR1",43,0)
 ;if the message is not to be stored, just read it and discard the segments
"RTN","HLOSRVR1",44,0)
 I 'STORE D
"RTN","HLOSRVR1",45,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)
"RTN","HLOSRVR1",46,0)
 ;
"RTN","HLOSRVR1",47,0)
 E  D
"RTN","HLOSRVR1",48,0)
 .N FS,NEWMSGID
"RTN","HLOSRVR1",49,0)
 .S NEWMSGID=""
"RTN","HLOSRVR1",50,0)
 .S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOSRVR1",51,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOSRVR1",52,0)
 ..N MSA,SEGTYPE,OLDMSGID,CODE,IEN,TEXT
"RTN","HLOSRVR1",53,0)
 ..S SEGTYPE=$E($E(SEG(1),1,3)_$E($G(SEG(2)),1,2),1,3)
"RTN","HLOSRVR1",54,0)
 ..I SEGTYPE="MSA" D
"RTN","HLOSRVR1",55,0)
 ...S MSA=SEG(1)_$G(SEG(2))_$G(SEG(3))
"RTN","HLOSRVR1",56,0)
 ...;; ** Start HL*1.6*138 PIJ **
"RTN","HLOSRVR1",57,0)
 ...;;S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2),TEXT=$E($P(MSA,FS,4),1,30)
"RTN","HLOSRVR1",58,0)
 ...S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2)
"RTN","HLOSRVR1",59,0)
 ...S TEXT=$$ESCAPE^HLOPBLD(.HLMSTATE,$P(MSA,FS,4))
"RTN","HLOSRVR1",60,0)
 ...;; ** End HL*1.6*138 **
"RTN","HLOSRVR1",61,0)
 ...I $E(CODE,1)'="A" S SEGTYPE="" Q
"RTN","HLOSRVR1",62,0)
 ...;** P143 START CJM
"RTN","HLOSRVR1",63,0)
 ...;S:$P(OLDMSGID,"-")]"" IEN=$O(^HLB("B",$P(OLDMSGID,"-"),0))
"RTN","HLOSRVR1",64,0)
 ...;S:$G(IEN) IEN=IEN_"^"_$P(OLDMSGID,"-",2)
"RTN","HLOSRVR1",65,0)
 ...S IEN=$$ACKTOIEN^HLOMSG1("",OLDMSGID)
"RTN","HLOSRVR1",66,0)
 ...;** P143 END CJM
"RTN","HLOSRVR1",67,0)
 ..I 'HLMSTATE("BATCH") D
"RTN","HLOSRVR1",68,0)
 ...D:SEGTYPE="MSA"
"RTN","HLOSRVR1",69,0)
 ....S HLMSTATE("ACK TO")=OLDMSGID
"RTN","HLOSRVR1",70,0)
 ....S HLMSTATE("ACK TO","ACK BY")=HLMSTATE("ID")
"RTN","HLOSRVR1",71,0)
 ....S HLMSTATE("ACK TO","STATUS")=$S(CODE="AA":"SU",1:"ER")
"RTN","HLOSRVR1",72,0)
 ....I $G(IEN) D
"RTN","HLOSRVR1",73,0)
 .....S HLMSTATE("ACK TO","IEN")=IEN
"RTN","HLOSRVR1",74,0)
 .....S HLMSTATE("ACK TO","SEQUENCE QUEUE")=$P($G(^HLB(+IEN,5)),"^")
"RTN","HLOSRVR1",75,0)
 ....S HLMSTATE("ACK TO","ERROR TEXT")=TEXT
"RTN","HLOSRVR1",76,0)
 ...D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",77,0)
 ..E  D  ;batch
"RTN","HLOSRVR1",78,0)
 ...I SEGTYPE="MSH" D
"RTN","HLOSRVR1",79,0)
 ....D SPLITHDR(.SEG)
"RTN","HLOSRVR1",80,0)
 ....S NEWMSGID=$P(SEG(2),FS,5)
"RTN","HLOSRVR1",81,0)
 ....D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",82,0)
 ...E  D  ;not MSH
"RTN","HLOSRVR1",83,0)
 ....D:SEGTYPE="MSA"
"RTN","HLOSRVR1",84,0)
 .....N SUBIEN S SUBIEN=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOSRVR1",85,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN)=OLDMSGID
"RTN","HLOSRVR1",86,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"ACK BY")=NEWMSGID
"RTN","HLOSRVR1",87,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"STATUS")=$S(CODE="AA":"SU",1:"ER")
"RTN","HLOSRVR1",88,0)
 .....S:$D(IEN) HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN")=IEN
"RTN","HLOSRVR1",89,0)
 ....D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",90,0)
 .I HLMSTATE("UNSTORED LINES"),HLCSTATE("MESSAGE ENDED"),$$SAVEMSG^HLOF778(.HLMSTATE)
"RTN","HLOSRVR1",91,0)
 ;
"RTN","HLOSRVR1",92,0)
 I STORE,'HLCSTATE("MESSAGE ENDED") D
"RTN","HLOSRVR1",93,0)
 .;reading failed, don't store
"RTN","HLOSRVR1",94,0)
 .D:HLMSTATE("IEN") DEL778(HLMSTATE("IEN")) D:HLMSTATE("BODY") DEL777(HLMSTATE("BODY"))
"RTN","HLOSRVR1",95,0)
 .S HLMSTATE("IEN")="",HLMSTATE("BODY")=""
"RTN","HLOSRVR1",96,0)
 E  D:STORE
"RTN","HLOSRVR1",97,0)
 .D CHECKMSG(.HLMSTATE)
"RTN","HLOSRVR1",98,0)
 .D ADDAC(.HLMSTATE) ;so future duplicates are detected
"RTN","HLOSRVR1",99,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR1",100,0)
 ;
"RTN","HLOSRVR1",101,0)
 D:'HLCSTATE("MESSAGE ENDED") CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",102,0)
 Q HLCSTATE("MESSAGE ENDED")
"RTN","HLOSRVR1",103,0)
 ;
"RTN","HLOSRVR1",104,0)
ADDAC(HLMSTATE) ;adds the AC xref for duplicates detection
"RTN","HLOSRVR1",105,0)
 ;
"RTN","HLOSRVR1",106,0)
 N FROM
"RTN","HLOSRVR1",107,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",108,0)
 S ^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR1",109,0)
 Q
"RTN","HLOSRVR1",110,0)
 ;
"RTN","HLOSRVR1",111,0)
DUP(HLMSTATE) ;
"RTN","HLOSRVR1",112,0)
 ;Returns 1 if the message is a duplicate and its ack (if requested) is found, 0 otherwise
"RTN","HLOSRVR1",113,0)
 ;Input:
"RTN","HLOSRVR1",114,0)
 ; HLMSTATE (pass by reference) the message being read
"RTN","HLOSRVR1",115,0)
 ;Output:
"RTN","HLOSRVR1",116,0)
 ;  Function returns 1 if the message is a duplicate, 0 otherwise
"RTN","HLOSRVR1",117,0)
 ;  HLMSTATE (pass by reference) IF the message is a duplicate:
"RTN","HLOSRVR1",118,0)
 ;     returns the prior MSA segment in HLMSTATE("MSA")
"RTN","HLOSRVR1",119,0)
 ;
"RTN","HLOSRVR1",120,0)
 N IEN,FROM,DUP
"RTN","HLOSRVR1",121,0)
 S (IEN,DUP)=0
"RTN","HLOSRVR1",122,0)
 ;
"RTN","HLOSRVR1",123,0)
 ;no way to determine!  Bad header will be rejected
"RTN","HLOSRVR1",124,0)
 Q:(HLMSTATE("ID")="") 0
"RTN","HLOSRVR1",125,0)
 ;
"RTN","HLOSRVR1",126,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",127,0)
 F  S IEN=$O(^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),IEN)) Q:'IEN  D  Q:DUP
"RTN","HLOSRVR1",128,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="NE" S DUP=1 Q
"RTN","HLOSRVR1",129,0)
 .;need the MSA to return
"RTN","HLOSRVR1",130,0)
 .D  Q
"RTN","HLOSRVR1",131,0)
 ..N NODE
"RTN","HLOSRVR1",132,0)
 ..S NODE=$P($G(^HLB(IEN,4)),"^",3,10)
"RTN","HLOSRVR1",133,0)
 ..S HLMSTATE("MSA",1)=$P(NODE,"|",2)
"RTN","HLOSRVR1",134,0)
 ..Q:$L(HLMSTATE("MSA",1))'=2
"RTN","HLOSRVR1",135,0)
 ..S HLMSTATE("MSA",2)=$P(NODE,"|",3)
"RTN","HLOSRVR1",136,0)
 ..S HLMSTATE("MSA",3)=$P(NODE,"|",4,10)
"RTN","HLOSRVR1",137,0)
 ..S DUP=1
"RTN","HLOSRVR1",138,0)
 ;
"RTN","HLOSRVR1",139,0)
 Q DUP
"RTN","HLOSRVR1",140,0)
 ;
"RTN","HLOSRVR1",141,0)
CHECKMSG(HLMSTATE) ;
"RTN","HLOSRVR1",142,0)
 ;Checks the header & MSA segment, sets HLMSTATE("STATUS","ACTION") if the message needs to be passed, determines if completion status should be set
"RTN","HLOSRVR1",143,0)
 ;Input:
"RTN","HLOSRVR1",144,0)
 ;  HLMSTATE("HDR") - the parsed header segment
"RTN","HLOSRVR1",145,0)
 ;Output:
"RTN","HLOSRVR1",146,0)
 ;  HLMSTATE("STATUS")="ER" if an error is detected
"RTN","HLOSRVR1",147,0)
 ;  HLMSTATE("STATUS","QUEUE") queue to put the message on
"RTN","HLOSRVR1",148,0)
 ;  HLMSTATE("STATUS","ACTION")  <tag^rtn> that is the processing routine for the receiving application
"RTN","HLOSRVR1",149,0)
 ;  HLMSTATE("MSA") - MSA(1)=accept code to be returned, MSA(3)= error txt
"RTN","HLOSRVR1",150,0)
 ;
"RTN","HLOSRVR1",151,0)
 N WANTACK,PASS,ACTION,QUEUE,ERROR
"RTN","HLOSRVR1",152,0)
 M HDR=HLMSTATE("HDR")
"RTN","HLOSRVR1",153,0)
 S ERROR=0
"RTN","HLOSRVR1",154,0)
 I HDR("ACCEPT ACK TYPE")="NE",'HLMSTATE("ORIGINAL MODE") D
"RTN","HLOSRVR1",155,0)
 .S WANTACK=0
"RTN","HLOSRVR1",156,0)
 E  D
"RTN","HLOSRVR1",157,0)
 .S WANTACK=1
"RTN","HLOSRVR1",158,0)
 I HLMSTATE("ORIGINAL MODE") S HLMSTATE("MSA",1)="AE",HLMSTATE("MSA",3)="THIS INTERFACE DOES NOT IMPLEMENT ORIGINAL MODE APPLICATION ACKOWLEDGMENTS",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",159,0)
 I $G(HLMSTATE("ACK TO"))="" D  Q:ERROR
"RTN","HLOSRVR1",160,0)
 .;
"RTN","HLOSRVR1",161,0)
 .;** do not implement the Pass Immediate parameter **
"RTN","HLOSRVR1",162,0)
 .;N IMMEDIATE
"RTN","HLOSRVR1",163,0)
 .;I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE,.IMMEDIATE) S ERROR=1 S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",164,0)
 .;S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE),HLMSTATE("STATUS","PASS IMMEDIATE")=$G(IMMEDIATE)
"RTN","HLOSRVR1",165,0)
 .;
"RTN","HLOSRVR1",166,0)
 .I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S ERROR=1 S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",167,0)
 .S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",168,0)
 E  D  Q:ERROR  ;this is an app ack
"RTN","HLOSRVR1",169,0)
 .;does the original message exist?
"RTN","HLOSRVR1",170,0)
 .;
"RTN","HLOSRVR1",171,0)
 .;** do not implement the Pass Immediate parameter **
"RTN","HLOSRVR1",172,0)
 .;N NODE,IMMEDIATE
"RTN","HLOSRVR1",173,0)
 .;
"RTN","HLOSRVR1",174,0)
 .N NODE
"RTN","HLOSRVR1",175,0)
 .S:+$G(HLMSTATE("ACK TO","IEN")) NODE=$G(^HLB(+HLMSTATE("ACK TO","IEN"),0))
"RTN","HLOSRVR1",176,0)
 .I $G(NODE)="" S ERROR=1,HLMSTATE("STATUS")="ER",HLMSTATE("ACK TO","IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE TO APPLICATION ACKNOWLEDGMENT NOT FOUND" Q
"RTN","HLOSRVR1",177,0)
 .I $P(NODE,"^",7)'="",$P(NODE,"^",7)'=HLMSTATE("ID") S ERROR=1,HLMSTATE("STATUS")="ER",HLMSTATE("ACK TO","IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE WAS ALREADY ACKED" Q
"RTN","HLOSRVR1",178,0)
 .;
"RTN","HLOSRVR1",179,0)
 .;** P152 START CJM **
"RTN","HLOSRVR1",180,0)
 .;I ($P(NODE,"^",11)]"") S HLMSTATE("STATUS","ACTION")=$P(NODE,"^",10,11),HLMSTATE("STATUS","QUEUE")=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")  Q
"RTN","HLOSRVR1",181,0)
 .S HLMSTATE("STATUS","QUEUE")=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")
"RTN","HLOSRVR1",182,0)
 .I ($P(NODE,"^",11)]"") S HLMSTATE("STATUS","ACTION")=$P(NODE,"^",10,11) Q
"RTN","HLOSRVR1",183,0)
 .;processing routine for the app ack wasn't found with the original message, look in the HLO Application Registry
"RTN","HLOSRVR1",184,0)
 .I HLMSTATE("HDR","MESSAGE TYPE")="ACK",HLMSTATE("HDR","EVENT")="" S HDR("EVENT")=$$GETEVENT^HLOCLNT2(+HLMSTATE("ACK TO","IEN"))
"RTN","HLOSRVR1",185,0)
 .;
"RTN","HLOSRVR1",186,0)
 .;** do not implement the Pass Immediate parameter **
"RTN","HLOSRVR1",187,0)
 .;I $$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE,.IMMEDIATE) S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE),HLMSTATE("STATUS","PASS IMMEDIATE")=$G(IMMEDIATE)
"RTN","HLOSRVR1",188,0)
 .;
"RTN","HLOSRVR1",189,0)
 .I $$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S HLMSTATE("STATUS","ACTION")=$G(ACTION) S:HLMSTATE("STATUS","QUEUE")="DEFAULT" HLMSTATE("STATUS","QUEUE")=QUEUE
"RTN","HLOSRVR1",190,0)
 .;**P152 END CJM
"RTN","HLOSRVR1",191,0)
 ;
"RTN","HLOSRVR1",192,0)
 I HDR("PROCESSING ID")'=HLCSTATE("SYSTEM","PROCESSING ID") S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("STATUS")="ER",HLMSTATE("MSA",3)="SYSTEM PROCESSING ID="_HLCSTATE("SYSTEM","PROCESSING ID") Q
"RTN","HLOSRVR1",193,0)
 ;
"RTN","HLOSRVR1",194,0)
 ;wrong receiving facility?  This is hard to check if the sender is not VistA, because the HL7 standard permits different coding systems to be used. This check is only for DNS or station number.
"RTN","HLOSRVR1",195,0)
 S PASS=0
"RTN","HLOSRVR1",196,0)
 D
"RTN","HLOSRVR1",197,0)
 .;if its an ack to an existing message, don't check the receiving facility
"RTN","HLOSRVR1",198,0)
 .I $G(HLMSTATE("ACK TO"))]"" S PASS=1 Q
"RTN","HLOSRVR1",199,0)
 .I HDR("RECEIVING FACILITY",1)=HLCSTATE("SYSTEM","STATION") S PASS=1 Q
"RTN","HLOSRVR1",200,0)
 .I HDR("RECEIVING FACILITY",3)'="DNS" S PASS=1 Q
"RTN","HLOSRVR1",201,0)
 .I HDR("RECEIVING FACILITY",2)="" S PASS=1 Q
"RTN","HLOSRVR1",202,0)
 .I $P(HDR("RECEIVING FACILITY",2),":")[HLCSTATE("SYSTEM","DOMAIN") S PASS=1 Q
"RTN","HLOSRVR1",203,0)
 .I HLCSTATE("SYSTEM","DOMAIN")[$P(HDR("RECEIVING FACILITY",2),":") S PASS=1 Q
"RTN","HLOSRVR1",204,0)
 I 'PASS S HLMSTATE("STATUS")="ER",HLMSTATE("MSA",3)="RECEIVING FACILITY IS "_HLCSTATE("SYSTEM","DOMAIN") S:WANTACK HLMSTATE("MSA",1)="CE"
"RTN","HLOSRVR1",205,0)
 I PASS,WANTACK S HLMSTATE("MSA",1)="CA"
"RTN","HLOSRVR1",206,0)
 Q
"RTN","HLOSRVR1",207,0)
 ;
"RTN","HLOSRVR1",208,0)
DEL777(IEN777) ;delete a record from file 777 where the read did not complete
"RTN","HLOSRVR1",209,0)
 ;
"RTN","HLOSRVR1",210,0)
 K ^HLA(IEN777,0)
"RTN","HLOSRVR1",211,0)
 Q
"RTN","HLOSRVR1",212,0)
DEL778(IEN778) ;delete a record from file 778 where the read did not complete
"RTN","HLOSRVR1",213,0)
 ;
"RTN","HLOSRVR1",214,0)
 K ^HLB(IEN778,0)
"RTN","HLOSRVR1",215,0)
 Q
"RTN","HLOSRVR1",216,0)
 ;
"RTN","HLOSRVR1",217,0)
SPLITHDR(HDR) ;
"RTN","HLOSRVR1",218,0)
 ;splits hdr segment into two lines, first being just components 1-6
"RTN","HLOSRVR1",219,0)
 ;
"RTN","HLOSRVR1",220,0)
 N TEMP,FS
"RTN","HLOSRVR1",221,0)
 D SQUISH(.HDR)
"RTN","HLOSRVR1",222,0)
 S FS=$E($G(HDR(1)),4)
"RTN","HLOSRVR1",223,0)
 S TEMP(1)=$P($G(HDR(1)),FS,1,6)
"RTN","HLOSRVR1",224,0)
 S TEMP(2)=""
"RTN","HLOSRVR1",225,0)
 I $L(TEMP(1))<$L($G(HDR(1))) S TEMP(2)=FS_$P($G(HDR(1)),FS,7,20)
"RTN","HLOSRVR1",226,0)
 S HDR(2)=TEMP(2)_$G(HDR(2))
"RTN","HLOSRVR1",227,0)
 S HDR(1)=TEMP(1)
"RTN","HLOSRVR1",228,0)
 Q
"RTN","HLOSRVR1",229,0)
 ;
"RTN","HLOSRVR1",230,0)
SQUISH(SEG) ;
"RTN","HLOSRVR1",231,0)
 ;reformat the segment array into full lines
"RTN","HLOSRVR1",232,0)
 ;
"RTN","HLOSRVR1",233,0)
 ;nothing to do if less than 2 lines
"RTN","HLOSRVR1",234,0)
 Q:'$O(SEG(1))
"RTN","HLOSRVR1",235,0)
 ;
"RTN","HLOSRVR1",236,0)
 N A,I,J,K,MAX,COUNT,LEN
"RTN","HLOSRVR1",237,0)
 S MAX=$S($G(HLCSTATE("SYSTEM","MAXSTRING"))>256:HLCSTATE("SYSTEM","MAXSTRING"),1:256)
"RTN","HLOSRVR1",238,0)
 S (COUNT,I)=0,J=1
"RTN","HLOSRVR1",239,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOSRVR1",240,0)
 .S LEN=$L(SEG(I))
"RTN","HLOSRVR1",241,0)
 .F K=1:1:LEN D
"RTN","HLOSRVR1",242,0)
 ..S A(J)=$G(A(J))_$E(SEG(I),K)
"RTN","HLOSRVR1",243,0)
 ..S COUNT=COUNT+1
"RTN","HLOSRVR1",244,0)
 ..I (COUNT>(MAX-1)) S COUNT=0,J=J+1
"RTN","HLOSRVR1",245,0)
 K SEG
"RTN","HLOSRVR1",246,0)
 M SEG=A
"RTN","HLOSRVR1",247,0)
 Q
"VER")
8.0^22.0
"BLD",1523,6)
^123
**END**
**END**
