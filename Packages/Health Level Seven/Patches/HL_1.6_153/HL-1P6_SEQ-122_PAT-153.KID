Released HL*1.6*153 SEQ #122
Extracted from mail message
**KIDS**:HL*1.6*153^

**INSTALL NAME**
HL*1.6*153
"BLD",1470,0)
HL*1.6*153^HEALTH LEVEL SEVEN^0^3110315^y
"BLD",1470,1,0)
^9.61A^2^2^3101201^^
"BLD",1470,1,1,0)
Please see the National Patch Module on Forum.
"BLD",1470,1,2,0)

"BLD",1470,4,0)
^9.64PA^772^3
"BLD",1470,4,772,0)
772
"BLD",1470,4,772,2,0)
^9.641^772^1
"BLD",1470,4,772,2,772,0)
HL7 MESSAGE TEXT  (File-top level)
"BLD",1470,4,772,2,772,1,0)
^9.6411^200^1
"BLD",1470,4,772,2,772,1,200,0)
MESSAGE TEXT
"BLD",1470,4,772,222)
y^n^p^^^^n^^n
"BLD",1470,4,772,224)

"BLD",1470,4,773,0)
773
"BLD",1470,4,773,2,0)
^9.641^773^1
"BLD",1470,4,773,2,773,0)
HL7 MESSAGE ADMINISTRATION  (File-top level)
"BLD",1470,4,773,2,773,1,0)
^9.6411^200^1
"BLD",1470,4,773,2,773,1,200,0)
MSH
"BLD",1470,4,773,222)
y^n^p^^^^n^^n
"BLD",1470,4,773,224)

"BLD",1470,4,870,0)
870
"BLD",1470,4,870,2,0)
^9.641^870.01^3
"BLD",1470,4,870,2,870,0)
HL LOGICAL LINK  (File-top level)
"BLD",1470,4,870,2,870,1,0)
^9.6411^22^1
"BLD",1470,4,870,2,870,1,22,0)
RETENTION TIME QUEUED STUB RCD
"BLD",1470,4,870,2,870.01,0)
OUT QUEUE  (sub-file)
"BLD",1470,4,870,2,870.01,1,0)
^9.6411^10^2
"BLD",1470,4,870,2,870.01,1,1,0)
STATUS
"BLD",1470,4,870,2,870.01,1,10,0)
DATE/TIME STUB RCD FOUND
"BLD",1470,4,870,2,870.019,0)
IN QUEUE  (sub-file)
"BLD",1470,4,870,2,870.019,1,0)
^9.6411^10^2
"BLD",1470,4,870,2,870.019,1,1,0)
STATUS
"BLD",1470,4,870,2,870.019,1,10,0)
DATE/TIME STUB RCD FOUND
"BLD",1470,4,870,222)
y^n^p^^^^n^^n
"BLD",1470,4,870,224)

"BLD",1470,4,"APDD",772,772)

"BLD",1470,4,"APDD",772,772,200)

"BLD",1470,4,"APDD",773,773)

"BLD",1470,4,"APDD",773,773,200)

"BLD",1470,4,"APDD",870,870)

"BLD",1470,4,"APDD",870,870,22)

"BLD",1470,4,"APDD",870,870.01)

"BLD",1470,4,"APDD",870,870.01,1)

"BLD",1470,4,"APDD",870,870.01,10)

"BLD",1470,4,"APDD",870,870.019)

"BLD",1470,4,"APDD",870,870.019,1)

"BLD",1470,4,"APDD",870,870.019,10)

"BLD",1470,4,"B",772,772)

"BLD",1470,4,"B",773,773)

"BLD",1470,4,"B",870,870)

"BLD",1470,6.3)
11
"BLD",1470,"ABPKG")
n
"BLD",1470,"INID")
^n
"BLD",1470,"INIT")
POST^HLP153
"BLD",1470,"KRN",0)
^9.67PA^9002226^21
"BLD",1470,"KRN",.4,0)
.4
"BLD",1470,"KRN",.401,0)
.401
"BLD",1470,"KRN",.402,0)
.402
"BLD",1470,"KRN",.403,0)
.403
"BLD",1470,"KRN",.5,0)
.5
"BLD",1470,"KRN",.84,0)
.84
"BLD",1470,"KRN",3.6,0)
3.6
"BLD",1470,"KRN",3.8,0)
3.8
"BLD",1470,"KRN",9.2,0)
9.2
"BLD",1470,"KRN",9.8,0)
9.8
"BLD",1470,"KRN",9.8,"NM",0)
^9.68A^21^20
"BLD",1470,"KRN",9.8,"NM",1,0)
HLUOPT1^^0^B61661726
"BLD",1470,"KRN",9.8,"NM",2,0)
HLCSOUT^^0^B12989203
"BLD",1470,"KRN",9.8,"NM",3,0)
HLCSQUE^^0^B28207653
"BLD",1470,"KRN",9.8,"NM",4,0)
HLCSQUE1^^0^B5361364
"BLD",1470,"KRN",9.8,"NM",5,0)
HLEVAPI3^^0^B59002159
"BLD",1470,"KRN",9.8,"NM",6,0)
HLP153^^0^B2856907
"BLD",1470,"KRN",9.8,"NM",7,0)
HLCSTCP2^^0^B83851505
"BLD",1470,"KRN",9.8,"NM",8,0)
HLOUSR^^0^B121166141
"BLD",1470,"KRN",9.8,"NM",9,0)
HLCSTCP3^^0^B14207498
"BLD",1470,"KRN",9.8,"NM",10,0)
HLOTRACE^^0^B73989818
"BLD",1470,"KRN",9.8,"NM",12,0)
HLOTCP^^0^B87019003
"BLD",1470,"KRN",9.8,"NM",13,0)
HLUTIL2^^0^B30814753
"BLD",1470,"KRN",9.8,"NM",14,0)
HLQPURGE^^0^B43329113
"BLD",1470,"KRN",9.8,"NM",15,0)
HLOSTRAC^^0^B50796847
"BLD",1470,"KRN",9.8,"NM",16,0)
HLOPROC1^^0^B95639479
"BLD",1470,"KRN",9.8,"NM",17,0)
HLOQUE^^0^B153912092
"BLD",1470,"KRN",9.8,"NM",18,0)
HLOSITE^^0^B8278014
"BLD",1470,"KRN",9.8,"NM",19,0)
HLOUSR7^^0^B22703242
"BLD",1470,"KRN",9.8,"NM",20,0)
HLCSIN^^0^B39104327
"BLD",1470,"KRN",9.8,"NM",21,0)
HLCSMM1^^0^B4480587
"BLD",1470,"KRN",9.8,"NM","B","HLCSIN",20)

"BLD",1470,"KRN",9.8,"NM","B","HLCSMM1",21)

"BLD",1470,"KRN",9.8,"NM","B","HLCSOUT",2)

"BLD",1470,"KRN",9.8,"NM","B","HLCSQUE",3)

"BLD",1470,"KRN",9.8,"NM","B","HLCSQUE1",4)

"BLD",1470,"KRN",9.8,"NM","B","HLCSTCP2",7)

"BLD",1470,"KRN",9.8,"NM","B","HLCSTCP3",9)

"BLD",1470,"KRN",9.8,"NM","B","HLEVAPI3",5)

"BLD",1470,"KRN",9.8,"NM","B","HLOPROC1",16)

"BLD",1470,"KRN",9.8,"NM","B","HLOQUE",17)

"BLD",1470,"KRN",9.8,"NM","B","HLOSITE",18)

"BLD",1470,"KRN",9.8,"NM","B","HLOSTRAC",15)

"BLD",1470,"KRN",9.8,"NM","B","HLOTCP",12)

"BLD",1470,"KRN",9.8,"NM","B","HLOTRACE",10)

"BLD",1470,"KRN",9.8,"NM","B","HLOUSR",8)

"BLD",1470,"KRN",9.8,"NM","B","HLOUSR7",19)

"BLD",1470,"KRN",9.8,"NM","B","HLP153",6)

"BLD",1470,"KRN",9.8,"NM","B","HLQPURGE",14)

"BLD",1470,"KRN",9.8,"NM","B","HLUOPT1",1)

"BLD",1470,"KRN",9.8,"NM","B","HLUTIL2",13)

"BLD",1470,"KRN",19,0)
19
"BLD",1470,"KRN",19,"NM",0)
^9.68A^8^8
"BLD",1470,"KRN",19,"NM",1,0)
HL PURGE QUEUE (TCP)^^0
"BLD",1470,"KRN",19,"NM",2,0)
HL MENU FILER LINK ERR^^2
"BLD",1470,"KRN",19,"NM",3,0)
HL CLEAR QUEUE^^0
"BLD",1470,"KRN",19,"NM",4,0)
HL RESET COUNTERS (TCP ONLY)^^0
"BLD",1470,"KRN",19,"NM",5,0)
HL DISPLAY LINKS (TCP ONLY)^^0
"BLD",1470,"KRN",19,"NM",6,0)
HL DISPLAY ONE LINK (TCP ONLY)^^0
"BLD",1470,"KRN",19,"NM",7,0)
HLO COUNT RECORDS^^1^
"BLD",1470,"KRN",19,"NM",8,0)
HLO RECOUNT MESSAGE QUEUES^^1^
"BLD",1470,"KRN",19,"NM","B","HL CLEAR QUEUE",3)

"BLD",1470,"KRN",19,"NM","B","HL DISPLAY LINKS (TCP ONLY)",5)

"BLD",1470,"KRN",19,"NM","B","HL DISPLAY ONE LINK (TCP ONLY)",6)

"BLD",1470,"KRN",19,"NM","B","HL MENU FILER LINK ERR",2)

"BLD",1470,"KRN",19,"NM","B","HL PURGE QUEUE (TCP)",1)

"BLD",1470,"KRN",19,"NM","B","HL RESET COUNTERS (TCP ONLY)",4)

"BLD",1470,"KRN",19,"NM","B","HLO COUNT RECORDS",7)

"BLD",1470,"KRN",19,"NM","B","HLO RECOUNT MESSAGE QUEUES",8)

"BLD",1470,"KRN",19.1,0)
19.1
"BLD",1470,"KRN",19.1,"NM",0)
^9.68A^^
"BLD",1470,"KRN",101,0)
101
"BLD",1470,"KRN",409.61,0)
409.61
"BLD",1470,"KRN",771,0)
771
"BLD",1470,"KRN",779.2,0)
779.2
"BLD",1470,"KRN",870,0)
870
"BLD",1470,"KRN",8989.51,0)
8989.51
"BLD",1470,"KRN",8989.52,0)
8989.52
"BLD",1470,"KRN",8994,0)
8994
"BLD",1470,"KRN",9002226,0)
9002226
"BLD",1470,"KRN","B",.4,.4)

"BLD",1470,"KRN","B",.401,.401)

"BLD",1470,"KRN","B",.402,.402)

"BLD",1470,"KRN","B",.403,.403)

"BLD",1470,"KRN","B",.5,.5)

"BLD",1470,"KRN","B",.84,.84)

"BLD",1470,"KRN","B",3.6,3.6)

"BLD",1470,"KRN","B",3.8,3.8)

"BLD",1470,"KRN","B",9.2,9.2)

"BLD",1470,"KRN","B",9.8,9.8)

"BLD",1470,"KRN","B",19,19)

"BLD",1470,"KRN","B",19.1,19.1)

"BLD",1470,"KRN","B",101,101)

"BLD",1470,"KRN","B",409.61,409.61)

"BLD",1470,"KRN","B",771,771)

"BLD",1470,"KRN","B",779.2,779.2)

"BLD",1470,"KRN","B",870,870)

"BLD",1470,"KRN","B",8989.51,8989.51)

"BLD",1470,"KRN","B",8989.52,8989.52)

"BLD",1470,"KRN","B",8994,8994)

"BLD",1470,"KRN","B",9002226,9002226)

"BLD",1470,"QDEF")
^^^^NO^^^^NO^^NO
"BLD",1470,"QUES",0)
^9.62^^
"BLD",1470,"REQB",0)
^9.611^2^2
"BLD",1470,"REQB",1,0)
HL*1.6*147^2
"BLD",1470,"REQB",2,0)
HL*1.6*151^2
"BLD",1470,"REQB","B","HL*1.6*147",1)

"BLD",1470,"REQB","B","HL*1.6*151",2)

"FIA",772)
HL7 MESSAGE TEXT
"FIA",772,0)
^HL(772,
"FIA",772,0,0)
772DI
"FIA",772,0,1)
y^n^p^^^^n^^n
"FIA",772,0,10)

"FIA",772,0,11)

"FIA",772,0,"RLRO")

"FIA",772,0,"VR")
1.6^HL
"FIA",772,772)
1
"FIA",772,772,200)

"FIA",772,772.02)
0
"FIA",773)
HL7 MESSAGE ADMINISTRATION
"FIA",773,0)
^HLMA(
"FIA",773,0,0)
773PI
"FIA",773,0,1)
y^n^p^^^^n^^n
"FIA",773,0,10)

"FIA",773,0,11)

"FIA",773,0,"RLRO")

"FIA",773,0,"VR")
1.6^HL
"FIA",773,773)
1
"FIA",773,773,200)

"FIA",773,773.01)
0
"FIA",870)
HL LOGICAL LINK
"FIA",870,0)
^HLCS(870,
"FIA",870,0,0)
870
"FIA",870,0,1)
y^n^p^^^^n^^n
"FIA",870,0,10)

"FIA",870,0,11)

"FIA",870,0,"RLRO")

"FIA",870,0,"VR")
1.6^HL
"FIA",870,870)
1
"FIA",870,870,22)

"FIA",870,870.01)
1
"FIA",870,870.01,1)

"FIA",870,870.01,10)

"FIA",870,870.019)
1
"FIA",870,870.019,1)

"FIA",870,870.019,10)

"INIT")
POST^HLP153
"KRN",19,647,-1)
0^3
"KRN",19,647,0)
HL CLEAR QUEUE^Purge Outgoing Queue (Non-TCP Only)^^R^^^^^^^^HEALTH LEVEL SEVEN
"KRN",19,647,1,0)
^19.06^1^1^3101207^^^^
"KRN",19,647,1,1,0)
This option allows the user to re-initialize a queue to zero entries
"KRN",19,647,10.1)
Clear Queue of All Entries
"KRN",19,647,25)
CLRQUE^HLUTIL2
"KRN",19,647,"U")
PURGE OUTGOING QUEUE (NON-TCP 
"KRN",19,766,-1)
2^2
"KRN",19,766,0)
HL MENU FILER LINK ERR^Link Errors^^M^6^^^^^^^9^y
"KRN",19,766,10,0)
^19.01IP^8^8
"KRN",19,766,10,4,0)
647^^4
"KRN",19,766,10,4,"^")
HL CLEAR QUEUE
"KRN",19,766,10,5,0)
1437
"KRN",19,766,10,5,"^")
HL PURGE QUEUE (TCP)
"KRN",19,766,10,6,0)
1438
"KRN",19,766,10,6,"^")
HL RESET COUNTERS (TCP ONLY)
"KRN",19,766,10,7,0)
1439
"KRN",19,766,10,7,"^")
HL DISPLAY LINKS (TCP ONLY)
"KRN",19,766,10,8,0)
1440
"KRN",19,766,10,8,"^")
HL DISPLAY ONE LINK (TCP ONLY)
"KRN",19,766,"U")
LINK ERRORS
"KRN",19,1437,-1)
0^1
"KRN",19,1437,0)
HL PURGE QUEUE (TCP)^Purge Outgoing Queue (TCP Only)^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1437,1,0)
^^3^3^3101207^
"KRN",19,1437,1,1,0)
This option will purge an outgoing TCP/IP client link of messages pending 
"KRN",19,1437,1,2,0)
transmission. 
"KRN",19,1437,1,3,0)

"KRN",19,1437,20)
D ASKPURGE^HLQPURGE
"KRN",19,1437,"U")
PURGE OUTGOING QUEUE (TCP ONLY
"KRN",19,1438,-1)
0^4
"KRN",19,1438,0)
HL RESET COUNTERS (TCP ONLY)^Reset Link's Counters (TCP Only)^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1438,1,0)
^19.06^6^6^3101229^^
"KRN",19,1438,1,1,0)
This option will not purge any messages from a queue.  It does count the 
"KRN",19,1438,1,2,0)
messages pending on the queue and re-initializes the count of messages sent
"KRN",19,1438,1,3,0)
and received for the link to 0 and the count of messages to send or still to
"KRN",19,1438,1,4,0)
processed to the actual count.
"KRN",19,1438,1,5,0)

"KRN",19,1438,1,6,0)

"KRN",19,1438,20)
D RESET^HLQPURGE
"KRN",19,1438,"U")
RESET LINK'S COUNTERS (TCP ONL
"KRN",19,1439,-1)
0^5
"KRN",19,1439,0)
HL DISPLAY LINKS (TCP ONLY)^Display Client and Server Links (TCP Only)^^A^^^^^^^y^HEALTH LEVEL SEVEN^^1
"KRN",19,1439,1,0)
^^5^5^3101207^
"KRN",19,1439,1,1,0)
This option was requested by Product Support to troubleshoot problems with
"KRN",19,1439,1,2,0)
TCP links.  It will dispay all TCP/IP links that have pending incoming or
"KRN",19,1439,1,3,0)
outgoing messages with the link's state, the first pending message, and a
"KRN",19,1439,1,4,0)
count of the pending messages. 
"KRN",19,1439,1,5,0)

"KRN",19,1439,20)
D SHOWTCP^HLQPURGE
"KRN",19,1439,"U")
DISPLAY CLIENT AND SERVER LINK
"KRN",19,1440,-1)
0^6
"KRN",19,1440,0)
HL DISPLAY ONE LINK (TCP ONLY)^Display One Link (TCP Only)^^A^^^^^^^y^HL7 OPTIMIZED (HLO)^^1
"KRN",19,1440,1,0)
^^4^4^3101207^
"KRN",19,1440,1,1,0)
Asks the user to select a TCP link.  It then displays the link, a count
"KRN",19,1440,1,2,0)
of the messages pending on its incoming and outgoing queues, along with
"KRN",19,1440,1,3,0)
the first message on the queue.
"KRN",19,1440,1,4,0)

"KRN",19,1440,20)
D ONETCP^HLQPURGE
"KRN",19,1440,"U")
DISPLAY ONE LINK (TCP ONLY)
"KRN",19,1441,-1)
1^7
"KRN",19,1441,0)
HLO COUNT RECORDS
"KRN",19,1442,-1)
1^8
"KRN",19,1442,0)
HLO RECOUNT MESSAGE QUEUES
"MBREQ")
0
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
153^3110315
"PKG",9,22,1,"PAH",1,1,0)
^^2^2^3110315
"PKG",9,22,1,"PAH",1,1,1,0)
Please see the National Patch Module on Forum.
"PKG",9,22,1,"PAH",1,1,2,0)

"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
20
"RTN","HLCSIN")
0^20^B39104327^B39104505
"RTN","HLCSIN",1,0)
HLCSIN ;ALB/JRP - INCOMING FILER;01-MAY-95 ;03/07/2011
"RTN","HLCSIN",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**2,30,14,19,62,109,115,122,140,145,153**;Oct 13, 1995;Build 11
"RTN","HLCSIN",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSIN",4,0)
STARTIN ;Main entry point for incoming background filer
"RTN","HLCSIN",5,0)
 ;Create/find entry denoting this filer in the INCOMING FILER TASK
"RTN","HLCSIN",6,0)
 ; NUMBER multiple (field #20) of the HL COMMUNICATION SERVER PARAMETER
"RTN","HLCSIN",7,0)
 ; file (#869.3)
"RTN","HLCSIN",8,0)
 N HLFLG,HLEXIT,HLPTRFLR
"RTN","HLCSIN",9,0)
 ;
"RTN","HLCSIN",10,0)
 ; patch HL*1.6*122
"RTN","HLCSIN",11,0)
 ;; N HLDUZ,DUZ  ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSIN",12,0)
 N HLDUZ
"RTN","HLCSIN",13,0)
 S HLDUZ=+$G(DUZ)
"RTN","HLCSIN",14,0)
 ;
"RTN","HLCSIN",15,0)
 S HLPTRFLR=+$$CRTFLR^HLCSUTL1(ZTSK,"IN")
"RTN","HLCSIN",16,0)
 ;Loop through Logical Links and check for incoming messages
"RTN","HLCSIN",17,0)
 S HLEXIT=0
"RTN","HLCSIN",18,0)
 ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSIN",19,0)
 ; patch HL*1.6*122, set DUZ for application proxy user
"RTN","HLCSIN",20,0)
 ;; D PROXY^HLCSTCP4
"RTN","HLCSIN",21,0)
 S HLPTRFLR("$J")=$J
"RTN","HLCSIN",22,0)
 F  D  Q:HLEXIT
"RTN","HLCSIN",23,0)
 . S HLFLG=0
"RTN","HLCSIN",24,0)
 . D DEFACK(.HLPTRFLR,.HLFLG,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",25,0)
 . D ACKNOW(.HLPTRFLR,.HLFLG,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",26,0)
 . Q:HLFLG
"RTN","HLCSIN",27,0)
 . I $$HDIFF^XLFDT($H,$G(HLPTRFLR("LASTDEL")),2)>3600 D  Q
"RTN","HLCSIN",28,0)
 . . S HLPTRFLR("LASTDEL")=$H    ; maintain queue sizes
"RTN","HLCSIN",29,0)
 . . D DELQUE(.HLPTRFLR,.HLEXIT) ; no more than once an hour.
"RTN","HLCSIN",30,0)
 . ; patch HL*1.6*122
"RTN","HLCSIN",31,0)
 . ; H 5
"RTN","HLCSIN",32,0)
 . H 1
"RTN","HLCSIN",33,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",34,0)
 S ZTSTOP=1 ;Asked to stop
"RTN","HLCSIN",35,0)
 D DELFLR^HLCSUTL1(HLPTRFLR,"IN") ;Delete entry denoting this filer
"RTN","HLCSIN",36,0)
 S ZTREQ="@"
"RTN","HLCSIN",37,0)
 Q
"RTN","HLCSIN",38,0)
DEFACK(HLPTRFLR,HLFLG,HLEXIT) ; Process TCP links with a deferred response
"RTN","HLCSIN",39,0)
 N HLXX,HLD0,HLPCT
"RTN","HLCSIN",40,0)
 S HLXX=0
"RTN","HLCSIN",41,0)
 F  S HLXX=$O(^HLMA("AC","I",HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",42,0)
 . ; HL*1.6*122, check the in-queue stop flag
"RTN","HLCSIN",43,0)
 . Q:$P($G(^HLCS(870,HLXX,0)),"^",9)
"RTN","HLCSIN",44,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",45,0)
 . ; patch HL*1.6*109: Does another filer have this?
"RTN","HLCSIN",46,0)
 . ; L +^HLMA("AC","I",HLXX):0 Q:'$T
"RTN","HLCSIN",47,0)
 . ; patch HL*1.6*140 - change the lock node, it conflicts with
"RTN","HLCSIN",48,0)
 . ; lock defined in routine, HLCSREP.
"RTN","HLCSIN",49,0)
 . ; L +^HLMA("AC","I",HLXX):2 Q:'$T  ; patch HL*1.6*122
"RTN","HLCSIN",50,0)
 . L +^HLMA("IN-FILER","AC","I",HLXX):0 Q:'$T  ; patch HL*1.6*122
"RTN","HLCSIN",51,0)
 . S HLD0=0,HLFLG=1
"RTN","HLCSIN",52,0)
 . ; HL*1.6*109 changes in for loop below, and post-quit code placed
"RTN","HLCSIN",53,0)
 . ; on following lines.
"RTN","HLCSIN",54,0)
 . S HLPCT=0 ; Counter whether filer should stop every 100th entry.
"RTN","HLCSIN",55,0)
 .;**109 - insure queue last processed at least 2 seconds ago
"RTN","HLCSIN",56,0)
 . ; patch HL*1.6*140
"RTN","HLCSIN",57,0)
 . ; I ($$HDIFF^XLFDT($H,$G(^XTMP("HL7-AC","I",HLXX)),2)<2) L -^HLMA("AC","I",HLXX) Q
"RTN","HLCSIN",58,0)
 . I ($$HDIFF^XLFDT($H,$G(^XTMP("HL7-AC","I",HLXX)),2)<2) L -^HLMA("IN-FILER","AC","I",HLXX) Q
"RTN","HLCSIN",59,0)
 . F  S HLD0=$O(^HLMA("AC","I",HLXX,HLD0)) Q:'HLD0!(HLEXIT)  D
"RTN","HLCSIN",60,0)
 .. ; patch HL*1.6*122 start
"RTN","HLCSIN",61,0)
 .. ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSIN",62,0)
 .. ; DUZ comparison/reset for application proxy user
"RTN","HLCSIN",63,0)
 .. ;; D HLDUZ^HLCSTCP4
"RTN","HLCSIN",64,0)
 .. D HLDUZ2^HLCSTCP4
"RTN","HLCSIN",65,0)
 .. ; protect HLDUZ
"RTN","HLCSIN",66,0)
 .. N HLDUZ
"RTN","HLCSIN",67,0)
 .. S HLPCT=HLPCT+1
"RTN","HLCSIN",68,0)
 .. I '(HLPCT#100) D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",69,0)
 .. ; L +^HLMA(HLD0):0 Q:'$T
"RTN","HLCSIN",70,0)
 .. F  L +^HLMA(HLD0):30 Q:$T  H 1
"RTN","HLCSIN",71,0)
 .. I '$$CHECKAC("I",HLXX,HLD0) L -^HLMA(HLD0) Q  ;-> Quit if not a valid AC xref
"RTN","HLCSIN",72,0)
 .. D DEFACK^HLTP3(HLXX,HLD0)
"RTN","HLCSIN",73,0)
 .. D DEQUE^HLCSREP(HLXX,"I",HLD0)
"RTN","HLCSIN",74,0)
 .. L -^HLMA(HLD0)
"RTN","HLCSIN",75,0)
 .. ; patch HL*1.6*145
"RTN","HLCSIN",76,0)
 .. ; increment counter after message has been processed.
"RTN","HLCSIN",77,0)
 .. D LLCNT^HLCSTCP(HLXX,2)
"RTN","HLCSIN",78,0)
 . ; patch HL*1.6*122 end
"RTN","HLCSIN",79,0)
 . ;**109 -add dt/tm stamp to time queue last processed
"RTN","HLCSIN",80,0)
 . S ^XTMP("HL7-AC","I",HLXX)=$H
"RTN","HLCSIN",81,0)
 . ;**109 -unlock the queue
"RTN","HLCSIN",82,0)
 . ; patch HL*1.6*140
"RTN","HLCSIN",83,0)
 . ; L -^HLMA("AC","I",HLXX)
"RTN","HLCSIN",84,0)
 . L -^HLMA("IN-FILER","AC","I",HLXX)
"RTN","HLCSIN",85,0)
 Q
"RTN","HLCSIN",86,0)
 ;
"RTN","HLCSIN",87,0)
CHECKAC(WAY,IEN870,IEN773) ; If AC xref shouldn't exist, kill it...
"RTN","HLCSIN",88,0)
 ;
"RTN","HLCSIN",89,0)
 ; Check status and if 3 (processed) kill XREF...
"RTN","HLCSIN",90,0)
 I $P($G(^HLMA(+IEN773,"P")),U)=3 D  QUIT "" ;->
"RTN","HLCSIN",91,0)
 .  D DEQUE^HLCSREP(IEN870,WAY,IEN773)
"RTN","HLCSIN",92,0)
 ;
"RTN","HLCSIN",93,0)
 ; Add other checks here in the future...
"RTN","HLCSIN",94,0)
 ;
"RTN","HLCSIN",95,0)
 Q 1
"RTN","HLCSIN",96,0)
 ;
"RTN","HLCSIN",97,0)
ACKNOW(HLPTRFLR,HLFLG,HLEXIT) ; Process Logical Link's IN-queue for received message
"RTN","HLCSIN",98,0)
 N HLXX,HLD0,HLD1
"RTN","HLCSIN",99,0)
 S HLXX=0
"RTN","HLCSIN",100,0)
 F  S HLXX=$O(^HLCS(870,"AISTAT","P",HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",101,0)
 . ; HL*1.6*122, check the in-queue stop flag
"RTN","HLCSIN",102,0)
 . Q:$P($G(^HLCS(870,HLXX,0)),"^",9)
"RTN","HLCSIN",103,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",104,0)
 . ; HL*1.6*109: Does another filer have this?
"RTN","HLCSIN",105,0)
 . ; L +^HLCS(870,HLXX,"INFILER"):0 Q:'$T
"RTN","HLCSIN",106,0)
 . L +^HLCS(870,HLXX,"INFILER"):2 Q:'$T  ; patch HL*1.6*122
"RTN","HLCSIN",107,0)
 . F  D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT  S HLD0=$$DEQUEUE^HLCSQUE(HLXX,"IN") Q:+HLD0<0  D
"RTN","HLCSIN",108,0)
 .. ;
"RTN","HLCSIN",109,0)
 .. ; patch HL*1.6*122 start
"RTN","HLCSIN",110,0)
 .. ; clean variables except Kernel related variables
"RTN","HLCSIN",111,0)
 .. D
"RTN","HLCSIN",112,0)
 ... ; protect variables defined in STARTIN^HLCSIN
"RTN","HLCSIN",113,0)
 ... N HLFLG,HLEXIT,HLPTRFLR
"RTN","HLCSIN",114,0)
 ... N HLDUZ
"RTN","HLCSIN",115,0)
 ... ; protect variables defined in ACKNOW^HLCSIN
"RTN","HLCSIN",116,0)
 ... N HLXX,HLD0,HLD1
"RTN","HLCSIN",117,0)
 ... D KILL^XUSCLEAN
"RTN","HLCSIN",118,0)
 .. ;
"RTN","HLCSIN",119,0)
 .. ; patch HL*1.6*122 TEST v2: DUZ code removed
"RTN","HLCSIN",120,0)
 .. ; DUZ comparison/reset for application proxy user
"RTN","HLCSIN",121,0)
 .. ;; D HLDUZ^HLCSTCP4
"RTN","HLCSIN",122,0)
 .. D HLDUZ2^HLCSTCP4
"RTN","HLCSIN",123,0)
 .. ; protect HLDUZ
"RTN","HLCSIN",124,0)
 .. N HLDUZ
"RTN","HLCSIN",125,0)
 .. ;Make sure message is ready to be received
"RTN","HLCSIN",126,0)
 .. S HLFLG=1
"RTN","HLCSIN",127,0)
 .. S HLD1=$P(HLD0,"^",2)
"RTN","HLCSIN",128,0)
 .. S HLD0=+HLD0 ; At this point, HLD0=HLXX
"RTN","HLCSIN",129,0)
 .. I $P($G(^HLCS(870,HLD0,1,HLD1,0)),"^",3)'="A" D  Q
"RTN","HLCSIN",130,0)
 ... D MONITOR^HLCSDR2("D",2,HLD0,HLD1,"IN") ;Set status to DONE
"RTN","HLCSIN",131,0)
 .. D RECEIVE^HLMA0(HLD0,HLD1) ;Process received message
"RTN","HLCSIN",132,0)
 .. D MONITOR^HLCSDR2("D",2,HLD0,HLD1,"IN") ;Set status to DONE
"RTN","HLCSIN",133,0)
 . ; patch HL*1.6*122 end
"RTN","HLCSIN",134,0)
 . I HLD0<0,$D(^HLCS(870,"AISTAT","P",HLXX)) D
"RTN","HLCSIN",135,0)
 . . S HLD1=0 ; Make sure there aren't any loose xrefs hanging around.
"RTN","HLCSIN",136,0)
 . . F  S HLD1=$O(^HLCS(870,"AISTAT","P",HLXX,HLD1)) Q:'HLD1  D
"RTN","HLCSIN",137,0)
 . . . ;I '$D(^HLCS(870,HLXX,1,HLD1,0)) K ^HLCS(870,"AISTAT","P",HLXX,HLD1)
"RTN","HLCSIN",138,0)
 . . . I $P($G(^HLCS(870,HLXX,1,HLD1,0)),U,2)'="P" K ^HLCS(870,"AISTAT","P",HLXX,HLD1)
"RTN","HLCSIN",139,0)
 . L -^HLCS(870,HLXX,"INFILER")
"RTN","HLCSIN",140,0)
 Q
"RTN","HLCSIN",141,0)
DELQUE(HLPTRFLR,HLEXIT) ; Delete messages outside the 'queue size' window.
"RTN","HLCSIN",142,0)
 N HLDIR,HLXX,HLFRONT
"RTN","HLCSIN",143,0)
 S HLDIR=1,HLXX=0
"RTN","HLCSIN",144,0)
 F  S HLXX=$O(^HLCS(870,HLXX)) Q:'HLXX  D  Q:HLEXIT
"RTN","HLCSIN",145,0)
 . D CHKUPD(.HLPTRFLR,.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",146,0)
 . ; patch HL*1.6*122, comment out, no need to lock
"RTN","HLCSIN",147,0)
 . ; L +^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"):0 Q:'$T
"RTN","HLCSIN",148,0)
 . S HLFRONT=$G(^HLCS(870,HLXX,"IN QUEUE FRONT POINTER"))
"RTN","HLCSIN",149,0)
 . ; patch HL*1.6*122, comment out
"RTN","HLCSIN",150,0)
 . ; L -^HLCS(870,HLXX,"IN QUEUE FRONT POINTER")
"RTN","HLCSIN",151,0)
 . D DELETE^HLCSQUE1(HLXX,HLDIR,HLFRONT)
"RTN","HLCSIN",152,0)
 Q
"RTN","HLCSIN",153,0)
CHKUPD(HLPTRFLR,HLEXIT) ;
"RTN","HLCSIN",154,0)
 Q:$$HDIFF^XLFDT($H,$G(HLPTRFLR("LASTUP")),2)<15
"RTN","HLCSIN",155,0)
 D SETFLRDH^HLCSUTL1(HLPTRFLR,"IN") ; Update LAST KNOWN $H (field #.03) for filer
"RTN","HLCSIN",156,0)
 S HLPTRFLR("LASTUP")=$H
"RTN","HLCSIN",157,0)
 D CHK4STOP^HLCSUTL2(HLPTRFLR,"IN",.HLEXIT) Q:HLEXIT
"RTN","HLCSIN",158,0)
 Q
"RTN","HLCSMM1")
0^21^B4480587^B3431569
"RTN","HLCSMM1",1,0)
HLCSMM1 ;ISC-SF/JC - HL7 PROTOCOL FOR MAILMAN  ;03/15/2011
"RTN","HLCSMM1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**35,49,153**;Oct 13, 1995;Build 11
"RTN","HLCSMM1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSMM1",4,0)
INIT ;
"RTN","HLCSMM1",5,0)
 N HLNOW,HLDOUT0,HLDOUT1
"RTN","HLCSMM1",6,0)
 Q:'$D(HLDP)
"RTN","HLCSMM1",7,0)
 ;
"RTN","HLCSMM1",8,0)
 ;**P153 START CJM
"RTN","HLCSMM1",9,0)
 L +^HLCS(870,HLDP,"OUT","MAILMAN CLIENT"):30 Q:'$T
"RTN","HLCSMM1",10,0)
 ;**P153 END CJM
"RTN","HLCSMM1",11,0)
 ;
"RTN","HLCSMM1",12,0)
 D NOW^%DTC S HLNOW=%
"RTN","HLCSMM1",13,0)
UPDT ;Update link info
"RTN","HLCSMM1",14,0)
 F  L +^HLCS(870,HLDP,0):DTIME Q:$T  H 1
"RTN","HLCSMM1",15,0)
 S ZTSK=$G(ZTSK)
"RTN","HLCSMM1",16,0)
 I ZTSK="" S HLTRACE=""
"RTN","HLCSMM1",17,0)
 S DIE="^HLCS(870,",DA=HLDP
"RTN","HLCSMM1",18,0)
 S DR="9////^S X=HLNOW;10////@;14////0;3////MM;18////@"
"RTN","HLCSMM1",19,0)
 I ZTSK S DR=DR_";11////^S X=ZTSK"
"RTN","HLCSMM1",20,0)
 D ^DIE K DIE,DA,DR
"RTN","HLCSMM1",21,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSMM1",22,0)
LOOP ;Begin send loop
"RTN","HLCSMM1",23,0)
 S STOP=0
"RTN","HLCSMM1",24,0)
 F  H 1 D START Q:STOP
"RTN","HLCSMM1",25,0)
 ;
"RTN","HLCSMM1",26,0)
 ;**P153 START CJM
"RTN","HLCSMM1",27,0)
 D STATUS("SHUTDOWN")
"RTN","HLCSMM1",28,0)
 L -^HLCS(870,HLDP,"OUT","MAILMAN CLIENT")
"RTN","HLCSMM1",29,0)
 ;**P153 END CJM
"RTN","HLCSMM1",30,0)
 Q
"RTN","HLCSMM1",31,0)
START ;
"RTN","HLCSMM1",32,0)
 S HLNXST="IDLE"
"RTN","HLCSMM1",33,0)
 D TRACE^HLCSDR2,STATUS(HLNXST)
"RTN","HLCSMM1",34,0)
 S HLDOUT0=$$DEQUEUE^HLCSQUE(HLDP,"OUT")
"RTN","HLCSMM1",35,0)
 S HLDOUT1=$P(HLDOUT0,U,2),HLDOUT0=+HLDOUT0
"RTN","HLCSMM1",36,0)
 I HLDOUT0'<0 D
"RTN","HLCSMM1",37,0)
 .S HLNXST="WRITING" D TRACE^HLCSDR2,STATUS(HLNXST)
"RTN","HLCSMM1",38,0)
 .D EN^HLCSMM(HLDOUT0,HLDOUT1)
"RTN","HLCSMM1",39,0)
 I $D(HLTRACE) U IO(0) W !,"Type 'Q' to quit: " R X:1 I $G(X)'=""&("Qq"[X) D
"RTN","HLCSMM1",40,0)
 .F  L +^HLCS(870,HLDP,0):DTIME Q:$T  H 1
"RTN","HLCSMM1",41,0)
 .S $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSMM1",42,0)
 .L -^HLCS(870,HLDP,0)
"RTN","HLCSMM1",43,0)
 D STOP
"RTN","HLCSMM1",44,0)
 Q
"RTN","HLCSMM1",45,0)
STATUS(HLNXST) ;Status update
"RTN","HLCSMM1",46,0)
 F  L +^HLCS(870,HLDP,0):DTIME Q:$T  H 1
"RTN","HLCSMM1",47,0)
 I $G(HLNXST)]"",$P(^HLCS(870,HLDP,0),U,5)=HLNXST L -^HLCS(870,HLDP,0) Q
"RTN","HLCSMM1",48,0)
 S $P(^HLCS(870,HLDP,0),U,5)=HLNXST
"RTN","HLCSMM1",49,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSMM1",50,0)
 D STOP
"RTN","HLCSMM1",51,0)
 Q
"RTN","HLCSMM1",52,0)
STOP ;Check for Shutdown request
"RTN","HLCSMM1",53,0)
 D NOW^%DTC
"RTN","HLCSMM1",54,0)
 F  L +^HLCS(870,HLDP,0):DTIME Q:$T  H 1
"RTN","HLCSMM1",55,0)
 I $P(^HLCS(870,HLDP,0),U,15)'=1 L -^HLCS(870,HLDP,0) Q
"RTN","HLCSMM1",56,0)
 S STOP=1,HLNXST="SHUTDOWN"
"RTN","HLCSMM1",57,0)
 S DIE="^HLCS(870,",DA=HLDP
"RTN","HLCSMM1",58,0)
 S DR="4///^S X=HLNXST;10////^S X=%;9////@;11////@"
"RTN","HLCSMM1",59,0)
 D ^DIE K DIE,DA,DR
"RTN","HLCSMM1",60,0)
 L -^HLCS(870,HLDP,0)
"RTN","HLCSMM1",61,0)
 Q
"RTN","HLCSOUT")
0^2^B12989203^B10861157
"RTN","HLCSOUT",1,0)
HLCSOUT ;ALB/JRP/CJM - OUTGOING FILER;2/25/97 ;03/07/2011
"RTN","HLCSOUT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**25,30,62,153**;Oct 13, 1995;Build 11
"RTN","HLCSOUT",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSOUT",4,0)
STARTOUT ;Main entry point for outgoing background filer
"RTN","HLCSOUT",5,0)
 ;Create/find entry denoting this filer in the OUTGOING FILER TASK
"RTN","HLCSOUT",6,0)
 ; NUMBER multiple (field #30) of the HL COMMUNICATION SERVER PARAMETER
"RTN","HLCSOUT",7,0)
 ; file (#869.3)
"RTN","HLCSOUT",8,0)
 ;N TMP ; These vbls are not used!
"RTN","HLCSOUT",9,0)
 N HLPTRFLR,HLPTRLL,HLCSLOOP,HLEXIT,HLXX,HLNODE,HLOGLINK,HLPARENT
"RTN","HLCSOUT",10,0)
 N HLHDRBLD,HLERROR,HLHDR,HLD0,HLD1,HLST1
"RTN","HLCSOUT",11,0)
 S HLPTRFLR=+$$CRTFLR^HLCSUTL1(ZTSK,"OUT")
"RTN","HLCSOUT",12,0)
 ;Check if any outgoing messages are in the pending transmission queue
"RTN","HLCSOUT",13,0)
 ;
"RTN","HLCSOUT",14,0)
 S (HLPTRLL,HLCSLOOP,HLEXIT)=0
"RTN","HLCSOUT",15,0)
 F  S HLPTRLL=+$O(^HL(772,"A-XMIT-OUT",HLPTRLL)) D  Q:HLEXIT
"RTN","HLCSOUT",16,0)
 . D CHK4STOP^HLCSUTL2(HLPTRFLR,"OUT",.HLEXIT) Q:HLEXIT
"RTN","HLCSOUT",17,0)
 . ;Update LAST KNOWN $H (field #.03) for filer every 200th iteration
"RTN","HLCSOUT",18,0)
 . D:'(HLCSLOOP#200) SETFLRDH^HLCSUTL1(HLPTRFLR,"OUT")
"RTN","HLCSOUT",19,0)
 . ;Increment loop counter (reset to 0 when greater than 1000)
"RTN","HLCSOUT",20,0)
 . S HLCSLOOP=HLCSLOOP+1 S:HLCSLOOP>1000 HLCSLOOP=0
"RTN","HLCSOUT",21,0)
 . I 'HLPTRLL H 1 Q
"RTN","HLCSOUT",22,0)
 .;
"RTN","HLCSOUT",23,0)
 .;**P153 CJM START
"RTN","HLCSOUT",24,0)
 .L +^HLCS(870,HLPTRLL,"OUT","OUTFILER"):1
"RTN","HLCSOUT",25,0)
 .Q:'$T
"RTN","HLCSOUT",26,0)
 .D
"RTN","HLCSOUT",27,0)
 ..;**P153 END CJM
"RTN","HLCSOUT",28,0)
 ..;
"RTN","HLCSOUT",29,0)
 .. S HLXX=+$O(^HL(772,"A-XMIT-OUT",HLPTRLL,0)) ;Pending messages?
"RTN","HLCSOUT",30,0)
 .. I 'HLXX H 1 Q  ;No pending messages
"RTN","HLCSOUT",31,0)
 .. L +^HL(772,HLXX,0):1 I ('$T) H 1 Q  ;Lock main node of Message Text
"RTN","HLCSOUT",32,0)
 .. ;Make sure status hasn't changed
"RTN","HLCSOUT",33,0)
 .. I '$D(^HL(772,"AF",1,HLXX)) L -^HL(772,HLXX,0) Q
"RTN","HLCSOUT",34,0)
 .. ;Get Logical Link and parent message
"RTN","HLCSOUT",35,0)
 .. ; Set status to ERROR DURING TRANSMISSION if not present
"RTN","HLCSOUT",36,0)
 .. S HLNODE=^HL(772,HLXX,0)
"RTN","HLCSOUT",37,0)
 .. S HLOGLINK=$P(HLNODE,"^",11)
"RTN","HLCSOUT",38,0)
 .. I HLOGLINK'>0 D  Q
"RTN","HLCSOUT",39,0)
 .. . D STATUS^HLTF0(HLXX,4,"","Logical Link not available")
"RTN","HLCSOUT",40,0)
 .. . L -^HL(772,HLXX,0)
"RTN","HLCSOUT",41,0)
 .. S HLPARENT=$P(HLNODE,"^",8)
"RTN","HLCSOUT",42,0)
 .. I HLPARENT'>0!'$G(^HL(772,HLPARENT,0)) D  Q
"RTN","HLCSOUT",43,0)
 .. . D STATUS^HLTF0(HLXX,4,"","Parent Message not available")
"RTN","HLCSOUT",44,0)
 .. . L -^HL(772,HLXX,0)
"RTN","HLCSOUT",45,0)
 .. ;Build message header or batch header
"RTN","HLCSOUT",46,0)
 .. S HLHDRBLD=$P(^HL(772,HLPARENT,0),U,14)
"RTN","HLCSOUT",47,0)
 .. I "^B^M^F^"'[(U_HLHDRBLD_U) D  Q
"RTN","HLCSOUT",48,0)
 .. . D STATUS^HLTF0(HLXX,4,"","Message Type (field #772,14) Error")
"RTN","HLCSOUT",49,0)
 .. . L -^HL(772,HLXX,0)
"RTN","HLCSOUT",50,0)
 .. S HLERROR=""
"RTN","HLCSOUT",51,0)
 .. I HLHDRBLD="M" D HEADER^HLCSHDR(HLXX,.HLERROR)
"RTN","HLCSOUT",52,0)
 .. I HLHDRBLD'="M" D BHSHDR^HLCSHDR(HLXX) S:$E(HLHDR(1),1,2)="-1" HLERROR=$P(HLHDR(1),"^",2)
"RTN","HLCSOUT",53,0)
 .. ;If error set status ERROR DURING TRANSMISSION
"RTN","HLCSOUT",54,0)
 .. I $G(HLERROR)'="" D STATUS^HLTF0(HLXX,4) L -^HL(772,HLXX,0) Q
"RTN","HLCSOUT",55,0)
 .. S HLD0=$$ENQUEUE^HLCSQUE(HLOGLINK,"OUT")
"RTN","HLCSOUT",56,0)
 .. ;If error set status ERROR DURING TRANSMISSION
"RTN","HLCSOUT",57,0)
 .. I +HLD0<0 D STATUS^HLTF0(HLXX,4) L -^HL(772,HLXX,0) Q
"RTN","HLCSOUT",58,0)
 .. S HLD1=$P(HLD0,"^",2)
"RTN","HLCSOUT",59,0)
 .. S HLD0=+HLD0
"RTN","HLCSOUT",60,0)
 .. ;Move Message Header and Message Text to file 870
"RTN","HLCSOUT",61,0)
 .. D MERGEOUT^HLTF2(HLPARENT,HLD0,HLD1,"HLHDR")
"RTN","HLCSOUT",62,0)
 .. K HLHDR
"RTN","HLCSOUT",63,0)
 .. D MONITOR^HLCSDR2("P",2,HLD0,HLD1,"OUT") ;Status in queue to "PENDING"
"RTN","HLCSOUT",64,0)
 .. ;Determine status, default to "Awaiting Ack"
"RTN","HLCSOUT",65,0)
 .. S HLST1=$$FNDSTAT^HLUTIL3(HLXX) S:'HLST1 HLST1=2
"RTN","HLCSOUT",66,0)
 .. D STATUS^HLTF0(HLXX,HLST1) ;Update status
"RTN","HLCSOUT",67,0)
 .. L -^HL(772,HLXX,0) ;Unlock main node of Message Text
"RTN","HLCSOUT",68,0)
 .. ;Update LAST KNOWN $H (field #.03) for filer
"RTN","HLCSOUT",69,0)
 .. D SETFLRDH^HLCSUTL1(HLPTRFLR,"OUT")
"RTN","HLCSOUT",70,0)
 .;P153 START CJM
"RTN","HLCSOUT",71,0)
 .L -^HLCS(870,HLPTRLL,"OUT","OUTFILER")
"RTN","HLCSOUT",72,0)
 .;P153 END CJM
"RTN","HLCSOUT",73,0)
 S ZTSTOP=1 ;Asked to stop
"RTN","HLCSOUT",74,0)
 D DELFLR^HLCSUTL1(HLPTRFLR,"OUT") ;Delete entry denoting this filer
"RTN","HLCSOUT",75,0)
 S ZTREQ="@"
"RTN","HLCSOUT",76,0)
 Q
"RTN","HLCSQUE")
0^3^B28207653^B14643380
"RTN","HLCSQUE",1,0)
HLCSQUE ;ALB/MFK/CJM HL7 UTILITY FUNCTIONS - 10/4/94 11AM ;02/17/2011
"RTN","HLCSQUE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**14,61,59,153**;Oct 13, 1995;Build 11
"RTN","HLCSQUE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSQUE",4,0)
ENQUEUE(IEN,HLDIR) ;Assign a message for queue entry
"RTN","HLCSQUE",5,0)
 ; INPUT: IEN  - Internal Entry Number for file 870 - HL7 QUEUE
"RTN","HLCSQUE",6,0)
 ;        HLDIR  - Direction of queue (IN/OUT)
"RTN","HLCSQUE",7,0)
 ; OUTPUT: BEG - Location in the queue to stuff the message
"RTN","HLCSQUE",8,0)
 ;        -1   - Error
"RTN","HLCSQUE",9,0)
 N FRONT,BACK,DIC,DA,X,DINUM,ENTRY,Y,BPOINTER,NEWREC
"RTN","HLCSQUE",10,0)
 ;  Make sure required variables were given
"RTN","HLCSQUE",11,0)
 S IEN=$G(IEN)
"RTN","HLCSQUE",12,0)
 Q:(IEN="") "-1^Queue not given"
"RTN","HLCSQUE",13,0)
 I +IEN<1 S IEN=$O(^HLCS(870,"B",IEN,""))
"RTN","HLCSQUE",14,0)
 Q:(IEN="") "-1^Invalid queue"
"RTN","HLCSQUE",15,0)
 ;  Convert direction to a number
"RTN","HLCSQUE",16,0)
 S HLDIR=$G(HLDIR)
"RTN","HLCSQUE",17,0)
 Q:(HLDIR'="IN")&(HLDIR'="OUT")&(HLDIR'=1)&(HLDIR'=2) "-1^Invalid direction"
"RTN","HLCSQUE",18,0)
 S HLDIR=$S(HLDIR="IN":1,HLDIR="OUT":2,HLDIR=2:2,1:1)
"RTN","HLCSQUE",19,0)
 S BPOINTER=$S(HLDIR=1:"IN",1:"OUT")_" QUEUE BACK POINTER"
"RTN","HLCSQUE",20,0)
 S FRONT=$G(^HLCS(870,IEN,$S(HLDIR=1:"IN",1:"OUT")_" QUEUE FRONT POINTER"))
"RTN","HLCSQUE",21,0)
 D DELETE^HLCSQUE1(IEN,HLDIR,FRONT)
"RTN","HLCSQUE",22,0)
 F  L +^HLCS(870,IEN,BPOINTER):20 Q:$T
"RTN","HLCSQUE",23,0)
 S BACK=$G(^HLCS(870,IEN,BPOINTER))
"RTN","HLCSQUE",24,0)
 ; Set up DICN call
"RTN","HLCSQUE",25,0)
 S DIC="^HLCS(870,"_IEN_","_HLDIR_","
"RTN","HLCSQUE",26,0)
 S ENTRY=HLDIR+18
"RTN","HLCSQUE",27,0)
 S DIC(0)="LNX",DA(1)=IEN,DIC("P")=$P(^DD(870,ENTRY,0),"^",2)
"RTN","HLCSQUE",28,0)
 S NEWREC=BACK+1
"RTN","HLCSQUE",29,0)
 S (DINUM,X)=NEWREC
"RTN","HLCSQUE",30,0)
 ;  Create Record
"RTN","HLCSQUE",31,0)
 K DD,DO
"RTN","HLCSQUE",32,0)
 F  D  Q:Y>0  H 1
"RTN","HLCSQUE",33,0)
 .F  L +^HLCS(870,IEN,HLDIR,NEWREC):20 Q:$T
"RTN","HLCSQUE",34,0)
 .D FILE^DICN
"RTN","HLCSQUE",35,0)
 .I Y=-1 L -^HLCS(870,IEN,HLDIR,NEWREC) S NEWREC=NEWREC+1,(X,DINUM)=NEWREC
"RTN","HLCSQUE",36,0)
 ;  Set the 'status' to 'S' for stub
"RTN","HLCSQUE",37,0)
 S $P(^HLCS(870,IEN,HLDIR,NEWREC,0),"^",2)="S"
"RTN","HLCSQUE",38,0)
 S ^HLCS(870,IEN,BPOINTER)=NEWREC
"RTN","HLCSQUE",39,0)
EXIT1 ;  Unlock and return results
"RTN","HLCSQUE",40,0)
 L -^HLCS(870,IEN,BPOINTER)
"RTN","HLCSQUE",41,0)
 L -^HLCS(870,IEN,HLDIR,NEWREC)
"RTN","HLCSQUE",42,0)
 Q IEN_"^"_NEWREC
"RTN","HLCSQUE",43,0)
 ;
"RTN","HLCSQUE",44,0)
DEQUEUE(IEN,HLDIR) ;Release the next message from the queue
"RTN","HLCSQUE",45,0)
 N RETURN,FRONT,FPOINTER
"RTN","HLCSQUE",46,0)
 ;
"RTN","HLCSQUE",47,0)
 N FOUND,NOMORE,NEXT,HLRTIME,STATUS
"RTN","HLCSQUE",48,0)
 ;
"RTN","HLCSQUE",49,0)
 S IEN=$G(IEN)
"RTN","HLCSQUE",50,0)
 Q:(IEN="") "-1^Queue not given"
"RTN","HLCSQUE",51,0)
 I +IEN<1 S IEN=$O(^HLCS(870,"B",IEN,""))
"RTN","HLCSQUE",52,0)
 Q:(IEN="") "-1^Invalid queue"
"RTN","HLCSQUE",53,0)
 ;  Convert direction to a number
"RTN","HLCSQUE",54,0)
 S HLDIR=$G(HLDIR)
"RTN","HLCSQUE",55,0)
 Q:(HLDIR'="IN")&(HLDIR'="OUT")&(HLDIR'=1)&(HLDIR'=2) "-1^Invalid direction"
"RTN","HLCSQUE",56,0)
 S HLDIR=$S(HLDIR="IN":1,HLDIR="OUT":2,HLDIR=2:2,1:1)
"RTN","HLCSQUE",57,0)
 S FPOINTER=$S(HLDIR=1:"IN",1:"OUT")_" QUEUE FRONT POINTER"
"RTN","HLCSQUE",58,0)
 S HLRTIME=$P($G(^HLCS(870,IEN,0)),"^",22) ; retention time in minutes for stub
"RTN","HLCSQUE",59,0)
 S:HLRTIME HLRTIME=HLRTIME*60
"RTN","HLCSQUE",60,0)
 S:(HLRTIME<300) HLRTIME=600
"RTN","HLCSQUE",61,0)
 L +^HLCS(870,IEN,FPOINTER):1
"RTN","HLCSQUE",62,0)
 I '$T S RETURN="-1^NO NEXT RECORD" G EXIT2
"RTN","HLCSQUE",63,0)
 S FRONT=$G(^HLCS(870,IEN,FPOINTER))
"RTN","HLCSQUE",64,0)
 S (FOUND,NOMORE)=0
"RTN","HLCSQUE",65,0)
 F NEXT=FRONT+1:1 D  Q:FOUND  Q:NOMORE
"RTN","HLCSQUE",66,0)
 .F  L +^HLCS(870,IEN,HLDIR,NEXT):20 Q:$T
"RTN","HLCSQUE",67,0)
 .I '$D(^HLCS(870,IEN,HLDIR,NEXT,0)) D  Q:NOMORE
"RTN","HLCSQUE",68,0)
 ..;missing record
"RTN","HLCSQUE",69,0)
 ..L -^HLCS(870,IEN,HLDIR,NEXT)
"RTN","HLCSQUE",70,0)
 ..;update front pointer
"RTN","HLCSQUE",71,0)
 ..S:$O(^HLCS(870,IEN,HLDIR,NEXT)) ^HLCS(870,IEN,FPOINTER)=NEXT
"RTN","HLCSQUE",72,0)
 ..;
"RTN","HLCSQUE",73,0)
 ..;Is there another record following the missing one?
"RTN","HLCSQUE",74,0)
 ..S NEXT=$O(^HLCS(870,IEN,HLDIR,NEXT))
"RTN","HLCSQUE",75,0)
 ..I 'NEXT S NOMORE=1,RETURN="-1^NO NEXT RECORD" Q
"RTN","HLCSQUE",76,0)
 ..;
"RTN","HLCSQUE",77,0)
 ..;The next record after missing record has been found - lock it!
"RTN","HLCSQUE",78,0)
 ..F  L +^HLCS(870,IEN,HLDIR,NEXT):20 Q:$T
"RTN","HLCSQUE",79,0)
 ..;
"RTN","HLCSQUE",80,0)
 .;A record has been found.
"RTN","HLCSQUE",81,0)
 .S STATUS=$P($G(^HLCS(870,IEN,HLDIR,NEXT,0)),"^",2)
"RTN","HLCSQUE",82,0)
 .;Is it a pending message, a stub, or done?
"RTN","HLCSQUE",83,0)
 .I STATUS="P" D
"RTN","HLCSQUE",84,0)
 ..;it is a pending message, so should be returned.
"RTN","HLCSQUE",85,0)
 ..S FOUND=1,RETURN=IEN_"^"_NEXT
"RTN","HLCSQUE",86,0)
 ..;
"RTN","HLCSQUE",87,0)
 .E  D
"RTN","HLCSQUE",88,0)
 ..;if the record is DONE then the front pointer is wrong - fix it and try again!
"RTN","HLCSQUE",89,0)
 ..I STATUS="D" S ^HLCS(870,IEN,FPOINTER)=NEXT Q
"RTN","HLCSQUE",90,0)
 ..;
"RTN","HLCSQUE",91,0)
 ..;Must be a stub record
"RTN","HLCSQUE",92,0)
 ..;
"RTN","HLCSQUE",93,0)
 ..;discard 'old' stub records
"RTN","HLCSQUE",94,0)
 ..N HLDT1
"RTN","HLCSQUE",95,0)
 ..S HLDT1=$P($G(^HLCS(870,IEN,HLDIR,NEXT,0)),"^",10)
"RTN","HLCSQUE",96,0)
 ..I 'HLDT1 D  Q
"RTN","HLCSQUE",97,0)
 ...;not an old stub record - can not discard
"RTN","HLCSQUE",98,0)
 ...S $P(^HLCS(870,IEN,HLDIR,NEXT,0),"^",10)=$$NOW^XLFDT,NOMORE=1,RETURN="-1^STUB"
"RTN","HLCSQUE",99,0)
 ..;
"RTN","HLCSQUE",100,0)
 ..I $$FMDIFF^XLFDT($$NOW^XLFDT,HLDT1,2)>HLRTIME D
"RTN","HLCSQUE",101,0)
 ...;Is an old stub record - should continue on to the next record
"RTN","HLCSQUE",102,0)
 ...S $P(^HLCS(870,IEN,HLDIR,NEXT,0),"^",2)="U"
"RTN","HLCSQUE",103,0)
 ...;update front pointer
"RTN","HLCSQUE",104,0)
 ...S ^HLCS(870,IEN,FPOINTER)=NEXT
"RTN","HLCSQUE",105,0)
 ..E  D
"RTN","HLCSQUE",106,0)
 ...;not an old stub record - should NOT continue to next record
"RTN","HLCSQUE",107,0)
 ...S NOMORE=1,RETURN="-1^STUB"
"RTN","HLCSQUE",108,0)
 .;
"RTN","HLCSQUE",109,0)
 .L -^HLCS(870,IEN,HLDIR,NEXT)
"RTN","HLCSQUE",110,0)
 ;
"RTN","HLCSQUE",111,0)
 S:FOUND ^HLCS(870,IEN,FPOINTER)=NEXT
"RTN","HLCSQUE",112,0)
EXIT2 L -^HLCS(870,IEN,FPOINTER)
"RTN","HLCSQUE",113,0)
 Q RETURN
"RTN","HLCSQUE",114,0)
 ;
"RTN","HLCSQUE",115,0)
CLEARQUE(IEN,HLDIR) ;Empty an entire queue
"RTN","HLCSQUE",116,0)
 ; IEN - Entry number for queue - can be name from "B" X-ref
"RTN","HLCSQUE",117,0)
 ; HLDIR - Can be "IN", "OUT", 1 or 2.
"RTN","HLCSQUE",118,0)
 ; output: 0 for success
"RTN","HLCSQUE",119,0)
 ;        -1^error for error
"RTN","HLCSQUE",120,0)
 N MSG,X,ERR,FP,BP
"RTN","HLCSQUE",121,0)
 ;NOTE: this is not needed to initialize a queue
"RTN","HLCSQUE",122,0)
 ; enqueue will set up (?) a new queue
"RTN","HLCSQUE",123,0)
 ;  Make sure that required variables exist
"RTN","HLCSQUE",124,0)
 S IEN=$G(IEN)
"RTN","HLCSQUE",125,0)
 Q:(IEN="") "-1^Internal Entry Number missing"
"RTN","HLCSQUE",126,0)
 I +IEN<1 S IEN=$O(^HLCS(870,"B",IEN,""))
"RTN","HLCSQUE",127,0)
 Q:(IEN="") "-1^Invalid IEN"
"RTN","HLCSQUE",128,0)
 ;  Convert direction to a number
"RTN","HLCSQUE",129,0)
 S HLDIR=$G(HLDIR)
"RTN","HLCSQUE",130,0)
 Q:(HLDIR'="IN")&(HLDIR'="OUT")&(HLDIR'=1)&(HLDIR'=2) "-1^Invalid direction"
"RTN","HLCSQUE",131,0)
 S HLDIR=$S(HLDIR="IN":1,HLDIR="OUT":2,HLDIR=2:2,1:1)
"RTN","HLCSQUE",132,0)
 ;  If in queue, set front pointer to 6, out pointer gets set to 8
"RTN","HLCSQUE",133,0)
 I HLDIR=1 S FP="IN QUEUE FRONT POINTER",BP="IN QUEUE BACK POINTER"
"RTN","HLCSQUE",134,0)
 I HLDIR=2 S FP="OUT QUEUE FRONT POINTER",BP="OUT QUEUE BACK POINTER"
"RTN","HLCSQUE",135,0)
 S MSG=0
"RTN","HLCSQUE",136,0)
 W !
"RTN","HLCSQUE",137,0)
 ;  Loop through and delete messages
"RTN","HLCSQUE",138,0)
 F  S MSG=$O(^HLCS(870,IEN,HLDIR,MSG)) Q:(MSG'>0)  D
"RTN","HLCSQUE",139,0)
 .S ERR=$$DELMSG^HLCSQUE1(IEN,HLDIR,MSG) W "."
"RTN","HLCSQUE",140,0)
 .I ERR W ERR,!
"RTN","HLCSQUE",141,0)
 ;  Clear front and back pointers
"RTN","HLCSQUE",142,0)
 S ^HLCS(870,IEN,FP)=0
"RTN","HLCSQUE",143,0)
 S ^HLCS(870,IEN,BP)=0
"RTN","HLCSQUE",144,0)
 ;K IEN,HLDIR
"RTN","HLCSQUE",145,0)
 Q 0
"RTN","HLCSQUE",146,0)
 ;
"RTN","HLCSQUE",147,0)
PUSH(HLDOUT0,HLDOUT1) ;-- Place message back on queue
"RTN","HLCSQUE",148,0)
 ;  INPUT - HLDOUT0 IEN of file 870
"RTN","HLCSQUE",149,0)
 ;          HLDOUT1 IEN of Out Multiple
"RTN","HLCSQUE",150,0)
 ;  OUTPUT- NONE
"RTN","HLCSQUE",151,0)
 ;
"RTN","HLCSQUE",152,0)
 ;-- exit if not vaild variables
"RTN","HLCSQUE",153,0)
 I 'HLDOUT0!'HLDOUT1 G PUSHQ
"RTN","HLCSQUE",154,0)
 ;-- exit if global does not already exist
"RTN","HLCSQUE",155,0)
 I '$D(^HLCS(870,HLDOUT0,"OUT QUEUE FRONT POINTER")) G PUSHQ
"RTN","HLCSQUE",156,0)
 S ^HLCS(870,HLDOUT0,"OUT QUEUE FRONT POINTER")=(HLDOUT1-1)
"RTN","HLCSQUE",157,0)
PUSHQ Q
"RTN","HLCSQUE",158,0)
 ;
"RTN","HLCSQUE1")
0^4^B5361364^B4079796
"RTN","HLCSQUE1",1,0)
HLCSQUE1 ;ALB/MFK HL7 UTILITY FUNCTIONS - 10/4/94 11AM ;02/17/2011
"RTN","HLCSQUE1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**14,59,100,153**;Oct 13, 1995;Build 11
"RTN","HLCSQUE1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSQUE1",4,0)
 ;
"RTN","HLCSQUE1",5,0)
 ;Utilities used by HLCSQUE
"RTN","HLCSQUE1",6,0)
 ;
"RTN","HLCSQUE1",7,0)
DELMSG(IEN,HLDIR,MSG) ;DELETE A SINGLE MESSAGE FROM A QUEUE
"RTN","HLCSQUE1",8,0)
 ;INPUT: IEN - Internal Entry Number for queue
"RTN","HLCSQUE1",9,0)
 ;       HLDIR - Direction of queue
"RTN","HLCSQUE1",10,0)
 ;       MSG - Message number to remove
"RTN","HLCSQUE1",11,0)
 ;OUTPUT:  0 - Success
"RTN","HLCSQUE1",12,0)
 ;        -1 - Error
"RTN","HLCSQUE1",13,0)
 N DIK,DA
"RTN","HLCSQUE1",14,0)
 ;  Check for required variables
"RTN","HLCSQUE1",15,0)
 S IEN=$G(IEN)
"RTN","HLCSQUE1",16,0)
 Q:(IEN="") "-1^Internal Entry Number missing"
"RTN","HLCSQUE1",17,0)
 I +IEN<1 S IEN=$O(^HLCS(870,"B",IEN,""))
"RTN","HLCSQUE1",18,0)
 Q:(IEN="") "-1^Invalid IEN"
"RTN","HLCSQUE1",19,0)
 S HLDIR=$G(HLDIR)
"RTN","HLCSQUE1",20,0)
 S HLDIR=$S(HLDIR="IN":1,HLDIR="OUT":2,HLDIR=2:2,HLDIR=1:1,1:"")
"RTN","HLCSQUE1",21,0)
 Q:(HLDIR="") "-1^Invalid direction"
"RTN","HLCSQUE1",22,0)
 S MSG=$G(MSG)
"RTN","HLCSQUE1",23,0)
 Q:(MSG="") "-1^No message number"
"RTN","HLCSQUE1",24,0)
 L +^HLCS(870,IEN,HLDIR,MSG):1
"RTN","HLCSQUE1",25,0)
 ;If lock fails, another process is doing the work.
"RTN","HLCSQUE1",26,0)
 I '$T Q 1
"RTN","HLCSQUE1",27,0)
 S DIK="^HLCS(870,"_IEN_","_HLDIR_",",DA(1)=IEN,DA=MSG
"RTN","HLCSQUE1",28,0)
 D ^DIK
"RTN","HLCSQUE1",29,0)
 L -^HLCS(870,IEN,HLDIR,MSG)
"RTN","HLCSQUE1",30,0)
 K IEN,HLDIR,MSG
"RTN","HLCSQUE1",31,0)
 Q 0
"RTN","HLCSQUE1",32,0)
DELETE(IEN,HLDIR,FRONT) ;  Delete messages outside the 'queue size' window
"RTN","HLCSQUE1",33,0)
 N MSG,TMP,QSIZE,STOP,HLX
"RTN","HLCSQUE1",34,0)
 ;  Make sure required variables exist
"RTN","HLCSQUE1",35,0)
 S IEN=$G(IEN) Q:(IEN="")
"RTN","HLCSQUE1",36,0)
 S HLDIR=$G(HLDIR) Q:(HLDIR="")
"RTN","HLCSQUE1",37,0)
 S FRONT=$G(FRONT) Q:(FRONT="")
"RTN","HLCSQUE1",38,0)
 S TMP=^HLCS(870,IEN,0)
"RTN","HLCSQUE1",39,0)
 S QSIZE=$P(TMP,"^",21)
"RTN","HLCSQUE1",40,0)
 I FRONT'>0 Q
"RTN","HLCSQUE1",41,0)
 I QSIZE'>0 S QSIZE=10
"RTN","HLCSQUE1",42,0)
 S MSG=0,STOP=0
"RTN","HLCSQUE1",43,0)
 ;  For each message from the beginning of the queue to the front
"RTN","HLCSQUE1",44,0)
 ;  of the queue-queue size, delete that message if it's done
"RTN","HLCSQUE1",45,0)
 F  S MSG=$O(^HLCS(870,IEN,HLDIR,MSG)) Q:(MSG>(FRONT-QSIZE))!(STOP'=0)!(MSG'>0)  D
"RTN","HLCSQUE1",46,0)
 .;P153 Start PIJ
"RTN","HLCSQUE1",47,0)
 .;I $P($G(^HLCS(870,IEN,HLDIR,MSG,0)),"^",2)'="D" D  QUIT:STOP  ;->
"RTN","HLCSQUE1",48,0)
 .I $P($G(^HLCS(870,IEN,HLDIR,MSG,0)),"^",2)'="D",$P($G(^HLCS(870,IEN,HLDIR,MSG,0)),"^",2)'="U" D  QUIT:STOP  ;->
"RTN","HLCSQUE1",49,0)
 ..;P153 End PIJ
"RTN","HLCSQUE1",50,0)
 ..I $D(^HLCS(870,IEN,HLDIR,MSG)) D  QUIT:STOP  ;->
"RTN","HLCSQUE1",51,0)
 ...S HLX=$O(^HLCS(870,IEN,HLDIR,MSG)) QUIT:HLX>0  ;->
"RTN","HLCSQUE1",52,0)
 ...S STOP=1
"RTN","HLCSQUE1",53,0)
 ..S HLX=+$G(HLX)
"RTN","HLCSQUE1",54,0)
 ..I '$D(^HLCS(870,IEN,HLDIR,+HLX,0)) S STOP=1 QUIT  ;->
"RTN","HLCSQUE1",55,0)
 ..Q:$P($G(^HLCS(870,IEN,HLDIR,+HLX,0)),U,2)="D"  ;-> All OK...
"RTN","HLCSQUE1",56,0)
 ..Q:$P($G(^HLCS(870,IEN,HLDIR,+HLX,0)),U,2)="U"  ;-> All OK...
"RTN","HLCSQUE1",57,0)
 ..S STOP=1
"RTN","HLCSQUE1",58,0)
 .S STOP=$$DELMSG(IEN,HLDIR,MSG)
"RTN","HLCSQUE1",59,0)
 K IEN,HLDIR,FRONT
"RTN","HLCSQUE1",60,0)
 Q
"RTN","HLCSTCP2")
0^7^B83851505^B83867946
"RTN","HLCSTCP2",1,0)
HLCSTCP2 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;12/01/2010
"RTN","HLCSTCP2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,49,57,63,64,66,67,76,77,87,109,133,122,140,142,145,153**;Oct 13,1995;Build 11
"RTN","HLCSTCP2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP2",4,0)
 ;Sender 
"RTN","HLCSTCP2",5,0)
 ;Request connection, send outbound message(s) delimited by MLLP
"RTN","HLCSTCP2",6,0)
 ;Input : HLDP=Logical Link to use
"RTN","HLCSTCP2",7,0)
 ; Set up error trap
"RTN","HLCSTCP2",8,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",9,0)
 N HLMSG,HLPORT,HLRETRY,HLRETMG,HLTCPO,POP
"RTN","HLCSTCP2",10,0)
 ;HLRETRY=number of retranmission for this link,HLRETMG=alert sent
"RTN","HLCSTCP2",11,0)
 S HLTCPO=HLDP,HLMSG="",(HLRETRY,HLRETMG)=0
"RTN","HLCSTCP2",12,0)
 ;
"RTN","HLCSTCP2",13,0)
 ; patch 122
"RTN","HLCSTCP2",14,0)
 ; patch 133
"RTN","HLCSTCP2",15,0)
 ; set IO(0) to the null device
"RTN","HLCSTCP2",16,0)
 I $G(^%ZOSF("OS"))]"",^%ZOSF("OS")'["GT.M" D
"RTN","HLCSTCP2",17,0)
 . S IO(0)=$S(^%ZOSF("OS")["OpenM":$S($$OS^%ZOSV()["VMS":"_NLA0:",$$OS^%ZOSV()["UNIX":"/dev/null",1:$P),^%ZOSF("OS")["DSM":"_NLA0:",1:$P)
"RTN","HLCSTCP2",18,0)
 . O IO(0) U IO(0)
"RTN","HLCSTCP2",19,0)
 ;
"RTN","HLCSTCP2",20,0)
 ;persistent conection, open connection first, HLPORT=open port
"RTN","HLCSTCP2",21,0)
 I $G(HLTCPLNK)["Y" F  Q:$$OPEN  G EXIT:$$STOP^HLCSTCP H 1
"RTN","HLCSTCP2",22,0)
 F  D QUE Q:$$STOP^HLCSTCP  D:'HLMSG  Q:$G(HLCSOUT)
"RTN","HLCSTCP2",23,0)
 . ;no messages to send
"RTN","HLCSTCP2",24,0)
 . D MON^HLCSTCP("Idle") H 3
"RTN","HLCSTCP2",25,0)
 . ;persistent connection, no retention
"RTN","HLCSTCP2",26,0)
 . Q:$G(HLTCPLNK)["Y"
"RTN","HLCSTCP2",27,0)
 . D MON^HLCSTCP("Retention")
"RTN","HLCSTCP2",28,0)
 . N % I 0
"RTN","HLCSTCP2",29,0)
 . ;if message comes in or ask to stop
"RTN","HLCSTCP2",30,0)
 . F %=1:1:HLTCPRET H 1 I $$STOP^HLCSTCP!$O(^HLMA("AC","O",HLDP,0)) Q
"RTN","HLCSTCP2",31,0)
 . E  S HLCSOUT=2 Q
"RTN","HLCSTCP2",32,0)
 . Q:$$STOP^HLCSTCP
"RTN","HLCSTCP2",33,0)
 . D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",34,0)
 ;Close port
"RTN","HLCSTCP2",35,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",36,0)
EXIT Q
"RTN","HLCSTCP2",37,0)
 ;
"RTN","HLCSTCP2",38,0)
QUE ; -- Check "OUT" queue for processing IF there is a message do it
"RTN","HLCSTCP2",39,0)
 ; and then check the link if it open or not
"RTN","HLCSTCP2",40,0)
 N HL,HLN,HLARR,HLHDR,HLI,HLJ,HLMSA,HLRESP,HLRESLT,HLRETRM,HLTCP,HLTCPI,X,Z,HLREREAD
"RTN","HLCSTCP2",41,0)
 N HLTMBUF
"RTN","HLCSTCP2",42,0)
 D MON^HLCSTCP("CheckOut")
"RTN","HLCSTCP2",43,0)
 ;HLMSG=next msg, set at tag DONE
"RTN","HLCSTCP2",44,0)
 I 'HLMSG S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0 Q:'HLMSG
"RTN","HLCSTCP2",45,0)
 ;
"RTN","HLCSTCP2",46,0)
 S HLI=+$G(^HLMA(HLMSG,0)),HLJ=$O(^("MSH",0)),HLTCP=""
"RTN","HLCSTCP2",47,0)
 ;don't have message text or MSH, kill x-ref and decrement 'to send'
"RTN","HLCSTCP2",48,0)
 ;
"RTN","HLCSTCP2",49,0)
 ; patch HL*1.6*122: MPI-client/server
"RTN","HLCSTCP2",50,0)
 ; I 'HLI!'HLJ K ^HLMA("AC","O",HLDP,HLMSG) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",51,0)
 I 'HLI!'HLJ D  Q
"RTN","HLCSTCP2",52,0)
 . F  L +^HLMA("AC","O",HLDP,HLMSG):10 Q:$T  H 1
"RTN","HLCSTCP2",53,0)
 . K ^HLMA("AC","O",HLDP,HLMSG)
"RTN","HLCSTCP2",54,0)
 . L -^HLMA("AC","O",HLDP,HLMSG)
"RTN","HLCSTCP2",55,0)
 . D LLCNT^HLCSTCP(HLDP,3,1)
"RTN","HLCSTCP2",56,0)
 . S HLMSG=0
"RTN","HLCSTCP2",57,0)
 ;
"RTN","HLCSTCP2",58,0)
 ; patch HL*1.6*142 start
"RTN","HLCSTCP2",59,0)
 ; to prevent data contention of end-user from competing with the link
"RTN","HLCSTCP2",60,0)
 ; processes sending data to backup workstations (for BCBU application)
"RTN","HLCSTCP2",61,0)
 I ($P(^HLMA(HLMSG,0),4)="D"),'$P($G(^HL(772,HLI,"P")),"^",2) D
"RTN","HLCSTCP2",62,0)
 . N COUNT
"RTN","HLCSTCP2",63,0)
 . F COUNT=1:1:15 Q:$P($G(^HL(772,HLI,"P")),"^",2)  H COUNT
"RTN","HLCSTCP2",64,0)
 ; patch HL*1.6*142 end
"RTN","HLCSTCP2",65,0)
 ;
"RTN","HLCSTCP2",66,0)
 ;update msg status to 'being transmitted'; if cancelled decrement link and quit
"RTN","HLCSTCP2",67,0)
 I '$$CHKMSG(1.5) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",68,0)
 ;number of retransmissions for message
"RTN","HLCSTCP2",69,0)
 S HLRETRM=+$P(^HLMA(HLMSG,"P"),U,5)
"RTN","HLCSTCP2",70,0)
 ;retries exceeded, HLRETRA:action i=ignore, r=restart, s=shutdown
"RTN","HLCSTCP2",71,0)
 ;quit if restart or shutdown, link is going down
"RTN","HLCSTCP2",72,0)
 I HLRETRY>HLDRETR D  Q:"I"'[HLRETRA
"RTN","HLCSTCP2",73,0)
 . D MON^HLCSTCP("Error")
"RTN","HLCSTCP2",74,0)
 . ;only 1 alert per link up time, don't send if restart
"RTN","HLCSTCP2",75,0)
 . D:'HLRETMG&(HLRETRA'="R")
"RTN","HLCSTCP2",76,0)
 .. ;send alert
"RTN","HLCSTCP2",77,0)
 .. N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
"RTN","HLCSTCP2",78,0)
 .. ;get mailgroup from file 869.3
"RTN","HLCSTCP2",79,0)
 .. S HLRETMG=1,Z=$P($$PARAM^HLCS2,U,8) Q:Z=""
"RTN","HLCSTCP2",80,0)
 .. S XQA("G."_Z)="",XQAMSG=$$HTE^XLFDT($H,2)_" HL7 LL "_$P(^HLCS(870,HLDP,0),U)_" exceeded retries. LL will "_$S(HLRETRA="S":"shutdown.",HLRETRA="R":"restart.",1:"keep trying.")
"RTN","HLCSTCP2",81,0)
 .. D SETUP^XQALERT
"RTN","HLCSTCP2",82,0)
 . ;quit if action is ignore
"RTN","HLCSTCP2",83,0)
 . Q:"I"[HLRETRA
"RTN","HLCSTCP2",84,0)
 . ;this will shutdown this link
"RTN","HLCSTCP2",85,0)
 . S HLCSOUT=1
"RTN","HLCSTCP2",86,0)
 . ;action is shutdown, set shutdown flag so LM won't restart
"RTN","HLCSTCP2",87,0)
 . S:HLRETRA="S" $P(^HLCS(870,HLDP,0),U,15)=1
"RTN","HLCSTCP2",88,0)
 . D STATUS^HLTF0(HLMSG,4,103,"LLP Exceeded Retry Param")
"RTN","HLCSTCP2",89,0)
 I '$$OPEN Q
"RTN","HLCSTCP2",90,0)
 D MON^HLCSTCP("Send")
"RTN","HLCSTCP2",91,0)
 ; -- data passed in global array, success=1
"RTN","HLCSTCP2",92,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",93,0)
 ; time: starts to send this message
"RTN","HLCSTCP2",94,0)
 S $P(^HLMA(HLMSG,"S"),"^",2)=$$NOW^XLFDT
"RTN","HLCSTCP2",95,0)
 I $$WRITE(HLMSG)<0 Q
"RTN","HLCSTCP2",96,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",97,0)
 ; time: this message has been sent
"RTN","HLCSTCP2",98,0)
 S $P(^HLMA(HLMSG,"S"),"^",3)=$$NOW^XLFDT
"RTN","HLCSTCP2",99,0)
 S (HLTCP,HLTCPI)=HLMSG,HLRETRY=HLRETRY+1,HLRETRM=HLRETRM+1
"RTN","HLCSTCP2",100,0)
 ;update status to awaiting response, decrement link if cancelled
"RTN","HLCSTCP2",101,0)
 I '$$CHKMSG(1.7) D LLCNT^HLCSTCP(HLDP,3,1) S HLMSG=0 Q
"RTN","HLCSTCP2",102,0)
 ;set transmission count, get ACKTIMEOUT override
"RTN","HLCSTCP2",103,0)
 S $P(^HLMA(HLMSG,"P"),U,5)=HLRETRM I $P(^("P"),U,7) S HLN("ACKTIME")=+$P(^("P"),U,7)
"RTN","HLCSTCP2",104,0)
 ;get header of message just sent
"RTN","HLCSTCP2",105,0)
 K HLJ M HLJ=^HLMA(HLMSG,"MSH")
"RTN","HLCSTCP2",106,0)
 ;first component of sending app.
"RTN","HLCSTCP2",107,0)
 S HLN("ECH")=$$P^HLTPCK2(.HLJ,2),HLN("SAN")=$P($$P^HLTPCK2(.HLJ,3),$E(HLN("ECH")))
"RTN","HLCSTCP2",108,0)
 ;msg type, msg. id, commit ack, and app. ack parameter
"RTN","HLCSTCP2",109,0)
 S HLN("TYPE")=$$P^HLTPCK2(.HLJ,1),HLN("MID")=$$P^HLTPCK2(.HLJ,10),HLN("ACAT")=$$P^HLTPCK2(.HLJ,15),HLN("APAT")=$$P^HLTPCK2(.HLJ,16)
"RTN","HLCSTCP2",110,0)
 ;MSA segment, message is a response, can't have an a. ack.
"RTN","HLCSTCP2",111,0)
 S Z=$$MSA^HLTP3(+^HLMA(HLMSG,0)) I Z]"" S:HLN("ACAT")="" HLN("ACAT")="NE" S HLN("APAT")="NE"
"RTN","HLCSTCP2",112,0)
 ;for batch/file with commit ack, reset c. ack and a. ack variables
"RTN","HLCSTCP2",113,0)
 I "BHS,FHS"[HLN("TYPE") S Z=$E(HLJ(1,0),5),X=$$P^HLTPCK2(.HLJ,9),HLN("ACAT")=$P(X,Z,5),HLN("APAT")=$P(X,Z,6),HLN("MID")=$$P^HLTPCK2(.HLJ,11)
"RTN","HLCSTCP2",114,0)
 ;get event protocol
"RTN","HLCSTCP2",115,0)
 S HLN("EID")=+$P(^HLMA(HLMSG,0),U,8),X=$G(^ORD(101,HLN("EID"),770))
"RTN","HLCSTCP2",116,0)
 ;set link counter to msg sent
"RTN","HLCSTCP2",117,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",118,0)
 ;commit and app. ack is never, update status to complete and hang UNI-DIRECTIONAL WAIT
"RTN","HLCSTCP2",119,0)
 I HLN("ACAT")="NE",HLN("APAT")="NE" D  Q
"RTN","HLCSTCP2",120,0)
 .D DONE(3)
"RTN","HLCSTCP2",121,0)
 .;
"RTN","HLCSTCP2",122,0)
 .;
"RTN","HLCSTCP2",123,0)
 .H $G(HLDWAIT)
"RTN","HLCSTCP2",124,0)
 ;
"RTN","HLCSTCP2",125,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",126,0)
 D
"RTN","HLCSTCP2",127,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",128,0)
 . ;HL*1.6*87: Read acknowledgement.  
"RTN","HLCSTCP2",129,0)
 . ;Loop to re-read from buffer when receiving incorrect ack.
"RTN","HLCSTCP2",130,0)
 . F  D  Q:'+$G(HLREREAD)
"RTN","HLCSTCP2",131,0)
 .. S HLREREAD=1
"RTN","HLCSTCP2",132,0)
 .. ;override ack timeout
"RTN","HLCSTCP2",133,0)
 .. I $G(HLN("ACKTIME")) N HLDBACK S HLDBACK=HLN("ACKTIME")
"RTN","HLCSTCP2",134,0)
 .. ;check for response, quit if no-response, msg will be resent
"RTN","HLCSTCP2",135,0)
 .. ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",136,0)
 .. S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",137,0)
 .. ;if no response, decrement counter and quit
"RTN","HLCSTCP2",138,0)
 .. I 'HLRESP D  Q
"RTN","HLCSTCP2",139,0)
 ...D LLCNT^HLCSTCP(HLDP,4,1)
"RTN","HLCSTCP2",140,0)
 ...S HLREREAD="0^No Response"
"RTN","HLCSTCP2",141,0)
 ...;check if the port needs to be closed and re-opened before the next re-transmission attempt
"RTN","HLCSTCP2",142,0)
 ...I $G(HLDRETR("CLOSE")) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",143,0)
 .. ;X 0=re-read msg, 1=commit ack, 3=app ack success, 4=error
"RTN","HLCSTCP2",144,0)
 .. S X=$$RSP^HLTP31(HLRESP,.HLN)
"RTN","HLCSTCP2",145,0)
 .. ;X=0, re-read msg. Incorrect ack (bad MSH,MSA,msg id,or sending app)
"RTN","HLCSTCP2",146,0)
 .. Q:'X 
"RTN","HLCSTCP2",147,0)
 .. ;commit ack - done
"RTN","HLCSTCP2",148,0)
 .. ; patch HL*1.6*142
"RTN","HLCSTCP2",149,0)
 .. ; time: this message has received commit ACK
"RTN","HLCSTCP2",150,0)
 .. S $P(^HLMA(HLMSG,"S"),"^",4)=$$NOW^XLFDT
"RTN","HLCSTCP2",151,0)
 .. I X=1 D  S HLREREAD="0^Commit Ack" Q
"RTN","HLCSTCP2",152,0)
 ... ;don't need app. ack, set status to complete
"RTN","HLCSTCP2",153,0)
 ... I "NE"[HLN("APAT") D  Q
"RTN","HLCSTCP2",154,0)
 ....D DONE(3)
"RTN","HLCSTCP2",155,0)
 ....;
"RTN","HLCSTCP2",156,0)
 ... ;response is deferred, set status to awaiting ack
"RTN","HLCSTCP2",157,0)
 ... D DONE(2)
"RTN","HLCSTCP2",158,0)
 ...;
"RTN","HLCSTCP2",159,0)
 .. ;Error, HLRESLT=error number^error message from HLTP3
"RTN","HLCSTCP2",160,0)
 .. I X=4 D  Q
"RTN","HLCSTCP2",161,0)
 ... D DONE(4,+$G(HLRESLT),$P($G(HLRESLT),U,2))
"RTN","HLCSTCP2",162,0)
 ...;
"RTN","HLCSTCP2",163,0)
 ... S HLREREAD="0^Error"
"RTN","HLCSTCP2",164,0)
 .. ;app ack was successful
"RTN","HLCSTCP2",165,0)
 .. D DONE(3) S HLREREAD="0^App Ack"
"RTN","HLCSTCP2",166,0)
 ..;
"RTN","HLCSTCP2",167,0)
 Q
"RTN","HLCSTCP2",168,0)
 ;
"RTN","HLCSTCP2",169,0)
DCSEND ;direct connect
"RTN","HLCSTCP2",170,0)
 ; Set up error trap
"RTN","HLCSTCP2",171,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",172,0)
 ; patch HL*1.6*122
"RTN","HLCSTCP2",173,0)
 N HLTMBUF
"RTN","HLCSTCP2",174,0)
 ;override ack timeout
"RTN","HLCSTCP2",175,0)
 I $G(HLP("ACKTIME")) N HLDBACK S HLDBACK=HLP("ACKTIME")
"RTN","HLCSTCP2",176,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",177,0)
 ; time: starts to send this message
"RTN","HLCSTCP2",178,0)
 S $P(^HLMA(HLMSG,"S"),"^",2)=$$NOW^XLFDT
"RTN","HLCSTCP2",179,0)
 I $$WRITE(HLMSG)<0 D:$G(HLERROR)]""  Q  ;HL*1.6*77
"RTN","HLCSTCP2",180,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,"^"),$P(HLERROR,"^",2),1) ;HL*1.6*77
"RTN","HLCSTCP2",181,0)
 .  D LLCNT^HLCSTCP(HLDP,3,1)
"RTN","HLCSTCP2",182,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",183,0)
 ; time: this message has been sent
"RTN","HLCSTCP2",184,0)
 S $P(^HLMA(HLMSG,"S"),"^",3)=$$NOW^XLFDT
"RTN","HLCSTCP2",185,0)
 D LLCNT^HLCSTCP(HLDP,4)
"RTN","HLCSTCP2",186,0)
 ;do structure is to stack error
"RTN","HLCSTCP2",187,0)
 D
"RTN","HLCSTCP2",188,0)
 . N $ETRAP,$ESTACK S $ETRAP="D RDERR^HLCSTCP2"
"RTN","HLCSTCP2",189,0)
 . ;HLRESP=ien 773^ien 772 for response message
"RTN","HLCSTCP2",190,0)
 . S HLRESP=$$READ^HLCSTCP1()
"RTN","HLCSTCP2",191,0)
 ;
"RTN","HLCSTCP2",192,0)
 ; patch HL*1.6*142
"RTN","HLCSTCP2",193,0)
 ; time: this message has received app ACK
"RTN","HLCSTCP2",194,0)
 S $P(^HLMA(HLMSG,"S"),"^",4)=$$NOW^XLFDT
"RTN","HLCSTCP2",195,0)
 D DONE(3):$G(HLRESP),DONE(4,108,$S($G(HLERROR)]"":$P(HLERROR,"^",2),1:"No response")):'$G(HLRESP)
"RTN","HLCSTCP2",196,0)
 I $G(HLERROR)']"" D
"RTN","HLCSTCP2",197,0)
 .D MON^HLCSTCP("Idle")
"RTN","HLCSTCP2",198,0)
 .I '$G(HLRESP) S HLERROR="108^No response"
"RTN","HLCSTCP2",199,0)
 ;Close port
"RTN","HLCSTCP2",200,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",201,0)
 Q
"RTN","HLCSTCP2",202,0)
 ;
"RTN","HLCSTCP2",203,0)
DONE(ST,ERR,ERRMSG) ;set status to complete
"RTN","HLCSTCP2",204,0)
 ;ST=status, ERR=error ien, ERRMSG=error msg
"RTN","HLCSTCP2",205,0)
 D STATUS^HLTF0(HLMSG,ST,$G(ERR),$G(ERRMSG),1)
"RTN","HLCSTCP2",206,0)
 ;
"RTN","HLCSTCP2",207,0)
 D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",208,0)
 ;
"RTN","HLCSTCP2",209,0)
 ;check for more msg.
"RTN","HLCSTCP2",210,0)
 I $G(HLPRIO)'="I" S HLMSG=+$O(^HLMA("AC","O",HLDP,0)),HLRETRY=0
"RTN","HLCSTCP2",211,0)
 Q
"RTN","HLCSTCP2",212,0)
 ;
"RTN","HLCSTCP2",213,0)
CHKMSG(HLI) ;check status of message and update if not cancelled
"RTN","HLCSTCP2",214,0)
 ;input: HLI=new status, HLMSG=ien of msg in 773
"RTN","HLCSTCP2",215,0)
 ;returns 1=msg was updated, 0=msg has been canceled
"RTN","HLCSTCP2",216,0)
 N X
"RTN","HLCSTCP2",217,0)
 ;
"RTN","HLCSTCP2",218,0)
 ; New HL*1.6*77 code starting here...
"RTN","HLCSTCP2",219,0)
 I '$D(^HLMA(HLMSG,"P")) D  Q 0
"RTN","HLCSTCP2",220,0)
 .  S HLERROR="2^Missing status field"
"RTN","HLCSTCP2",221,0)
 .  D STATUS^HLTF0(HLMSG,4,$P(HLERROR,U),$P(HLERROR,U,2),1)
"RTN","HLCSTCP2",222,0)
 .;
"RTN","HLCSTCP2",223,0)
 . D DEQUE^HLCSREP(HLDP,"O",HLMSG)
"RTN","HLCSTCP2",224,0)
 ;
"RTN","HLCSTCP2",225,0)
 ; End of HL*1.6*77
"RTN","HLCSTCP2",226,0)
 ;
"RTN","HLCSTCP2",227,0)
 ;get status, quit if msg was cancelled
"RTN","HLCSTCP2",228,0)
 ;
"RTN","HLCSTCP2",229,0)
 ; patch HL*1.6*145
"RTN","HLCSTCP2",230,0)
 ; S X=+^HLMA(HLMSG,"P") Q:X=3 0
"RTN","HLCSTCP2",231,0)
 S X=+^HLMA(HLMSG,"P")
"RTN","HLCSTCP2",232,0)
 ;
"RTN","HLCSTCP2",233,0)
 ;update status if it is different
"RTN","HLCSTCP2",234,0)
 I $G(HLI),HLI'=X D STATUS^HLTF0(HLMSG,HLI)
"RTN","HLCSTCP2",235,0)
 ;
"RTN","HLCSTCP2",236,0)
 Q 1
"RTN","HLCSTCP2",237,0)
 ;
"RTN","HLCSTCP2",238,0)
WRITE(HLDA) ; write message in HL7 format
"RTN","HLCSTCP2",239,0)
 ;  HLDA       - ien of message in 773
"RTN","HLCSTCP2",240,0)
 ;             - start block $C(11)
"RTN","HLCSTCP2",241,0)
 ;             - end block $C(28)
"RTN","HLCSTCP2",242,0)
 ;             - record separator $C(13)
"RTN","HLCSTCP2",243,0)
 ;Output(s): 1 - Successful
"RTN","HLCSTCP2",244,0)
 ;           -1 - Unsuccessful
"RTN","HLCSTCP2",245,0)
 ;
"RTN","HLCSTCP2",246,0)
 N HLDA2,HLAR,HLI,LINENO,X,CRCOUNT
"RTN","HLCSTCP2",247,0)
 S CRCOUNT=0
"RTN","HLCSTCP2",248,0)
 ;set error trap, used when called from HLTP3
"RTN","HLCSTCP2",249,0)
 ;
"RTN","HLCSTCP2",250,0)
 ; New HL*1.6*77 code starts here...
"RTN","HLCSTCP2",251,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2"
"RTN","HLCSTCP2",252,0)
 I $G(^HLMA(HLDA,0))'>0 D  Q -1
"RTN","HLCSTCP2",253,0)
 .  S HLERROR="2^Message Text pointer missing"
"RTN","HLCSTCP2",254,0)
 S HLDA2=+$G(^HLMA(HLDA,0))
"RTN","HLCSTCP2",255,0)
 ; End of HL*1.6*77 modifications...
"RTN","HLCSTCP2",256,0)
 ;
"RTN","HLCSTCP2",257,0)
 Q:'$G(^HLMA(HLDA,0)) -1 ;HL*1.6*77
"RTN","HLCSTCP2",258,0)
 ; header is in ^HLMA(, message is in ^HL(772,
"RTN","HLCSTCP2",259,0)
 S LINENO=1,HLI=0,HLAR="^HLMA(HLDA,""MSH"")"
"RTN","HLCSTCP2",260,0)
 U IO
"RTN","HLCSTCP2",261,0)
 D  W $C(13) S HLAR="^HL(772,HLDA2,""IN"")",HLI=0 D
"RTN","HLCSTCP2",262,0)
 . F  S HLI=$O(@HLAR@(HLI)) Q:'HLI  S X=$G(^(HLI,0)) D
"RTN","HLCSTCP2",263,0)
 .. ;first line, need start block char.
"RTN","HLCSTCP2",264,0)
 .. S:LINENO=1 X=$C(11)_X
"RTN","HLCSTCP2",265,0)
 .. ; HL*1.6*122
"RTN","HLCSTCP2",266,0)
 .. ; I X]"" W X,!
"RTN","HLCSTCP2",267,0)
 .. N LENGTH
"RTN","HLCSTCP2",268,0)
 .. S LENGTH=$L(X)
"RTN","HLCSTCP2",269,0)
 .. ; patch HL*1.6*142 start
"RTN","HLCSTCP2",270,0)
 .. ; buffer should be limited to 510
"RTN","HLCSTCP2",271,0)
 .. ; I LENGTH>512 D
"RTN","HLCSTCP2",272,0)
 .. I LENGTH>510 D
"RTN","HLCSTCP2",273,0)
 ... N X1
"RTN","HLCSTCP2",274,0)
 ... ; F  Q:LENGTH<512  D
"RTN","HLCSTCP2",275,0)
 ... F  Q:LENGTH<511  D
"RTN","HLCSTCP2",276,0)
 .... ; S X1=$E(X,1,512),X=$E(X,513,999999)
"RTN","HLCSTCP2",277,0)
 .... S X1=$E(X,1,510),X=$E(X,511,999999)
"RTN","HLCSTCP2",278,0)
 .... S LENGTH=$L(X)
"RTN","HLCSTCP2",279,0)
 .... ; patch HL*1.6*140
"RTN","HLCSTCP2",280,0)
 .... ; W X1,@IOF
"RTN","HLCSTCP2",281,0)
 .... W X1,@HLTCPLNK("IOF")
"RTN","HLCSTCP2",282,0)
 .. ; patch HL*1.6*142 end
"RTN","HLCSTCP2",283,0)
 .. ;
"RTN","HLCSTCP2",284,0)
 .. ; @HLTCPLNK("IOF") (! or #) for flush character
"RTN","HLCSTCP2",285,0)
 .. I X]"" W X,@HLTCPLNK("IOF") S CRCOUNT=0
"RTN","HLCSTCP2",286,0)
 .. ;send CR
"RTN","HLCSTCP2",287,0)
 .. I X="" W $C(13) S CRCOUNT=CRCOUNT+1
"RTN","HLCSTCP2",288,0)
 .. ; prevent from maxstring error
"RTN","HLCSTCP2",289,0)
 .. I CRCOUNT>200 W @HLTCPLNK("IOF") S CRCOUNT=0
"RTN","HLCSTCP2",290,0)
 .. S LINENO=LINENO+1
"RTN","HLCSTCP2",291,0)
 ; Sends end block for this message
"RTN","HLCSTCP2",292,0)
 S X=$C(28)_$C(13)
"RTN","HLCSTCP2",293,0)
 ; U IO W X,!
"RTN","HLCSTCP2",294,0)
 U IO W X,@HLTCPLNK("IOF")
"RTN","HLCSTCP2",295,0)
 ;switch to null device
"RTN","HLCSTCP2",296,0)
 I $G(IO(0))'="",$G(IO(0))'=IO U IO(0)
"RTN","HLCSTCP2",297,0)
 Q 1
"RTN","HLCSTCP2",298,0)
 ;
"RTN","HLCSTCP2",299,0)
OPEN() ; -- Open TCP/IP device (Client)
"RTN","HLCSTCP2",300,0)
 ;HLPORT=port, defined only if port is open
"RTN","HLCSTCP2",301,0)
 ;HLPORTA=number of attempted opens
"RTN","HLCSTCP2",302,0)
 I $D(HLPORT) S IO=HLPORT D  Q 1
"RTN","HLCSTCP2",303,0)
 . U IO
"RTN","HLCSTCP2",304,0)
 . I HLOS["OpenM" X "U IO:(::""-M"")" ;use packet mode on Cache'
"RTN","HLCSTCP2",305,0)
 N HLDOM,HLI,HLIP,HLPORTA
"RTN","HLCSTCP2",306,0)
 G OPENA^HLCSTCP3
"RTN","HLCSTCP2",307,0)
 ;
"RTN","HLCSTCP2",308,0)
RDERR D RDERR^HLCSTCP4 Q
"RTN","HLCSTCP2",309,0)
ERROR D ERROR^HLCSTCP4 Q
"RTN","HLCSTCP2",310,0)
 ;
"RTN","HLCSTCP2",311,0)
CC(X) ;cleanup and close
"RTN","HLCSTCP2",312,0)
 D MON^HLCSTCP(X)
"RTN","HLCSTCP2",313,0)
 I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP2",314,0)
 ; patch HL*1.6*140
"RTN","HLCSTCP2",315,0)
 ; H 2
"RTN","HLCSTCP2",316,0)
 H 1
"RTN","HLCSTCP2",317,0)
 Q
"RTN","HLCSTCP3")
0^9^B14207498^B12715740
"RTN","HLCSTCP3",1,0)
HLCSTCP3 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;12/01/2010
"RTN","HLCSTCP3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**76,77,133,122,153**;OCT 13, 1995;Build 11
"RTN","HLCSTCP3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLCSTCP3",4,0)
 ;
"RTN","HLCSTCP3",5,0)
OPENA ;
"RTN","HLCSTCP3",6,0)
 ; called from $$OPEN^HLCSTCP2 and this sub-routine OPENA
"RTN","HLCSTCP3",7,0)
 ;
"RTN","HLCSTCP3",8,0)
 ; **P153 START CJM
"RTN","HLCSTCP3",9,0)
 ; Reset the TCP Address incase DNS changed it without a successful connection
"RTN","HLCSTCP3",10,0)
 K HLDOM
"RTN","HLCSTCP3",11,0)
 S HLTCPADD=$P(^HLCS(870,HLDP,400),U)
"RTN","HLCSTCP3",12,0)
 ;
"RTN","HLCSTCP3",13,0)
RETRY ;
"RTN","HLCSTCP3",14,0)
 ; **P153 END CJM
"RTN","HLCSTCP3",15,0)
 ;
"RTN","HLCSTCP3",16,0)
 I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S HLPORTA=+$P(^("P"),U,6)
"RTN","HLCSTCP3",17,0)
 S POP=1
"RTN","HLCSTCP3",18,0)
 ;
"RTN","HLCSTCP3",19,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP3",20,0)
 ; variable HLDRETR=re-transmit attemps (#870,200.02)
"RTN","HLCSTCP3",21,0)
 ; variable HLTCPLNK("TIMEOUT")=timeout for 3rd parameter of CALL^%ZISTCP()
"RTN","HLCSTCP3",22,0)
 ; defined in HLCSTCP routine
"RTN","HLCSTCP3",23,0)
 ;
"RTN","HLCSTCP3",24,0)
 I '$G(HLDRETR("COUNT")) S HLDRETR("COUNT")=1
"RTN","HLCSTCP3",25,0)
 I '$G(HLTCPLNK("TIMEOUT")) S HLTCPLNK("TIMEOUT")=5
"RTN","HLCSTCP3",26,0)
 S HLDRETR("COUNT-2")=HLDRETR("COUNT")+HLDRETR
"RTN","HLCSTCP3",27,0)
 ; patch 133
"RTN","HLCSTCP3",28,0)
 ; I $G(HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",29,0)
 ; .S HLI=1
"RTN","HLCSTCP3",30,0)
 ; .D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLDIRECT("OPEN TIMEOUT"))
"RTN","HLCSTCP3",31,0)
 ; E  D
"RTN","HLCSTCP3",32,0)
 ; .F HLI=1:1:HLDRETR D CALL^%ZISTCP(HLTCPADD,HLTCPORT) Q:'POP
"RTN","HLCSTCP3",33,0)
 I $G(HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",34,0)
 . D MON^HLCSTCP("Open")
"RTN","HLCSTCP3",35,0)
 . D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLDIRECT("OPEN TIMEOUT"))
"RTN","HLCSTCP3",36,0)
 . ; give site one more chance to override the application setup
"RTN","HLCSTCP3",37,0)
 . I $G(POP),(HLTCPLNK("TIMEOUT")>HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",38,0)
 .. D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLTCPLNK("TIMEOUT"))
"RTN","HLCSTCP3",39,0)
 E  D
"RTN","HLCSTCP3",40,0)
 . N COUNT
"RTN","HLCSTCP3",41,0)
 . ; try to connect HLDRETR times
"RTN","HLCSTCP3",42,0)
 . F HLDRETR("COUNT")=HLDRETR("COUNT"):1:HLDRETR("COUNT-2") D  Q:('POP)!($$STOP^HLCSTCP)
"RTN","HLCSTCP3",43,0)
 .. D MON^HLCSTCP("Open")
"RTN","HLCSTCP3",44,0)
 .. ; D CALL^%ZISTCP(HLTCPADD,HLTCPORT)
"RTN","HLCSTCP3",45,0)
 .. D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLTCPLNK("TIMEOUT"))
"RTN","HLCSTCP3",46,0)
 .. ;open error
"RTN","HLCSTCP3",47,0)
 .. I POP D
"RTN","HLCSTCP3",48,0)
 ... D CC^HLCSTCP2("Openfail")
"RTN","HLCSTCP3",49,0)
 ... H $S(HLDRETR("COUNT")=1:0,HLDRETR("COUNT")<10:1,1:8)
"RTN","HLCSTCP3",50,0)
 ... I '$D(^XTMP("HL7-Openfail",$J)) D
"RTN","HLCSTCP3",51,0)
 .... S ^XTMP("HL7-Openfail",0)=$$FMADD^XLFDT($$NOW^XLFDT,3)_"^"_$$NOW^XLFDT
"RTN","HLCSTCP3",52,0)
 .... S ^XTMP("HL7-Openfail",$J,"COUNT","FIRST")=HLDRETR("COUNT")_"^"_$$NOW^XLFDT
"RTN","HLCSTCP3",53,0)
 ... S COUNT=$P($G(^XTMP("HL7-Openfail",$J,"COUNT","LAST")),"^")+1
"RTN","HLCSTCP3",54,0)
 ... S ^XTMP("HL7-Openfail",$J,"COUNT","LAST")=COUNT_"^"_$$NOW^XLFDT
"RTN","HLCSTCP3",55,0)
 ;
"RTN","HLCSTCP3",56,0)
 ;set # of opens back in msg
"RTN","HLCSTCP3",57,0)
 ; I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S $P(^("P"),U,6)=HLPORTA+HLI
"RTN","HLCSTCP3",58,0)
 I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S $P(^("P"),U,6)=HLDRETR("COUNT")
"RTN","HLCSTCP3",59,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP3",60,0)
 ;
"RTN","HLCSTCP3",61,0)
 ;device open
"RTN","HLCSTCP3",62,0)
 I 'POP S HLPORT=IO D  Q $S($G(HLERROR)]"":0,1:1)
"RTN","HLCSTCP3",63,0)
 . N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2" ;HL*1.6*77
"RTN","HLCSTCP3",64,0)
 . ;if address came from DNS, set back into LL
"RTN","HLCSTCP3",65,0)
 . I $D(HLIP) S $P(^HLCS(870,HLDP,400),U)=HLTCPADD
"RTN","HLCSTCP3",66,0)
 . ; write and read to check if still open
"RTN","HLCSTCP3",67,0)
 . Q:HLOS'["OpenM"  X "U IO:(::""-M"")" ; must be Cache/NT + use packet mode
"RTN","HLCSTCP3",68,0)
 . Q:$P(^HLCS(870,HLDP,400),U,7)'="Y"  ; must want to SAY HELO
"RTN","HLCSTCP3",69,0)
 . U IO W "HELO "_$$KSP^XUPARAM("WHERE"),! R X:1
"RTN","HLCSTCP3",70,0)
 ;openfail-try DNS lookup
"RTN","HLCSTCP3",71,0)
 ;
"RTN","HLCSTCP3",72,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP3",73,0)
 ;I '$D(HLDOM) S HLDOM=+$P(^HLCS(870,HLDP,0),U,7),HLDOM=$P($G(^DIC(4.2,HLDOM,0)),U) D:HLDOM]"" DNS
"RTN","HLCSTCP3",74,0)
 I '$D(HLDOM) D
"RTN","HLCSTCP3",75,0)
 . S HLDOM=+$P(^HLCS(870,HLDP,0),U,7),HLDOM=$P($G(^DIC(4.2,HLDOM,0)),U)
"RTN","HLCSTCP3",76,0)
 . S HLDOM("DNS")=$P($G(^HLCS(870,+$G(HLDP),0)),"^",8)
"RTN","HLCSTCP3",77,0)
 . D:HLDOM]""!($L(HLDOM("DNS"),".")>2) DNS
"RTN","HLCSTCP3",78,0)
 ;
"RTN","HLCSTCP3",79,0)
 Q:$$STOP^HLCSTCP 0
"RTN","HLCSTCP3",80,0)
 ;HLIP=ip add. from DNS call, get first one and try open again
"RTN","HLCSTCP3",81,0)
 ;
"RTN","HLCSTCP3",82,0)
 ; **P153 START CJM
"RTN","HLCSTCP3",83,0)
 ;I $D(HLIP) S HLTCPADD=$P(HLIP,","),HLIP=$P(HLIP,",",2,99) G:HLTCPADD OPENA
"RTN","HLCSTCP3",84,0)
 I $D(HLIP) S HLTCPADD=$P(HLIP,","),HLIP=$P(HLIP,",",2,99) G:HLTCPADD RETRY
"RTN","HLCSTCP3",85,0)
 ; **P153 END CJM
"RTN","HLCSTCP3",86,0)
 ;
"RTN","HLCSTCP3",87,0)
 ; open error
"RTN","HLCSTCP3",88,0)
 ;cleanup and close
"RTN","HLCSTCP3",89,0)
 ; patch 133
"RTN","HLCSTCP3",90,0)
 I $G(HLDIRECT("OPEN TIMEOUT")) D
"RTN","HLCSTCP3",91,0)
 . D MON^HLCSTCP("Openfail")
"RTN","HLCSTCP3",92,0)
 . I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
"RTN","HLCSTCP3",93,0)
 E  D
"RTN","HLCSTCP3",94,0)
 . D CC^HLCSTCP2("Openfail")
"RTN","HLCSTCP3",95,0)
 Q 0
"RTN","HLCSTCP3",96,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP3",97,0)
 ;
"RTN","HLCSTCP3",98,0)
 ;
"RTN","HLCSTCP3",99,0)
 ;following code was removed, site's complained of to many alerts
"RTN","HLCSTCP3",100,0)
 ;couldn't open, send 1 alert
"RTN","HLCSTCP3",101,0)
 ;I '$G(HLPORTA) D
"RTN","HLCSTCP3",102,0)
 ;. ;send alert
"RTN","HLCSTCP3",103,0)
 ;. N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
"RTN","HLCSTCP3",104,0)
 ;. ;get mailgroup from file 869.3
"RTN","HLCSTCP3",105,0)
 ;. S Z=$P($$PARAM^HLCS2,U,8),HLPORTA="" Q:Z=""
"RTN","HLCSTCP3",106,0)
 ;. S XQA("G."_Z)="",XQAMSG=$$HTE^XLFDT($H,2)_" Logical Link "_$P(^HLCS(870,HLDP,0),U)_" exceeded Open Retries."
"RTN","HLCSTCP3",107,0)
 ;. D SETUP^XQALERT
"RTN","HLCSTCP3",108,0)
 ;open error
"RTN","HLCSTCP3",109,0)
 ;D CC("Openfail") H 3
"RTN","HLCSTCP3",110,0)
 ;Q 0
"RTN","HLCSTCP3",111,0)
 ;
"RTN","HLCSTCP3",112,0)
 ;
"RTN","HLCSTCP3",113,0)
DNS ;VA domains must have "med" inserted.
"RTN","HLCSTCP3",114,0)
 ;All domains must use port 5000 and are prepended with "HL7"
"RTN","HLCSTCP3",115,0)
 ;non-VA DNS lookups will succeed if site uses port 5000 and 
"RTN","HLCSTCP3",116,0)
 ;configure their local DNS with "HL7.yourdomain.com" and entries
"RTN","HLCSTCP3",117,0)
 ;are created in the logical link file and domain file.
"RTN","HLCSTCP3",118,0)
 D MON^HLCSTCP("DNS Lkup")
"RTN","HLCSTCP3",119,0)
 I HLDOM["VA.GOV"&(HLDOM'[".MED.") S HLDOM=$P(HLDOM,".VA.GOV")_".MED.VA.GOV"
"RTN","HLCSTCP3",120,0)
 I HLTCPORT=5000 S HLDOM="HL7."_HLDOM
"RTN","HLCSTCP3",121,0)
 I HLTCPORT=5500 S HLDOM="MPI."_HLDOM
"RTN","HLCSTCP3",122,0)
 ;
"RTN","HLCSTCP3",123,0)
 ; patch HL*1.6*122 start
"RTN","HLCSTCP3",124,0)
 I $L($G(HLDOM("DNS")),".")>2 D
"RTN","HLCSTCP3",125,0)
 . S HLDOM=HLDOM("DNS")
"RTN","HLCSTCP3",126,0)
 ; patch HL*1.6*122 end
"RTN","HLCSTCP3",127,0)
 ;
"RTN","HLCSTCP3",128,0)
 S HLIP=$$ADDRESS^XLFNSLK(HLDOM)
"RTN","HLCSTCP3",129,0)
 K:HLIP="" HLIP
"RTN","HLCSTCP3",130,0)
 Q
"RTN","HLCSTCP3",131,0)
 ;
"RTN","HLEVAPI3")
0^5^B59002159^B53454303
"RTN","HLEVAPI3",1,0)
HLEVAPI3 ;O-OIFO/LJA/PIJ - Event Monitor APIs ;12/08/2010
"RTN","HLEVAPI3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**109,153**;Oct 13, 1995;Build 11
"RTN","HLEVAPI3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLEVAPI3",4,0)
EVENTONE(HLEVIENM,HLEVNM,HLEVIENE) ; Master job check of an event...
"RTN","HLEVAPI3",5,0)
 ; ZTSKMST -- req
"RTN","HLEVAPI3",6,0)
 N CONT,CURR,CURRNOW,IEN,LAPSEMIN,LASTRUN,MAILGRP,MCHECK,MSTART,NO,NODE
"RTN","HLEVAPI3",7,0)
 N NODE0,NODE40,PAR1,PAR2,PAR3,PAR4,PAR5,PAR6,PAR7,PAR8,RUNNOW
"RTN","HLEVAPI3",8,0)
 N START,STAT,ZTDESC,ZTDTH,ZTIO,ZTRTN
"RTN","HLEVAPI3",9,0)
 ;
"RTN","HLEVAPI3",10,0)
 S NODE0=$G(^HLEV(776.1,+$G(HLEVIENE),0))
"RTN","HLEVAPI3",11,0)
 I NODE0']"" D RECEVM(HLEVIENM,HLEVIENE,"X^NO-0-NODE") QUIT  ;->
"RTN","HLEVAPI3",12,0)
 S STAT=$P(NODE0,U,2) I STAT'="A" D RECEVM(HLEVIENM,HLEVIENE,"I") QUIT  ;->
"RTN","HLEVAPI3",13,0)
 ; Requeue minutes for monitor...
"RTN","HLEVAPI3",14,0)
 S LAPSE=$P(NODE0,U,4) I LAPSE'?1.N D RECEVM(HLEVIENM,HLEVIENE,"X^INVALID-LAPSE") QUIT  ;->
"RTN","HLEVAPI3",15,0)
 ;
"RTN","HLEVAPI3",16,0)
 ; Required M TAG^RTN for monitor...
"RTN","HLEVAPI3",17,0)
 S MSTART=$TR($P(NODE0,U,6),"~",U) I '$$OKMCODE^HLEVAPI0(MSTART) D  QUIT  ;->
"RTN","HLEVAPI3",18,0)
 .  D RECEVM(HLEVIENM,HLEVIENE,"X^INVALID-M ["_$TR(MSTART,U,"~")_"]")
"RTN","HLEVAPI3",19,0)
 ;
"RTN","HLEVAPI3",20,0)
 ; Optional M $$EXTFUNCTION^RTN for determining whether new job should start
"RTN","HLEVAPI3",21,0)
 S MCHECK=$TR($P(NODE0,U,7),"~",U)
"RTN","HLEVAPI3",22,0)
 ;
"RTN","HLEVAPI3",23,0)
 ; If M check for start code exists, but is not valid M code, quit...
"RTN","HLEVAPI3",24,0)
 I MCHECK]"",'$$OKMCODE^HLEVAPI0($P(MCHECK,"$$",2,99)) D  QUIT  ;->
"RTN","HLEVAPI3",25,0)
 .  D RECEVM(HLEVIENM,HLEVIENE,"X-INVALID-M-CHK ["_$TR(MCHECK,U,"~")_"]")
"RTN","HLEVAPI3",26,0)
 ;
"RTN","HLEVAPI3",27,0)
 ; When last run (started)?  Return NULL if not completed...
"RTN","HLEVAPI3",28,0)
 S IEN=$O(^HLEV(776,"M",+HLEVIENE,":"),-1)
"RTN","HLEVAPI3",29,0)
 S (NODE,LASTRUN(1))=$G(^HLEV(776,+IEN,0))
"RTN","HLEVAPI3",30,0)
 S LASTRUN=$P(NODE,U),LASTRUN=$S(LASTRUN?7N1"."1.N:LASTRUN,1:"")
"RTN","HLEVAPI3",31,0)
 S X=$P(NODE,U,2) I X?7N1"."1.N S LASTRUN=X
"RTN","HLEVAPI3",32,0)
 ;
"RTN","HLEVAPI3",33,0)
 ; Set start new job default to YES...
"RTN","HLEVAPI3",34,0)
 S CONT=1
"RTN","HLEVAPI3",35,0)
 ;
"RTN","HLEVAPI3",36,0)
 ; If M start check code doesn't exist, check usual fields...
"RTN","HLEVAPI3",37,0)
 I MCHECK']"" D  QUIT:'CONT  ;->
"RTN","HLEVAPI3",38,0)
 .
"RTN","HLEVAPI3",39,0)
 .  ;Start new monitor if last job running and timestamp is current,
"RTN","HLEVAPI3",40,0)
 .  ;or monitor never run...
"RTN","HLEVAPI3",41,0)
 .
"RTN","HLEVAPI3",42,0)
 .  ; Never run, so start new monitor...
"RTN","HLEVAPI3",43,0)
 .  QUIT:LASTRUN']""
"RTN","HLEVAPI3",44,0)
 .
"RTN","HLEVAPI3",45,0)
 .  ; Monitor running now, and is current, so don't do anything...
"RTN","HLEVAPI3",46,0)
 .  S CURRNOW=$$CURR^HLEVAPI1(+IEN) I CURRNOW D  QUIT  ;->
"RTN","HLEVAPI3",47,0)
 .  .  I CURRNOW S CONT=0
"RTN","HLEVAPI3",48,0)
 .  .  D RECEVM(HLEVIENM,HLEVIENE,"R") ; Monitor running already...
"RTN","HLEVAPI3",49,0)
 .
"RTN","HLEVAPI3",50,0)
 .  ; Monitor run, and if time to run new monitor, quit...
"RTN","HLEVAPI3",51,0)
 .  S RUNNOW=$$RUNEV^HLEVAPI0(LASTRUN,LAPSE) QUIT:RUNNOW  ;->
"RTN","HLEVAPI3",52,0)
 .
"RTN","HLEVAPI3",53,0)
 .  S CONT=0 ; Set "no new monitor job needed" variable...
"RTN","HLEVAPI3",54,0)
 .  D RECEVM(HLEVIENM,HLEVIENE,"E") QUIT  ;-> Too early...
"RTN","HLEVAPI3",55,0)
 ;
"RTN","HLEVAPI3",56,0)
 I MCHECK]"" D  QUIT:'CONT  ;->
"RTN","HLEVAPI3",57,0)
 .  N HLEVRUN
"RTN","HLEVAPI3",58,0)
 .  D RUNS(HLEVIENE,.HLEVRUN) ; Define recent monitor runs for API call...
"RTN","HLEVAPI3",59,0)
 .  S CONT="S CONT="_MCHECK X CONT
"RTN","HLEVAPI3",60,0)
 .  S CONT=$S(CONT=1:1,1:0) QUIT:CONT  ;->
"RTN","HLEVAPI3",61,0)
 .  D RECEVM(HLEVIENM,HLEVIENE,"M") ; Package API check failed...
"RTN","HLEVAPI3",62,0)
 ;
"RTN","HLEVAPI3",63,0)
 S HLEVIENJ=$$NEWEVENT^HLEVAPI(HLEVIENE) I HLEVIENJ'>0 D  QUIT  ;->
"RTN","HLEVAPI3",64,0)
 .  KILL HLPAR1D,HLPAR2D,HLPAR3D,HLPAR4D,HLPAR5D,HLPAR6D,HLPAR7D,HLPAR8D
"RTN","HLEVAPI3",65,0)
 ;
"RTN","HLEVAPI3",66,0)
 ; Queue a new job...
"RTN","HLEVAPI3",67,0)
 S ZTIO="",ZTDTH=$H,ZTDESC="HL Event Monitor - #"_HLEVIENE
"RTN","HLEVAPI3",68,0)
 S ZTRTN="QUEUEV^HLEVAPI3"
"RTN","HLEVAPI3",69,0)
 S ZTSAVE("HLEVIENJ")="",ZTSAVE("HLEVIENE")=""
"RTN","HLEVAPI3",70,0)
 S ZTSAVE("HLEVNM")="",ZTSAVE("HLEVIENM")=""
"RTN","HLEVAPI3",71,0)
 D ^%ZTLOAD
"RTN","HLEVAPI3",72,0)
 ;
"RTN","HLEVAPI3",73,0)
 ; Save info in 776.2...
"RTN","HLEVAPI3",74,0)
 D RECEVM(HLEVIENM,HLEVIENE,"Q",ZTSK,+HLEVIENJ)
"RTN","HLEVAPI3",75,0)
 ;
"RTN","HLEVAPI3",76,0)
 ; Save task number in 776...
"RTN","HLEVAPI3",77,0)
 D UPDFLDE^HLEVAPI(+HLEVIENJ,8,ZTSK)
"RTN","HLEVAPI3",78,0)
 ;
"RTN","HLEVAPI3",79,0)
 ; Reset back...
"RTN","HLEVAPI3",80,0)
 S ZTSK=ZTSKMST
"RTN","HLEVAPI3",81,0)
 ;
"RTN","HLEVAPI3",82,0)
 QUIT
"RTN","HLEVAPI3",83,0)
 ;
"RTN","HLEVAPI3",84,0)
RUNS(HLEVIENE,RUN) ; Find latest 10 runs for calling API...
"RTN","HLEVAPI3",85,0)
 N CT,IEN,NODE
"RTN","HLEVAPI3",86,0)
 KILL RUN
"RTN","HLEVAPI3",87,0)
 S CT=0,IEN=":"
"RTN","HLEVAPI3",88,0)
 F  S IEN=$O(^HLEV(776,"M",HLEVIENE,IEN),-1) Q:'IEN  D  QUIT:CT>9
"RTN","HLEVAPI3",89,0)
 .  S NODE=$G(^HLEV(776,+IEN,0)) QUIT:NODE']""  ;->
"RTN","HLEVAPI3",90,0)
 .  S CT=CT+1
"RTN","HLEVAPI3",91,0)
 .  S RUN(CT)=NODE
"RTN","HLEVAPI3",92,0)
 Q
"RTN","HLEVAPI3",93,0)
 ;
"RTN","HLEVAPI3",94,0)
RECEVM(HLEVIENM,HLEVIENE,RES,ZTSK,HLEVIENJ) ;
"RTN","HLEVAPI3",95,0)
 N CT,DATA,REA
"RTN","HLEVAPI3",96,0)
 ;
"RTN","HLEVAPI3",97,0)
 I $E(RES)="X" S REA=$P(RES,U,2),RES="X"
"RTN","HLEVAPI3",98,0)
 ;
"RTN","HLEVAPI3",99,0)
 S RES=$S($G(RES)]"":RES,1:"?")
"RTN","HLEVAPI3",100,0)
 S NOEVCHK(RES)=$G(NOEVCHK(RES))+1
"RTN","HLEVAPI3",101,0)
 ;
"RTN","HLEVAPI3",102,0)
 QUIT:$G(^HLEV(776.2,+$G(HLEVIENM),0))']""  ;->
"RTN","HLEVAPI3",103,0)
 QUIT:$G(^HLEV(776.1,+$G(HLEVIENE),0))']""  ;->
"RTN","HLEVAPI3",104,0)
 ;
"RTN","HLEVAPI3",105,0)
 S CT=$O(^HLEV(776.2,+HLEVIENM,51,":"),-1)+1
"RTN","HLEVAPI3",106,0)
 S ^HLEV(776.2,+HLEVIENM,51,0)="^776.2051PA^"_CT_U_CT
"RTN","HLEVAPI3",107,0)
 S DATA=HLEVIENE_U_$G(RES)_U_$$NOW^XLFDT
"RTN","HLEVAPI3",108,0)
 I $G(ZTSK) S $P(DATA,U,4)=ZTSK
"RTN","HLEVAPI3",109,0)
 I $G(REA)]"" S $P(DATA,U,7)=REA
"RTN","HLEVAPI3",110,0)
 I $G(HLEVIENJ)>0 S $P(DATA,U,8)=HLEVIENJ
"RTN","HLEVAPI3",111,0)
 S ^HLEV(776.2,+HLEVIENM,51,+CT,0)=DATA
"RTN","HLEVAPI3",112,0)
 S ^HLEV(776.2,+HLEVIENM,51,"B",HLEVIENE,CT)=""
"RTN","HLEVAPI3",113,0)
 ;
"RTN","HLEVAPI3",114,0)
 Q
"RTN","HLEVAPI3",115,0)
 ;
"RTN","HLEVAPI3",116,0)
QUEUEV ; Queued event job starts here...
"RTN","HLEVAPI3",117,0)
 ; HLEVIENE,HLEVIENJ,HLEVIENM -- req
"RTN","HLEVAPI3",118,0)
 N EVMCODE,EVMGRP,EVNAME,NODE,EVPAR1,EVPAR2,EVPAR3,EVPAR4,EVPAR5
"RTN","HLEVAPI3",119,0)
 N EVPAR6,DVPAR7,EVPAR8
"RTN","HLEVAPI3",120,0)
 ;
"RTN","HLEVAPI3",121,0)
 S ZTREQ="@"
"RTN","HLEVAPI3",122,0)
 ;
"RTN","HLEVAPI3",123,0)
 ; Mark RUNNING before doing anything else...
"RTN","HLEVAPI3",124,0)
 D EVRES^HLEVAPI0(+HLEVIENM,+HLEVIENE,"R",+HLEVIENJ)
"RTN","HLEVAPI3",125,0)
 ;
"RTN","HLEVAPI3",126,0)
 ;*** P153 START CJM ***
"RTN","HLEVAPI3",127,0)
 L +^HLEV(776.1,+$G(HLEVIENE),0):1 Q:'$T
"RTN","HLEVAPI3",128,0)
 ;*** P153 END CJM
"RTN","HLEVAPI3",129,0)
 S NODE=$G(^HLEV(776.1,+$G(HLEVIENE),0)) I NODE']"" D  QUIT  ;->
"RTN","HLEVAPI3",130,0)
 .  D EVRES^HLEVAPI0(+HLEVIENM,+HLEVIENE,"XE",+HLEVIENJ)
"RTN","HLEVAPI3",131,0)
 .  ;*** Begin HL7*1.6*153 - pij ***
"RTN","HLEVAPI3",132,0)
 .  L -^HLEV(776.1,+$G(HLEVIENE),0)
"RTN","HLEVAPI3",133,0)
 .  ;*** End HL7*1.6*153 - pij ***
"RTN","HLEVAPI3",134,0)
 S EVNAME=$P(NODE,U),EVMGRP=$P(NODE,U,5)
"RTN","HLEVAPI3",135,0)
 S EVMCODE=$TR($P(NODE,U,6),"~",U) I EVMCODE'?1.8E1"^"1.8E D  QUIT  ;->
"RTN","HLEVAPI3",136,0)
 .  D EVRES^HLEVAPI0(+HLEVIENM,+HLEVIENE,"XE",+HLEVIENJ)
"RTN","HLEVAPI3",137,0)
 .  ;*** Begin HL7*1.6*153 - pij ***
"RTN","HLEVAPI3",138,0)
 .  L -^HLEV(776.1,+$G(HLEVIENE),0)
"RTN","HLEVAPI3",139,0)
 .  ;*** End HL7*1.6*153 - pij ***
"RTN","HLEVAPI3",140,0)
 ;
"RTN","HLEVAPI3",141,0)
 ; Node 40...
"RTN","HLEVAPI3",142,0)
 S NODE40=$G(^HLEV(776.1,+HLEVIENE,40))
"RTN","HLEVAPI3",143,0)
 F NO=1:1:8 S @("EVPAR"_NO)=$P(NODE40,U,NO)
"RTN","HLEVAPI3",144,0)
 ;
"RTN","HLEVAPI3",145,0)
 ; Final M code check...
"RTN","HLEVAPI3",146,0)
 I '$$OKMCODE^HLEVAPI0(EVMCODE) D  QUIT  ;->
"RTN","HLEVAPI3",147,0)
 .  D EVRES^HLEVAPI0(+HLEVIENM,+HLEVIENE,"XM",+HLEVIENJ)
"RTN","HLEVAPI3",148,0)
 .  ;*** Begin HL7*1.6*153 - pij ***
"RTN","HLEVAPI3",149,0)
 .  L -^HLEV(776.1,+$G(HLEVIENE),0)
"RTN","HLEVAPI3",150,0)
 .  ;*** End HL7*1.6*153 - pij ***
"RTN","HLEVAPI3",151,0)
 ;
"RTN","HLEVAPI3",152,0)
 D @EVMCODE
"RTN","HLEVAPI3",153,0)
 ;*** Begin HL7*1.6*153 - pij ***
"RTN","HLEVAPI3",154,0)
 L -^HLEV(776.1,+$G(HLEVIENE),0)
"RTN","HLEVAPI3",155,0)
 ;*** End HL7*1.6*153 - pij ***
"RTN","HLEVAPI3",156,0)
 ;
"RTN","HLEVAPI3",157,0)
 D EVRES^HLEVAPI0(+HLEVIENM,+HLEVIENE,"F",+HLEVIENJ)
"RTN","HLEVAPI3",158,0)
 ;
"RTN","HLEVAPI3",159,0)
 Q
"RTN","HLEVAPI3",160,0)
 ;
"RTN","HLEVAPI3",161,0)
MAILIT ; Generic mail out call...
"RTN","HLEVAPI3",162,0)
 ; HLEVIENE,HLEVIENJ -- req
"RTN","HLEVAPI3",163,0)
 ; XMY(...) can be created before this call...
"RTN","HLEVAPI3",164,0)
 N MGRP
"RTN","HLEVAPI3",165,0)
 ;
"RTN","HLEVAPI3",166,0)
 D DEBUG^HLEVAPI2("MAILIT") ; Debug data created conditionally
"RTN","HLEVAPI3",167,0)
 ;
"RTN","HLEVAPI3",168,0)
 ; Stop all event monitoring to enable on-site debugging...
"RTN","HLEVAPI3",169,0)
 QUIT:$G(^TMP("HLEVFLAG",$J))["STOP"  ;->
"RTN","HLEVAPI3",170,0)
 ;
"RTN","HLEVAPI3",171,0)
 D ADDXMYS^HLEVAPI2(HLEVIENE,$G(XTMP))
"RTN","HLEVAPI3",172,0)
 ;
"RTN","HLEVAPI3",173,0)
 ; If no mail group, and no passed in XMY, use DUZ...
"RTN","HLEVAPI3",174,0)
 I '$D(XMY),$G(DUZ)>0 S XMY(DUZ)=""
"RTN","HLEVAPI3",175,0)
 ;
"RTN","HLEVAPI3",176,0)
 QUIT:'$D(XMY)
"RTN","HLEVAPI3",177,0)
 ;
"RTN","HLEVAPI3",178,0)
 D SENDMAIL^HLEVAPI(HLEVIENE,+$G(HLEVIENJ),.XMY) ; Use generic email...
"RTN","HLEVAPI3",179,0)
 ;
"RTN","HLEVAPI3",180,0)
 KILL XMSUB,XMTEXT,XMY
"RTN","HLEVAPI3",181,0)
 ;
"RTN","HLEVAPI3",182,0)
 Q
"RTN","HLEVAPI3",183,0)
 ;
"RTN","HLEVAPI3",184,0)
MONFLAG(VAL) ; Set ^TMP("HLEVFLAG",$J), or return it's value...
"RTN","HLEVAPI3",185,0)
 ; User may pass in the following values for VAL...
"RTN","HLEVAPI3",186,0)
 ;
"RTN","HLEVAPI3",187,0)
 ; * ABORT,STOP   -> Will set ^TMP("HLEVFLAG",$J)="STOP"
"RTN","HLEVAPI3",188,0)
 ; * START,RUN,XEC -> Will kill ^TMP("HLEVFLAG",$J)
"RTN","HLEVAPI3",189,0)
 ; * SHOW,"" -> Will return value of ^TMP("HLEVFLAG",$J)
"RTN","HLEVAPI3",190,0)
 ;
"RTN","HLEVAPI3",191,0)
 ; What did user pass in?  
"RTN","HLEVAPI3",192,0)
 S VAL=$$UP^XLFSTR($G(VAL))
"RTN","HLEVAPI3",193,0)
 S VAL=$S(VAL="STOP":"STOP",VAL="ABORT":"STOP",VAL="SET":"STOP",VAL="KILL":"@",VAL="START":"@",VAL="RUN":"@",VAL="XEC":"@",1:"")
"RTN","HLEVAPI3",194,0)
 ;
"RTN","HLEVAPI3",195,0)
 I VAL']"" QUIT $G(^TMP("HLEVFLAG",$J)) ;-> Just show value...
"RTN","HLEVAPI3",196,0)
 I VAL="@" KILL ^TMP("HLEVFLAG",$J) QUIT "" ;->
"RTN","HLEVAPI3",197,0)
 I VAL="STOP" S ^TMP("HLEVFLAG",$J)="STOP" QUIT "STOP" ;->
"RTN","HLEVAPI3",198,0)
 ;
"RTN","HLEVAPI3",199,0)
 Q $G(^TMP("HLEVFLAG",$J))
"RTN","HLEVAPI3",200,0)
 ;
"RTN","HLEVAPI3",201,0)
COUNT(MON,STATUS,GBL,LIM) ; Number of entries for monitor with STATUS...
"RTN","HLEVAPI3",202,0)
 ;
"RTN","HLEVAPI3",203,0)
 ; Pass in... MON    -> Name or IEN of monitor
"RTN","HLEVAPI3",204,0)
 ;
"RTN","HLEVAPI3",205,0)
 ;            STATUS -> 776's STATUS field code or full expansion
"RTN","HLEVAPI3",206,0)
 ;                      -- Default = RUNNING
"RTN","HLEVAPI3",207,0)
 ;                      -- Pass in ALL for all entries
"RTN","HLEVAPI3",208,0)
 ;
"RTN","HLEVAPI3",209,0)
 ;            [GBL]  -> Global for entry storage. [OPTIONAL]
"RTN","HLEVAPI3",210,0)
 ;                      Creates @GBL@(#)=IEN ~ 776 zero node
"RTN","HLEVAPI3",211,0)
 ;                      (KILL @GBL at beginning!)
"RTN","HLEVAPI3",212,0)
 ;
"RTN","HLEVAPI3",213,0)
 ;            [LIM]  -> Limit to # entries/status to store in GBL.
"RTN","HLEVAPI3",214,0)
 ;                     
"RTN","HLEVAPI3",215,0)
 ;
"RTN","HLEVAPI3",216,0)
 ; Examples:  
"RTN","HLEVAPI3",217,0)
 ; 
"RTN","HLEVAPI3",218,0)
 ; $$COUNT("FAST HL7 PURGE #2") -> # events running (default)
"RTN","HLEVAPI3",219,0)
 ; $$COUNT("FAST HL7 PURGE #2","R") -> # events running
"RTN","HLEVAPI3",220,0)
 ; $$COUNT("FAST HL7 PURGE #2","ALL") -> # events of all statuses
"RTN","HLEVAPI3",221,0)
 ;
"RTN","HLEVAPI3",222,0)
 ; The call...  $$COUNT("FAST HL7 PURGE #2","ALL","HLEV",1)
"RTN","HLEVAPI3",223,0)
 ;
"RTN","HLEVAPI3",224,0)
 ; Returns...   (1) # event entries that exist of all statuses.
"RTN","HLEVAPI3",225,0)
 ;              (2) Stores entries in HLEV(#)=zero node
"RTN","HLEVAPI3",226,0)
 ;              (3) Stores only the most recent entry (LIM=1)
"RTN","HLEVAPI3",227,0)
 ;
"RTN","HLEVAPI3",228,0)
 ;              If LIM>2, for example, the most recent two entries
"RTN","HLEVAPI3",229,0)
 ;              would be returned.  But, note that the subscripting
"RTN","HLEVAPI3",230,0)
 ;              is not oldest to newest, but newest (with subscript 
"RTN","HLEVAPI3",231,0)
 ;              of 1) to oldest (with subscript of 2.)
"RTN","HLEVAPI3",232,0)
 ;
"RTN","HLEVAPI3",233,0)
 N CT,IEN,NO
"RTN","HLEVAPI3",234,0)
 ;
"RTN","HLEVAPI3",235,0)
 QUIT:$G(MON)']"" "" ;->
"RTN","HLEVAPI3",236,0)
 S:$G(STATUS)']"" STATUS="R" ; Default to RUNNING...
"RTN","HLEVAPI3",237,0)
 S:STATUS="ALL" STATUS="EFQR"
"RTN","HLEVAPI3",238,0)
 I STATUS'="EFQR" S STATUS=$$UP^XLFSTR($E($G(STATUS)_" "))
"RTN","HLEVAPI3",239,0)
 QUIT:"EFQR"'[STATUS "" ;->
"RTN","HLEVAPI3",240,0)
 ;
"RTN","HLEVAPI3",241,0)
 ; If passed GBL, check/set limit..
"RTN","HLEVAPI3",242,0)
 S GBL=$G(GBL),LIM=$G(LIM)
"RTN","HLEVAPI3",243,0)
 S LIM=$S(LIM:LIM,1:999999)
"RTN","HLEVAPI3",244,0)
 ;
"RTN","HLEVAPI3",245,0)
 ; It's OK to pass in the IEN...
"RTN","HLEVAPI3",246,0)
 I MON'=+MON S MON=$O(^HLEV(776.1,"B",MON,0)) QUIT:MON'>0 "" ;->
"RTN","HLEVAPI3",247,0)
 ;
"RTN","HLEVAPI3",248,0)
 ; Remove any data hanging around from before call...
"RTN","HLEVAPI3",249,0)
 I GBL]"" KILL @GBL
"RTN","HLEVAPI3",250,0)
 ;
"RTN","HLEVAPI3",251,0)
 S CT=0,IEN=":"
"RTN","HLEVAPI3",252,0)
 F  S IEN=$O(^HLEV(776,"M",+MON,IEN),-1) Q:'IEN  D
"RTN","HLEVAPI3",253,0)
 .  S DATA=$G(^HLEV(776,+IEN,0))
"RTN","HLEVAPI3",254,0)
 .  ; Don't count if doesn't even have a status!
"RTN","HLEVAPI3",255,0)
 .  QUIT:$P(DATA,U,4)']""  ;->
"RTN","HLEVAPI3",256,0)
 .  ; If STATUS="EFQR", every status should be counted...
"RTN","HLEVAPI3",257,0)
 .  I STATUS'="EFQR" QUIT:$P(DATA,U,4)'=STATUS  ;->
"RTN","HLEVAPI3",258,0)
 .  S CT=CT+1
"RTN","HLEVAPI3",259,0)
 .  QUIT:$G(GBL)']""  ;-> Don't store and return...
"RTN","HLEVAPI3",260,0)
 .  S CT(1)=$O(@GBL@($P(DATA,U,4),":"),-1)+1
"RTN","HLEVAPI3",261,0)
 .  QUIT:CT(1)>LIM  ;->
"RTN","HLEVAPI3",262,0)
 .  S @GBL@($P(DATA,U,4),+CT(1))=IEN_"~"_DATA
"RTN","HLEVAPI3",263,0)
 ;
"RTN","HLEVAPI3",264,0)
 Q $S(CT:CT,1:"")
"RTN","HLEVAPI3",265,0)
 ;
"RTN","HLEVAPI3",266,0)
MARKERR ; Mark any RUNNING, but non-current entry's status to ERROR...
"RTN","HLEVAPI3",267,0)
 N DATA,IEN776,HLEVIENE,HLEVIENM,STAT
"RTN","HLEVAPI3",268,0)
 ;
"RTN","HLEVAPI3",269,0)
 S IEN776=0
"RTN","HLEVAPI3",270,0)
 F  S IEN776=$O(^HLEV(776,IEN776)) Q:'IEN776  D
"RTN","HLEVAPI3",271,0)
 .  S DATA=$G(^HLEV(776,+IEN776,0))
"RTN","HLEVAPI3",272,0)
 .  S STAT=$P(DATA,U,4) QUIT:STAT'="R"&(STAT'="Q")  ;->
"RTN","HLEVAPI3",273,0)
 .  QUIT:$$CURR^HLEVAPI1(+IEN776)  ;->
"RTN","HLEVAPI3",274,0)
 .  S HLEVIENE=$P(DATA,U,3) QUIT:$G(^HLEV(776.1,+HLEVIENE,0))']""  ;->
"RTN","HLEVAPI3",275,0)
 .  S HLEVIENM=$P(DATA,U,9) QUIT:$G(^HLEV(776.2,+HLEVIENM,0))']""  ;->
"RTN","HLEVAPI3",276,0)
 .  D EVRES^HLEVAPI0(HLEVIENM,HLEVIENE,"XE",IEN776)
"RTN","HLEVAPI3",277,0)
 ;
"RTN","HLEVAPI3",278,0)
 Q
"RTN","HLEVAPI3",279,0)
 ;
"RTN","HLEVAPI3",280,0)
EOR ;HLEVAPI3 - Event Monitor APIs ;5/16/03 14:42
"RTN","HLOPROC1")
0^16^B95639479^B102064543
"RTN","HLOPROC1",1,0)
HLOPROC1 ;ALB/CJM/OAK/PIJ- Process Manager - 10/4/94 1pm ;12/30/2010
"RTN","HLOPROC1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,138,139,147,153**;Oct 13, 1995;Build 11
"RTN","HLOPROC1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPROC1",4,0)
 ;
"RTN","HLOPROC1",5,0)
 ;
"RTN","HLOPROC1",6,0)
GETWORK(PROCESS) ;
"RTN","HLOPROC1",7,0)
 ;This is the GETWORK function for the process manager
"RTN","HLOPROC1",8,0)
 ;Finds a process that needs to be started
"RTN","HLOPROC1",9,0)
 ;
"RTN","HLOPROC1",10,0)
 N NAME,IEN,GOTWORK
"RTN","HLOPROC1",11,0)
 ;this is how  HL7 can be stopped via Taskman
"RTN","HLOPROC1",12,0)
 I $$S^%ZTLOAD D STOPHL7 Q 0
"RTN","HLOPROC1",13,0)
 S GOTWORK=0
"RTN","HLOPROC1",14,0)
 S IEN=+$G(PROCESS("IEN"))
"RTN","HLOPROC1",15,0)
 F  S IEN=$O(^HLD(779.3,"C",1,IEN)) Q:IEN=$G(PROCESS("IEN"))  I IEN D  Q:GOTWORK
"RTN","HLOPROC1",16,0)
 .N PROC,COUNT,QUEUED,RUNNING
"RTN","HLOPROC1",17,0)
 .Q:'$$GETPROC(IEN,.PROC)
"RTN","HLOPROC1",18,0)
 .Q:PROC("VMS SERVICE")
"RTN","HLOPROC1",19,0)
 .Q:PROC("NAME")="PROCESS MANAGER"
"RTN","HLOPROC1",20,0)
 .Q:'PROC("ACTIVE")
"RTN","HLOPROC1",21,0)
 .S PROCESS("COUNT")=1
"RTN","HLOPROC1",22,0)
 .S QUEUED=+$G(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC("NAME")))
"RTN","HLOPROC1",23,0)
 .S:QUEUED<0 QUEUED=0
"RTN","HLOPROC1",24,0)
 .S RUNNING=+$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC("NAME")))
"RTN","HLOPROC1",25,0)
 .S:RUNNING<0 RUNNING=0
"RTN","HLOPROC1",26,0)
 .S COUNT=QUEUED+RUNNING
"RTN","HLOPROC1",27,0)
 .I COUNT<PROC("MINIMUM") S GOTWORK=1,PROCESS("IEN")=IEN,PROCESS("NAME")=PROC("NAME"),PROCESS("COUNT")=(PROC("MINIMUM")-COUNT),PROCESS("NODE")=PROC("NODE") Q
"RTN","HLOPROC1",28,0)
 .I COUNT<PROC("MAXIMUM"),$$FMDIFF^XLFDT($$NOW^XLFDT,PROC("LAST DT/TM"),2)>PROC("WAIT SECONDS"),'QUEUED S GOTWORK=1,PROCESS("IEN")=IEN,PROCESS("NAME")=PROC("NAME"),PROCESS("COUNT")=1,PROCESS("NODE")=PROC("NODE") Q
"RTN","HLOPROC1",29,0)
 I 'GOTWORK K PROCESS
"RTN","HLOPROC1",30,0)
 Q GOTWORK
"RTN","HLOPROC1",31,0)
 ;
"RTN","HLOPROC1",32,0)
DOWORK(PROCESS) ;
"RTN","HLOPROC1",33,0)
 ;starts a process
"RTN","HLOPROC1",34,0)
 ;
"RTN","HLOPROC1",35,0)
 ;don't start a new task if stopped
"RTN","HLOPROC1",36,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOPROC1",37,0)
 ;
"RTN","HLOPROC1",38,0)
 N ZTRTN,ZTDESC,ZTSAVE,ZTIO,ZTSK,I,ZTDTH,ZTCPU
"RTN","HLOPROC1",39,0)
 S:'$G(PROCESS("COUNT")) PROCESS("COUNT")=1
"RTN","HLOPROC1",40,0)
 F I=1:1:PROCESS("COUNT") D
"RTN","HLOPROC1",41,0)
 .S ZTRTN="PROCESS^HLOPROC"
"RTN","HLOPROC1",42,0)
 .S ZTDESC="HL7 - "_PROCESS("NAME")
"RTN","HLOPROC1",43,0)
 .S ZTIO=""
"RTN","HLOPROC1",44,0)
 .S ZTSAVE("PROCNAME")=PROCESS("NAME")
"RTN","HLOPROC1",45,0)
 .S ZTDTH=$H
"RTN","HLOPROC1",46,0)
 .I $L(PROCESS("NODE")) S ZTCPU=PROCESS("NODE")
"RTN","HLOPROC1",47,0)
 .D ^%ZTLOAD
"RTN","HLOPROC1",48,0)
 .I $D(ZTSK) D
"RTN","HLOPROC1",49,0)
 ..;lock before changing counts
"RTN","HLOPROC1",50,0)
 ..L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",51,0)
 ..I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCESS("NAME"))))
"RTN","HLOPROC1",52,0)
 ..S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT,^HLTMP("HL7 QUEUED PROCESSES",ZTSK)=$H_"^"_PROCESS("NAME")
"RTN","HLOPROC1",53,0)
 ..L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",54,0)
 Q
"RTN","HLOPROC1",55,0)
 ;
"RTN","HLOPROC1",56,0)
GETPROC(IEN,PROCESS) ;
"RTN","HLOPROC1",57,0)
 ;given the ien of the HL7 Process Registry entry, returns the entry as a subscripted array in .PROCESS
"RTN","HLOPROC1",58,0)
 ;
"RTN","HLOPROC1",59,0)
 ;Output: Function returns 0 on failure, 1 on success
"RTN","HLOPROC1",60,0)
 ;
"RTN","HLOPROC1",61,0)
 N NODE
"RTN","HLOPROC1",62,0)
 S NODE=$G(^HLD(779.3,IEN,0))
"RTN","HLOPROC1",63,0)
 Q:NODE="" 0
"RTN","HLOPROC1",64,0)
 S PROCESS("NAME")=$P(NODE,"^")
"RTN","HLOPROC1",65,0)
 S PROCESS("IEN")=IEN
"RTN","HLOPROC1",66,0)
 S PROCESS("ACTIVE")=$P(NODE,"^",2)
"RTN","HLOPROC1",67,0)
 S PROCESS("MINIMUM")=+$P(NODE,"^",3)
"RTN","HLOPROC1",68,0)
 S PROCESS("MAXIMUM")=+$P(NODE,"^",4)
"RTN","HLOPROC1",69,0)
 S PROCESS("WAIT SECONDS")=+($P(NODE,"^",5))*60
"RTN","HLOPROC1",70,0)
 I 'PROCESS("WAIT SECONDS") S PROCESS("WAIT SECONDS")=1000
"RTN","HLOPROC1",71,0)
 S PROCESS("LAST DT/TM")=$P(NODE,"^",6)
"RTN","HLOPROC1",72,0)
 S PROCESS("VMS SERVICE")=$P(NODE,"^",15)
"RTN","HLOPROC1",73,0)
 S PROCESS("NODE")=$P(NODE,"^",16)
"RTN","HLOPROC1",74,0)
 I PROCESS("NODE") D
"RTN","HLOPROC1",75,0)
 .S PROCESS("NODE")=$P($G(^%ZIS(14.7,PROCESS("NODE"),0)),"^")
"RTN","HLOPROC1",76,0)
 E  S PROCESS("NODE")=""
"RTN","HLOPROC1",77,0)
 I '$L(PROCESS("NODE")) S PROCESS("NODE")=$$GETNODE^HLOSITE
"RTN","HLOPROC1",78,0)
 Q 1
"RTN","HLOPROC1",79,0)
 ;
"RTN","HLOPROC1",80,0)
STOPHL7 ;shut down HLO HL7
"RTN","HLOPROC1",81,0)
 N ZTSK,DOLLARJ
"RTN","HLOPROC1",82,0)
 ;let other processes know that starting/stopping is underway
"RTN","HLOPROC1",83,0)
 S $P(^HLD(779.1,1,0),"^",9)=0
"RTN","HLOPROC1",84,0)
 S ZTSK=""
"RTN","HLOPROC1",85,0)
 F  S ZTSK=$O(^HLTMP("HL7 QUEUED PROCESSES",ZTSK)) Q:ZTSK=""  D DQ^%ZTLOAD
"RTN","HLOPROC1",86,0)
 S DOLLARJ=""
"RTN","HLOPROC1",87,0)
 F  S DOLLARJ=$O(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)) Q:DOLLARJ=""  S ZTSK=$P($G(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)),"^",2) I ZTSK]"" D PCLEAR^%ZTLOAD(ZTSK) I $$ASKSTOP^%ZTLOAD(ZTSK)
"RTN","HLOPROC1",88,0)
 D CHKQUED
"RTN","HLOPROC1",89,0)
 Q
"RTN","HLOPROC1",90,0)
 ;
"RTN","HLOPROC1",91,0)
STARTHL7 ;
"RTN","HLOPROC1",92,0)
 ;start HL7 system
"RTN","HLOPROC1",93,0)
 ;
"RTN","HLOPROC1",94,0)
 N PROCESS
"RTN","HLOPROC1",95,0)
 S $P(^HLD(779.1,1,0),"^",9)=1
"RTN","HLOPROC1",96,0)
 D RECOUNT()
"RTN","HLOPROC1",97,0)
 D RESET
"RTN","HLOPROC1",98,0)
 ;
"RTN","HLOPROC1",99,0)
 L +^HLTMP("PROCESS MANAGER"):20
"RTN","HLOPROC1",100,0)
 ;if the lock was obtained then the Process Manager isn't running
"RTN","HLOPROC1",101,0)
 I $T D
"RTN","HLOPROC1",102,0)
 .L -^HLTMP("PROCESS MANAGER")
"RTN","HLOPROC1",103,0)
 .S PROCESS("IEN")=$O(^HLD(779.3,"B","PROCESS MANAGER",0))
"RTN","HLOPROC1",104,0)
 .D GETPROC(PROCESS("IEN"),.PROCESS)
"RTN","HLOPROC1",105,0)
 .D DOWORK(.PROCESS)
"RTN","HLOPROC1",106,0)
 Q
"RTN","HLOPROC1",107,0)
 ;
"RTN","HLOPROC1",108,0)
QUIT1(COUNT) ;just returns 1 as function value first time around,then 0, insuring that the DO WORK function is called just once
"RTN","HLOPROC1",109,0)
 I '$G(COUNT) S COUNT=1 Q 1
"RTN","HLOPROC1",110,0)
 Q 0
"RTN","HLOPROC1",111,0)
 ;
"RTN","HLOPROC1",112,0)
CHKDEAD(WORK) ;
"RTN","HLOPROC1",113,0)
 ;did any process terminate without erasing itself?
"RTN","HLOPROC1",114,0)
 ;WORK (pass by reference, not required) by the Process Manager that is not used and not required
"RTN","HLOPROC1",115,0)
 N DOLLARJ S DOLLARJ=""
"RTN","HLOPROC1",116,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",117,0)
 Q:'$T
"RTN","HLOPROC1",118,0)
 F  S DOLLARJ=$O(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)) Q:DOLLARJ=""  I DOLLARJ'=$J L +^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ):1 D:$T
"RTN","HLOPROC1",119,0)
 .L -^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)
"RTN","HLOPROC1",120,0)
 .N PROC
"RTN","HLOPROC1",121,0)
 .S PROC=$P($G(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)),"^",3)
"RTN","HLOPROC1",122,0)
 .K ^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)
"RTN","HLOPROC1",123,0)
 .Q:PROC=""
"RTN","HLOPROC1",124,0)
 .I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)),1)
"RTN","HLOPROC1",125,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",126,0)
 Q
"RTN","HLOPROC1",127,0)
CHKQUED ;did any queued task get dequeued without being erased?
"RTN","HLOPROC1",128,0)
 N PROC,JOB
"RTN","HLOPROC1",129,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",130,0)
 Q:'$T
"RTN","HLOPROC1",131,0)
 S JOB=""
"RTN","HLOPROC1",132,0)
 F  S JOB=$O(^HLTMP("HL7 QUEUED PROCESSES",JOB)) Q:JOB=""  I '$$QUEUED(JOB) D
"RTN","HLOPROC1",133,0)
 .N PROC
"RTN","HLOPROC1",134,0)
 .S PROC=$P($G(^HLTMP("HL7 QUEUED PROCESSES",JOB)),"^",2)
"RTN","HLOPROC1",135,0)
 .I PROC]"",$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)),1)
"RTN","HLOPROC1",136,0)
 .K ^HLTMP("HL7 QUEUED PROCESSES",JOB)
"RTN","HLOPROC1",137,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",138,0)
 Q
"RTN","HLOPROC1",139,0)
 ;
"RTN","HLOPROC1",140,0)
QUEUED(TASK) ;
"RTN","HLOPROC1",141,0)
 ;function returns 0 if ZTSK is not queued to run, 1 if it is
"RTN","HLOPROC1",142,0)
 N ZTSK
"RTN","HLOPROC1",143,0)
 S ZTSK=TASK
"RTN","HLOPROC1",144,0)
 D ISQED^%ZTLOAD
"RTN","HLOPROC1",145,0)
 Q:ZTSK(0) 1
"RTN","HLOPROC1",146,0)
 Q 0
"RTN","HLOPROC1",147,0)
 ;
"RTN","HLOPROC1",148,0)
CNTLIVE ;count the running processes
"RTN","HLOPROC1",149,0)
 N JOB,COUNTS,PROC
"RTN","HLOPROC1",150,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",151,0)
 Q:'$T
"RTN","HLOPROC1",152,0)
 S JOB=""
"RTN","HLOPROC1",153,0)
 F  S JOB=$O(^HLTMP("HL7 RUNNING PROCESSES",JOB)) Q:JOB=""  S PROC=$P($G(^HLTMP("HL7 RUNNING PROCESSES",JOB)),"^",3) I PROC]"" S COUNTS(PROC)=$G(COUNTS(PROC))+1
"RTN","HLOPROC1",154,0)
 S PROC="" F  S PROC=$O(COUNTS(PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)=COUNTS(PROC)
"RTN","HLOPROC1",155,0)
 S PROC="" F  S PROC=$O(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","RUNNING",PROC)=+$G(COUNTS(PROC))
"RTN","HLOPROC1",156,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",157,0)
 Q
"RTN","HLOPROC1",158,0)
 ;
"RTN","HLOPROC1",159,0)
CNTQUED ;count the queued tasks
"RTN","HLOPROC1",160,0)
 N JOB,COUNTS,PROC
"RTN","HLOPROC1",161,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC1",162,0)
 Q:'$T
"RTN","HLOPROC1",163,0)
 S JOB=""
"RTN","HLOPROC1",164,0)
 F  S JOB=$O(^HLTMP("HL7 QUEUED PROCESSES",JOB)) Q:JOB=""  S PROC=$P($G(^HLTMP("HL7 QUEUED PROCESSES",JOB)),"^",2) I PROC]"" S COUNTS(PROC)=$G(COUNTS(PROC))+1
"RTN","HLOPROC1",165,0)
 S PROC="" F  S PROC=$O(COUNTS(PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)=COUNTS(PROC)
"RTN","HLOPROC1",166,0)
 S PROC="" F  S PROC=$O(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)) Q:PROC=""  S ^HLC("HL7 PROCESS COUNTS","QUEUED",PROC)=+$G(COUNTS(PROC))
"RTN","HLOPROC1",167,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC1",168,0)
 Q
"RTN","HLOPROC1",169,0)
 ;
"RTN","HLOPROC1",170,0)
RECOUNT(RECOUNT) ;check that the processes that are supposed to be running actually are, same for the queued processes
"RTN","HLOPROC1",171,0)
 ;Input:
"RTN","HLOPROC1",172,0)
 ;  RECOUNT (pass by reference, optional) not used, but passed in by the process manager
"RTN","HLOPROC1",173,0)
 ;
"RTN","HLOPROC1",174,0)
 ;
"RTN","HLOPROC1",175,0)
 ;check for processes that are supposed to be running or queued but aren't
"RTN","HLOPROC1",176,0)
 D CHKDEAD(),CHKQUED
"RTN","HLOPROC1",177,0)
 ;
"RTN","HLOPROC1",178,0)
 ;recount the processes
"RTN","HLOPROC1",179,0)
 D CNTLIVE,CNTQUED
"RTN","HLOPROC1",180,0)
 Q
"RTN","HLOPROC1",181,0)
 ;
"RTN","HLOPROC1",182,0)
RESET ;
"RTN","HLOPROC1",183,0)
 N CTR,DT,LINK,QUEUE,MSGIEN
"RTN","HLOPROC1",184,0)
 K ^HLTMP("FAILING LINKS")
"RTN","HLOPROC1",185,0)
 S LINK=""
"RTN","HLOPROC1",186,0)
 F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D
"RTN","HLOPROC1",187,0)
 . S DT=$G(^HLB("QUEUE","OUT",LINK))
"RTN","HLOPROC1",188,0)
 . I DT'="" S ^HLTMP("FAILING LINKS",LINK)=DT ;; down link (has a DT/TM)
"RTN","HLOPROC1",189,0)
 Q
"RTN","HLOPROC1",190,0)
 ;
"RTN","HLOPROC1",191,0)
ERROR ;
"RTN","HLOPROC1",192,0)
 ;cleanup if the error occurred during queue recount
"RTN","HLOPROC1",193,0)
 L -^HLTMP("PROCESS MANAGER")
"RTN","HLOPROC1",194,0)
 D:$G(HLON) STARTHL7
"RTN","HLOPROC1",195,0)
 D RCNT^HLOSITE("U")
"RTN","HLOPROC1",196,0)
 I $L($G(LOCK)) L -@LOCK
"RTN","HLOPROC1",197,0)
 D ^%ZTER
"RTN","HLOPROC1",198,0)
 D UNWIND^%ZTER
"RTN","HLOPROC1",199,0)
 Q
"RTN","HLOPROC1",200,0)
 ;*****End HL*1.6*138
"RTN","HLOPROC1",201,0)
QCOUNT(WORK) ;count messages pending on all the queues
"RTN","HLOPROC1",202,0)
 N LOCK,FROM,LINK,QUEUE
"RTN","HLOPROC1",203,0)
 D RCNT^HLOSITE("S") ; Set RECOUNT FLAG on
"RTN","HLOPROC1",204,0)
 ;
"RTN","HLOPROC1",205,0)
 ; recount each OUT queue
"RTN","HLOPROC1",206,0)
 ;first delete counters for non-existent queues
"RTN","HLOPROC1",207,0)
 S LINK=""
"RTN","HLOPROC1",208,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOPROC1",209,0)
 . S QUEUE=""
"RTN","HLOPROC1",210,0)
 . F  S QUEUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUEUE)) Q:QUEUE=""  I '$O(^HLB("QUEUE","OUT",LINK,QUEUE,0)) D
"RTN","HLOPROC1",211,0)
 . . S LOCK=$NA(RECOUNT("OUT",LINK,QUEUE))
"RTN","HLOPROC1",212,0)
 . . L +@LOCK:1 Q:'$T  ;If lock not obtained skip recount for this queue
"RTN","HLOPROC1",213,0)
 . .I '$O(^HLB("QUEUE","OUT",LINK,QUEUE,0)) S ^HLC("QUEUECOUNT","OUT",LINK,QUEUE)=0
"RTN","HLOPROC1",214,0)
 . . L -@LOCK
"RTN","HLOPROC1",215,0)
 ;
"RTN","HLOPROC1",216,0)
 ;now count the queues
"RTN","HLOPROC1",217,0)
 S LINK=""
"RTN","HLOPROC1",218,0)
 F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D
"RTN","HLOPROC1",219,0)
 . S QUEUE=""
"RTN","HLOPROC1",220,0)
 . F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:QUEUE=""  D
"RTN","HLOPROC1",221,0)
 . . S LOCK=$NA(RECOUNT("OUT",LINK,QUEUE))
"RTN","HLOPROC1",222,0)
 . . L +@LOCK:1 Q:'$T  ;If lock not obtained skip recount for this queue
"RTN","HLOPROC1",223,0)
 . . S (MSGIEN,CTR)=0
"RTN","HLOPROC1",224,0)
 . . F  S MSGIEN=$O(^HLB("QUEUE","OUT",LINK,QUEUE,MSGIEN)) Q:MSGIEN=""  S CTR=CTR+1
"RTN","HLOPROC1",225,0)
 . . S ^HLC("QUEUECOUNT","OUT",LINK,QUEUE)=CTR
"RTN","HLOPROC1",226,0)
 . . L -@LOCK
"RTN","HLOPROC1",227,0)
 ;
"RTN","HLOPROC1",228,0)
 ; recount each sequence queue
"RTN","HLOPROC1",229,0)
 ;first delete counts for non-existent queues
"RTN","HLOPROC1",230,0)
 S QUEUE=""
"RTN","HLOPROC1",231,0)
 F  S QUEUE=$O(^HLC("QUEUECOUNT","SEQUENCE",QUEUE)) Q:QUEUE=""  D
"RTN","HLOPROC1",232,0)
 . Q:$G(^HLB("QUEUE","SEQUENCE",QUEUE))!$O(^HLB("QUEUE","SEQUENCE",QUEUE,0))
"RTN","HLOPROC1",233,0)
 . S LOCK=$NA(RECOUNT("SEQUENCE",QUEUE))
"RTN","HLOPROC1",234,0)
 . L +@LOCK:1 Q:'$T
"RTN","HLOPROC1",235,0)
 . I '$G(^HLB("QUEUE","SEQUENCE",QUEUE)),'$O(^HLB("QUEUE","SEQUENCE",QUEUE,0)) S ^HLC("QUEUECOUNT","SEQUENCE",QUEUE)=0
"RTN","HLOPROC1",236,0)
 . L -@LOCK
"RTN","HLOPROC1",237,0)
 ;
"RTN","HLOPROC1",238,0)
 ;now count the queues
"RTN","HLOPROC1",239,0)
 S QUEUE=""
"RTN","HLOPROC1",240,0)
 F  S QUEUE=$O(^HLB("QUEUE","SEQUENCE",QUEUE)) Q:QUEUE=""  D
"RTN","HLOPROC1",241,0)
 .S LOCK=$NA(RECOUNT("SEQUENCE",QUEUE))
"RTN","HLOPROC1",242,0)
 . L +@LOCK:1 Q:'$T  ;should not fail, but if it does, skip the recount  of this queue
"RTN","HLOPROC1",243,0)
 .;
"RTN","HLOPROC1",244,0)
 .S (MSGIEN,CTR)=0
"RTN","HLOPROC1",245,0)
 .;count msg even if not on the queue if the queue is waiting on it
"RTN","HLOPROC1",246,0)
 . I +$G(^HLB("QUEUE","SEQUENCE",QUEUE)) S CTR=1
"RTN","HLOPROC1",247,0)
 .;
"RTN","HLOPROC1",248,0)
 . F  S MSGIEN=$O(^HLB("QUEUE","SEQUENCE",QUEUE,MSGIEN)) Q:MSGIEN=""  S CTR=CTR+1
"RTN","HLOPROC1",249,0)
 . S ^HLC("QUEUECOUNT","SEQUENCE",QUEUE)=CTR
"RTN","HLOPROC1",250,0)
 . L -@LOCK
"RTN","HLOPROC1",251,0)
 ;
"RTN","HLOPROC1",252,0)
 ;
"RTN","HLOPROC1",253,0)
 ; now caculate the all-inclusive counter
"RTN","HLOPROC1",254,0)
 S QUEUE=""
"RTN","HLOPROC1",255,0)
 S CTR=0
"RTN","HLOPROC1",256,0)
 F  S QUEUE=$O(^HLC("QUEUECOUNT","SEQUENCE",QUEUE)) Q:QUEUE=""  S CTR=CTR+$G(^HLC("QUEUECOUNT","SEQUENCE",QUEUE))
"RTN","HLOPROC1",257,0)
 S ^HLC("QUEUECOUNT","SEQUENCE")=CTR
"RTN","HLOPROC1",258,0)
 ;
"RTN","HLOPROC1",259,0)
 ;
"RTN","HLOPROC1",260,0)
 ; recount IN queues
"RTN","HLOPROC1",261,0)
 ;
"RTN","HLOPROC1",262,0)
 ;first delete counts for non-existent queues
"RTN","HLOPROC1",263,0)
 S FROM=""
"RTN","HLOPROC1",264,0)
 F  S FROM=$O(^HLC("QUEUECOUNT","IN",FROM)) Q:FROM=""  D
"RTN","HLOPROC1",265,0)
 . S QUEUE=""
"RTN","HLOPROC1",266,0)
 . F  S QUEUE=$O(^HLC("QUEUECOUNT","IN",FROM,QUEUE)) Q:QUEUE=""  I '$O(^HLB("QUEUE","IN",FROM,QUEUE,0)) D
"RTN","HLOPROC1",267,0)
 . . S LOCK=$NA(RECOUNT("IN","FROM",QUEUE))
"RTN","HLOPROC1",268,0)
 . . L +@LOCK:1 Q:'$T  ;If lock not obtained skip recount for this queue
"RTN","HLOPROC1",269,0)
 . .I '$O(^HLB("QUEUE","IN",FROM,QUEUE,0)) S ^HLC("QUEUECOUNT","IN",FROM,QUEUE)=0
"RTN","HLOPROC1",270,0)
 . . L -@LOCK
"RTN","HLOPROC1",271,0)
 ;
"RTN","HLOPROC1",272,0)
 ;now count the queues
"RTN","HLOPROC1",273,0)
 S FROM=""
"RTN","HLOPROC1",274,0)
 F  S FROM=$O(^HLB("QUEUE","IN",FROM)) Q:FROM=""  D
"RTN","HLOPROC1",275,0)
 . S QUEUE=""
"RTN","HLOPROC1",276,0)
 . F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:QUEUE=""  D
"RTN","HLOPROC1",277,0)
 . . S LOCK=$NA(RECOUNT("IN","FROM",QUEUE))
"RTN","HLOPROC1",278,0)
 . . L +@LOCK:1 Q:'$T  ;If lock not obtained skip recount for this queue
"RTN","HLOPROC1",279,0)
 . . S (MSGIEN,CTR)=0
"RTN","HLOPROC1",280,0)
 . . F  S MSGIEN=$O(^HLB("QUEUE","IN",FROM,QUEUE,MSGIEN)) Q:MSGIEN=""  D
"RTN","HLOPROC1",281,0)
 . . . S CTR=CTR+1
"RTN","HLOPROC1",282,0)
 . . S ^HLC("QUEUECOUNT","IN",FROM,QUEUE)=CTR
"RTN","HLOPROC1",283,0)
 . . L -@LOCK
"RTN","HLOPROC1",284,0)
 ;
"RTN","HLOPROC1",285,0)
 ;recount flag not needed anymore
"RTN","HLOPROC1",286,0)
 D RCNT^HLOSITE("U")
"RTN","HLOPROC1",287,0)
 Q
"RTN","HLOQUE")
0^17^B153912092^B148335504
"RTN","HLOQUE",1,0)
HLOQUE ;ALB/CJM/OAK/PIJ/RBN- HL7 QUEUE MANAGEMENT - 10/4/94 1pm ;02/22/2011
"RTN","HLOQUE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132,134,137,138,143,147,153**;Oct 13, 1995;Build 11
"RTN","HLOQUE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOQUE",4,0)
 ;
"RTN","HLOQUE",5,0)
INQUE(FROM,QNAME,IEN778,ACTION,PURGE) ;
"RTN","HLOQUE",6,0)
 ;Will place the message=IEN778 on the IN queue, incoming
"RTN","HLOQUE",7,0)
 ;Input:
"RTN","HLOQUE",8,0)
 ;  FROM - sending facility from message header.
"RTN","HLOQUE",9,0)
 ;         For actions other than incoming messages, its the specified link.
"RTN","HLOQUE",10,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",11,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",12,0)
 ;  ACTION - <tag^routine> that should be executed for the application
"RTN","HLOQUE",13,0)
 ;  PURGE (optional) - PURGE=1 indicates that the purge dt/tm needs to be set by the infiler
"RTN","HLOQUE",14,0)
 ;     If PURGE("ACKTOIEN") is set, it indicates that the purge dt/tm of
"RTN","HLOQUE",15,0)
 ;     the original message to this application ack also needs to be set.
"RTN","HLOQUE",16,0)
 ;Output: none
"RTN","HLOQUE",17,0)
 ;
"RTN","HLOQUE",18,0)
 N FLG
"RTN","HLOQUE",19,0)
ZB36 I $G(FROM)="" S FROM="UNKNOWN"
"RTN","HLOQUE",20,0)
 I $$RCNT^HLOSITE L +RECOUNT("IN",FROM,QNAME):20 S:$T FLG=1
"RTN","HLOQUE",21,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",22,0)
 S ^HLB("QUEUE","IN",FROM,QNAME,IEN778)=ACTION_"^"_$G(PURGE)_"^"_$G(PURGE("ACKTOIEN"))
"RTN","HLOQUE",23,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","IN",FROM,QNAME)))
"RTN","HLOQUE",24,0)
 L:$G(FLG) -RECOUNT("IN",FROM,QNAME)
"RTN","HLOQUE",25,0)
 Q
"RTN","HLOQUE",26,0)
 ;
"RTN","HLOQUE",27,0)
OUTQUE(LINKNAME,PORT,QNAME,IEN778) ;
"RTN","HLOQUE",28,0)
 ;Will place the message=IEN778 on the out-going queue
"RTN","HLOQUE",29,0)
 ;Input:
"RTN","HLOQUE",30,0)
 ;  LINKNAME = name of (.01) the logical link
"RTN","HLOQUE",31,0)
 ;  PORT (optional) the port to connect to
"RTN","HLOQUE",32,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",33,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",34,0)
 ;Output: none
"RTN","HLOQUE",35,0)
 ;
"RTN","HLOQUE",36,0)
 ;
"RTN","HLOQUE",37,0)
 N SUB,FLG
"RTN","HLOQUE",38,0)
 S SUB=LINKNAME
"RTN","HLOQUE",39,0)
 I PORT S SUB=SUB_":"_PORT
"RTN","HLOQUE",40,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",41,0)
 ;***Start HL*1.6*138 PIJ
"RTN","HLOQUE",42,0)
 ;if recount in progress, give it up to 20 seconds to finish - if it takes longer than that the recount won't be exact, but a longer delay is unreasonable
"RTN","HLOQUE",43,0)
 I $$RCNT^HLOSITE L +RECOUNT("OUT",SUB,QNAME):20 S:$T FLG=1
"RTN","HLOQUE",44,0)
 ;***End HL*1.6*138 PIJ"
"RTN","HLOQUE",45,0)
 S ^HLB("QUEUE","OUT",SUB,QNAME,IEN778)=""
"RTN","HLOQUE",46,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","OUT",SUB,QNAME)))
"RTN","HLOQUE",47,0)
 L:$G(FLG) -RECOUNT("OUT",SUB,QNAME)
"RTN","HLOQUE",48,0)
 Q
"RTN","HLOQUE",49,0)
 ;
"RTN","HLOQUE",50,0)
DEQUE(FROMORTO,QNAME,DIR,IEN778) ;
"RTN","HLOQUE",51,0)
 ;This routine will remove the message=IEN778 from its queue
"RTN","HLOQUE",52,0)
 ;Input:
"RTN","HLOQUE",53,0)
 ;  DIR = "IN" or "OUT", denoting the direction that the message is going in
"RTN","HLOQUE",54,0)
 ;  FROMORTO = for outgoing: the .01 field of the logical link
"RTN","HLOQUE",55,0)
 ;         for incoming: sending facility
"RTN","HLOQUE",56,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",57,0)
 ;Output: none
"RTN","HLOQUE",58,0)
 ;
"RTN","HLOQUE",59,0)
 Q:(FROMORTO="")
"RTN","HLOQUE",60,0)
 I ($G(QNAME)="") S QNAME="DEFAULT"
"RTN","HLOQUE",61,0)
 D
"RTN","HLOQUE",62,0)
 .I $E(DIR)="I" S DIR="IN" Q
"RTN","HLOQUE",63,0)
 .I $E(DIR)="O" S DIR="OUT" Q
"RTN","HLOQUE",64,0)
 I DIR'="IN",DIR'="OUT" Q
"RTN","HLOQUE",65,0)
 Q:'$G(IEN778)
"RTN","HLOQUE",66,0)
 D:$D(^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778))
"RTN","HLOQUE",67,0)
 .N FLG
"RTN","HLOQUE",68,0)
 .I $$RCNT^HLOSITE L +RECOUNT(DIR,FROMORTO,QNAME):20 S:$T FLG=1
"RTN","HLOQUE",69,0)
 .K ^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778)
"RTN","HLOQUE",70,0)
 .;don't let the count become negative
"RTN","HLOQUE",71,0)
 .I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT",DIR,FROMORTO,QNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT",DIR,FROMORTO,QNAME)))
"RTN","HLOQUE",72,0)
 .L:$G(FLG) -RECOUNT(DIR,FROMORTO,QNAME)
"RTN","HLOQUE",73,0)
 Q
"RTN","HLOQUE",74,0)
 ;
"RTN","HLOQUE",75,0)
STOPQUE(DIR,QUEUE) ;
"RTN","HLOQUE",76,0)
 ;This API is used to set a stop flag on a named queue.
"RTN","HLOQUE",77,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",78,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",79,0)
 ;
"RTN","HLOQUE",80,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",81,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",82,0)
 S ^HLTMP("STOPPED QUEUES",DIR,QUEUE)=1
"RTN","HLOQUE",83,0)
 Q
"RTN","HLOQUE",84,0)
STARTQUE(DIR,QUEUE) ;
"RTN","HLOQUE",85,0)
 ;This API is used to REMOVE the stop flag on a named queue.
"RTN","HLOQUE",86,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",87,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",88,0)
 ;
"RTN","HLOQUE",89,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",90,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",91,0)
 K ^HLTMP("STOPPED QUEUES",DIR,QUEUE)
"RTN","HLOQUE",92,0)
 Q
"RTN","HLOQUE",93,0)
STOPPED(DIR,QUEUE) ;
"RTN","HLOQUE",94,0)
 ;This API is used to DETERMINE if the stop flag on a named queue is set.
"RTN","HLOQUE",95,0)
 ;Input:
"RTN","HLOQUE",96,0)
 ;  DIR=<"IN" or "OUT">
"RTN","HLOQUE",97,0)
 ;  QUEUE - the name of the queue to be checked
"RTN","HLOQUE",98,0)
 ;Output:
"RTN","HLOQUE",99,0)
 ;  Function returns 1 if the queue is stopped, 0 otherwise
"RTN","HLOQUE",100,0)
 N RET
"RTN","HLOQUE",101,0)
 S RET=0
"RTN","HLOQUE",102,0)
 Q:$G(DIR)="" 0
"RTN","HLOQUE",103,0)
 Q:$G(QUEUE)="" 0
"RTN","HLOQUE",104,0)
 S:$G(^HLTMP("STOPPED QUEUES",DIR,QUEUE)) RET=1
"RTN","HLOQUE",105,0)
ZB0 Q RET
"RTN","HLOQUE",106,0)
 ;
"RTN","HLOQUE",107,0)
SQUE(SQUE,LINKNAME,PORT,QNAME,IEN778) ;
"RTN","HLOQUE",108,0)
 ;Will place the message=IEN778 on the sequencing queue. This is always done in the context of the application calling an HLO API to send a message.
"RTN","HLOQUE",109,0)
 ;Input:
"RTN","HLOQUE",110,0)
 ;  SQUE - name of the sequencing queue
"RTN","HLOQUE",111,0)
 ;  LINKNAME = name of (.01) the logical link
"RTN","HLOQUE",112,0)
 ;  PORT (optional) the port to connect to
"RTN","HLOQUE",113,0)
 ;  QNAME (optional) outgoing queue
"RTN","HLOQUE",114,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",115,0)
 ;Output: 1 if placed on the outgoing queue, 0 if placed on the sequence queue
"RTN","HLOQUE",116,0)
 ;
"RTN","HLOQUE",117,0)
 N NEXT,MOVED,FLG
"RTN","HLOQUE",118,0)
 S MOVED=0
"RTN","HLOQUE",119,0)
 ;
"RTN","HLOQUE",120,0)
 ;keep a count of messages pending on sequence queues for the HLO System Monitor
"RTN","HLOQUE",121,0)
 ;
"RTN","HLOQUE",122,0)
 ;***Start HL*1.6*138 PIJ
"RTN","HLOQUE",123,0)
 ;if recount in progress, pause up to 20 seconds to finish - if it takes longer than that the recount won't be exact, but a longer delay is unreasonable
"RTN","HLOQUE",124,0)
 I $$RCNT^HLOSITE L +RECOUNT("SEQUENCE",SQUE):20 S:$T FLG=1
"RTN","HLOQUE",125,0)
 ;***End HL*1.6*138 PIJ
"RTN","HLOQUE",126,0)
 ;
"RTN","HLOQUE",127,0)
 ;** START 143 CJM
"RTN","HLOQUE",128,0)
 L +^HLB("QUEUE","SEQUENCE",SQUE):200
"RTN","HLOQUE",129,0)
 ;** END 143 CJM
"RTN","HLOQUE",130,0)
 ;
"RTN","HLOQUE",131,0)
 S NEXT=+$G(^HLB("QUEUE","SEQUENCE",SQUE))
"RTN","HLOQUE",132,0)
 I NEXT=IEN778 L -^HLB("QUEUE","SEQUENCE",SQUE) Q 0  ;already queued!
"RTN","HLOQUE",133,0)
 ;
"RTN","HLOQUE",134,0)
 ;increment the counter for all sequence queues
"RTN","HLOQUE",135,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")))
"RTN","HLOQUE",136,0)
 ;
"RTN","HLOQUE",137,0)
 ;*** Start HL*1.6*138 CJM
"RTN","HLOQUE",138,0)
 ;also keep counter for the individual queue
"RTN","HLOQUE",139,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)))
"RTN","HLOQUE",140,0)
 ;*** End HL*1.6*138 CJM
"RTN","HLOQUE",141,0)
 ;
"RTN","HLOQUE",142,0)
 ;** START 143 CJM
"RTN","HLOQUE",143,0)
 ;L +^HLB("QUEUE","SEQUENCE",SQUE):200
"RTN","HLOQUE",144,0)
 ;** END 143 CJM
"RTN","HLOQUE",145,0)
 ;
"RTN","HLOQUE",146,0)
 ;if the sequence queue is empty and not waiting on a message, then the message can be put directly on the outgoing queue, bypassing the sequence queue
"RTN","HLOQUE",147,0)
 I '$O(^HLB("QUEUE","SEQUENCE",SQUE,0)),'NEXT D
"RTN","HLOQUE",148,0)
 .S ^HLB("QUEUE","SEQUENCE",SQUE)=IEN778 ;to mean something moved to outgoing but not yet transmitted
"RTN","HLOQUE",149,0)
 .D OUTQUE(.LINKNAME,.PORT,.QNAME,IEN778)
"RTN","HLOQUE",150,0)
 .S MOVED=1
"RTN","HLOQUE",151,0)
 E  D
"RTN","HLOQUE",152,0)
 .;Put the message on the sequence queue.
"RTN","HLOQUE",153,0)
 .S ^HLB("QUEUE","SEQUENCE",SQUE,IEN778)=""
"RTN","HLOQUE",154,0)
 .;
"RTN","HLOQUE",155,0)
 .;**P143 START CJM
"RTN","HLOQUE",156,0)
 .I 'NEXT,$$ADVANCE(SQUE,"")
"RTN","HLOQUE",157,0)
 .;**P143 END CJM
"RTN","HLOQUE",158,0)
 .;
"RTN","HLOQUE",159,0)
 .;**P147 START CJM
"RTN","HLOQUE",160,0)
 .I NEXT,$L($P($G(^HLB(NEXT,0)),"^",7)) D ADVANCE(SQUE,NEXT)
"RTN","HLOQUE",161,0)
 .;**P147 END CJM
"RTN","HLOQUE",162,0)
 .;
"RTN","HLOQUE",163,0)
 L -^HLB("QUEUE","SEQUENCE",SQUE)
"RTN","HLOQUE",164,0)
 L:$G(FLG) -RECOUNT("SEQUENCE",SQUE)
"RTN","HLOQUE",165,0)
 Q MOVED
"RTN","HLOQUE",166,0)
 ;
"RTN","HLOQUE",167,0)
ADVANCE(SQUE,MSGIEN) ;
"RTN","HLOQUE",168,0)
 ;Will move the specified sequencing queue to the next message. 
"RTN","HLOQUE",169,0)
 ;Input:
"RTN","HLOQUE",170,0)
 ;  SQUE - name of the sequencing queue
"RTN","HLOQUE",171,0)
 ;  MSGIEN - the ien of the message upon which the sequence queue was waiting.  If it is NOT the correct ien, then the sequence queue will NOT be advance.
"RTN","HLOQUE",172,0)
 ;Output:
"RTN","HLOQUE",173,0)
 ;  Function - 1 if advanced, 0 if not
"RTN","HLOQUE",174,0)
 ;
"RTN","HLOQUE",175,0)
 N NODE,IEN778,LINKNAME,PORT,QNAME
"RTN","HLOQUE",176,0)
 Q:'$L($G(SQUE)) 0
"RTN","HLOQUE",177,0)
 ;
"RTN","HLOQUE",178,0)
 ;**P143 START CJM
"RTN","HLOQUE",179,0)
 ;Q:'$G(MSGIEN) 0
"RTN","HLOQUE",180,0)
 Q:'$D(MSGIEN) 0
"RTN","HLOQUE",181,0)
 ;**P143 END CJM
"RTN","HLOQUE",182,0)
 ;
"RTN","HLOQUE",183,0)
 L +^HLB("QUEUE","SEQUENCE",SQUE):200
"RTN","HLOQUE",184,0)
 ;
"RTN","HLOQUE",185,0)
 ;do not advance if the queue wasn't pending the message=MSGIEN
"RTN","HLOQUE",186,0)
 ;**P143 START CJM
"RTN","HLOQUE",187,0)
 ;I (MSGIEN'=$P($G(^HLB("QUEUE","SEQUENCE",SQUE)),"^")) L -^HLB("QUEUE","SEQUENCE",SQUE) Q 0
"RTN","HLOQUE",188,0)
 I ($G(MSGIEN)'=$P($G(^HLB("QUEUE","SEQUENCE",SQUE)),"^")) L -^HLB("QUEUE","SEQUENCE",SQUE) Q 0
"RTN","HLOQUE",189,0)
 ;**P143 END CJM
"RTN","HLOQUE",190,0)
 ;
"RTN","HLOQUE",191,0)
 ;decrement the count of messages pending on all sequence queues
"RTN","HLOQUE",192,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")))
"RTN","HLOQUE",193,0)
 ;
"RTN","HLOQUE",194,0)
 ;**Start HL*1.6*138 CJM
"RTN","HLOQUE",195,0)
 ;decrement the count of messages pending on this individual queue
"RTN","HLOQUE",196,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)))
"RTN","HLOQUE",197,0)
 ;**End HL*1.6*138 CJM
"RTN","HLOQUE",198,0)
 ;
"RTN","HLOQUE",199,0)
 S IEN778=0
"RTN","HLOQUE",200,0)
 ;look for the first message on the sequence que.  Make sure its valid, if not remove the invalid entry and keep looking.
"RTN","HLOQUE",201,0)
 F  S IEN778=$O(^HLB("QUEUE","SEQUENCE",SQUE,0)) Q:'IEN778  S NODE=$G(^HLB(IEN778,0)) Q:$L(NODE)  D
"RTN","HLOQUE",202,0)
 .;message does not exist! Remove from queue and try again.
"RTN","HLOQUE",203,0)
 .K ^HLB("QUEUE","SEQUENCE",SQUE,IEN778)
"RTN","HLOQUE",204,0)
 .I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE"))) ;decrement the count of messages pending sequence queues
"RTN","HLOQUE",205,0)
 .;**Start HL*1.6*138 CJM
"RTN","HLOQUE",206,0)
 .; also decrement the count of messages pending on this individual queue
"RTN","HLOQUE",207,0)
 .I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)))
"RTN","HLOQUE",208,0)
 .;**End HL*1.6*138 CJM
"RTN","HLOQUE",209,0)
 ;
"RTN","HLOQUE",210,0)
 ;IEN778 is the next pending msg on this sequence queue
"RTN","HLOQUE",211,0)
 I IEN778 D
"RTN","HLOQUE",212,0)
 .;
"RTN","HLOQUE",213,0)
 .;parse out info needed to move to outgoing queue
"RTN","HLOQUE",214,0)
 .S LINKNAME=$P(NODE,"^",5),PORT=$P(NODE,"^",8),QNAME=$P(NODE,"^",6)
"RTN","HLOQUE",215,0)
 .;
"RTN","HLOQUE",216,0)
 .S ^HLB("QUEUE","SEQUENCE",SQUE)=IEN778 ;indicates this sequence queue is now waiting for msg=IEN778 before advancing.  The second pieces is the timer, but will not be set until the message=IEN778 is actually transmitted.
"RTN","HLOQUE",217,0)
 .K ^HLB("QUEUE","SEQUENCE",SQUE,IEN778) ;remove from sequence queue
"RTN","HLOQUE",218,0)
 .L -^HLB("QUEUE","SEQUENCE",SQUE)
"RTN","HLOQUE",219,0)
 .S $P(^HLB(IEN778,5),"^",2)=1
"RTN","HLOQUE",220,0)
 .D OUTQUE(.LINKNAME,$G(PORT),$G(QNAME),IEN778) ;move to outgoing queue
"RTN","HLOQUE",221,0)
 E  D
"RTN","HLOQUE",222,0)
 .K ^HLB("QUEUE","SEQUENCE",SQUE) ;this sequence queue is currently empty and not needed
"RTN","HLOQUE",223,0)
 .L -^HLB("QUEUE","SEQUENCE",SQUE)
"RTN","HLOQUE",224,0)
 Q 1
"RTN","HLOQUE",225,0)
 ;
"RTN","HLOQUE",226,0)
SEQCHK(WORK) ;functions under the HLO Process Manager
"RTN","HLOQUE",227,0)
 ;check sequence queues for timeout
"RTN","HLOQUE",228,0)
 N QUE,NOW
"RTN","HLOQUE",229,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOQUE",230,0)
 S QUE=""
"RTN","HLOQUE",231,0)
 F  S QUE=$O(^HLB("QUEUE","SEQUENCE",QUE)) Q:QUE=""  D
"RTN","HLOQUE",232,0)
 .N NODE,MSGIEN,ACTION,NODE
"RTN","HLOQUE",233,0)
 .S NODE=$G(^HLB("QUEUE","SEQUENCE",QUE))
"RTN","HLOQUE",234,0)
 .Q:'$P(NODE,"^",2)
"RTN","HLOQUE",235,0)
 .Q:$P(NODE,"^",2)>NOW
"RTN","HLOQUE",236,0)
 .Q:$P(NODE,"^",3)
"RTN","HLOQUE",237,0)
 .L +^HLB("QUEUE","SEQUENCE",QUE):2
"RTN","HLOQUE",238,0)
 .;don't report if a lock wasn't obtained
"RTN","HLOQUE",239,0)
 .Q:'$T
"RTN","HLOQUE",240,0)
 .S NODE=$G(^HLB("QUEUE","SEQUENCE",QUE))
"RTN","HLOQUE",241,0)
 .I '$P(NODE,"^",2) L -^HLB("QUEUE","SEQUENCE",QUE) Q
"RTN","HLOQUE",242,0)
 .I ($P(NODE,"^",2)>NOW) L -^HLB("QUEUE","SEQUENCE",QUE) Q
"RTN","HLOQUE",243,0)
 .I $P(NODE,"^",3) L -^HLB("QUEUE","SEQUENCE",QUE) Q  ;exception already raised
"RTN","HLOQUE",244,0)
 .S MSGIEN=$P(NODE,"^")
"RTN","HLOQUE",245,0)
 .I 'MSGIEN L -^HLB("QUEUE","SEQUENCE",QUE) Q
"RTN","HLOQUE",246,0)
 .S ACTION=$$EXCEPT^HLOAPP($$GETSAP^HLOCLNT2(MSGIEN))
"RTN","HLOQUE",247,0)
 .S $P(^HLB(MSGIEN,5),"^",3)=1
"RTN","HLOQUE",248,0)
 .S $P(^HLB("QUEUE","SEQUENCE",QUE),"^",3)=1 ;indicates exception raised
"RTN","HLOQUE",249,0)
 .L -^HLB("QUEUE","SEQUENCE",QUE)
"RTN","HLOQUE",250,0)
 .D  ;call the application to take action
"RTN","HLOQUE",251,0)
 ..N HLMSGIEN,MCODE,DUZ,QUE,NOW
"RTN","HLOQUE",252,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOQUE"
"RTN","HLOQUE",253,0)
 ..S HLMSGIEN=MSGIEN
"RTN","HLOQUE",254,0)
 ..S MCODE="D "_ACTION
"RTN","HLOQUE",255,0)
 ..N MSGIEN,X
"RTN","HLOQUE",256,0)
 ..D DUZ^XUP(.5)
"RTN","HLOQUE",257,0)
 ..X MCODE
"RTN","HLOQUE",258,0)
 ..;kill the apps variables
"RTN","HLOQUE",259,0)
 ..D
"RTN","HLOQUE",260,0)
 ...N ZTSK
"RTN","HLOQUE",261,0)
 ...D KILL^XUSCLEAN
"RTN","HLOQUE",262,0)
 Q
"RTN","HLOQUE",263,0)
ERROR ;error trap for application context
"RTN","HLOQUE",264,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOQUE",265,0)
 D ^%ZTER
"RTN","HLOQUE",266,0)
 S $ECODE=",UAPPLICATION ERROR,"
"RTN","HLOQUE",267,0)
 ;
"RTN","HLOQUE",268,0)
 ;kill the apps variables
"RTN","HLOQUE",269,0)
 D
"RTN","HLOQUE",270,0)
 .N ZTSK,MSGIEN,QUEUE
"RTN","HLOQUE",271,0)
 .D KILL^XUSCLEAN
"RTN","HLOQUE",272,0)
 ;
"RTN","HLOQUE",273,0)
 ;release all the locks the app may have set, except Taskman lock
"RTN","HLOQUE",274,0)
 L:$D(ZTSK) ^%ZTSCH("TASK",ZTSK):1
"RTN","HLOQUE",275,0)
 L:'$D(ZTSK)
"RTN","HLOQUE",276,0)
 ;reset HLO's lock
"RTN","HLOQUE",277,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOQUE",278,0)
 ;return to processing the next message on the queue
"RTN","HLOQUE",279,0)
 D UNWIND^%ZTER
"RTN","HLOQUE",280,0)
 Q
"RTN","HLOQUE",281,0)
 ;
"RTN","HLOQUE",282,0)
 ; *** start HL*1.6*143 -  RBN ***
"RTN","HLOQUE",283,0)
 ;
"RTN","HLOQUE",284,0)
 ; IMPLEMENTATION OF HL0 QUEUE COUNT SUMMARY
"RTN","HLOQUE",285,0)
 ;
"RTN","HLOQUE",286,0)
QUECNT(QUEARRAY) ;
"RTN","HLOQUE",287,0)
 ; 
"RTN","HLOQUE",288,0)
 ; DESC  : Functions eturns the total number of messages on all the queues and an the QUEARRAY
"RTN","HLOQUE",289,0)
 ;        
"RTN","HLOQUE",290,0)
 ; INPUT : QUEARRAY - the array, passed by reference, to contain the queue counts. 
"RTN","HLOQUE",291,0)
 ;               
"RTN","HLOQUE",292,0)
 ; OUTPUT : Filled array
"RTN","HLOQUE",293,0)
 ;               
"RTN","HLOQUE",294,0)
 ;               Format:
"RTN","HLOQUE",295,0)
 ;             
"RTN","HLOQUE",296,0)
 ;               QUE("TOTAL") = Total number of messages on all queues.
"RTN","HLOQUE",297,0)
 ;               QUE("OUT")   = Total number of outgoing messages.
"RTN","HLOQUE",298,0)
 ;               QUE("IN")    = Total number of incoming messages.
"RTN","HLOQUE",299,0)
 ;               QUE("SEQ")   = Total number of messages on sequence queues.
"RTN","HLOQUE",300,0)
 ;               QUE("IN",link_name,queue_name) = Number of messages on given link and queue.
"RTN","HLOQUE",301,0)
 ;               QUE("OUT",link_name,queue_name) = Number of messages on given link and queue.
"RTN","HLOQUE",302,0)
 ;               QUE("SEQ",queue_name) = Number of messages on given sequence queue.
"RTN","HLOQUE",303,0)
 ; 
"RTN","HLOQUE",304,0)
 ; There are four possible calls ("entry points") to this API:
"RTN","HLOQUE",305,0)
 ;   1. QUECNT - returns the referenced array with all of the above data.
"RTN","HLOQUE",306,0)
 ;   2. IN     - returns only the data related to the IN queues.
"RTN","HLOQUE",307,0)
 ;   3. OUT    - returns only the data related to the OUT queues.
"RTN","HLOQUE",308,0)
 ;   4. SEQ    - returns only the data related to the SEQUENCE queues.
"RTN","HLOQUE",309,0)
 ;   
"RTN","HLOQUE",310,0)
 N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",311,0)
 S FLG=1
"RTN","HLOQUE",312,0)
 ; Get incomming counts
"RTN","HLOQUE",313,0)
 D IN(.QUEARRAY)
"RTN","HLOQUE",314,0)
 ; Get outgoing counts
"RTN","HLOQUE",315,0)
 D OUT(.QUEARRAY)
"RTN","HLOQUE",316,0)
 ; Get sequence counts
"RTN","HLOQUE",317,0)
 D SEQ(.QUEARRAY)
"RTN","HLOQUE",318,0)
 ;
"RTN","HLOQUE",319,0)
 ; Total messages on all queues
"RTN","HLOQUE",320,0)
 ; 
"RTN","HLOQUE",321,0)
 S QUEARRAY("TOTAL")=INCNT+OUTCNT+SEQCNT
"RTN","HLOQUE",322,0)
 Q QUEARRAY("TOTAL")
"RTN","HLOQUE",323,0)
 ;
"RTN","HLOQUE",324,0)
IN(QUEARRAY) ;
"RTN","HLOQUE",325,0)
 ; Count messages on incoming queues
"RTN","HLOQUE",326,0)
 ;
"RTN","HLOQUE",327,0)
 I '$G(FLG) N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",328,0)
 S (LINK,QUE)=""
"RTN","HLOQUE",329,0)
 S INCNT=0
"RTN","HLOQUE",330,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","IN",LINK)) Q:LINK=""  D
"RTN","HLOQUE",331,0)
 .  F  S QUE=$O(^HLC("QUEUECOUNT","IN",LINK,QUE)) Q:QUE=""  D
"RTN","HLOQUE",332,0)
 .  .  S INCNT=INCNT+^HLC("QUEUECOUNT","IN",LINK,QUE)
"RTN","HLOQUE",333,0)
 .  .  S QUEARRAY("IN",LINK,QUE)=^HLC("QUEUECOUNT","IN",LINK,QUE)
"RTN","HLOQUE",334,0)
 S QUEARRAY("IN")=INCNT
"RTN","HLOQUE",335,0)
 I '$G(FLG) Q INCNT
"RTN","HLOQUE",336,0)
 Q
"RTN","HLOQUE",337,0)
 ;
"RTN","HLOQUE",338,0)
OUT(QUEARRAY) ;
"RTN","HLOQUE",339,0)
 ; Count messages on outgoing queues
"RTN","HLOQUE",340,0)
 ;
"RTN","HLOQUE",341,0)
 I '$G(FLG) N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",342,0)
 S (LINK,QUE)=""
"RTN","HLOQUE",343,0)
 S OUTCNT=0
"RTN","HLOQUE",344,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOQUE",345,0)
 .  F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOQUE",346,0)
 .  .  S OUTCNT=OUTCNT+^HLC("QUEUECOUNT","OUT",LINK,QUE)
"RTN","HLOQUE",347,0)
 .  .  S QUEARRAY("OUT",LINK,QUE)=^HLC("QUEUECOUNT","OUT",LINK,QUE)
"RTN","HLOQUE",348,0)
 S QUEARRAY("OUT")=OUTCNT
"RTN","HLOQUE",349,0)
 I '$G(FLG) Q OUTCNT
"RTN","HLOQUE",350,0)
 Q
"RTN","HLOQUE",351,0)
 ;
"RTN","HLOQUE",352,0)
SEQ(QUEARRAY) ;
"RTN","HLOQUE",353,0)
 ; Count messages on sequence queues
"RTN","HLOQUE",354,0)
 ;
"RTN","HLOQUE",355,0)
 I '$G(FLG) N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",356,0)
 S QUE=""
"RTN","HLOQUE",357,0)
 S SEQCNT=0
"RTN","HLOQUE",358,0)
 F  S QUE=$O(^HLC("QUEUECOUNT","SEQUENCE",QUE)) Q:QUE=""  D
"RTN","HLOQUE",359,0)
 .  S SEQCNT=SEQCNT+^HLC("QUEUECOUNT","SEQUENCE",QUE)
"RTN","HLOQUE",360,0)
 .  S QUEARRAY("SEQ",QUE)=^HLC("QUEUECOUNT","SEQUENCE",QUE)
"RTN","HLOQUE",361,0)
 S QUEARRAY("SEQ")=^HLC("QUEUECOUNT","SEQUENCE")
"RTN","HLOQUE",362,0)
 I '$G(FLG) Q QUEARRAY("SEQ")
"RTN","HLOQUE",363,0)
 Q
"RTN","HLOQUE",364,0)
 ;
"RTN","HLOQUE",365,0)
 ; *** End HL*1.6*143 -  RBN ***
"RTN","HLOQUE",366,0)
 ;
"RTN","HLOQUE",367,0)
 ;** P147 START CJM
"RTN","HLOQUE",368,0)
RESETF(IEN) ;
"RTN","HLOQUE",369,0)
 ;resets the "F" index on the HLO Priority Queues file (#779.9) for
"RTN","HLOQUE",370,0)
 ;for record IEN
"RTN","HLOQUE",371,0)
 ;
"RTN","HLOQUE",372,0)
 N DA
"RTN","HLOQUE",373,0)
 S DA(1)=IEN
"RTN","HLOQUE",374,0)
 S DA=0
"RTN","HLOQUE",375,0)
 F  S DA=$O(^HLD(779.9,DA(1),1,DA)) Q:'DA  D
"RTN","HLOQUE",376,0)
 .N DATA
"RTN","HLOQUE",377,0)
 .S DATA(.01)=$P($G(^HLD(779.9,DA(1),1,DA,0)),"^")
"RTN","HLOQUE",378,0)
 .Q:DATA(.01)=""
"RTN","HLOQUE",379,0)
 .D UPD^HLOASUB1(779.91,.DA,.DATA)
"RTN","HLOQUE",380,0)
 Q
"RTN","HLOQUE",381,0)
 ;
"RTN","HLOQUE",382,0)
GETPRTY(QUEUE,LINK) ;
"RTN","HLOQUE",383,0)
 ;Inputs:
"RTN","HLOQUE",384,0)
 ;    QUEUE (required)
"RTN","HLOQUE",385,0)
 ;    LINK (required) the name of hte link, possibly with the port # appeded
"RTN","HLOQUE",386,0)
 ;
"RTN","HLOQUE",387,0)
 ;
"RTN","HLOQUE",388,0)
 N PRTY,LNK
"RTN","HLOQUE",389,0)
 S PRTY=0
"RTN","HLOQUE",390,0)
 S LNK=$P(LINK,":")
"RTN","HLOQUE",391,0)
 I $L(LNK) S PRTY=$G(^HLD(779.9,"F",QUEUE,"OUT",LNK))
"RTN","HLOQUE",392,0)
 I PRTY Q PRTY
"RTN","HLOQUE",393,0)
 S PRTY=$G(^HLD(779.9,"E",QUEUE,"OUT"))
"RTN","HLOQUE",394,0)
 Q:'PRTY 50
"RTN","HLOQUE",395,0)
 Q PRTY
"RTN","HLOQUE",396,0)
 ; 
"RTN","HLOQUE",397,0)
SETPRTY ;  User interface to set queue priority
"RTN","HLOQUE",398,0)
 ; 
"RTN","HLOQUE",399,0)
 N DIC,DA,DR,Y,DIE,QUEUE
"RTN","HLOQUE",400,0)
 S DIC="^HLD(779.9,"
"RTN","HLOQUE",401,0)
 S DIC(0)="QEAL"
"RTN","HLOQUE",402,0)
 S DIC("A")="Enter the name of an outgoing queue: "
"RTN","HLOQUE",403,0)
 S DIC("DR")=".01"
"RTN","HLOQUE",404,0)
 D ^DIC
"RTN","HLOQUE",405,0)
 I $G(DTOUT)!($G(DUOUT))!(Y=-1) D  Q
"RTN","HLOQUE",406,0)
 . K DIC,DA,DR,Y,DIE
"RTN","HLOQUE",407,0)
 S DA=+Y,QUEUE=$P(Y,"^",2)
"RTN","HLOQUE",408,0)
 I $$ASKYESNO^HLOUSR2("Do you want to set "_QUEUE_"'s priority for just one specific logical link","YES") D
"RTN","HLOQUE",409,0)
 .N DATA
"RTN","HLOQUE",410,0)
 .S DATA(.02)="OUT"
"RTN","HLOQUE",411,0)
 .D UPD^HLOASUB1(779.9,DA,.DATA)
"RTN","HLOQUE",412,0)
 .S DIC="^HLD(779.9,"_DA_",1,"
"RTN","HLOQUE",413,0)
 .S DA(1)=DA,DA=""
"RTN","HLOQUE",414,0)
 .;S DIC("DR")=.02
"RTN","HLOQUE",415,0)
 .S DIC(0)="QEAL"
"RTN","HLOQUE",416,0)
 .S DIC("A")="Select the specific link: "
"RTN","HLOQUE",417,0)
 .D ^DIC
"RTN","HLOQUE",418,0)
 .I Y>0 D
"RTN","HLOQUE",419,0)
 ..S DA=+Y
"RTN","HLOQUE",420,0)
 ..S DIE="^HLD(779.9,"_DA(1)_",1,"
"RTN","HLOQUE",421,0)
 ..S DR=.02
"RTN","HLOQUE",422,0)
 ..D ^DIE
"RTN","HLOQUE",423,0)
 E  D
"RTN","HLOQUE",424,0)
 .N DATA
"RTN","HLOQUE",425,0)
 .S DATA(.02)="OUT"
"RTN","HLOQUE",426,0)
 .S DATA(.03)=1
"RTN","HLOQUE",427,0)
 .D UPD^HLOASUB1(779.9,DA,.DATA)
"RTN","HLOQUE",428,0)
 .S DIE="^HLD(779.9,"
"RTN","HLOQUE",429,0)
 .S DR=.04
"RTN","HLOQUE",430,0)
 .D ^DIE
"RTN","HLOQUE",431,0)
 Q
"RTN","HLOQUE",432,0)
SETP(QUEUE,PRIORITY,LINK) ;
"RTN","HLOQUE",433,0)
 ;Description: API for setting an outgoing queue's priority
"RTN","HLOQUE",434,0)
 ;Input:
"RTN","HLOQUE",435,0)
 ;   QUEUE (required) the name of the queue
"RTN","HLOQUE",436,0)
 ;   PRIORITY (required) the priority, 20-100
"RTN","HLOQUE",437,0)
 ;   LINK (optional) name or IEN of an HL Logical Link. If specified, 
"RTN","HLOQUE",438,0)
 ;                   the priority will be applied only to the specific
"RTN","HLOQUE",439,0)
 ;                   link, otherwise the priority will be applied to all
"RTN","HLOQUE",440,0)
 ;                   queues named QUEUE
"RTN","HLOQUE",441,0)
 ;Output:
"RTN","HLOQUE",442,0)
 ;     function returns 1 on success, 0 on failure
"RTN","HLOQUE",443,0)
 ;
"RTN","HLOQUE",444,0)
 N LINKIEN,DA,DATA
"RTN","HLOQUE",445,0)
 S LINKIEN=0
"RTN","HLOQUE",446,0)
 S PRIORITY=+$G(PRIORITY)
"RTN","HLOQUE",447,0)
 I $G(PRIORITY)<20 Q 0
"RTN","HLOQUE",448,0)
 I PRIORITY>100 Q 0
"RTN","HLOQUE",449,0)
 I '$L($G(QUEUE)) Q 0
"RTN","HLOQUE",450,0)
 I $L(QUEUE)>20 Q 0
"RTN","HLOQUE",451,0)
 I $L($G(LINK)) D  Q:'LINKIEN 0
"RTN","HLOQUE",452,0)
 .S LINKIEN=0
"RTN","HLOQUE",453,0)
 .I LINK,$D(^HLCS(870,LINK,0)) S LINKIEN=LINK Q
"RTN","HLOQUE",454,0)
 .S LINKIEN=$O(^HLCS(870,"B",LINK,0))
"RTN","HLOQUE",455,0)
 S DA=$O(^HLD(779.9,"B",QUEUE,0))
"RTN","HLOQUE",456,0)
 I 'DA D
"RTN","HLOQUE",457,0)
 .S DATA(.02)="OUT"
"RTN","HLOQUE",458,0)
 .S DATA(.01)=QUEUE
"RTN","HLOQUE",459,0)
 .I 'LINKIEN S DATA(.03)=1,DATA(.04)=PRIORITY
"RTN","HLOQUE",460,0)
 .S DA=$$ADD^HLOASUB1(779.9,,.DATA)
"RTN","HLOQUE",461,0)
 E  I 'LINKIEN D  Q $$UPD^HLOASUB1(779.9,DA,.DATA)
"RTN","HLOQUE",462,0)
 .S DATA(.02)="OUT"
"RTN","HLOQUE",463,0)
 .S DATA(.03)=1
"RTN","HLOQUE",464,0)
 .S DATA(.04)=PRIORITY
"RTN","HLOQUE",465,0)
 Q:'DA 0
"RTN","HLOQUE",466,0)
 Q:'LINKIEN 1
"RTN","HLOQUE",467,0)
 S DA(1)=DA
"RTN","HLOQUE",468,0)
 S DA=$O(^HLD(779.9,DA(1),1,"B",LINKIEN,0))
"RTN","HLOQUE",469,0)
 K DATA
"RTN","HLOQUE",470,0)
 S DATA(.01)=LINKIEN
"RTN","HLOQUE",471,0)
 S DATA(.02)=PRIORITY
"RTN","HLOQUE",472,0)
 I DA Q $$UPD^HLOASUB1(779.91,.DA,.DATA)
"RTN","HLOQUE",473,0)
 I $$ADD^HLOASUB1(779.91,.DA,.DATA,.ERROR) Q 1
"RTN","HLOQUE",474,0)
 Q 0
"RTN","HLOQUE",475,0)
 ;**P147 END CJM
"RTN","HLOSITE")
0^18^B8278014^B8246314
"RTN","HLOSITE",1,0)
HLOSITE ;ALB/CJM/OAK/PIJ-HL7 - API for getting site parameters ;12/30/2010
"RTN","HLOSITE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,138,147,153**;Oct 13, 1995;Build 11
"RTN","HLOSITE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSITE",4,0)
 ;
"RTN","HLOSITE",5,0)
SYSPARMS(SYSTEM) ;Gets system parameters from file 779.1
"RTN","HLOSITE",6,0)
 ;Input: none
"RTN","HLOSITE",7,0)
 ;Output:
"RTN","HLOSITE",8,0)
 ;
"RTN","HLOSITE",9,0)
 N NODE,LINK
"RTN","HLOSITE",10,0)
 S NODE=$G(^HLD(779.1,1,0))
"RTN","HLOSITE",11,0)
 S SYSTEM("DOMAIN")=$P(NODE,"^")
"RTN","HLOSITE",12,0)
 S SYSTEM("STATION")=$P(NODE,"^",2)
"RTN","HLOSITE",13,0)
 S SYSTEM("PROCESSING ID")=$P(NODE,"^",3)
"RTN","HLOSITE",14,0)
 S SYSTEM("MAXSTRING")=$P(NODE,"^",4)
"RTN","HLOSITE",15,0)
 I ('SYSTEM("MAXSTRING"))!(SYSTEM("MAXSTRING")<256) D
"RTN","HLOSITE",16,0)
 .N OS S OS=^%ZOSF("OS")
"RTN","HLOSITE",17,0)
 .S SYSTEM("MAXSTRING")=$S(OS["OpenM":512,OS["DSM":512,1:256)
"RTN","HLOSITE",18,0)
 S SYSTEM("HL7 BUFFER")=$P(NODE,"^",5)
"RTN","HLOSITE",19,0)
 S:'SYSTEM("HL7 BUFFER") SYSTEM("HL7 BUFFER")=15000
"RTN","HLOSITE",20,0)
 S SYSTEM("USER BUFFER")=$P(NODE,"^",6)
"RTN","HLOSITE",21,0)
 S:'SYSTEM("USER BUFFER") SYSTEM("USER BUFFER")=5000
"RTN","HLOSITE",22,0)
 S SYSTEM("NORMAL PURGE")=$P(NODE,"^",7)
"RTN","HLOSITE",23,0)
 I 'SYSTEM("NORMAL PURGE") S SYSTEM("NORMAL PURGE")=36
"RTN","HLOSITE",24,0)
 S SYSTEM("ERROR PURGE")=$P(NODE,"^",8)
"RTN","HLOSITE",25,0)
 I 'SYSTEM("ERROR PURGE") S SYSTEM("ERROR PURGE")=7
"RTN","HLOSITE",26,0)
 S LINK=$P(NODE,"^",10)
"RTN","HLOSITE",27,0)
 S:LINK SYSTEM("PORT")=$$PORT^HLOTLNK(LINK)
"RTN","HLOSITE",28,0)
 S:'$G(SYSTEM("PORT")) SYSTEM("PORT")=$S(SYSTEM("PROCESSING ID")="P":5001,1:5026)
"RTN","HLOSITE",29,0)
 S SYSTEM("NODE")=$P(NODE,"^",13)
"RTN","HLOSITE",30,0)
 I SYSTEM("NODE") S SYSTEM("NODE")=$P($G(^%ZIS(14.7,SYSTEM("NODE"),0)),"^")
"RTN","HLOSITE",31,0)
 Q
"RTN","HLOSITE",32,0)
 ;
"RTN","HLOSITE",33,0)
GETNODE() ;
"RTN","HLOSITE",34,0)
 N NODE
"RTN","HLOSITE",35,0)
 S NODE=$P($G(^HLD(779.1,1,0)),"^",13)
"RTN","HLOSITE",36,0)
 Q:NODE $P($G(^%ZIS(14.7,NODE,0)),"^")
"RTN","HLOSITE",37,0)
 Q ""
"RTN","HLOSITE",38,0)
 ;
"RTN","HLOSITE",39,0)
INC(VARIABLE,AMOUNT) ;
"RTN","HLOSITE",40,0)
 ;Increments VARIABLE by AMOUNT, using $I if available, otherwise by locking.
"RTN","HLOSITE",41,0)
 ;
"RTN","HLOSITE",42,0)
 N OS
"RTN","HLOSITE",43,0)
 ;if HLCSTATE has been defined, then we have already checked the OS, so use it.
"RTN","HLOSITE",44,0)
 I $D(HLCSTATE("SYSTEM","OS")) D
"RTN","HLOSITE",45,0)
 .S OS=HLCSTATE("SYSTEM","OS")
"RTN","HLOSITE",46,0)
 E  D
"RTN","HLOSITE",47,0)
 .S OS=^%ZOSF("OS")
"RTN","HLOSITE",48,0)
 I '$G(AMOUNT) S AMOUNT=1
"RTN","HLOSITE",49,0)
 I (OS["OpenM")!(OS["DSM")!(OS["CACHE") Q $I(@VARIABLE,AMOUNT)
"RTN","HLOSITE",50,0)
 L +VARIABLE:100
"RTN","HLOSITE",51,0)
 S @VARIABLE=@VARIABLE+AMOUNT
"RTN","HLOSITE",52,0)
 L -VARIABLE
"RTN","HLOSITE",53,0)
 Q @VARIABLE
"RTN","HLOSITE",54,0)
 ;
"RTN","HLOSITE",55,0)
COUNT778() ;
"RTN","HLOSITE",56,0)
 ;This function returns the # of records in file 778.
"RTN","HLOSITE",57,0)
 N COUNT,IEN
"RTN","HLOSITE",58,0)
 S (COUNT,IEN)=0
"RTN","HLOSITE",59,0)
 F  S IEN=$O(^HLB(IEN)) Q:'IEN  S COUNT=COUNT+1
"RTN","HLOSITE",60,0)
 Q COUNT
"RTN","HLOSITE",61,0)
COUNT777() ;
"RTN","HLOSITE",62,0)
 ;This function returns the # of records in file 777.
"RTN","HLOSITE",63,0)
 N COUNT,IEN
"RTN","HLOSITE",64,0)
 S (COUNT,IEN)=0
"RTN","HLOSITE",65,0)
 F  S IEN=$O(^HLA(IEN)) Q:'IEN  S COUNT=COUNT+1
"RTN","HLOSITE",66,0)
 Q COUNT
"RTN","HLOSITE",67,0)
 ;
"RTN","HLOSITE",68,0)
UPDCNTS(WORK) ;update the record counts for file 777,778
"RTN","HLOSITE",69,0)
 N COUNT
"RTN","HLOSITE",70,0)
 S COUNT=$$COUNT777^HLOSITE
"RTN","HLOSITE",71,0)
 S $P(^HLA(0),"^",4)=COUNT
"RTN","HLOSITE",72,0)
 S ^HLTMP("FILE 777 RECORD COUNT")=COUNT_"^"_$$NOW^XLFDT
"RTN","HLOSITE",73,0)
 S COUNT=$$COUNT778^HLOSITE
"RTN","HLOSITE",74,0)
 S $P(^HLB(0),"^",4)=COUNT
"RTN","HLOSITE",75,0)
 S ^HLTMP("FILE 778 RECORD COUNT")=COUNT_"^"_$$NOW^XLFDT
"RTN","HLOSITE",76,0)
 Q
"RTN","HLOSITE",77,0)
 ;;HL*1.6*138 start PIJ 10/26/2007
"RTN","HLOSITE",78,0)
RCNT(ST) ;This section sets or reads the recount flag.
"RTN","HLOSITE",79,0)
 ;; When ST="S" Flag is set
"RTN","HLOSITE",80,0)
 ;; When ST="U" Flag is unset
"RTN","HLOSITE",81,0)
 I $G(ST)="S" S $P(^HLD(779.1,1,0),"^",11)=1
"RTN","HLOSITE",82,0)
 I $G(ST)="U" S $P(^HLD(779.1,1,0),"^",11)=0
"RTN","HLOSITE",83,0)
 Q $P($G(^HLD(779.1,1,0)),"^",11)
"RTN","HLOSITE",84,0)
 ;;HL*1.6*138 end
"RTN","HLOSITE",85,0)
OLDPURGE() ;returns the retention time in days for unsent messages
"RTN","HLOSITE",86,0)
 N TIME
"RTN","HLOSITE",87,0)
 S TIME=$P($G(^HLD(779.1,1,0)),"^",12)
"RTN","HLOSITE",88,0)
 Q $S(TIME:TIME,1:45)
"RTN","HLOSTRAC")
0^15^B50796847^B43533858
"RTN","HLOSTRAC",1,0)
HLOSTRAC ;;OIFO-OAK/RBN/CJM ;02/22/2011
"RTN","HLOSTRAC",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**146,147,153**;Oct 13, 1995;Build 11
"RTN","HLOSTRAC",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSTRAC",4,0)
 ;;
"RTN","HLOSTRAC",5,0)
 ;; HLO SERVER TRACE Tool
"RTN","HLOSTRAC",6,0)
 ;; *** For troubleshooting HLO server issues ***
"RTN","HLOSTRAC",7,0)
 ;;     The HLO server runs in the foreground and writes trace
"RTN","HLOSTRAC",8,0)
 ;;     statements to the screen.
"RTN","HLOSTRAC",9,0)
 ;; 
"RTN","HLOSTRAC",10,0)
TRACE    ;
"RTN","HLOSTRAC",11,0)
 N CONF,HLOTRACE
"RTN","HLOSTRAC",12,0)
 S HLOTRACE("COUNT")=0
"RTN","HLOSTRAC",13,0)
 S HLOTRACE("ERRORS")=0
"RTN","HLOSTRAC",14,0)
 I '$G(DUZ) W !,"Your DUZ must be set!" Q
"RTN","HLOSTRAC",15,0)
 D OWNSKEY^XUSRB(.CONF,"XUPROG",DUZ)
"RTN","HLOSTRAC",16,0)
 I 'CONF(0) D  Q
"RTN","HLOSTRAC",17,0)
 . W !!,"   Sorry, you are not authorized to use this tool.",!!
"RTN","HLOSTRAC",18,0)
 I $P($$VERSION^%ZOSV(1),"/",1)'["Cache" D  Q
"RTN","HLOSTRAC",19,0)
 . W !!,"   Sorry, this tool can only be used under Cache",!!
"RTN","HLOSTRAC",20,0)
 N IEN,LINK,PORT
"RTN","HLOSTRAC",21,0)
 S IEN=+$O(^HLD(779.1,0))
"RTN","HLOSTRAC",22,0)
 D:IEN
"RTN","HLOSTRAC",23,0)
 .S LINK=$P($G(^HLD(779.1,IEN,0)),"^",10)
"RTN","HLOSTRAC",24,0)
 .S LINK=$P($G(^HLCS(870,LINK,0)),"^")
"RTN","HLOSTRAC",25,0)
 S:'$L($G(LINK)) LINK="HLO DEFAULT LISTENER"
"RTN","HLOSTRAC",26,0)
 W !,"What port do you want to listen on while in server trace mode?"
"RTN","HLOSTRAC",27,0)
 W !,"The port must be free. If a server already has it opened then the"
"RTN","HLOSTRAC",28,0)
 W !,"server needs to be stopped before starting in server trace mode."
"RTN","HLOSTRAC",29,0)
 S PORT=$$ASKPORT^HLOUSRA(LINK)
"RTN","HLOSTRAC",30,0)
 Q:'PORT
"RTN","HLOSTRAC",31,0)
 D SETBREAKS
"RTN","HLOSTRAC",32,0)
 ;
"RTN","HLOSTRAC",33,0)
 ZB ZB999^HLOSRVR:"N":1:"S LINK(""PORT"")=PORT,LINK(""SERVER"")=""1^S"",LINK(""LLP"")=""TCP"""
"RTN","HLOSTRAC",34,0)
 ;
"RTN","HLOSTRAC",35,0)
 W !!,"Starting the server, hit the CTRL-C key to stop the server...",!!
"RTN","HLOSTRAC",36,0)
READ D
"RTN","HLOSTRAC",37,0)
 .N $ETRAP,$ESTACK
"RTN","HLOSTRAC",38,0)
 .S $ETRAP="G ERROR^HLOSTRAC"
"RTN","HLOSTRAC",39,0)
 .D SERVER^HLOSRVR(LINK)
"RTN","HLOSTRAC",40,0)
 .U $PRINCIPAL
"RTN","HLOSTRAC",41,0)
 .W !,"DONE!"
"RTN","HLOSTRAC",42,0)
 ZB /CLEAR
"RTN","HLOSTRAC",43,0)
 Q
"RTN","HLOSTRAC",44,0)
 ;
"RTN","HLOSTRAC",45,0)
SETBREAKS ;
"RTN","HLOSTRAC",46,0)
 ZB /CLEAR
"RTN","HLOSTRAC",47,0)
 ZB /INTERRUPT:NORMAL
"RTN","HLOSTRAC",48,0)
 ;
"RTN","HLOSTRAC",49,0)
 ;!!!! for debuggng only
"RTN","HLOSTRAC",50,0)
 ;ZB ERROR^HLOSTRAC
"RTN","HLOSTRAC",51,0)
 ;!!!!!!
"RTN","HLOSTRAC",52,0)
 ;
"RTN","HLOSTRAC",53,0)
 ;
"RTN","HLOSTRAC",54,0)
 ;report errors
"RTN","HLOSTRAC",55,0)
 ZB ZB1^HLOSRVR:"N":1:"S $ETRAP=""G ZB3^HLOSTRAC"""
"RTN","HLOSTRAC",56,0)
 ;
"RTN","HLOSTRAC",57,0)
 ;allow Server Trace tool to run even if HLO is shut down
"RTN","HLOSTRAC",58,0)
 ZB ZB25^HLOPROC:"N":1:"S RET=0"
"RTN","HLOSTRAC",59,0)
 ZB READMSG^HLOSRVR1:"N":1:"D READMSG^HLOSTRAC"
"RTN","HLOSTRAC",60,0)
 ZB PARSEHDR^HLOPRS:"N":1:"D PARSEHDR^HLOSTRAC"
"RTN","HLOSTRAC",61,0)
 ZB DUP^HLOSRVR1:"N":1:"D DUP^HLOSTRAC"
"RTN","HLOSTRAC",62,0)
 ZB CLOSE^HLOT:"N":1:"D CLOSE^HLOSTRAC"
"RTN","HLOSTRAC",63,0)
 ;set break ZB10 in the client(start of $$READHDR^HLOT)
"RTN","HLOSTRAC",64,0)
 ZB ZB10^HLOT:"N":1:"D ZB10^HLOSTRAC"
"RTN","HLOSTRAC",65,0)
 ;set break ZB11 in the client(end of $$READHDR^HLOT)
"RTN","HLOSTRAC",66,0)
 ZB ZB11^HLOT:"N":1:"D ZB11^HLOSTRAC"
"RTN","HLOSTRAC",67,0)
 ;set break ZB12 in the client(start of $$READSEG^HLOT)
"RTN","HLOSTRAC",68,0)
 ZB ZB12^HLOT:"N":1:"D ZB12^HLOSTRAC"
"RTN","HLOSTRAC",69,0)
 ;set break ZB13 in the client(end of $$READSEG^HLOT)
"RTN","HLOSTRAC",70,0)
 ZB ZB13^HLOT:"N":1:"D ZB13^HLOSTRAC"
"RTN","HLOSTRAC",71,0)
 ;set break ZB14 in the client(start of $$WRITESEG^HLOT)
"RTN","HLOSTRAC",72,0)
 ZB ZB14^HLOT:"N":1:"D ZB14^HLOSTRAC"
"RTN","HLOSTRAC",73,0)
 ;set break ZB15 in the client(end of $$WRITESEG^HLOT)
"RTN","HLOSTRAC",74,0)
 ZB ZB15^HLOT:"N":1:"D ZB15^HLOSTRAC"
"RTN","HLOSTRAC",75,0)
 ;set break ZB16 in the client(start of $$WRITEHDR^HLOT)
"RTN","HLOSTRAC",76,0)
 ZB ZB16^HLOT:"N":1:"D ZB16^HLOSTRAC"
"RTN","HLOSTRAC",77,0)
 ;set break ZB17 in the client(end of $$WRITEHDR^HLOT)
"RTN","HLOSTRAC",78,0)
 ZB ZB17^HLOT:"N":1:"D ZB17^HLOSTRAC"
"RTN","HLOSTRAC",79,0)
 ;set break ZB18 in the client(start of $$ENDMSG^HLOT)
"RTN","HLOSTRAC",80,0)
 ZB ZB18^HLOT:"N":1:"D ZB18^HLOSTRAC"
"RTN","HLOSTRAC",81,0)
 ;set break ZB19 in the server(end of $$ENDMSG^HLOT)
"RTN","HLOSTRAC",82,0)
 ZB ZB19^HLOT:"N":1:"D ZB19^HLOSTRAC"
"RTN","HLOSTRAC",83,0)
 ZB ZB25^HLOTCP:"N":1:"D ZB25^HLOSTRAC"
"RTN","HLOSTRAC",84,0)
 ZB ZB26^HLOTCP:"N":1:"D ZB26^HLOSTRAC"
"RTN","HLOSTRAC",85,0)
 ;
"RTN","HLOSTRAC",86,0)
 ZB ZB27^HLOTCP:"N":1:"D ZB27^HLOSTRAC"
"RTN","HLOSTRAC",87,0)
 ;
"RTN","HLOSTRAC",88,0)
 ZB ZB28^HLOTCP:"N":1:"D ZB28^HLOSTRAC"
"RTN","HLOSTRAC",89,0)
 ;set break ZB29 in the server(after parsing the message header)
"RTN","HLOSTRAC",90,0)
 ZB ZB29^HLOSRVR1:"N":1:"D ZB29^HLOSTRAC"
"RTN","HLOSTRAC",91,0)
 ;set break ZB30 in the server(afterchecking if duplicate)
"RTN","HLOSTRAC",92,0)
 ZB ZB30^HLOSRVR1:"N":1:"D ZB30^HLOSTRAC"
"RTN","HLOSTRAC",93,0)
 ZB ZB31^HLOTCP:"N":1:"D WRITE^HLOTRACE(""Beginning READ over TCP..."")"
"RTN","HLOSTRAC",94,0)
 ZB ZB32^HLOTCP:"N":1:"D ZB32^HLOTRACE"
"RTN","HLOSTRAC",95,0)
 Q
"RTN","HLOSTRAC",96,0)
 ;
"RTN","HLOSTRAC",97,0)
WRITE(MSG) ;
"RTN","HLOSTRAC",98,0)
 N OLD
"RTN","HLOSTRAC",99,0)
 S OLD=$IO
"RTN","HLOSTRAC",100,0)
 U $PRINCIPAL
"RTN","HLOSTRAC",101,0)
 W !,?5,"Time: ",$$NOW^XLFDT,"   ",MSG
"RTN","HLOSTRAC",102,0)
 U OLD
"RTN","HLOSTRAC",103,0)
 Q
"RTN","HLOSTRAC",104,0)
WRITE2(MSG,VALUE) ;
"RTN","HLOSTRAC",105,0)
 N OLD,I
"RTN","HLOSTRAC",106,0)
 S OLD=$IO
"RTN","HLOSTRAC",107,0)
 U $PRINCIPAL
"RTN","HLOSTRAC",108,0)
 W !,?5,"Time: ",$$NOW^XLFDT,"   ",MSG
"RTN","HLOSTRAC",109,0)
 S I=0
"RTN","HLOSTRAC",110,0)
 W:$O(VALUE(0)) !
"RTN","HLOSTRAC",111,0)
 F  S I=$O(VALUE(I)) Q:'I  W VALUE(I)
"RTN","HLOSTRAC",112,0)
 U OLD
"RTN","HLOSTRAC",113,0)
 Q
"RTN","HLOSTRAC",114,0)
WRITE3(MSG) ;
"RTN","HLOSTRAC",115,0)
 N OLD
"RTN","HLOSTRAC",116,0)
 S OLD=$IO
"RTN","HLOSTRAC",117,0)
 U $PRINCIPAL
"RTN","HLOSTRAC",118,0)
 W !,MSG
"RTN","HLOSTRAC",119,0)
 U OLD
"RTN","HLOSTRAC",120,0)
 Q
"RTN","HLOSTRAC",121,0)
READMSG ;
"RTN","HLOSTRAC",122,0)
 ;
"RTN","HLOSTRAC",123,0)
 S HLOTRACE("COUNT")=HLOTRACE("COUNT")+1
"RTN","HLOSTRAC",124,0)
 S HLOTRACE("ERRORS")=0
"RTN","HLOSTRAC",125,0)
 I HLOTRACE("COUNT")>10 D
"RTN","HLOSTRAC",126,0)
 .N OLD,SEND
"RTN","HLOSTRAC",127,0)
 .S OLD=$IO
"RTN","HLOSTRAC",128,0)
 .U $PRINCIPAL
"RTN","HLOSTRAC",129,0)
 .W !
"RTN","HLOSTRAC",130,0)
 .S SEND=$$ASKYESNO^HLOUSR2("Do you want to trace more message transmissions","NO")
"RTN","HLOSTRAC",131,0)
 .I 'SEND S $ECODE=",UHLOSTOP,"
"RTN","HLOSTRAC",132,0)
 .U OLD
"RTN","HLOSTRAC",133,0)
 W !
"RTN","HLOSTRAC",134,0)
 D WRITE3^HLOSTRAC("Beginning to read next message...")
"RTN","HLOSTRAC",135,0)
 Q
"RTN","HLOSTRAC",136,0)
PARSEHDR ;
"RTN","HLOSTRAC",137,0)
 D WRITE^HLOSTRAC("Parsing the message header...")
"RTN","HLOSTRAC",138,0)
 Q
"RTN","HLOSTRAC",139,0)
DUP ;
"RTN","HLOSTRAC",140,0)
 D WRITE^HLOSTRAC("Checking if duplicate message...")
"RTN","HLOSTRAC",141,0)
 Q
"RTN","HLOSTRAC",142,0)
CLOSE ;
"RTN","HLOSTRAC",143,0)
 D WRITE^HLOSTRAC("Closing the port...")
"RTN","HLOSTRAC",144,0)
 Q
"RTN","HLOSTRAC",145,0)
 ;
"RTN","HLOSTRAC",146,0)
ERROR ;
"RTN","HLOSTRAC",147,0)
 I ($ECODE["EDITED") Q:$QUIT "" Q
"RTN","HLOSTRAC",148,0)
 I ($ECODE["ZINTERRUPT") Q:$QUIT "" Q
"RTN","HLOSTRAC",149,0)
 D WRITE^HLOSTRAC("*** ERROR *** : "_$ECODE)
"RTN","HLOSTRAC",150,0)
 S HLOTRACE("ERRORS")=HLOTRACE("ERRORS")+1
"RTN","HLOSTRAC",151,0)
 I HLOTRACE("ERRORS")>5 Q:$QUIT "" Q
"RTN","HLOSTRAC",152,0)
 S $ECODE=""
"RTN","HLOSTRAC",153,0)
 G READ^HLOSTRAC
"RTN","HLOSTRAC",154,0)
 Q:$QUIT "" Q
"RTN","HLOSTRAC",155,0)
 Q
"RTN","HLOSTRAC",156,0)
ZB10 ;
"RTN","HLOSTRAC",157,0)
 D WRITE^HLOSTRAC("Getting message header...")
"RTN","HLOSTRAC",158,0)
 Q
"RTN","HLOSTRAC",159,0)
ZB11 I $D(HDR) D WRITE2^HLOSTRAC(" Header follows...",.HDR)
"RTN","HLOSTRAC",160,0)
 D WRITE^HLOSTRAC($S(SUCCESS:"Got the header!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",161,0)
 Q
"RTN","HLOSTRAC",162,0)
ZB12 ;
"RTN","HLOSTRAC",163,0)
 D WRITE^HLOSTRAC("Getting next segment...")
"RTN","HLOSTRAC",164,0)
 Q
"RTN","HLOSTRAC",165,0)
ZB13 I $D(SEG) D WRITE2^HLOSTRAC(" Segment follows...",.SEG)
"RTN","HLOSTRAC",166,0)
 D WRITE^HLOSTRAC($S(RETURN:"Got the segment!",$G(HLCSTATE("MESSAGE ENDED")):"No more segments!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",167,0)
 Q
"RTN","HLOSTRAC",168,0)
ZB14 ;
"RTN","HLOSTRAC",169,0)
 D WRITE2^HLOSTRAC("Writing next segment...",.SEG)
"RTN","HLOSTRAC",170,0)
 Q
"RTN","HLOSTRAC",171,0)
ZB15 D WRITE^HLOSTRAC($S(RETURN:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",172,0)
 Q
"RTN","HLOSTRAC",173,0)
ZB16 ;
"RTN","HLOSTRAC",174,0)
 D WRITE3^HLOSTRAC("Beginning to write the commit acknowledgment...")
"RTN","HLOSTRAC",175,0)
 D WRITE2^HLOSTRAC("Writing header segment...",.HDR)
"RTN","HLOSTRAC",176,0)
 Q
"RTN","HLOSTRAC",177,0)
ZB17 D WRITE^HLOSTRAC($S(SUCCESS:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",178,0)
 Q
"RTN","HLOSTRAC",179,0)
ZB18 ;
"RTN","HLOSTRAC",180,0)
 D WRITE^HLOSTRAC("Writing message terminators and flushing buffer...")
"RTN","HLOSTRAC",181,0)
 Q
"RTN","HLOSTRAC",182,0)
ZB19 D WRITE^HLOSTRAC($S(RETURN:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOSTRAC",183,0)
 Q
"RTN","HLOSTRAC",184,0)
ZB25 D WRITE^HLOSTRAC("Opening the port...")
"RTN","HLOSTRAC",185,0)
 Q
"RTN","HLOSTRAC",186,0)
ZB26 D WRITE^HLOSTRAC("Waiting for remote client to connect...")
"RTN","HLOSTRAC",187,0)
 Q
"RTN","HLOSTRAC",188,0)
ZB27 D WRITE^HLOSTRAC("Remote client connected...")
"RTN","HLOSTRAC",189,0)
 Q
"RTN","HLOSTRAC",190,0)
ZB28 D:'$G(HLCSTATE("CONNECTED")) WRITE^HLOSTRAC("**** UNABLE TO OPEN PORT *****")
"RTN","HLOSTRAC",191,0)
 Q
"RTN","HLOSTRAC",192,0)
ZB29 D WRITE3^HLOSTRAC("*** THE MESSAGE HEADER COULD NOT BE PARSED   ***")
"RTN","HLOSTRAC",193,0)
 Q
"RTN","HLOSTRAC",194,0)
ZB30 D WRITE3^HLOSTRAC("*** THE MESSAGE IS A DUPLICATE AND WILL BE DISCARDED   ***")
"RTN","HLOSTRAC",195,0)
 D WRITE3^HLOSTRAC("*** THE ORIGINAL COMMIT ACKNOWLEDMENT WILL BE RETURNED ***")
"RTN","HLOSTRAC",196,0)
 Q
"RTN","HLOSTRAC",197,0)
 ;
"RTN","HLOSTRAC",198,0)
ZB3 ;
"RTN","HLOSTRAC",199,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOSTRAC",200,0)
 D END^HLOSRVR
"RTN","HLOSTRAC",201,0)
 N CON,MSG
"RTN","HLOSTRAC",202,0)
 S CON=($ZA\8192#2)
"RTN","HLOSTRAC",203,0)
 S MSG="Error encountered, $ECODE="_$ECODE
"RTN","HLOSTRAC",204,0)
 D WRITE^HLOTRACE(MSG)
"RTN","HLOSTRAC",205,0)
 S MSG=$S(CON:"           TCP connection still active",1:"          TCP connection was dropped")
"RTN","HLOSTRAC",206,0)
 D WRITE3^HLOTRACE(MSG)
"RTN","HLOSTRAC",207,0)
 I ($ECODE["EDITED") Q:$QUIT "" Q
"RTN","HLOSTRAC",208,0)
 I ($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D
"RTN","HLOSTRAC",209,0)
 .;
"RTN","HLOSTRAC",210,0)
 E  D
"RTN","HLOSTRAC",211,0)
 .D ^%ZTER
"RTN","HLOSTRAC",212,0)
 Q
"RTN","HLOSTRAC",213,0)
ZB32 D:('$G(RETURN)) WRITE^HLOTRACE("**** FAILED ****")
"RTN","HLOSTRAC",214,0)
 D:$G(RETURN) WRITE3^HLOTRACE("")
"RTN","HLOSTRAC",215,0)
 D:$G(RETURN) WRITE3^HLOTRACE($G(BUF))
"RTN","HLOSTRAC",216,0)
 Q
"RTN","HLOTCP")
0^12^B87019003^B85513944
"RTN","HLOTCP",1,0)
HLOTCP ;ALB/CJM- TCP/IP I/O - 10/4/94 1pm ;03/01/2011
"RTN","HLOTCP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131,134,137,138,139,146,153**;Oct 13, 1995;Build 11
"RTN","HLOTCP",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOTCP",4,0)
 ;
"RTN","HLOTCP",5,0)
OPEN(HLCSTATE,LOGICAL) ;
"RTN","HLOTCP",6,0)
 ;This may be called either in the context of a client or a server.
"RTN","HLOTCP",7,0)
 ;For the server, there are 3 situations:
"RTN","HLOTCP",8,0)
 ; 1) The server is not concurrent.  In this case the TCP device should be opened.
"RTN","HLOTCP",9,0)
 ; 2) The server is concurrent, but this process was spawned by the OS
"RTN","HLOTCP",10,0)
 ;    (via a VMS TCP Service)  In this case, the device should be opened
"RTN","HLOTCP",11,0)
 ;    via the LOGICAL that was passed in.
"RTN","HLOTCP",12,0)
 ;  3) The server is concurrent, but this process was spawned by the
"RTN","HLOTCP",13,0)
 ;     TaskMan multi-listener.  In this case TaskMan already opened the
"RTN","HLOTCP",14,0)
 ;     device.  This case can be determined by the absence of the LOGICAL
"RTN","HLOTCP",15,0)
 ;     input parameter.
"RTN","HLOTCP",16,0)
 ;
"RTN","HLOTCP",17,0)
 N IP,PORT,DNSFLAG
"RTN","HLOTCP",18,0)
 ;
"RTN","HLOTCP",19,0)
 S DNSFLAG=0 ;DNS has not been contacted for IP
"RTN","HLOTCP",20,0)
 ;
"RTN","HLOTCP",21,0)
 S:'$G(HLCSTATE("SERVER")) IP=HLCSTATE("LINK","IP")
"RTN","HLOTCP",22,0)
 S PORT=HLCSTATE("LINK","PORT")
"RTN","HLOTCP",23,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOTCP",24,0)
 S HLCSTATE("READ HEADER")="READHDR^HLOTCP"
"RTN","HLOTCP",25,0)
 S HLCSTATE("WRITE HEADER")="WRITEHDR^HLOTCP"
"RTN","HLOTCP",26,0)
 S HLCSTATE("READ SEGMENT")="READSEG^HLOTCP"
"RTN","HLOTCP",27,0)
 S HLCSTATE("WRITE SEGMENT")="WRITESEG^HLOTCP"
"RTN","HLOTCP",28,0)
 S HLCSTATE("END MESSAGE")="ENDMSG^HLOTCP"
"RTN","HLOTCP",29,0)
 S HLCSTATE("CLOSE")="CLOSE^HLOTCP"
"RTN","HLOTCP",30,0)
 S HLCSTATE("TCP BUFFER")=""
"RTN","HLOTCP",31,0)
 S HLCSTATE("TCP BUFFER $X")=0
"RTN","HLOTCP",32,0)
 ;
"RTN","HLOTCP",33,0)
 ;spawned by TaskMan multi-listener? If so, the device has already been opened
"RTN","HLOTCP",34,0)
 I $G(HLCSTATE("SERVER")),$G(HLCSTATE("LINK","SERVER"))="1^M",$G(LOGICAL)="" D  Q
"RTN","HLOTCP",35,0)
 .S HLCSTATE("DEVICE")=IO(0),HLCSTATE("FLUSH")="!",HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",36,0)
 .S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",37,0)
 ;
"RTN","HLOTCP",38,0)
 ;if no IP, not a server, give DNS a shot
"RTN","HLOTCP",39,0)
 I '$G(HLCSTATE("SERVER")),IP="" S DNSFLAG=1,IP=$$DNS(HLCSTATE("LINK","DOMAIN")),HLCSTATE("LINK","IP")=IP Q:IP=""
"RTN","HLOTCP",40,0)
 ;
"RTN","HLOTCP",41,0)
RETRY ;
"RTN","HLOTCP",42,0)
 ;
"RTN","HLOTCP",43,0)
 I HLCSTATE("SYSTEM","OS")="DSM" D
"RTN","HLOTCP",44,0)
 .S HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",45,0)
 .I $G(LOGICAL)]"" S HLCSTATE("DEVICE")=LOGICAL
"RTN","HLOTCP",46,0)
 .E  S HLCSTATE("DEVICE")=PORT
"RTN","HLOTCP",47,0)
 .S HLCSTATE("FLUSH")="!"
"RTN","HLOTCP",48,0)
 .I $G(HLCSTATE("SERVER")) D
"RTN","HLOTCP",49,0)
 ..O:$G(LOGICAL)]"" HLCSTATE("DEVICE"):(TCPDEV,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",50,0)
 ..O:$G(LOGICAL)="" HLCSTATE("DEVICE"):(TCPCHAN,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",51,0)
 ..I $T D
"RTN","HLOTCP",52,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",53,0)
 ...U HLCSTATE("DEVICE"):NOECHO
"RTN","HLOTCP",54,0)
 .E  D  ;client
"RTN","HLOTCP",55,0)
 ..O HLCSTATE("DEVICE"):(TCPCHAN,ADDRESS=IP,BLOCKSIZE=512):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",56,0)
 ..I $T D
"RTN","HLOTCP",57,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",58,0)
 ...U HLCSTATE("DEVICE"):NOECHO
"RTN","HLOTCP",59,0)
 E  I HLCSTATE("SYSTEM","OS")="CACHE" D
"RTN","HLOTCP",60,0)
 .S HLCSTATE("FLUSH")="!"
"RTN","HLOTCP",61,0)
 .I $G(LOGICAL)]"" S HLCSTATE("DEVICE")=LOGICAL
"RTN","HLOTCP",62,0)
 .E  S HLCSTATE("DEVICE")="|TCP|"_PORT
"RTN","HLOTCP",63,0)
 .S HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",64,0)
 .I $G(HLCSTATE("SERVER")) D
"RTN","HLOTCP",65,0)
 ..I HLCSTATE("SERVER")="1^S" D  Q
"RTN","HLOTCP",66,0)
 ...;single server (no concurrent connections)
"RTN","HLOTCP",67,0)
ZB25 ...;
"RTN","HLOTCP",68,0)
 ...O HLCSTATE("DEVICE"):(:PORT:"+A-S":::):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",69,0)
 ...I $T D
"RTN","HLOTCP",70,0)
 ....N A
"RTN","HLOTCP",71,0)
ZB26 ....S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",72,0)
 ....U HLCSTATE("DEVICE")
"RTN","HLOTCP",73,0)
 ....F  R *A:HLCSTATE("READ TIMEOUT") Q:$T  I $$CHKSTOP^HLOPROC S HLCSTATE("CONNECTED")=0 D CLOSE(.HLCSTATE) Q
"RTN","HLOTCP",74,0)
ZB27 ....;
"RTN","HLOTCP",75,0)
 ...E  D
"RTN","HLOTCP",76,0)
ZB28 ....;
"RTN","HLOTCP",77,0)
 ..;multi-server spawned by OS - VMS TCP Services
"RTN","HLOTCP",78,0)
 ..O HLCSTATE("DEVICE")::HLCSTATE("OPEN TIMEOUT") I '$T S HLCSTATE("CONNECTED")=0 Q
"RTN","HLOTCP",79,0)
 ..S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",80,0)
 ..U HLCSTATE("DEVICE"):(::"-S")
"RTN","HLOTCP",81,0)
 ..;
"RTN","HLOTCP",82,0)
 .E  D  ;client
"RTN","HLOTCP",83,0)
 ..S HLCSTATE("TCP BUFFER SIZE")=512
"RTN","HLOTCP",84,0)
 ..O HLCSTATE("DEVICE"):(IP:PORT:"-S":::):HLCSTATE("OPEN TIMEOUT")
"RTN","HLOTCP",85,0)
 ..I $T D
"RTN","HLOTCP",86,0)
 ...S HLCSTATE("CONNECTED")=1
"RTN","HLOTCP",87,0)
 E  D  ;any other system but Cache or DSM
"RTN","HLOTCP",88,0)
 .S HLCSTATE("TCP BUFFER SIZE")=256
"RTN","HLOTCP",89,0)
 .D CALL^%ZISTCP(IP,PORT,HLCSTATE("OPEN TIMEOUT"))
"RTN","HLOTCP",90,0)
 .S HLCSTATE("CONNECTED")='POP
"RTN","HLOTCP",91,0)
 .I HLCSTATE("CONNECTED") S HLCSTATE("DEVICE")=IO
"RTN","HLOTCP",92,0)
 ;
"RTN","HLOTCP",93,0)
 ;if not connected, not the server, give DNS a shot if not tried already
"RTN","HLOTCP",94,0)
 I '$G(HLCSTATE("SERVER")),'HLCSTATE("CONNECTED"),'DNSFLAG S DNSFLAG=1,IP=$$DNS(HLCSTATE("LINK","DOMAIN")) I IP]"",IP'=HLCSTATE("LINK","IP") S HLCSTATE("LINK","IP")=IP Q:IP=""  G RETRY
"RTN","HLOTCP",95,0)
 ;
"RTN","HLOTCP",96,0)
 I HLCSTATE("CONNECTED"),DNSFLAG S $P(^HLCS(870,HLCSTATE("LINK","IEN"),400),"^")=IP
"RTN","HLOTCP",97,0)
 Q
"RTN","HLOTCP",98,0)
 ;
"RTN","HLOTCP",99,0)
DNS(DOMAIN) ;
"RTN","HLOTCP",100,0)
 Q $P($$ADDRESS^XLFNSLK(DOMAIN),",")
"RTN","HLOTCP",101,0)
 ;
"RTN","HLOTCP",102,0)
WRITEHDR(HLCSTATE,HDR) ;
"RTN","HLOTCP",103,0)
 ;
"RTN","HLOTCP",104,0)
 ;insure that package buffer is empty
"RTN","HLOTCP",105,0)
 K HLCSTATE("BUFFER")
"RTN","HLOTCP",106,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0
"RTN","HLOTCP",107,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0
"RTN","HLOTCP",108,0)
 ;
"RTN","HLOTCP",109,0)
 ;Start the message with <SB>, then write the header
"RTN","HLOTCP",110,0)
 N SEG
"RTN","HLOTCP",111,0)
 S SEG(1)=$C(11)_HDR(1)
"RTN","HLOTCP",112,0)
 S SEG(2)=HDR(2)
"RTN","HLOTCP",113,0)
 Q $$WRITESEG(.HLCSTATE,.SEG)
"RTN","HLOTCP",114,0)
 ;
"RTN","HLOTCP",115,0)
WRITESEG(HLCSTATE,SEG) ;
"RTN","HLOTCP",116,0)
 N I,LAST
"RTN","HLOTCP",117,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=HLCSTATE("BUFFER","SEGMENT COUNT")+1
"RTN","HLOTCP",118,0)
 S I=0,LAST=$O(SEG(99999),-1)
"RTN","HLOTCP",119,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOTCP",120,0)
 .I HLCSTATE("BUFFER","BYTE COUNT")>HLCSTATE("SYSTEM","BUFFER") D FLUSH
"RTN","HLOTCP",121,0)
 .I I=LAST S SEG(I)=SEG(I)_$C(13)
"RTN","HLOTCP",122,0)
 .S HLCSTATE("BUFFER",HLCSTATE("BUFFER","SEGMENT COUNT"),I)=SEG(I),HLCSTATE("BUFFER","BYTE COUNT")=HLCSTATE("BUFFER","BYTE COUNT")+$L(SEG(I))+20
"RTN","HLOTCP",123,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOTCP",124,0)
 ;
"RTN","HLOTCP",125,0)
FLUSH ;flushes the HL7 package buffer, and the system TCP buffer when full
"RTN","HLOTCP",126,0)
 N SEGMENT,MAX
"RTN","HLOTCP",127,0)
 S SEGMENT=0
"RTN","HLOTCP",128,0)
 ;
"RTN","HLOTCP",129,0)
 S MAX=HLCSTATE("TCP BUFFER SIZE")-2
"RTN","HLOTCP",130,0)
 ;
"RTN","HLOTCP",131,0)
 U HLCSTATE("DEVICE") I (HLCSTATE("SYSTEM","OS")="CACHE") S HLCSTATE("CONNECTED")=($ZA\8192#2) I 'HLCSTATE("CONNECTED") D CLOSE(.HLCSTATE)
"RTN","HLOTCP",132,0)
 F  S SEGMENT=$O(HLCSTATE("BUFFER",SEGMENT)) Q:'SEGMENT  D
"RTN","HLOTCP",133,0)
 .N I S I=0
"RTN","HLOTCP",134,0)
 .F  S I=$O(HLCSTATE("BUFFER",SEGMENT,I)) Q:'I  D
"RTN","HLOTCP",135,0)
 ..N LINE
"RTN","HLOTCP",136,0)
 ..S LINE=HLCSTATE("BUFFER",SEGMENT,I)
"RTN","HLOTCP",137,0)
 ..;put the line in the TCP buffer, or as much as will fit - flush the buffer when it gets full
"RTN","HLOTCP",138,0)
 ..F  Q:LINE=""  D
"RTN","HLOTCP",139,0)
 ...N INC
"RTN","HLOTCP",140,0)
 ...;INC is how much space is left in the buffer
"RTN","HLOTCP",141,0)
 ...S INC=MAX-HLCSTATE("TCP BUFFER $X")
"RTN","HLOTCP",142,0)
 ...I '($L(LINE)>INC) D
"RTN","HLOTCP",143,0)
 ....S HLCSTATE("TCP BUFFER")=HLCSTATE("TCP BUFFER")_LINE
"RTN","HLOTCP",144,0)
 ....S HLCSTATE("TCP BUFFER $X")=HLCSTATE("TCP BUFFER $X")+$L(LINE)
"RTN","HLOTCP",145,0)
 ....S LINE=""
"RTN","HLOTCP",146,0)
 ...E  D
"RTN","HLOTCP",147,0)
 ....S HLCSTATE("TCP BUFFER")=HLCSTATE("TCP BUFFER")_$E(LINE,1,INC)
"RTN","HLOTCP",148,0)
 ....S HLCSTATE("TCP BUFFER $X")=MAX
"RTN","HLOTCP",149,0)
 ....S LINE=$E(LINE,INC+1,99999)
"RTN","HLOTCP",150,0)
 ...I HLCSTATE("TCP BUFFER $X")=MAX D
"RTN","HLOTCP",151,0)
 ....W HLCSTATE("TCP BUFFER"),@HLCSTATE("FLUSH")
"RTN","HLOTCP",152,0)
 ....S HLCSTATE("TCP BUFFER")="",HLCSTATE("TCP BUFFER $X")=0
"RTN","HLOTCP",153,0)
 K HLCSTATE("BUFFER")
"RTN","HLOTCP",154,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=1
"RTN","HLOTCP",155,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0
"RTN","HLOTCP",156,0)
 Q
"RTN","HLOTCP",157,0)
 ;
"RTN","HLOTCP",158,0)
READSEG(HLCSTATE,SEG) ;
"RTN","HLOTCP",159,0)
 ;
"RTN","HLOTCP",160,0)
 ;Output:
"RTN","HLOTCP",161,0)
 ;  SEG - returns the segment (pass by reference)
"RTN","HLOTCP",162,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOTCP",163,0)
 ;
"RTN","HLOTCP",164,0)
 K SEG
"RTN","HLOTCP",165,0)
 ;**START P139 CJM - if the header segment has been read, and <EB> is encountered before the <CR>, then accept whatever came before <EB> as a segment
"RTN","HLOTCP",166,0)
 Q:HLCSTATE("MESSAGE ENDED") 0
"RTN","HLOTCP",167,0)
 ;**END P139
"RTN","HLOTCP",168,0)
 ;
"RTN","HLOTCP",169,0)
 N SUCCESS,COUNT,BUF
"RTN","HLOTCP",170,0)
 S (COUNT,SUCCESS)=0
"RTN","HLOTCP",171,0)
 ;
"RTN","HLOTCP",172,0)
 ;anything left from last read?
"RTN","HLOTCP",173,0)
 S BUF=HLCSTATE("READ")
"RTN","HLOTCP",174,0)
 S HLCSTATE("READ")=""
"RTN","HLOTCP",175,0)
 I BUF]"" D  ;something was left!
"RTN","HLOTCP",176,0)
 .S COUNT=1
"RTN","HLOTCP",177,0)
 .I BUF[$C(13) D  Q
"RTN","HLOTCP",178,0)
 ..S SEG(1)=$P(BUF,$C(13)),BUF=$P(BUF,$C(13),2,999999)
"RTN","HLOTCP",179,0)
 ..S SUCCESS=1
"RTN","HLOTCP",180,0)
 .;**START P139 CJM
"RTN","HLOTCP",181,0)
 .I HLCSTATE("MESSAGE STARTED"),BUF[$C(28) D  Q
"RTN","HLOTCP",182,0)
 ..S SEG(1)=$P(BUF,$C(28)),BUF=$P(BUF,$C(28),2,999999)
"RTN","HLOTCP",183,0)
 ..S SUCCESS=1
"RTN","HLOTCP",184,0)
 ..S HLCSTATE("MESSAGE ENDED")=1
"RTN","HLOTCP",185,0)
 .;**END P139 CJM
"RTN","HLOTCP",186,0)
 .S SEG(1)=BUF,BUF=""
"RTN","HLOTCP",187,0)
 ;
"RTN","HLOTCP",188,0)
 ; *** Begin HL*1.6*146 - RBN ***
"RTN","HLOTCP",189,0)
 ;I 'SUCCESS U HLCSTATE("DEVICE") F  R BUF:HLCSTATE("READ TIMEOUT") Q:'$T D Q:SUCCESS
"RTN","HLOTCP",190,0)
 I 'SUCCESS U HLCSTATE("DEVICE") F  Q:'$$READ(.BUF)  D  Q:SUCCESS
"RTN","HLOTCP",191,0)
 .;** End HL*1.6*146 - RBN ***
"RTN","HLOTCP",192,0)
 .;
"RTN","HLOTCP",193,0)
 .I BUF[$C(13) S SUCCESS=1,COUNT=COUNT+1,SEG(COUNT)=$P(BUF,$C(13)),BUF=$P(BUF,$C(13),2,999999) Q
"RTN","HLOTCP",194,0)
 .;
"RTN","HLOTCP",195,0)
 .;**START P139 CJM
"RTN","HLOTCP",196,0)
 .I HLCSTATE("MESSAGE STARTED"),BUF[$C(28) S SUCCESS=1,HLCSTATE("MESSAGE ENDED")=1,COUNT=COUNT+1,SEG(COUNT)=$P(BUF,$C(28)),BUF=$P(BUF,$C(28),2,999999) Q
"RTN","HLOTCP",197,0)
 .;**END P139 CJM
"RTN","HLOTCP",198,0)
 .;
"RTN","HLOTCP",199,0)
 .S COUNT=COUNT+1,SEG(COUNT)=BUF
"RTN","HLOTCP",200,0)
 ;
"RTN","HLOTCP",201,0)
 I SUCCESS D
"RTN","HLOTCP",202,0)
 .S HLCSTATE("READ")=BUF ;save the leftover
"RTN","HLOTCP",203,0)
 .I COUNT>1,SEG(COUNT)="" K SEG(COUNT) S COUNT=COUNT-1
"RTN","HLOTCP",204,0)
 ;Cache can return the connection status
"RTN","HLOTCP",205,0)
 E  I (HLCSTATE("SYSTEM","OS")="CACHE") S HLCSTATE("CONNECTED")=($ZA\8192#2) I 'HLCSTATE("CONNECTED") D CLOSE(.HLCSTATE)
"RTN","HLOTCP",206,0)
 ;
"RTN","HLOTCP",207,0)
 ;if the <EB> character was encountered, then there are no more segments in the message, set the end of message flag
"RTN","HLOTCP",208,0)
 I SUCCESS,SEG(COUNT)[$C(28) D
"RTN","HLOTCP",209,0)
 .K SEG
"RTN","HLOTCP",210,0)
 .S SUCCESS=0
"RTN","HLOTCP",211,0)
 .S HLCSTATE("MESSAGE ENDED")=1
"RTN","HLOTCP",212,0)
 Q SUCCESS
"RTN","HLOTCP",213,0)
 ;
"RTN","HLOTCP",214,0)
READHDR(HLCSTATE,HDR) ;
"RTN","HLOTCP",215,0)
 ;reads the next header segment in the message stream, discarding everything that comes before it
"RTN","HLOTCP",216,0)
 ;
"RTN","HLOTCP",217,0)
 N SEG,SUCCESS,J,I
"RTN","HLOTCP",218,0)
 S SUCCESS=0
"RTN","HLOTCP",219,0)
 K HDR
"RTN","HLOTCP",220,0)
 F  Q:'$$READSEG(.HLCSTATE,.SEG)  D  Q:SUCCESS
"RTN","HLOTCP",221,0)
 .S I=0
"RTN","HLOTCP",222,0)
 .;look for the <SB>
"RTN","HLOTCP",223,0)
 .;perhaps the <SB> isn't in the first line
"RTN","HLOTCP",224,0)
 .F  S I=$O(SEG(I)) Q:'I  D  Q:SUCCESS
"RTN","HLOTCP",225,0)
 ..I (SEG(I)'[$C(11)) K SEG(I) Q
"RTN","HLOTCP",226,0)
 ..S SEG(I)=$P(SEG(I),$C(11),2)
"RTN","HLOTCP",227,0)
 ..S SUCCESS=1
"RTN","HLOTCP",228,0)
 ..K:SEG(I)="" SEG(I)
"RTN","HLOTCP",229,0)
 I SUCCESS S (I,J)=0 F  S J=$O(SEG(J)) Q:'J  S I=I+1,HDR(I)=SEG(J)
"RTN","HLOTCP",230,0)
 Q SUCCESS
"RTN","HLOTCP",231,0)
 ;
"RTN","HLOTCP",232,0)
CLOSE(HLCSTATE) ;
"RTN","HLOTCP",233,0)
 CLOSE HLCSTATE("DEVICE")
"RTN","HLOTCP",234,0)
 ;**P146 START CJM
"RTN","HLOTCP",235,0)
 I $G(HLCSTATE("READ TIMEOUT","CHANGED")) D PUTTIME(.HLCSTATE)
"RTN","HLOTCP",236,0)
 ;**P146 END CJM
"RTN","HLOTCP",237,0)
 Q
"RTN","HLOTCP",238,0)
 ;
"RTN","HLOTCP",239,0)
ENDMSG(HLCSTATE)        ;
"RTN","HLOTCP",240,0)
 N SEG
"RTN","HLOTCP",241,0)
 S SEG(1)=$C(28)
"RTN","HLOTCP",242,0)
 I $$WRITESEG(.HLCSTATE,.SEG) D  Q 1
"RTN","HLOTCP",243,0)
 .D FLUSH
"RTN","HLOTCP",244,0)
 .I HLCSTATE("TCP BUFFER $X") D
"RTN","HLOTCP",245,0)
 ..U HLCSTATE("DEVICE")
"RTN","HLOTCP",246,0)
 ..W HLCSTATE("TCP BUFFER"),@HLCSTATE("FLUSH")
"RTN","HLOTCP",247,0)
 ..S HLCSTATE("TCP BUFFER")=""
"RTN","HLOTCP",248,0)
 ..S HLCSTATE("TCP BUFFER $X")=0
"RTN","HLOTCP",249,0)
 Q 0
"RTN","HLOTCP",250,0)
 ;
"RTN","HLOTCP",251,0)
 ;**P146 START CJM
"RTN","HLOTCP",252,0)
READ(BUF) ;
"RTN","HLOTCP",253,0)
 ;Performs a READ to BUF and returns the $T result as the function value.
"RTN","HLOTCP",254,0)
 ;For client reads the timeout value is dynamically adjusted based
"RTN","HLOTCP",255,0)
 ;on a random sample. For server reads the timeout is static.
"RTN","HLOTCP",256,0)
 ;
"RTN","HLOTCP",257,0)
 ;
"RTN","HLOTCP",258,0)
ZB31 ;
"RTN","HLOTCP",259,0)
 N RETURN
"RTN","HLOTCP",260,0)
 S RETURN=0
"RTN","HLOTCP",261,0)
 ;for the server the timeout is static
"RTN","HLOTCP",262,0)
 I $G(HLCSTATE("SERVER")) D
"RTN","HLOTCP",263,0)
 .R BUF:HLCSTATE("READ TIMEOUT")
"RTN","HLOTCP",264,0)
 .S RETURN=$T
"RTN","HLOTCP",265,0)
 ;
"RTN","HLOTCP",266,0)
 E  D  ;client
"RTN","HLOTCP",267,0)
 .I ($R(100)<10) D
"RTN","HLOTCP",268,0)
 ..;measure how long the READ really takes
"RTN","HLOTCP",269,0)
 .. N T1,T2
"RTN","HLOTCP",270,0)
 .. S T1=$$NOW^XLFDT
"RTN","HLOTCP",271,0)
 .. R BUF:100
"RTN","HLOTCP",272,0)
 ..I $T D
"RTN","HLOTCP",273,0)
 ...S RETURN=1
"RTN","HLOTCP",274,0)
 ...S T2=$$NOW^XLFDT
"RTN","HLOTCP",275,0)
 ...D SETTIME($$FMDIFF^XLFDT(T2,T1,2))
"RTN","HLOTCP",276,0)
 ..E  D
"RTN","HLOTCP",277,0)
 ...S RETURN=0
"RTN","HLOTCP",278,0)
 .E  D
"RTN","HLOTCP",279,0)
 ..R BUF:HLCSTATE("READ TIMEOUT")
"RTN","HLOTCP",280,0)
 ..S RETURN=$T
"RTN","HLOTCP",281,0)
ZB32 ;
"RTN","HLOTCP",282,0)
 ;
"RTN","HLOTCP",283,0)
 Q RETURN
"RTN","HLOTCP",284,0)
 ;
"RTN","HLOTCP",285,0)
SETTIME(TIME) ;
"RTN","HLOTCP",286,0)
 ;Re-sets the Read Timeout based on an algorithm that uses the
"RTN","HLOTCP",287,0)
 ;new read time + the prior 4 historical values.
"RTN","HLOTCP",288,0)
 ;
"RTN","HLOTCP",289,0)
 N MAX,I,TEMP
"RTN","HLOTCP",290,0)
 S HLCSTATE("READ TIMEOUT","HISTORICAL")=TIME_"^"_$P(HLCSTATE("READ TIMEOUT","HISTORICAL"),"^",1,4)
"RTN","HLOTCP",291,0)
 S MAX=0
"RTN","HLOTCP",292,0)
 F I=1:1:5 S TEMP=$P(HLCSTATE("READ TIMEOUT","HISTORICAL"),"^",I) I TEMP>MAX S MAX=TEMP
"RTN","HLOTCP",293,0)
 S TEMP=MAX+5
"RTN","HLOTCP",294,0)
 I TEMP<20 S TEMP=20
"RTN","HLOTCP",295,0)
 I TEMP>60 S TEMP=60
"RTN","HLOTCP",296,0)
 S HLCSTATE("READ TIMEOUT")=TEMP
"RTN","HLOTCP",297,0)
 S HLCSTATE("READ TIMEOUT","CHANGED")=1
"RTN","HLOTCP",298,0)
 Q
"RTN","HLOTCP",299,0)
 ;
"RTN","HLOTCP",300,0)
GETTIME(HLCSTATE) ;
"RTN","HLOTCP",301,0)
 ;Gets from ^HLTMP the current read timeout for the client link and the
"RTN","HLOTCP",302,0)
 ;historical data that the timeout value is based on.
"RTN","HLOTCP",303,0)
 N DATA
"RTN","HLOTCP",304,0)
 S DATA=$G(^HLTMP("READ TIMEOUT",HLCSTATE("LINK","NAME")))
"RTN","HLOTCP",305,0)
 I $P(DATA,"^")<20 D
"RTN","HLOTCP",306,0)
 .S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOTCP",307,0)
 E  D
"RTN","HLOTCP",308,0)
 .S HLCSTATE("READ TIMEOUT")=$P(DATA,"^")
"RTN","HLOTCP",309,0)
 S HLCSTATE("READ TIMEOUT","HISTORICAL")=$P(DATA,"^",2,6)
"RTN","HLOTCP",310,0)
 S HLCSTATE("READ TIMEOUT","CHANGED")=0
"RTN","HLOTCP",311,0)
 Q
"RTN","HLOTCP",312,0)
 ;
"RTN","HLOTCP",313,0)
PUTTIME(HLCSTATE) ;
"RTN","HLOTCP",314,0)
 ;Stores to ^HLTMP the current read timeout for the client link and
"RTN","HLOTCP",315,0)
 ;the historical data that the timeout value is based on.
"RTN","HLOTCP",316,0)
 S ^HLTMP("READ TIMEOUT",HLCSTATE("LINK","NAME"))=HLCSTATE("READ TIMEOUT")_"^"_HLCSTATE("READ TIMEOUT","HISTORICAL")
"RTN","HLOTCP",317,0)
 Q
"RTN","HLOTCP",318,0)
 ;**P146 END CJM
"RTN","HLOTRACE")
0^10^B73989818^B65409615
"RTN","HLOTRACE",1,0)
HLOTRACE ;;OIFO-OAK/PIJ/CJM ;03/07/2011
"RTN","HLOTRACE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**146,147,153** ;Oct 13, 1995;Build 11
"RTN","HLOTRACE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOTRACE",4,0)
 ;;
"RTN","HLOTRACE",5,0)
 ;; HLO CLIENT TRACE Tool
"RTN","HLOTRACE",6,0)
 ;; *** For troubleshooting HLO client issues ***
"RTN","HLOTRACE",7,0)
 ;;     Client runs in the foreground and writes trace statements
"RTN","HLOTRACE",8,0)
 ;;     to the screen.
"RTN","HLOTRACE",9,0)
 ;; 
"RTN","HLOTRACE",10,0)
START ;
"RTN","HLOTRACE",11,0)
 N CONF
"RTN","HLOTRACE",12,0)
 I '$G(DUZ) W !,"Your DUZ must be set!" Q
"RTN","HLOTRACE",13,0)
 D OWNSKEY^XUSRB(.CONF,"XUPROG",DUZ)
"RTN","HLOTRACE",14,0)
 I 'CONF(0) D  Q
"RTN","HLOTRACE",15,0)
 . W !!,"   Sorry, you are not authorized to use this tool.",!!
"RTN","HLOTRACE",16,0)
 ;I $P($$VERSION^%ZOSV(1),"/",1)'="Cache for OpenVMS" D  Q
"RTN","HLOTRACE",17,0)
 I $P($$VERSION^%ZOSV(1),"/",1)'["Cache" D  Q
"RTN","HLOTRACE",18,0)
 . W !!,"   Sorry, this tool can only be used under Cache",!!
"RTN","HLOTRACE",19,0)
 N LINK,PORT,QUE,SUB,WORK,HLMSTATE,HLCSTATE,OLD,MAXTRACE,TRACECNT
"RTN","HLOTRACE",20,0)
 S LINK=$$ASKLINK^HLOUSR
"RTN","HLOTRACE",21,0)
 Q:LINK=""
"RTN","HLOTRACE",22,0)
 S PORT=$$ASKPORT(LINK)
"RTN","HLOTRACE",23,0)
 Q:'PORT
"RTN","HLOTRACE",24,0)
 S SUB=LINK_":"_PORT
"RTN","HLOTRACE",25,0)
 S QUE=$$ASKQUE(SUB)
"RTN","HLOTRACE",26,0)
 Q:QUE=""
"RTN","HLOTRACE",27,0)
 ZB /INTERRUPT:NORMAL ;disable CTRL-C breaks
"RTN","HLOTRACE",28,0)
 L +^HLB("QUEUE","OUT",SUB,QUE):20
"RTN","HLOTRACE",29,0)
 ;
"RTN","HLOTRACE",30,0)
 I '$T W !,"That queue is currently being processed. You need to either stop that link,",!,"stop that queue, or totally stop HLO so that this tool can be used." Q
"RTN","HLOTRACE",31,0)
 I '$O(^HLB("QUEUE","OUT",SUB,QUE,0)) W !,"There are no messages pending on that queue!" Q
"RTN","HLOTRACE",32,0)
 S TRACECNT=0
"RTN","HLOTRACE",33,0)
 S MAXTRACE=$$ASKCOUNT
"RTN","HLOTRACE",34,0)
 Q:(MAXTRACE<1)
"RTN","HLOTRACE",35,0)
 S WORK("QUEUE")=QUE,WORK("LINK")=SUB
"RTN","HLOTRACE",36,0)
 D SETBREAKS
"RTN","HLOTRACE",37,0)
 D DOWORK^HLOCLNT(.WORK)
"RTN","HLOTRACE",38,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOTRACE",39,0)
 ;
"RTN","HLOTRACE",40,0)
 U $PRINCIPAL
"RTN","HLOTRACE",41,0)
 L -^HLB("QUEUE","OUT",SUB,QUE)
"RTN","HLOTRACE",42,0)
 ZB /CLEAR
"RTN","HLOTRACE",43,0)
 W !,"DONE!"
"RTN","HLOTRACE",44,0)
 ;
"RTN","HLOTRACE",45,0)
 Q
"RTN","HLOTRACE",46,0)
SETBREAKS ;
"RTN","HLOTRACE",47,0)
 ZB /CLEAR
"RTN","HLOTRACE",48,0)
 ;
"RTN","HLOTRACE",49,0)
 ;set break in $$STOPPED^HLOQUE to circumvent shutdown of the queue
"RTN","HLOTRACE",50,0)
 ZB ZB0^HLOQUE:"N":1:"S RET=0"
"RTN","HLOTRACE",51,0)
 ;set break in $$IFSHUT^HLOTLNK to circumvent shutdown of the link
"RTN","HLOTRACE",52,0)
 ZB ZB0^HLOTLNK:"N":1:"S RET=0"
"RTN","HLOTRACE",53,0)
 ;set break at ZB0 in client (start of DOWORK)
"RTN","HLOTRACE",54,0)
 ZB ZB0^HLOCLNT:"N":1:"D WRITE^HLOTRACE(""Launching the client process..."")"
"RTN","HLOTRACE",55,0)
 ;set break at ZB1 in client ($$CONNECT)
"RTN","HLOTRACE",56,0)
 ZB ZB1^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Trying to connect..."")"
"RTN","HLOTRACE",57,0)
 ;set break at ZB2 in client (end of $$CONNECT)
"RTN","HLOTRACE",58,0)
 ZB ZB2^HLOCLNT1:"N":1:"D ZB2^HLOTRACE"
"RTN","HLOTRACE",59,0)
 ;set break at ZB3 in client (ERROR TRAP)
"RTN","HLOTRACE",60,0)
 ZB ZB3^HLOCLNT:"N":1:"D ZB3^HLOTRACE"
"RTN","HLOTRACE",61,0)
 ;set break at ZB4 in client (FOR loop on the outgoing queue)
"RTN","HLOTRACE",62,0)
 ZB ZB4^HLOCLNT:"N":1:"D ZB4^HLOTRACE"
"RTN","HLOTRACE",63,0)
 ;set break at ZB5 in client (end of DOWORK, with just cleanup left)
"RTN","HLOTRACE",64,0)
 ZB ZB5^HLOCLNT:"N":1:"D WRITE3^HLOTRACE(""Cleaning up...."")"
"RTN","HLOTRACE",65,0)
 ;set break at ZB6 in client (start of $$TRANSMIT^HLOCLNT1)
"RTN","HLOTRACE",66,0)
 ZB ZB6^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Beginning to transmit message...."")"
"RTN","HLOTRACE",67,0)
 ;set break at ZB7 in client (end of $$TRANSMIT^HLOCLNT1)
"RTN","HLOTRACE",68,0)
 ZB ZB7^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Message transmitted!"")"
"RTN","HLOTRACE",69,0)
 ;set break at ZB8 in client (start of $$READACK^HLOCLNT1)
"RTN","HLOTRACE",70,0)
 ;ZB ZB8^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Beginning to read commit acknowledgment...."")"
"RTN","HLOTRACE",71,0)
 ZB ZB8^HLOCLNT1:"N":1:"D ZB8^HLOTRACE"
"RTN","HLOTRACE",72,0)
 ;set break at ZB9 in client (end of $$READACK^HLOCLNT1)
"RTN","HLOTRACE",73,0)
 ;ZB ZB9^HLOCLNT1:"N":1:"D WRITE^HLOTRACE(""Commit acknowledgment received!"")"
"RTN","HLOTRACE",74,0)
 ZB ZB9^HLOCLNT1:"N":1:"D ZB9^HLOTRACE"
"RTN","HLOTRACE",75,0)
 ;set break ZB10 in the client(start of $$READHDR^HLOT)
"RTN","HLOTRACE",76,0)
 ZB ZB10^HLOT:"N":1:"D ZB10^HLOTRACE"
"RTN","HLOTRACE",77,0)
 ;set break ZB11 in the client(end of $$READHDR^HLOT)
"RTN","HLOTRACE",78,0)
 ZB ZB11^HLOT:"N":1:"D ZB11^HLOTRACE"
"RTN","HLOTRACE",79,0)
 ;set break ZB12 in the client(start of $$READSEG^HLOT)
"RTN","HLOTRACE",80,0)
 ZB ZB12^HLOT:"N":1:"D ZB12^HLOTRACE"
"RTN","HLOTRACE",81,0)
 ;set break ZB13 in the client(end of $$READSEG^HLOT)
"RTN","HLOTRACE",82,0)
 ZB ZB13^HLOT:"N":1:"D ZB13^HLOTRACE"
"RTN","HLOTRACE",83,0)
 ;set break ZB14 in the client(start of $$WRITESEG^HLOT)
"RTN","HLOTRACE",84,0)
 ZB ZB14^HLOT:"N":1:"D ZB14^HLOTRACE"
"RTN","HLOTRACE",85,0)
 ;set break ZB15 in the client(end of $$WRITESEG^HLOT)
"RTN","HLOTRACE",86,0)
 ZB ZB15^HLOT:"N":1:"D ZB15^HLOTRACE"
"RTN","HLOTRACE",87,0)
 ;set break ZB16 in the client(start of $$WRITEHDR^HLOT)
"RTN","HLOTRACE",88,0)
 ZB ZB16^HLOT:"N":1:"D ZB16^HLOTRACE"
"RTN","HLOTRACE",89,0)
 ;set break ZB17 in the client(end of $$WRITEHDR^HLOT)
"RTN","HLOTRACE",90,0)
 ZB ZB17^HLOT:"N":1:"D ZB17^HLOTRACE"
"RTN","HLOTRACE",91,0)
 ;set break ZB18 in the client(start of $$ENDMSG^HLOT)
"RTN","HLOTRACE",92,0)
 ZB ZB18^HLOT:"N":1:"D ZB18^HLOTRACE"
"RTN","HLOTRACE",93,0)
 ;set break ZB19 in the client(end of $$ENDMSG^HLOT)
"RTN","HLOTRACE",94,0)
 ZB ZB19^HLOT:"N":1:"D ZB19^HLOTRACE"
"RTN","HLOTRACE",95,0)
 ZB ZB20^HLOCLNT:"N":1:"D ZB20^HLOTRACE"
"RTN","HLOTRACE",96,0)
 ZB ZB21^HLOCLNT:"N":1:"D ZB21^HLOTRACE"
"RTN","HLOTRACE",97,0)
 ZB ZB22^HLOCLNT:"N":1:"D ZB22^HLOTRACE"
"RTN","HLOTRACE",98,0)
 ZB ZB23^HLOCLNT:"N":1:"D ZB23^HLOTRACE"
"RTN","HLOTRACE",99,0)
 ZB ZB24^HLOCLNT1:"N":1:"D ZB24^HLOTRACE"
"RTN","HLOTRACE",100,0)
 ZB ZB25^HLOCLNT:"N":1:"D WRITE^HLOTRACE(""Calling DEQUE..."")"
"RTN","HLOTRACE",101,0)
 ZB ZB31^HLOTCP:"N":1:"D WRITE^HLOTRACE(""Beginning READ over TCP..."")"
"RTN","HLOTRACE",102,0)
 ZB ZB32^HLOTCP:"N":1:"D ZB32^HLOTRACE"
"RTN","HLOTRACE",103,0)
 Q
"RTN","HLOTRACE",104,0)
WRITE(MSG) ;
"RTN","HLOTRACE",105,0)
 N OLD
"RTN","HLOTRACE",106,0)
 S OLD=$IO
"RTN","HLOTRACE",107,0)
 U $PRINCIPAL
"RTN","HLOTRACE",108,0)
 W !,?5,"Time: ",$$NOW^XLFDT,"   ",MSG
"RTN","HLOTRACE",109,0)
 U OLD
"RTN","HLOTRACE",110,0)
 Q
"RTN","HLOTRACE",111,0)
WRITE2(MSG,VALUE) ;
"RTN","HLOTRACE",112,0)
 N OLD,I
"RTN","HLOTRACE",113,0)
 S OLD=$IO
"RTN","HLOTRACE",114,0)
 U $PRINCIPAL
"RTN","HLOTRACE",115,0)
 W !,?5,"Time: ",$$NOW^XLFDT,"   ",MSG
"RTN","HLOTRACE",116,0)
 S I=0
"RTN","HLOTRACE",117,0)
 W:$O(VALUE(0)) !
"RTN","HLOTRACE",118,0)
 F  S I=$O(VALUE(I)) Q:'I  W VALUE(I)
"RTN","HLOTRACE",119,0)
 U OLD
"RTN","HLOTRACE",120,0)
 Q
"RTN","HLOTRACE",121,0)
WRITE3(MSG) ;
"RTN","HLOTRACE",122,0)
 N OLD
"RTN","HLOTRACE",123,0)
 S OLD=$IO
"RTN","HLOTRACE",124,0)
 U $PRINCIPAL
"RTN","HLOTRACE",125,0)
 W !,MSG
"RTN","HLOTRACE",126,0)
 U OLD
"RTN","HLOTRACE",127,0)
 Q
"RTN","HLOTRACE",128,0)
 ;
"RTN","HLOTRACE",129,0)
ZB3 ;
"RTN","HLOTRACE",130,0)
 N CON,MSG
"RTN","HLOTRACE",131,0)
 S CON=($ZA\8192#2)
"RTN","HLOTRACE",132,0)
 S MSG="Error encountered, $ECODE="_$ECODE
"RTN","HLOTRACE",133,0)
 D WRITE^HLOTRACE(MSG)
"RTN","HLOTRACE",134,0)
 S MSG=$S(CON:"           TCP connection still active",1:"          TCP connection was dropped")
"RTN","HLOTRACE",135,0)
 D WRITE3^HLOTRACE(MSG)
"RTN","HLOTRACE",136,0)
 D ^%ZTER
"RTN","HLOTRACE",137,0)
 Q
"RTN","HLOTRACE",138,0)
ZB4 ;
"RTN","HLOTRACE",139,0)
 N OLD
"RTN","HLOTRACE",140,0)
 S OLD=$IO
"RTN","HLOTRACE",141,0)
 U $PRINCIPAL
"RTN","HLOTRACE",142,0)
 W !!,"Looking for the next message to transmit..."
"RTN","HLOTRACE",143,0)
 I 'MSGIEN W !!,"No more messages pending on that queue!" S SUCCESS=0 Q
"RTN","HLOTRACE",144,0)
 S TRACECNT=$G(TRACECNT)+1
"RTN","HLOTRACE",145,0)
 I MAXTRACE>1 D
"RTN","HLOTRACE",146,0)
 .W !!,"Message IEN=",MSGIEN," next on queue"
"RTN","HLOTRACE",147,0)
 .I TRACECNT>MAXTRACE D
"RTN","HLOTRACE",148,0)
 ..I $$ASKYESNO^HLOUSR2("Do you want to trace another group of message transmissions","YES") S SUCCESS=1,TRACECNT=1
"RTN","HLOTRACE",149,0)
 ..E  S SUCCESS=0
"RTN","HLOTRACE",150,0)
 .E  S SUCCESS=1
"RTN","HLOTRACE",151,0)
 E  D
"RTN","HLOTRACE",152,0)
 .I '$$ASKYESNO^HLOUSR2("Message IEN="_MSGIEN_" next on queue, do you want to trace its transmission","YES") S SUCCESS=0
"RTN","HLOTRACE",153,0)
 U OLD
"RTN","HLOTRACE",154,0)
 Q
"RTN","HLOTRACE",155,0)
 ;
"RTN","HLOTRACE",156,0)
ZB2 ;
"RTN","HLOTRACE",157,0)
 W !,$S('HLCSTATE("CONNECTED"):"Connection Failed!",1:"Connected!")
"RTN","HLOTRACE",158,0)
 Q
"RTN","HLOTRACE",159,0)
ZB8 ;
"RTN","HLOTRACE",160,0)
 D WRITE^HLOTRACE("Beginning to read commit acknowledgment....")
"RTN","HLOTRACE",161,0)
 Q
"RTN","HLOTRACE",162,0)
ZB9 ;
"RTN","HLOTRACE",163,0)
 I $G(SUCCESS) D
"RTN","HLOTRACE",164,0)
 .D WRITE^HLOTRACE("Commit acknowledgment received!")
"RTN","HLOTRACE",165,0)
 E  D
"RTN","HLOTRACE",166,0)
 .D WRITE^HLOTRACE("Read of commit acknowledgment FAILED!")
"RTN","HLOTRACE",167,0)
 Q
"RTN","HLOTRACE",168,0)
ZB10 ;
"RTN","HLOTRACE",169,0)
 D WRITE^HLOTRACE("Getting message header...")
"RTN","HLOTRACE",170,0)
 Q
"RTN","HLOTRACE",171,0)
ZB11 ;
"RTN","HLOTRACE",172,0)
 I $D(HDR) D WRITE2^HLOTRACE("",.HDR)
"RTN","HLOTRACE",173,0)
 D WRITE^HLOTRACE($S(SUCCESS:"Got message header!",1:"**** FAILED TO READ MESSAGE HEADER! *****"))
"RTN","HLOTRACE",174,0)
 Q
"RTN","HLOTRACE",175,0)
ZB12 ;
"RTN","HLOTRACE",176,0)
 D WRITE^HLOTRACE("Getting next segment...")
"RTN","HLOTRACE",177,0)
 Q
"RTN","HLOTRACE",178,0)
ZB13 I $D(SEG) D WRITE2^HLOTRACE("",.SEG)
"RTN","HLOTRACE",179,0)
 D WRITE^HLOTRACE($S(RETURN:"Got next segment!",$G(HLCSTATE("MESSAGE ENDED")):"No more segments!",1:"**** FAILED TO COMPLETE READING NEXT SEGMENT *****"))
"RTN","HLOTRACE",180,0)
 Q
"RTN","HLOTRACE",181,0)
ZB14 ;
"RTN","HLOTRACE",182,0)
 D WRITE2^HLOTRACE("Writing next segment...",.SEG)
"RTN","HLOTRACE",183,0)
 Q
"RTN","HLOTRACE",184,0)
ZB15 D WRITE^HLOTRACE($S(RETURN:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOTRACE",185,0)
 Q
"RTN","HLOTRACE",186,0)
ZB16 ;
"RTN","HLOTRACE",187,0)
 D WRITE2^HLOTRACE("Writing header segment...",.HDR)
"RTN","HLOTRACE",188,0)
 Q
"RTN","HLOTRACE",189,0)
ZB17 D WRITE^HLOTRACE($S(SUCCESS:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOTRACE",190,0)
 Q
"RTN","HLOTRACE",191,0)
ZB18 ;
"RTN","HLOTRACE",192,0)
 D WRITE^HLOTRACE("Writing message terminators and flushing buffer...")
"RTN","HLOTRACE",193,0)
 Q
"RTN","HLOTRACE",194,0)
ZB19 D WRITE^HLOTRACE($S(RETURN:"Completed!",1:"**** FAILED TO COMPLETE *****"))
"RTN","HLOTRACE",195,0)
 Q
"RTN","HLOTRACE",196,0)
ZB20 ;
"RTN","HLOTRACE",197,0)
 D WRITE^HLOTRACE("Message on queue was already transmitted, will be deleted from queue...")
"RTN","HLOTRACE",198,0)
 Q
"RTN","HLOTRACE",199,0)
ZB21 ;
"RTN","HLOTRACE",200,0)
 D WRITE^HLOTRACE("MSA segment shows this is not a commmit ack to the message transmitted...")
"RTN","HLOTRACE",201,0)
 Q
"RTN","HLOTRACE",202,0)
ZB22 ;
"RTN","HLOTRACE",203,0)
 D WRITE^HLOTRACE("Commit ack not CA, message status set to error...")
"RTN","HLOTRACE",204,0)
 Q
"RTN","HLOTRACE",205,0)
ZB23 ;
"RTN","HLOTRACE",206,0)
 D WRITE^HLOTRACE("Setting timestamp of sequence queue...")
"RTN","HLOTRACE",207,0)
 Q
"RTN","HLOTRACE",208,0)
ZB24 ;S HLOCSTATE("CONNECTED")=1
"RTN","HLOTRACE",209,0)
 S HLCSTATE("LINK","SHUTDOWN")=0
"RTN","HLOTRACE",210,0)
 Q
"RTN","HLOTRACE",211,0)
ZB32 D:('$G(RETURN)) WRITE^HLOTRACE("**** FAILED ****")
"RTN","HLOTRACE",212,0)
 D:$G(RETURN) WRITE3^HLOTRACE("")
"RTN","HLOTRACE",213,0)
 D:$G(RETURN) WRITE3^HLOTRACE($G(BUF))
"RTN","HLOTRACE",214,0)
 D:$G(RETURN) WRITE3^HLOTRACE("")
"RTN","HLOTRACE",215,0)
 D:$G(RETURN) WRITE^HLOTRACE("READ over TCP completed! #Characters read: "_$L($G(BUF)))
"RTN","HLOTRACE",216,0)
 Q
"RTN","HLOTRACE",217,0)
 ; 
"RTN","HLOTRACE",218,0)
ASKQUE(SUB) ;
"RTN","HLOTRACE",219,0)
 N DIR,Q1,Q2
"RTN","HLOTRACE",220,0)
 S Q1=$O(^HLB("QUEUE","OUT",SUB,""))
"RTN","HLOTRACE",221,0)
 I Q1="" W !,"There are no outgoing messages queued to that link!",! Q ""
"RTN","HLOTRACE",222,0)
 S Q2=$O(^HLB("QUEUE","OUT",SUB,Q1))
"RTN","HLOTRACE",223,0)
 I Q2="" D
"RTN","HLOTRACE",224,0)
 .S DIR("B")=Q1
"RTN","HLOTRACE",225,0)
 E  I $D(^HLB("QUEUE","OUT",SUB,"DEFAULT")) D
"RTN","HLOTRACE",226,0)
 .S DIR("B")="DEFAULT"
"RTN","HLOTRACE",227,0)
 E  D
"RTN","HLOTRACE",228,0)
 .S DIR("B")=Q1
"RTN","HLOTRACE",229,0)
 S DIR(0)="F^1:20"
"RTN","HLOTRACE",230,0)
 S DIR("A")="What is the name of the queue"
"RTN","HLOTRACE",231,0)
 S DIR("?",1)="To use this tool, there must be messages aleady pending transmission."
"RTN","HLOTRACE",232,0)
 S DIR("?")="Enter the name of the queue, or '^' to exit."
"RTN","HLOTRACE",233,0)
 D ^DIR
"RTN","HLOTRACE",234,0)
 I $D(DIRUT)!(Y="") Q ""
"RTN","HLOTRACE",235,0)
 Q Y
"RTN","HLOTRACE",236,0)
 ;
"RTN","HLOTRACE",237,0)
ASKCOUNT() ;
"RTN","HLOTRACE",238,0)
 N DIR
"RTN","HLOTRACE",239,0)
 S DIR(0)="N^1:100"
"RTN","HLOTRACE",240,0)
 S DIR("A")="Send how many at a time"
"RTN","HLOTRACE",241,0)
 S DIR("B")=1
"RTN","HLOTRACE",242,0)
 S DIR("?",1)="How many messages do you want to transmit at once"
"RTN","HLOTRACE",243,0)
 S DIR("?")="while tracing the client (100 maximum)?"
"RTN","HLOTRACE",244,0)
 D ^DIR
"RTN","HLOTRACE",245,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOTRACE",246,0)
 Q X
"RTN","HLOTRACE",247,0)
ASKPORT(LINK) ;
"RTN","HLOTRACE",248,0)
 Q:LINK="" ""
"RTN","HLOTRACE",249,0)
 N PORT,QUEUE
"RTN","HLOTRACE",250,0)
 S QUEUE=$O(^HLB("QUEUE","OUT",LINK_":"))
"RTN","HLOTRACE",251,0)
 Q:$P(QUEUE,":")'=LINK ""
"RTN","HLOTRACE",252,0)
 S PORT=$P(QUEUE,":",2)
"RTN","HLOTRACE",253,0)
 Q:'PORT ""
"RTN","HLOTRACE",254,0)
 S QUEUE=$O(^HLB("QUEUE","OUT",QUEUE))
"RTN","HLOTRACE",255,0)
 Q:$P(QUEUE,":")'=LINK PORT
"RTN","HLOTRACE",256,0)
 S PORT=$$ASKPORT^HLOUSRA(LINK)
"RTN","HLOTRACE",257,0)
 Q PORT
"RTN","HLOUSR")
0^8^B121166141^B121177713
"RTN","HLOUSR",1,0)
HLOUSR ;ALB/CJM/OAK/PIJ/RBN -ListManager Screen for viewing system status;12 JUN 1997 10:00 am ;12/01/2010
"RTN","HLOUSR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,134,137,138,139,146,147,153**;Oct 13, 1995;Build 11
"RTN","HLOUSR",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR",4,0)
 ;
"RTN","HLOUSR",5,0)
EN ;
"RTN","HLOUSR",6,0)
 ;
"RTN","HLOUSR",7,0)
 N HLSCREEN,TESTOPEN,HLRFRSH,HLPARMS
"RTN","HLOUSR",8,0)
 D WAIT^DICD
"RTN","HLOUSR",9,0)
 D EN^VALM("HLO SYSTEM MONITOR")
"RTN","HLOUSR",10,0)
 Q
"RTN","HLOUSR",11,0)
 ;
"RTN","HLOUSR",12,0)
BRIEF ;
"RTN","HLOUSR",13,0)
 N COUNT,LINK,QUE,FROM,TIME,STATUS,TEMP,DIR,TODAY,LIST,LNKMSG,OS
"RTN","HLOUSR",14,0)
 S HLRFRSH="BRIEF^HLOUSR"
"RTN","HLOUSR",15,0)
 S (HLSCREEN,VALMSG)="Brief System Status"
"RTN","HLOUSR",16,0)
 S VALMCNT=16
"RTN","HLOUSR",17,0)
 ;K @VALMAR
"RTN","HLOUSR",18,0)
 S OS=$$OS^%ZOSV
"RTN","HLOUSR",19,0)
 ;
"RTN","HLOUSR",20,0)
 D CLEAN^VALM10
"RTN","HLOUSR",21,0)
 S VALMBG=1
"RTN","HLOUSR",22,0)
 S VALMBCK="R"
"RTN","HLOUSR",23,0)
 S VALMDDF("COL 1")="COL1^1^80^"
"RTN","HLOUSR",24,0)
 K VALMDDF("COL 2"),VALMDDF("COL 3"),VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",25,0)
 D CHGCAP^VALM("COL 1"," Brief Operational Overview")
"RTN","HLOUSR",26,0)
 S @VALMAR@(1,0)="SYSTEM STATUS:             "_$S($$CHKSTOP^HLOPROC:"STOPPED",1:"RUNNING")
"RTN","HLOUSR",27,0)
 S @VALMAR@(2,0)="PROCESS MANAGER:           "_$S($$RUNNING:"RUNNING",1:"STOPPED")
"RTN","HLOUSR",28,0)
 ;
"RTN","HLOUSR",29,0)
 ;
"RTN","HLOUSR",30,0)
 I $$CHKSTOP^HLOPROC,OS'["VMS" S TESTOPEN("LISTENER")=""
"RTN","HLOUSR",31,0)
 S TIME=$P($G(TESTOPEN("LISTENER")),"^",2)
"RTN","HLOUSR",32,0)
 I TIME,$$FMDIFF^XLFDT($$NOW^XLFDT,TIME,2)<100 D
"RTN","HLOUSR",33,0)
 .S STATUS=+TESTOPEN("LISTENER")
"RTN","HLOUSR",34,0)
 E  D
"RTN","HLOUSR",35,0)
 .;** P147 START CJM
"RTN","HLOUSR",36,0)
 .;is the Kernel listener running under the HLO process manager?
"RTN","HLOUSR",37,0)
 .S STATUS=$$KLISTEN
"RTN","HLOUSR",38,0)
 .;
"RTN","HLOUSR",39,0)
 .;if the Kernel listner is NOT running, might check the listener via the OPEN command.  With loadbalancing, the IP address of the listener link sometimes fails, so also try 'loopback'.
"RTN","HLOUSR",40,0)
 .I 'STATUS,(OS["VMS")!('$$CHKSTOP^HLOPROC) D
"RTN","HLOUSR",41,0)
 ..N IP,LINK
"RTN","HLOUSR",42,0)
 ..S LINK=$P($G(^HLD(779.1,1,0)),"^",10)
"RTN","HLOUSR",43,0)
 ..I LINK,$$GET^HLOTLNK(LINK,.LINK) D
"RTN","HLOUSR",44,0)
 ...F IP="127.0.0.1","0.0.0.0",LINK("IP") D  Q:STATUS
"RTN","HLOUSR",45,0)
 ....N POP,IO,IOF,IOST
"RTN","HLOUSR",46,0)
 ....D CALL^%ZISTCP(IP,LINK("PORT"),5)
"RTN","HLOUSR",47,0)
 ....S STATUS='POP
"RTN","HLOUSR",48,0)
 ....C:STATUS IO
"RTN","HLOUSR",49,0)
 .;
"RTN","HLOUSR",50,0)
 .S:(('STATUS)&('$$CHKSTOP^HLOPROC)) LNKMSG=$S(OS["VMS":" Please start the HLO VMS TCPIP SERVICE",1:"Please start the HLO Listener")
"RTN","HLOUSR",51,0)
 .;
"RTN","HLOUSR",52,0)
 .;** P147 END CJM
"RTN","HLOUSR",53,0)
 .;
"RTN","HLOUSR",54,0)
 .D:'STATUS CNTRL^VALM10(3,38,85,IOINHI,IOINORM)
"RTN","HLOUSR",55,0)
 .S TESTOPEN("LISTENER")=STATUS_"^"_$$NOW^XLFDT
"RTN","HLOUSR",56,0)
 ;
"RTN","HLOUSR",57,0)
 S @VALMAR@(3,0)="STANDARD LISTENER:         "_$S(STATUS:"RUNNING",1:"STOPPED   ")_$G(LNKMSG)
"RTN","HLOUSR",58,0)
 ;** P139 end **
"RTN","HLOUSR",59,0)
 ;
"RTN","HLOUSR",60,0)
 S @VALMAR@(4,0)="TASKMAN:                   "_$S($$TM^%ZTLOAD:"RUNNING",1:"STOPPED")
"RTN","HLOUSR",61,0)
 ;
"RTN","HLOUSR",62,0)
 S (LIST,LINK)=""
"RTN","HLOUSR",63,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D  I $L(LIST)>60 S LIST=LIST_",..." Q
"RTN","HLOUSR",64,0)
 .N TIME,QUE,LINKARY
"RTN","HLOUSR",65,0)
 .I $$GETLINK^HLOTLNK($P(LINK,":"),.LINKARY)
"RTN","HLOUSR",66,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOUSR",67,0)
 .I '$G(LINKARY("SHUTDOWN")),TIME="" Q
"RTN","HLOUSR",68,0)
 .I '$G(LINKARY("SHUTDOWN")),($$HDIFF^XLFDT($H,TIME,2)<300) Q
"RTN","HLOUSR",69,0)
 .;;***patch HL*1.6*138 start
"RTN","HLOUSR",70,0)
 .S LIST=LIST_$S($L(LIST):", ",1:"")_LINK
"RTN","HLOUSR",71,0)
 .;;.S LIST=LIST_$S($L(LIST):", ",1:"")_$P(LINK,":")
"RTN","HLOUSR",72,0)
 .;; ***patch HL*1.6*138 end
"RTN","HLOUSR",73,0)
 S @VALMAR@(5,0)="DOWN LINKS: "_LIST
"RTN","HLOUSR",74,0)
 S @VALMAR@(6,0)="CLIENT LINK PROCESSES:     "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","OUTGOING CLIENT LINK"))
"RTN","HLOUSR",75,0)
 S @VALMAR@(7,0)="IN-FILER PROCESSES:        "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","INCOMING QUEUES"))
"RTN","HLOUSR",76,0)
 ; ***patch HL*1.6*146 START - RBN ***
"RTN","HLOUSR",77,0)
 ;S COUNT=0,LINK=""
"RTN","HLOUSR",78,0)
 ;F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOUSR",79,0)
 ;.S QUE=""
"RTN","HLOUSR",80,0)
 ;.F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOUSR",81,0)
 ;..S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE))
"RTN","HLOUSR",82,0)
 ;..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",83,0)
 N CNTARRAY
"RTN","HLOUSR",84,0)
 S COUNT=$$OUT^HLOQUE(.CNTARRAY)
"RTN","HLOUSR",85,0)
 ; ***patch HL*1.6*146 END - RBN ***
"RTN","HLOUSR",86,0)
 S @VALMAR@(8,0)="MESSAGES PENDING ON OUT QUEUES:    "_$$RJ(+COUNT,7)_"     ON SEQUENCE QUEUES:  "_$$RJ(+$G(^HLC("QUEUECOUNT","SEQUENCE")),7)
"RTN","HLOUSR",87,0)
 S TEMP="STOPPED OUTGOING QUEUES: "
"RTN","HLOUSR",88,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",89,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","OUT",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",90,0)
 S @VALMAR@(9,0)=TEMP
"RTN","HLOUSR",91,0)
 ; ***patch HL*1.6*146 START - RBN ***
"RTN","HLOUSR",92,0)
 ;S COUNT=0,QUE=""
"RTN","HLOUSR",93,0)
 ;F  S QUE=$O(^HLC("QUEUECOUNT","IN",QUE)) Q:QUE=""  D
"RTN","HLOUSR",94,0)
 ;.S FROM=""
"RTN","HLOUSR",95,0)
 ;.F  S FROM=$O(^HLC("QUEUECOUNT","IN",QUE,FROM)) Q:FROM=""  D
"RTN","HLOUSR",96,0)
 ;..S TEMP=$G(^HLC("QUEUECOUNT","IN",QUE,FROM))
"RTN","HLOUSR",97,0)
 ;..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",98,0)
 S COUNT=0
"RTN","HLOUSR",99,0)
 K CNTARRAY
"RTN","HLOUSR",100,0)
 S COUNT=$$IN^HLOQUE(.CNTARRAY)
"RTN","HLOUSR",101,0)
 ; ***patch HL*1.6*146 END - RBN ***
"RTN","HLOUSR",102,0)
 S @VALMAR@(10,0)="MESSAGES PENDING ON APPLICATIONS: "_$$RJ(+COUNT,7)
"RTN","HLOUSR",103,0)
 S TEMP="STOPPED INCOMING QUEUES: "
"RTN","HLOUSR",104,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",105,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","IN",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",106,0)
 S @VALMAR@(11,0)=TEMP
"RTN","HLOUSR",107,0)
 S @VALMAR@(12,0)="FILE 777 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^",2))
"RTN","HLOUSR",108,0)
 S @VALMAR@(13,0)="FILE 778 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^",2))
"RTN","HLOUSR",109,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOUSR",110,0)
 S @VALMAR@(14,0)="MESSAGES SENT TODAY:           "_$$RJ($$ADD("OUT"),10)
"RTN","HLOUSR",111,0)
 S @VALMAR@(15,0)="MESSAGES RECEIVED TODAY:       "_$$RJ($$ADD("IN"),10)
"RTN","HLOUSR",112,0)
 S @VALMAR@(16,0)="MESSAGE ERRORS TODAY:          "_$$RJ($$ADD("EOUT")+$$ADD("EIN"),10)
"RTN","HLOUSR",113,0)
 Q
"RTN","HLOUSR",114,0)
 ;
"RTN","HLOUSR",115,0)
ADD(DIR) ;
"RTN","HLOUSR",116,0)
 N RAP,SAP,TIME,TOTAL,TYPE
"RTN","HLOUSR",117,0)
 S TOTAL=0
"RTN","HLOUSR",118,0)
 S TIME=TODAY-.0001
"RTN","HLOUSR",119,0)
 F  S TIME=$O(^HLSTATS(DIR,"HOURLY",TIME)) Q:'TIME  Q:((TIME\1)>TODAY)  D
"RTN","HLOUSR",120,0)
 .S SAP=""
"RTN","HLOUSR",121,0)
 .F  S SAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOUSR",122,0)
 ..Q:SAP="ACCEPT ACK"
"RTN","HLOUSR",123,0)
 ..S RAP=""
"RTN","HLOUSR",124,0)
 ..F  S RAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOUSR",125,0)
 ...S TYPE=""
"RTN","HLOUSR",126,0)
 ...F  S TYPE=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOUSR",127,0)
 ....S TOTAL=TOTAL+$G(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE))
"RTN","HLOUSR",128,0)
 Q TOTAL
"RTN","HLOUSR",129,0)
 ;
"RTN","HLOUSR",130,0)
HELP ;
"RTN","HLOUSR",131,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSR",132,0)
 Q
"RTN","HLOUSR",133,0)
 ;
"RTN","HLOUSR",134,0)
EXIT ;
"RTN","HLOUSR",135,0)
 D CLEAN^VALM10
"RTN","HLOUSR",136,0)
 D CLEAR^VALM1
"RTN","HLOUSR",137,0)
 Q
"RTN","HLOUSR",138,0)
 ;
"RTN","HLOUSR",139,0)
EXPND ;
"RTN","HLOUSR",140,0)
 Q
"RTN","HLOUSR",141,0)
 ;
"RTN","HLOUSR",142,0)
PROCS ;
"RTN","HLOUSR",143,0)
 S HLRFRSH="PROCS^HLOUSR"
"RTN","HLOUSR",144,0)
 ;K @VALMAR
"RTN","HLOUSR",145,0)
 D CLEAN^VALM10
"RTN","HLOUSR",146,0)
 S VALMCNT=0
"RTN","HLOUSR",147,0)
 S VALMBCK="R"
"RTN","HLOUSR",148,0)
 S VALMDDF("COL 1")="COL 1^1^34^"
"RTN","HLOUSR",149,0)
 S VALMDDF("COL 2")="COL 2^35^10^MIN^H"
"RTN","HLOUSR",150,0)
 S VALMDDF("COL 3")="COL 3^47^10^MAX^H"
"RTN","HLOUSR",151,0)
 S VALMDDF("COL 4")="COL 4^59^10^#RUNNING^H"
"RTN","HLOUSR",152,0)
 S VALMDDF("COL 5")="COL 5^71^10^#QUEUED^IOBON"
"RTN","HLOUSR",153,0)
 D CHGCAP^VALM("COL 1"," Process Type")
"RTN","HLOUSR",154,0)
 N IEN
"RTN","HLOUSR",155,0)
 S IEN=0
"RTN","HLOUSR",156,0)
 F  S IEN=$O(^HLD(779.3,"C",1,IEN)) Q:'IEN  D
"RTN","HLOUSR",157,0)
 .N PROC
"RTN","HLOUSR",158,0)
 .Q:'$$GETPROC^HLOPROC1(IEN,.PROC)
"RTN","HLOUSR",159,0)
 .Q:PROC("NAME")="VMS TCP LISTENER"
"RTN","HLOUSR",160,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",161,0)
 .S @VALMAR@(VALMCNT,0)=$$LJ(PROC("NAME"),30)_$$RJ(PROC("MINIMUM"),6)_$$RJ(PROC("MAXIMUM"),12)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC("NAME"))),14)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC("NAME"))),12)
"RTN","HLOUSR",162,0)
 S VALMCNT=VALMCNT+1,@VALMAR@(VALMCNT,0)=""
"RTN","HLOUSR",163,0)
 S IEN=""
"RTN","HLOUSR",164,0)
 F  S IEN=$O(^HLTMP("HL7 RUNNING PROCESSES",IEN)) Q:IEN=""  D
"RTN","HLOUSR",165,0)
 .N NODE
"RTN","HLOUSR",166,0)
 .S NODE=$G(^HLTMP("HL7 RUNNING PROCESSES",IEN))
"RTN","HLOUSR",167,0)
 .Q:NODE=""
"RTN","HLOUSR",168,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",169,0)
 .S @VALMAR@(VALMCNT,0)="$J: "_$$LJ(IEN,9)_" ->"_$$CJ($P(NODE,"^",3),28)_"<- started at "_$$HTE^XLFDT($P(NODE,"^"))
"RTN","HLOUSR",170,0)
 Q
"RTN","HLOUSR",171,0)
 ;
"RTN","HLOUSR",172,0)
INQUEUE ;
"RTN","HLOUSR",173,0)
 N FROM
"RTN","HLOUSR",174,0)
 D CLEAN^VALM10
"RTN","HLOUSR",175,0)
 ;K @VALMAR
"RTN","HLOUSR",176,0)
 S HLRFRSH="INQUEUE^HLOUSR"
"RTN","HLOUSR",177,0)
 S (HLSCREEN,VALMSG)="Incoming Queues ('!' = stopped queues)"
"RTN","HLOUSR",178,0)
 S VALMCNT=0
"RTN","HLOUSR",179,0)
 S VALMBCK="R"
"RTN","HLOUSR",180,0)
 S VALMDDF("COL 1")="COL 1^1^40^ From^H"
"RTN","HLOUSR",181,0)
 S VALMDDF("COL 2")="COL 2^45^20^Queue^H"
"RTN","HLOUSR",182,0)
 S VALMDDF("COL 3")="COL 3^70^10^Count^H"
"RTN","HLOUSR",183,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",184,0)
 D CHGCAP^VALM("COL 1"," From")
"RTN","HLOUSR",185,0)
 S FROM=""
"RTN","HLOUSR",186,0)
 F  S FROM=$O(^HLC("QUEUECOUNT","IN",FROM)) Q:FROM=""  D
"RTN","HLOUSR",187,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR",188,0)
 .S SHOW=$$LJ(FROM,40)_"  "
"RTN","HLOUSR",189,0)
 .S QUE=""
"RTN","HLOUSR",190,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","IN",FROM,QUE)) Q:QUE=""  D
"RTN","HLOUSR",191,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","IN",FROM,QUE))
"RTN","HLOUSR",192,0)
 ..Q:COUNT<0
"RTN","HLOUSR",193,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR",194,0)
 ..S @VALMAR@(VALMCNT,0)=SHOW_$$LJ($S($$STOPPED^HLOQUE("IN",QUE):"!",1:"")_QUE,21)_" "_$$RJ(COUNT,10)
"RTN","HLOUSR",195,0)
 ..S SHOW=$$LJ("",40)_"  "
"RTN","HLOUSR",196,0)
 Q
"RTN","HLOUSR",197,0)
VIEWLINK ;
"RTN","HLOUSR",198,0)
 N C,QUIT,LINK,LINKARY,TEMP
"RTN","HLOUSR",199,0)
 S (QUIT,C,LINK)=""
"RTN","HLOUSR",200,0)
 S VALMBCK="R"
"RTN","HLOUSR",201,0)
 ;
"RTN","HLOUSR",202,0)
 ;currently HL7 (Optimized) only does TCP
"RTN","HLOUSR",203,0)
 S LINK=$$ASKLINK
"RTN","HLOUSR",204,0)
 Q:LINK=""
"RTN","HLOUSR",205,0)
 Q:'$$GETLINK^HLOTLNK(LINK,.LINKARY)
"RTN","HLOUSR",206,0)
 S LINK=LINK_":"_LINKARY("PORT")
"RTN","HLOUSR",207,0)
 W !,"Hit any key to stop...",!
"RTN","HLOUSR",208,0)
 F  D  Q:QUIT
"RTN","HLOUSR",209,0)
 .N COUNT,QUE
"RTN","HLOUSR",210,0)
 .S (COUNT,QUE)=""
"RTN","HLOUSR",211,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE)) S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",212,0)
 .W $C(13),"                             ",$C(13),"MESSAGES PENDING TRANSMISSION: ",IOBON,$$RJ(+COUNT,10),IOBOFF
"RTN","HLOUSR",213,0)
 .R *C:1 I $T S QUIT=1
"RTN","HLOUSR",214,0)
 Q
"RTN","HLOUSR",215,0)
 ;
"RTN","HLOUSR",216,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR",217,0)
 Q $$CJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",218,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR",219,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",220,0)
RJ(STRING,LEN) ;
"RTN","HLOUSR",221,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",222,0)
 ;
"RTN","HLOUSR",223,0)
RUNNING() ;Process Manager running?
"RTN","HLOUSR",224,0)
 N RUNNING
"RTN","HLOUSR",225,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOUSR",226,0)
 S RUNNING='$T
"RTN","HLOUSR",227,0)
 I 'RUNNING L -^HLTMP("PROCESS MANAGER")
"RTN","HLOUSR",228,0)
 Q RUNNING
"RTN","HLOUSR",229,0)
 ;
"RTN","HLOUSR",230,0)
TESTLINK ;
"RTN","HLOUSR",231,0)
 N LINKNAME,OK,PORT,LINK
"RTN","HLOUSR",232,0)
 S VALMBCK="R"
"RTN","HLOUSR",233,0)
 S LINKNAME=$$ASKLINK
"RTN","HLOUSR",234,0)
 Q:LINKNAME=""
"RTN","HLOUSR",235,0)
 ;**P138 START
"RTN","HLOUSR",236,0)
 S PORT=$$ASKPORT^HLOUSRA(LINKNAME)
"RTN","HLOUSR",237,0)
 Q:'PORT
"RTN","HLOUSR",238,0)
 S LINK=LINKNAME_":"_PORT
"RTN","HLOUSR",239,0)
 ;S OK=$$IFOPEN^HLOUSR1(LINKNAME)
"RTN","HLOUSR",240,0)
 S OK=$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOUSR",241,0)
 ;** P138 END
"RTN","HLOUSR",242,0)
 I OK W !,LINK_" IS operational..."
"RTN","HLOUSR",243,0)
 E  W !,LINK_" is NOT operational..."
"RTN","HLOUSR",244,0)
 W !,"Hit any key to continue..."
"RTN","HLOUSR",245,0)
 R *C:DTIME
"RTN","HLOUSR",246,0)
 Q
"RTN","HLOUSR",247,0)
 ;
"RTN","HLOUSR",248,0)
ASKLINK() ;
"RTN","HLOUSR",249,0)
 N DIC,TCP,X,Y,DTOUT,DUOUT
"RTN","HLOUSR",250,0)
 S DIC=870
"RTN","HLOUSR",251,0)
 S DIC(0)="AEMNQ"
"RTN","HLOUSR",252,0)
 S TCP=$O(^HLCS(869.1,"B","TCP",0))
"RTN","HLOUSR",253,0)
 S DIC("A")="Select a TCP link:"
"RTN","HLOUSR",254,0)
 S DIC("S")="I $P(^(0),U,3)=TCP"
"RTN","HLOUSR",255,0)
 D FULL^VALM1
"RTN","HLOUSR",256,0)
 D ^DIC
"RTN","HLOUSR",257,0)
 I +Y'=-1,'$D(DTOUT),'$D(DUOUT) Q $P(Y,"^",2)
"RTN","HLOUSR",258,0)
 Q ""
"RTN","HLOUSR",259,0)
 ;
"RTN","HLOUSR",260,0)
STOP ;
"RTN","HLOUSR",261,0)
 I '$$ASKYESNO^HLOUSR2("Are you SURE that you want to stop sending and receiving messages","NO") S VALMBCK="" Q
"RTN","HLOUSR",262,0)
 ;
"RTN","HLOUSR",263,0)
 D STOPHL7^HLOPROC1
"RTN","HLOUSR",264,0)
 S VALMBCK="R",VALMSG="HL7 (Optimized) has been stopped...."
"RTN","HLOUSR",265,0)
 H 5
"RTN","HLOUSR",266,0)
 D @HLRFRSH
"RTN","HLOUSR",267,0)
 ;D:HLSCREEN="Brief System Status" BRIEF^HLOUSR
"RTN","HLOUSR",268,0)
 ;D:HLSCREEN="Running Processes" PROCS^HLOUSR
"RTN","HLOUSR",269,0)
 Q
"RTN","HLOUSR",270,0)
 ;
"RTN","HLOUSR",271,0)
UPDMODE ;realtime
"RTN","HLOUSR",272,0)
 Q:'$L(HLRFRSH)
"RTN","HLOUSR",273,0)
 N TOP,BOTTOM,DX,DY,IOTM,IOBM,LINE,OLD,OLDCNT
"RTN","HLOUSR",274,0)
 S OLDCNT=VALMCNT
"RTN","HLOUSR",275,0)
 W !!!!!,IOINHI,"Hit any key to escape realtime display mode...",IOINORM
"RTN","HLOUSR",276,0)
 S IOTM=20,IOBM=23 W @IOSTBM
"RTN","HLOUSR",277,0)
 S TOP=VALMBG
"RTN","HLOUSR",278,0)
 S BOTTOM=TOP+20
"RTN","HLOUSR",279,0)
 F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",280,0)
 .I LINE>VALMCNT S @VALMAR@(LINE,0)=$$LJ(" ",80) Q
"RTN","HLOUSR",281,0)
 .S @VALMAR@(LINE,0)=$$LJ($G(@VALMAR@(LINE,0)),80)
"RTN","HLOUSR",282,0)
 F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",283,0)
 .S OLD(LINE)=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR",284,0)
 F LINE=17:1:BOTTOM D
"RTN","HLOUSR",285,0)
 .S DX=50,DY=22 X IOXY W !
"RTN","HLOUSR",286,0)
 .D WRITE^VALM10(LINE)
"RTN","HLOUSR",287,0)
 D  F  R *C:4 Q:$T  D
"RTN","HLOUSR",288,0)
 .D @HLRFRSH
"RTN","HLOUSR",289,0)
 .;**START PATCH 138**
"RTN","HLOUSR",290,0)
 .S OLDCNT=VALMCNT
"RTN","HLOUSR",291,0)
 .;**END PATCH 138**
"RTN","HLOUSR",292,0)
 .F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",293,0)
 ..I LINE>VALMCNT S @VALMAR@(LINE,0)=$$LJ(" ",80) Q
"RTN","HLOUSR",294,0)
 ..S @VALMAR@(LINE,0)=$$LJ($G(@VALMAR@(LINE,0)),80)
"RTN","HLOUSR",295,0)
 .S VALMCNT=BOTTOM
"RTN","HLOUSR",296,0)
 .F LINE=TOP:1:BOTTOM IF OLD(LINE)'=$G(@VALMAR@(LINE,0)) D
"RTN","HLOUSR",297,0)
 ..S OLD(LINE)=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR",298,0)
 ..S DX=50,DY=22 X IOXY W !
"RTN","HLOUSR",299,0)
 ..D WRITE^VALM10(LINE)
"RTN","HLOUSR",300,0)
 ;**START PATCH 138**
"RTN","HLOUSR",301,0)
 S VALMCNT=OLDCNT
"RTN","HLOUSR",302,0)
 I VALMCNT<VALMBG S VALMBG=VALMCNT
"RTN","HLOUSR",303,0)
 ;**END PATCH 138**
"RTN","HLOUSR",304,0)
 S VALMBCK="R"
"RTN","HLOUSR",305,0)
 Q
"RTN","HLOUSR",306,0)
 ;
"RTN","HLOUSR",307,0)
EDITSITE ;
"RTN","HLOUSR",308,0)
 ;edit HLO System Parameters
"RTN","HLOUSR",309,0)
 N DR,DA,DIE
"RTN","HLOUSR",310,0)
 S DA=$O(^HLD(779.1,0))
"RTN","HLOUSR",311,0)
 Q:'DA
"RTN","HLOUSR",312,0)
 S DIE="^HLD(779.1,"
"RTN","HLOUSR",313,0)
 S DR="[HLO EDIT SYSTEM PARAMETERS]"
"RTN","HLOUSR",314,0)
 D ^DIE
"RTN","HLOUSR",315,0)
 Q
"RTN","HLOUSR",316,0)
 ;
"RTN","HLOUSR",317,0)
LOGALL ;
"RTN","HLOUSR",318,0)
 N ON,CHANGE,DATA
"RTN","HLOUSR",319,0)
 ;Will turn on/off logging of all errors
"RTN","HLOUSR",320,0)
 S ON=$G(^HLTMP("LOG ALL ERRORS"))
"RTN","HLOUSR",321,0)
 W !!,"Logging of all HLO errors is turned ",$S(ON:"ON",1:"OFF"),"."
"RTN","HLOUSR",322,0)
 W !!,"Logging of all HLO errors, including READ and WRITE errors, should be turned",!,"on only for short periods for troubleshooting purposes.",!
"RTN","HLOUSR",323,0)
 S CHANGE=$$ASKYESNO^HLOUSR2("Do you want logging of all HLO errors turned "_$S(ON:"OFF",1:"ON"),$S(ON:"YES",1:"NO"))
"RTN","HLOUSR",324,0)
 Q:'CHANGE
"RTN","HLOUSR",325,0)
 S ON='ON
"RTN","HLOUSR",326,0)
 S ^HLTMP("LOG ALL ERRORS")=ON
"RTN","HLOUSR",327,0)
 W !,"Logging of all HLO errors is turned ",$S(ON:"ON",1:"OFF"),"."
"RTN","HLOUSR",328,0)
 Q
"RTN","HLOUSR",329,0)
 ;
"RTN","HLOUSR",330,0)
KLISTEN() ;
"RTN","HLOUSR",331,0)
 ;checks if the Kernel multi-listener is running
"RTN","HLOUSR",332,0)
 N DOLLARJ,FOUND
"RTN","HLOUSR",333,0)
 S DOLLARJ=""
"RTN","HLOUSR",334,0)
 S FOUND=0
"RTN","HLOUSR",335,0)
 F  S DOLLARJ=$O(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)) Q:DOLLARJ=""  I $P($G(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)),"^",3)["TASKMAN MULTI-LISTENER" S FOUND=1 Q
"RTN","HLOUSR",336,0)
 Q FOUND
"RTN","HLOUSR7")
0^19^B22703242^B22703242
"RTN","HLOUSR7",1,0)
HLOUSR7 ;OIFO-ALB/CJM - Deleting HLO queues ;01/13/2011
"RTN","HLOUSR7",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**147,153**;Oct 13, 1995;Build 11
"RTN","HLOUSR7",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR7",4,0)
 ;
"RTN","HLOUSR7",5,0)
 ;
"RTN","HLOUSR7",6,0)
SPURGE ; Entry point from ListManager for deleting sequential queues.
"RTN","HLOUSR7",7,0)
 N CONF,LINK,QUE,PORT,WHEN,COUNT,IEN
"RTN","HLOUSR7",8,0)
 S VALMBCK="R"
"RTN","HLOUSR7",9,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR7",10,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR7",11,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOUSR7",12,0)
 S QUE=$$GETQ^HLOUSR4()
"RTN","HLOUSR7",13,0)
 Q:QUE=""
"RTN","HLOUSR7",14,0)
 I '$D(^HLB("QUEUE","SEQUENCE",QUE)) W !,"There are no messages on that queue!" D PAUSE^VALM1 Q
"RTN","HLOUSR7",15,0)
 W !!,"Deleting a queue in error will result in lost messages!"
"RTN","HLOUSR7",16,0)
 Q:'$$ASKYESNO^HLOUSR2("Are you SURE you want to delete that queue","NO")
"RTN","HLOUSR7",17,0)
 W !!,"After removing the messages from the sequence queue they will deleted"
"RTN","HLOUSR7",18,0)
 W !,"When do you want to schedule the messages to be purged?"
"RTN","HLOUSR7",19,0)
 S WHEN=$$ASKWHEN($$FMADD^XLFDT($$NOW^XLFDT,7),"Date/Time to schedule purge:")
"RTN","HLOUSR7",20,0)
 Q:'WHEN
"RTN","HLOUSR7",21,0)
 S (IEN,COUNT)=0
"RTN","HLOUSR7",22,0)
 F  S IEN=$O(^HLB("QUEUE","SEQUENCE",QUE,IEN)) Q:'IEN  S COUNT=COUNT+1 Q:COUNT>100
"RTN","HLOUSR7",23,0)
 I COUNT>100,$$ASKTASK() D
"RTN","HLOUSR7",24,0)
 .S ZTRTN="SEQPURGE^HLOUSR7"
"RTN","HLOUSR7",25,0)
 .S ZTDESC="HLO QUEUE PURGE"
"RTN","HLOUSR7",26,0)
 .S ZTDTH=$H
"RTN","HLOUSR7",27,0)
 .S ZTIO=""
"RTN","HLOUSR7",28,0)
 .S ZTSAVE("QUE")=QUE,ZTSAVE("WHEN")=""
"RTN","HLOUSR7",29,0)
 .D ^%ZTLOAD
"RTN","HLOUSR7",30,0)
 .I '$G(ZTSK) W !!,?5,"UNABLE TO SCHEDULE PURGE JOB",!
"RTN","HLOUSR7",31,0)
 .I $G(ZTSK) W !!,?5,"Purge job is scheduled, task #"_ZTSK
"RTN","HLOUSR7",32,0)
 .D PAUSE^VALM1
"RTN","HLOUSR7",33,0)
 E  D
"RTN","HLOUSR7",34,0)
 .D SEQPURGE
"RTN","HLOUSR7",35,0)
 .I $L(HLRFRSH) D @HLRFRSH
"RTN","HLOUSR7",36,0)
 Q
"RTN","HLOUSR7",37,0)
 ;
"RTN","HLOUSR7",38,0)
OPURGE ; Entry point from ListManager for deleting outgoing queues.
"RTN","HLOUSR7",39,0)
 N CONF,LINK,QUE,PORT,WHEN,COUNT,IEN
"RTN","HLOUSR7",40,0)
 S VALMBCK="R"
"RTN","HLOUSR7",41,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR7",42,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR7",43,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOUSR7",44,0)
 S LINK=$$ASKLINK^HLOUSR
"RTN","HLOUSR7",45,0)
 Q:LINK=""
"RTN","HLOUSR7",46,0)
 W !
"RTN","HLOUSR7",47,0)
 S PORT=$$ASKPORT^HLOTRACE(LINK)
"RTN","HLOUSR7",48,0)
 I 'PORT W !,"There are no outgoing messages for that destination!" Q
"RTN","HLOUSR7",49,0)
 S LINK=LINK_":"_PORT
"RTN","HLOUSR7",50,0)
 W !
"RTN","HLOUSR7",51,0)
 S QUE=$$ASKQUE^HLOTRACE(LINK)
"RTN","HLOUSR7",52,0)
 I QUE=""  W !,"There are no outgoing messages for that destination!" Q
"RTN","HLOUSR7",53,0)
 W !!,"Deleting a queue in error will result in lost messages!"
"RTN","HLOUSR7",54,0)
 Q:'$$ASKYESNO^HLOUSR2("Are you SURE you want to delete that queue","NO")
"RTN","HLOUSR7",55,0)
 W !!,"After removing the messages from the outgoing queue they will deleted"
"RTN","HLOUSR7",56,0)
 W !,"When do you want to schedule the messages to be purged?"
"RTN","HLOUSR7",57,0)
 S WHEN=$$ASKWHEN($$FMADD^XLFDT($$NOW^XLFDT,7),"Date/Time to schedule purge:")
"RTN","HLOUSR7",58,0)
 Q:'WHEN
"RTN","HLOUSR7",59,0)
 S (IEN,COUNT)=0
"RTN","HLOUSR7",60,0)
 F  S IEN=$O(^HLB("QUEUE","OUT",LINK,QUE,IEN)) Q:'IEN  S COUNT=COUNT+1 Q:COUNT>100
"RTN","HLOUSR7",61,0)
 I COUNT>100,$$ASKTASK() D
"RTN","HLOUSR7",62,0)
 .S ZTRTN="OUTPURGE^HLOUSR7"
"RTN","HLOUSR7",63,0)
 .S ZTDESC="HLO QUEUE PURGE"
"RTN","HLOUSR7",64,0)
 .S ZTDTH=$H
"RTN","HLOUSR7",65,0)
 .S ZTIO=""
"RTN","HLOUSR7",66,0)
 .S ZTSAVE("LINK")="",ZTSAVE("QUE")=QUE,ZTSAVE("WHEN")=""
"RTN","HLOUSR7",67,0)
 .D ^%ZTLOAD
"RTN","HLOUSR7",68,0)
 .I '$G(ZTSK) W !!,?5,"UNABLE TO SCHEDULE PURGE JOB",!
"RTN","HLOUSR7",69,0)
 .I $G(ZTSK) W !!,?5,"Purge job is scheduled, task #"_ZTSK
"RTN","HLOUSR7",70,0)
 .D PAUSE^VALM1
"RTN","HLOUSR7",71,0)
 E  D
"RTN","HLOUSR7",72,0)
 .D OUTPURGE
"RTN","HLOUSR7",73,0)
 .D OUTQUE^HLOUSR6
"RTN","HLOUSR7",74,0)
 Q
"RTN","HLOUSR7",75,0)
 ;
"RTN","HLOUSR7",76,0)
ASKTASK() ;
"RTN","HLOUSR7",77,0)
 W !!,"There are a lot of messages pending on that queue!"
"RTN","HLOUSR7",78,0)
 Q $$ASKYESNO^HLOUSR2("Would you like to delete the queue in the background via a separate task","YES")
"RTN","HLOUSR7",79,0)
 ;
"RTN","HLOUSR7",80,0)
  ;
"RTN","HLOUSR7",81,0)
ASKWHEN(DEFAULT,PROMPT)       ;
"RTN","HLOUSR7",82,0)
 ;Description: Asks the user to enter a dt/tm.
"RTN","HLOUSR7",83,0)
 ;Input: DEFAULT - the suggested default dt/time (optional, defaults to NOW)
"RTN","HLOUSR7",84,0)
 ;PROMPT - optional prompt
"RTN","HLOUSR7",85,0)
 ;Output: Returns the date as the function value, or 0 if the user does not select a date
"RTN","HLOUSR7",86,0)
 ;
"RTN","HLOUSR7",87,0)
 ;
"RTN","HLOUSR7",88,0)
 N %DT
"RTN","HLOUSR7",89,0)
 S %DT="AEST"
"RTN","HLOUSR7",90,0)
 S:$L($G(PROMPT)) %DT("A")=PROMPT
"RTN","HLOUSR7",91,0)
 S %DT("B")=$$FMTE^XLFDT($S($L($G(DEFAULT)):DEFAULT,1:"NOW"))
"RTN","HLOUSR7",92,0)
 S %DT(0)="NOW"
"RTN","HLOUSR7",93,0)
 Q:$D(DTOUT) 0
"RTN","HLOUSR7",94,0)
 D ^%DT
"RTN","HLOUSR7",95,0)
 I Y=-1 Q 0
"RTN","HLOUSR7",96,0)
 Q Y
"RTN","HLOUSR7",97,0)
OUTPURGE ;Purge outgoing queue
"RTN","HLOUSR7",98,0)
 N MSG,CNT
"RTN","HLOUSR7",99,0)
 N MSG
"RTN","HLOUSR7",100,0)
 S (CNT,MSG)=0
"RTN","HLOUSR7",101,0)
 I '$D(ZTQUEUED) W !,"Removing messages....",!
"RTN","HLOUSR7",102,0)
 F  S MSG=$O(^HLB("QUEUE","OUT",LINK,QUE,MSG)) Q:'MSG  D
"RTN","HLOUSR7",103,0)
 .S CNT=CNT+1
"RTN","HLOUSR7",104,0)
 .I '(CNT#100),'$D(ZTQUEUED) W "."
"RTN","HLOUSR7",105,0)
 .I '(CNT#70000),'$D(ZTQUEUED) W "!"
"RTN","HLOUSR7",106,0)
 .D DEQUE^HLOQUE(LINK,QUE,"OUT",MSG)
"RTN","HLOUSR7",107,0)
 .I $$SETPURGE^HLOAPI3(MSG,WHEN) S $P(^HLB(MSG,0),"^",21)="MESSAGE GENERATED IN ERROR AND NOT TRANSMITTED"
"RTN","HLOUSR7",108,0)
 Q
"RTN","HLOUSR7",109,0)
 ;
"RTN","HLOUSR7",110,0)
SEQPURGE ;Purge sequence queue
"RTN","HLOUSR7",111,0)
 N MSG,CNT
"RTN","HLOUSR7",112,0)
 S (CNT,MSG)=0
"RTN","HLOUSR7",113,0)
 I '$D(ZTQUEUED) W !,"Removing messages....",!
"RTN","HLOUSR7",114,0)
 F  S MSG=$O(^HLB("QUEUE","SEQUENCE",QUE,MSG)) Q:'MSG  D
"RTN","HLOUSR7",115,0)
 .S CNT=CNT+1
"RTN","HLOUSR7",116,0)
 .I '(CNT#100),'$D(ZTQUEUED) W "."
"RTN","HLOUSR7",117,0)
 .I '(CNT#70000),'$D(ZTQUEUED) W "!"
"RTN","HLOUSR7",118,0)
 .K ^HLB("QUEUE","SEQUENCE",QUE,MSG)
"RTN","HLOUSR7",119,0)
 .I $$SETPURGE^HLOAPI3(MSG,WHEN) S $P(^HLB(MSG,0),"^",21)="MESSAGE GENERATED IN ERROR AND NOT TRANSMITTED"
"RTN","HLOUSR7",120,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")),-$G(^HLC("QUEUECOUNT","SEQUENCE",QUE)))
"RTN","HLOUSR7",121,0)
 S ^HLC("QUEUECOUNT","SEQUENCE",QUE)=0
"RTN","HLOUSR7",122,0)
 S ^HLB("QUEUE","SEQUENCE",QUE)=""
"RTN","HLOUSR7",123,0)
 Q
"RTN","HLP153")
0^6^B2856907^n/a
"RTN","HLP153",1,0)
HLP153 ;IRMFO-ALB/CJM -Post-Install routine;03/24/2004  14:43 ;02/14/2011
"RTN","HLP153",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**153**;Oct 13, 1995;Build 11
"RTN","HLP153",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLP153",4,0)
 ;
"RTN","HLP153",5,0)
POST N IEN,DATA
"RTN","HLP153",6,0)
 ;
"RTN","HLP153",7,0)
 ;Inactivates HL7 Monitor-Link 870
"RTN","HLP153",8,0)
 S IEN=$O(^HLEV(776.1,"B","LINK (870) CHECKS",0))
"RTN","HLP153",9,0)
 I IEN,$D(^HLEV(776.1,IEN,0)) S $P(^HLEV(776.1,IEN,0),"^",2)="I"
"RTN","HLP153",10,0)
 ;
"RTN","HLP153",11,0)
 ;These two entries need to be in the HLO Process Registry file.
"RTN","HLP153",12,0)
 S IEN=$O(^HLD(779.3,"B","COUNT RECORDS",0))
"RTN","HLP153",13,0)
 I 'IEN S DATA(.01)="COUNT RECORDS",DATA(.02)=1,IEN=$$ADD^HLOASUB1(779.3,,.DATA)
"RTN","HLP153",14,0)
 I IEN S ^HLD(779.3,IEN,0)="COUNT RECORDS^1^0^1^1440^"_DT_".02^0^QUIT1^HLOPROC1^UPDCNTS^HLOSITE^1^0^^0",^HLD(779.3,"C",1,IEN)="" K ^HLD(779.3,"C",0,IEN)
"RTN","HLP153",15,0)
 ;
"RTN","HLP153",16,0)
 S IEN=$O(^HLD(779.3,"B","RECOUNT ALL QUEUES",0))
"RTN","HLP153",17,0)
 I 'IEN S DATA(.01)="RECOUNT ALL QUEUES",DATA(.02)=1,IEN=$$ADD^HLOASUB1(779.3,,.DATA)
"RTN","HLP153",18,0)
 I IEN S ^HLD(779.3,IEN,0)="RECOUNT ALL QUEUES^1^0^1^2880^"_DT_".02^0^QUIT1^HLOPROC1^QCOUNT^HLOPROC1^1^0^^0",^HLD(779.3,"C",1,IEN)="" K ^HLD(779.3,"C",0,IEN)
"RTN","HLP153",19,0)
 Q
"RTN","HLQPURGE")
0^14^B43329113^n/a
"RTN","HLQPURGE",1,0)
HLQPURGE ;ALB/CJM/ -PURGING A LINK ;02/14/2011
"RTN","HLQPURGE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**153**;Oct 13, 1995;Build 11
"RTN","HLQPURGE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLQPURGE",4,0)
 ;
"RTN","HLQPURGE",5,0)
ASKPURGE ;
"RTN","HLQPURGE",6,0)
 N LINKIEN,END,LINKNAME,QUIT
"RTN","HLQPURGE",7,0)
 S LINKIEN=$$ASKLINK
"RTN","HLQPURGE",8,0)
 ;W !,"LINKIEN=",LINKIEN
"RTN","HLQPURGE",9,0)
 Q:'LINKIEN
"RTN","HLQPURGE",10,0)
 S LINKNAME=$P($G(^HLCS(870,LINKIEN,0)),"^")
"RTN","HLQPURGE",11,0)
 I '$P($G(^HLCS(870,LINKIEN,0)),"^",15) W !!,LINKNAME_" must be shutdown before it can be cleared of pending messages!" Q
"RTN","HLQPURGE",12,0)
 S PROMPT="Are you sure you want to purge "_LINKNAME
"RTN","HLQPURGE",13,0)
 Q:'$$ASKYESNO(PROMPT,"NO")
"RTN","HLQPURGE",14,0)
 S QUIT=0
"RTN","HLQPURGE",15,0)
 ;;; Added the following instuctional message. - RBN
"RTN","HLQPURGE",16,0)
 W !!,"There are two purging options: ALL or Before a particular DT/TM",!
"RTN","HLQPURGE",17,0)
 S PROMPT="Do you want to purge all messages queued to that link"
"RTN","HLQPURGE",18,0)
 I '$$ASKYESNO(PROMPT,"NO") D  Q:QUIT
"RTN","HLQPURGE",19,0)
 .S PROMPT="Do you want to purge messages before a particular DT/TM"
"RTN","HLQPURGE",20,0)
 .I '$$ASKYESNO(PROMPT,"YES") W !,"Sorry, those are the only options!" S QUIT=1 QUIT
"RTN","HLQPURGE",21,0)
 .S END=$$ASKEND
"RTN","HLQPURGE",22,0)
 .I 'END S QUIT=1
"RTN","HLQPURGE",23,0)
 I '$G(END) S END=0
"RTN","HLQPURGE",24,0)
 D QPURGE(LINKIEN,END)
"RTN","HLQPURGE",25,0)
 S $P(^HLCS(870,LINKIEN,"OUT QUEUE FRONT POINTER"),"^")=0
"RTN","HLQPURGE",26,0)
 S $P(^HLCS(870,LINKIEN,"OUT QUEUE BACK POINTER"),"^")=$$COUNT(LINKIEN)
"RTN","HLQPURGE",27,0)
 Q
"RTN","HLQPURGE",28,0)
RESET ;Resets the counters for a TCP queue
"RTN","HLQPURGE",29,0)
 N LINKIEN,STATE
"RTN","HLQPURGE",30,0)
 S LINKIEN=$$ASKLINK
"RTN","HLQPURGE",31,0)
 Q:'LINKIEN
"RTN","HLQPURGE",32,0)
 S $P(^HLCS(870,LINKIEN,"OUT QUEUE FRONT POINTER"),"^")=0
"RTN","HLQPURGE",33,0)
 S $P(^HLCS(870,LINKIEN,"OUT QUEUE BACK POINTER"),"^")=$$COUNT(LINKIEN)
"RTN","HLQPURGE",34,0)
 S $P(^HLCS(870,LINKIEN,"IN QUEUE FRONT POINTER"),"^")=0
"RTN","HLQPURGE",35,0)
 S $P(^HLCS(870,LINKIEN,"IN QUEUE BACK POINTER"),"^")=$$COUNT(LINKIEN,"I")
"RTN","HLQPURGE",36,0)
 S STATE=$P(^HLCS(870,LINKIEN,0),U,5)
"RTN","HLQPURGE",37,0)
 I +STATE,$P(STATE," ",2)="server" S STATE="0 server"
"RTN","HLQPURGE",38,0)
 Q
"RTN","HLQPURGE",39,0)
 ;
"RTN","HLQPURGE",40,0)
QPURGE(LINKIEN,END) ;
"RTN","HLQPURGE",41,0)
 N MSGIEN,QUIT,DOTCNT,MSGCNT
"RTN","HLQPURGE",42,0)
 S (QUIT,MSGIEN,DOTCNT,DOTCNT,MSGCNT)=0
"RTN","HLQPURGE",43,0)
 I $D(^HLMA("AC","O",LINKIEN)) D
"RTN","HLQPURGE",44,0)
 . W !
"RTN","HLQPURGE",45,0)
 E  W !,"There are no messages to purge!" Q
"RTN","HLQPURGE",46,0)
 F  S MSGIEN=$O(^HLMA("AC","O",LINKIEN,MSGIEN)) Q:'MSGIEN  D  Q:QUIT
"RTN","HLQPURGE",47,0)
 .I END S QUIT=0 D  Q:QUIT
"RTN","HLQPURGE",48,0)
 ..N TIME,BODY
"RTN","HLQPURGE",49,0)
 ..S BODY=$P($G(^HLMA(MSGIEN,0)),"^")
"RTN","HLQPURGE",50,0)
 ..Q:'BODY
"RTN","HLQPURGE",51,0)
 ..S TIME=$P($G(^HL(772,BODY,0)),"^")
"RTN","HLQPURGE",52,0)
 ..I TIME>END S QUIT=1
"RTN","HLQPURGE",53,0)
 .;
"RTN","HLQPURGE",54,0)
 .; Added counter to decrease the number of dots printed - RBN
"RTN","HLQPURGE",55,0)
 .; Added counter to display the number of messages processed - RBN
"RTN","HLQPURGE",56,0)
 .; 
"RTN","HLQPURGE",57,0)
 .;W "."
"RTN","HLQPURGE",58,0)
 .;
"RTN","HLQPURGE",59,0)
 .I '(DOTCNT#1000) D
"RTN","HLQPURGE",60,0)
 ..W "."
"RTN","HLQPURGE",61,0)
 .S DOTCNT=DOTCNT+1
"RTN","HLQPURGE",62,0)
 .S MSGCNT=MSGCNT+1
"RTN","HLQPURGE",63,0)
 .K ^HLMA("AC","O",LINKIEN,MSGIEN)
"RTN","HLQPURGE",64,0)
 .S $P(^HLMA(MSGIEN,"P"),"^",1)="4"
"RTN","HLQPURGE",65,0)
 .S $P(^HLMA(MSGIEN,"P"),"^",2)=$$NOW^XLFDT
"RTN","HLQPURGE",66,0)
 .S $P(^HLMA(MSGIEN,"P"),"^",3)="Cancelled by application"
"RTN","HLQPURGE",67,0)
 .D PURGE(MSGIEN)
"RTN","HLQPURGE",68,0)
 W !,"DONE: "_MSGCNT_" messages processed."
"RTN","HLQPURGE",69,0)
 Q
"RTN","HLQPURGE",70,0)
 ;
"RTN","HLQPURGE",71,0)
PURGE(IEN) ;sets the AI x-ref on file 773 and the FAST PURGE DT/TM fields in file 772 and 773
"RTN","HLQPURGE",72,0)
 ;Input:  IEN is the ien of record in file 773
"RTN","HLQPURGE",73,0)
 ;
"RTN","HLQPURGE",74,0)
 Q:'$G(IEN)
"RTN","HLQPURGE",75,0)
 ;
"RTN","HLQPURGE",76,0)
 ;
"RTN","HLQPURGE",77,0)
 N NODE,WHEN,CHILD
"RTN","HLQPURGE",78,0)
 ;
"RTN","HLQPURGE",79,0)
 ;also not if DON'T PURGE field is set
"RTN","HLQPURGE",80,0)
 Q:$P($G(^HLMA(IEN,2)),"^")=1
"RTN","HLQPURGE",81,0)
 ;
"RTN","HLQPURGE",82,0)
 ;also not if this isn't the initial message
"RTN","HLQPURGE",83,0)
 S NODE=$G(^HLMA(IEN,0))
"RTN","HLQPURGE",84,0)
 I $P(NODE,"^",6),$P(NODE,"^",6)'=IEN Q
"RTN","HLQPURGE",85,0)
 ;
"RTN","HLQPURGE",86,0)
 ;This record can be purged via FAST PURGE
"RTN","HLQPURGE",87,0)
 ;determine the dt/tm the record can be purged
"RTN","HLQPURGE",88,0)
 S WHEN=$$NOW^XLFDT
"RTN","HLQPURGE",89,0)
 S WHEN=$$FMADD^XLFDT(WHEN,3)
"RTN","HLQPURGE",90,0)
 ;
"RTN","HLQPURGE",91,0)
 ;set the FAST PURGE DT/TM and x-ref, and do the same for file 772 record
"RTN","HLQPURGE",92,0)
 D SET(IEN,WHEN,+NODE)
"RTN","HLQPURGE",93,0)
 ;
"RTN","HLQPURGE",94,0)
 ;All the records in file 773 that point to this record (children) should be purged at the same time
"RTN","HLQPURGE",95,0)
 S CHILD=0
"RTN","HLQPURGE",96,0)
 F  S CHILD=$O(^HLMA("AF",IEN,CHILD)) Q:'CHILD  D:(CHILD'=IEN) SET(CHILD,WHEN,+$G(^HLMA(CHILD,0)))
"RTN","HLQPURGE",97,0)
 Q
"RTN","HLQPURGE",98,0)
 ;
"RTN","HLQPURGE",99,0)
SET(IEN773,WHEN,IEN772) ;sets FAST PURGE DT/TM for and the AI x~ref for both file 772 & 773
"RTN","HLQPURGE",100,0)
 ;Input:
"RTN","HLQPURGE",101,0)
 ;   IEN773 - ien of record to be purged in file 773
"RTN","HLQPURGE",102,0)
 ;   WHEN - date/time to purge
"RTN","HLQPURGE",103,0)
 ;   IEN772 - ien of corresponding record in file 772
"RTN","HLQPURGE",104,0)
 ;
"RTN","HLQPURGE",105,0)
 N OLDWHEN
"RTN","HLQPURGE",106,0)
 ;if the fast purge dt/tm changed, kill the old xref
"RTN","HLQPURGE",107,0)
 S OLDWHEN=$P($G(^HLMA(IEN773,2)),"^",2)
"RTN","HLQPURGE",108,0)
 I $L(OLDWHEN) K ^HLMA("AI",OLDWHEN,773,IEN773)
"RTN","HLQPURGE",109,0)
 ;
"RTN","HLQPURGE",110,0)
 ;set the FAST PURGE DATE
"RTN","HLQPURGE",111,0)
 S $P(^HLMA(IEN773,2),"^",2)=WHEN
"RTN","HLQPURGE",112,0)
 ;
"RTN","HLQPURGE",113,0)
 ;set the AI x-ref
"RTN","HLQPURGE",114,0)
 S ^HLMA("AI",WHEN,773,IEN773)=""
"RTN","HLQPURGE",115,0)
 ;
"RTN","HLQPURGE",116,0)
 ;do the same for the corresponding entry in file 772
"RTN","HLQPURGE",117,0)
 I IEN772,$D(^HL(772,IEN772,0)) D
"RTN","HLQPURGE",118,0)
 .;if the fast purge dt/tm changed, kill the old xref
"RTN","HLQPURGE",119,0)
 .S OLDWHEN=$P($G(^HL(772,IEN772,2)),"^",2)
"RTN","HLQPURGE",120,0)
 .I $L(OLDWHEN) K ^HLMA("AI",OLDWHEN,772,IEN772)
"RTN","HLQPURGE",121,0)
 .;set the FAST PURGE DATE
"RTN","HLQPURGE",122,0)
 .S $P(^HL(772,IEN772,2),"^",2)=WHEN
"RTN","HLQPURGE",123,0)
 .;
"RTN","HLQPURGE",124,0)
 .;set the AI x-ref
"RTN","HLQPURGE",125,0)
 .S ^HLMA("AI",WHEN,772,IEN772)=""
"RTN","HLQPURGE",126,0)
 Q
"RTN","HLQPURGE",127,0)
 ;
"RTN","HLQPURGE",128,0)
ASKYESNO(PROMPT,DEFAULT) ;
"RTN","HLQPURGE",129,0)
 ;Description: Displays PROMPT, appending '?'.  Expects a YES NO response
"RTN","HLQPURGE",130,0)
 ;Input:
"RTN","HLQPURGE",131,0)
 ;   PROMPT - text to display as prompt.  Appends '?'
"RTN","HLQPURGE",132,0)
 ;   DEFAULT - (optional) YES or NO.  If not passed, defaults to YES
"RTN","HLQPURGE",133,0)
 ;Output:
"RTN","HLQPURGE",134,0)
 ;  Function value: 1 if yes, 0 if no, "" if '^' entered or timeout
"RTN","HLQPURGE",135,0)
 ;
"RTN","HLQPURGE",136,0)
 N DIR,Y
"RTN","HLQPURGE",137,0)
 S DIR(0)="Y"
"RTN","HLQPURGE",138,0)
 S DIR("A")=PROMPT
"RTN","HLQPURGE",139,0)
 S DIR("B")=$S($G(DEFAULT)="NO":"NO",1:"YES")
"RTN","HLQPURGE",140,0)
 D ^DIR
"RTN","HLQPURGE",141,0)
 Q:$D(DIRUT) ""
"RTN","HLQPURGE",142,0)
 Q Y
"RTN","HLQPURGE",143,0)
 ;
"RTN","HLQPURGE",144,0)
ASKLINK() ;
"RTN","HLQPURGE",145,0)
 N DIC,TCP,X,Y,DTOUT,DUOUT
"RTN","HLQPURGE",146,0)
 S DIC=870
"RTN","HLQPURGE",147,0)
 S DIC(0)="AENQ"
"RTN","HLQPURGE",148,0)
 S TCP=$O(^HLCS(869.1,"B","TCP",0))
"RTN","HLQPURGE",149,0)
 S DIC("A")="Select a TCP link:"
"RTN","HLQPURGE",150,0)
 S DIC("S")="I $P(^(0),U,3)=TCP"
"RTN","HLQPURGE",151,0)
 D ^DIC
"RTN","HLQPURGE",152,0)
 I +Y'=-1,'$D(DTOUT),'$D(DUOUT) Q $P(Y,"^")
"RTN","HLQPURGE",153,0)
 Q ""
"RTN","HLQPURGE",154,0)
 ;
"RTN","HLQPURGE",155,0)
ASKEND() ;
"RTN","HLQPURGE",156,0)
 ;
"RTN","HLQPURGE",157,0)
 N %DT
"RTN","HLQPURGE",158,0)
 S %DT="AEST"
"RTN","HLQPURGE",159,0)
 S %DT("A")="Enter the ending date/time: "
"RTN","HLQPURGE",160,0)
 S %DT(0)="-NOW"
"RTN","HLQPURGE",161,0)
 Q:$D(DTOUT) 0
"RTN","HLQPURGE",162,0)
 D ^%DT
"RTN","HLQPURGE",163,0)
 I Y=-1 Q 0
"RTN","HLQPURGE",164,0)
 Q Y
"RTN","HLQPURGE",165,0)
COUNT(LINKIEN,DIR) ;
"RTN","HLQPURGE",166,0)
 N MSG,COUNT
"RTN","HLQPURGE",167,0)
 I $G(DIR)="" S DIR="O"
"RTN","HLQPURGE",168,0)
 S (MSG,COUNT)=0
"RTN","HLQPURGE",169,0)
 F  S MSG=$O(^HLMA("AC",DIR,LINKIEN,MSG)) Q:'MSG  S COUNT=COUNT+1
"RTN","HLQPURGE",170,0)
 Q COUNT
"RTN","HLQPURGE",171,0)
SHOWTCP ;
"RTN","HLQPURGE",172,0)
 N Q,H,F,NM,HDR,LINE,QUIT,CRT
"RTN","HLQPURGE",173,0)
 S QUIT=0
"RTN","HLQPURGE",174,0)
 S CRT=$S($E(IOST,1,2)="C-":1,1:0)
"RTN","HLQPURGE",175,0)
 W @IOF
"RTN","HLQPURGE",176,0)
 S HDR(1)="Link(ien)       Dir/Dev/Auto    First Message      Count      State"
"RTN","HLQPURGE",177,0)
 S HDR(2)="=========       ============    ===============    =========  =========="
"RTN","HLQPURGE",178,0)
 D LINE(HDR(1))
"RTN","HLQPURGE",179,0)
 D LINE(HDR(2))
"RTN","HLQPURGE",180,0)
 F Q="I","O" D
"RTN","HLQPURGE",181,0)
 .S H=0
"RTN","HLQPURGE",182,0)
 .F  S H=$O(^HLMA("AC",Q,H)) Q:'H  Q:QUIT  D
"RTN","HLQPURGE",183,0)
 ..N NODE0
"RTN","HLQPURGE",184,0)
 ..S NODE0=$G(^HLCS(870,H,0))
"RTN","HLQPURGE",185,0)
 ..S F=$O(^HLMA("AC",Q,H,0))
"RTN","HLQPURGE",186,0)
 ..S NM=$P(NODE0,"^")
"RTN","HLQPURGE",187,0)
 ..S:NM="" NM="ORPHAN"
"RTN","HLQPURGE",188,0)
 ..S LINE=$$LJ(NM_"("_H_")",14)_"  "_$$LJ(Q_"/"_$$LJ($P(NODE0,"^",4),2)_"/"_$S($P(NODE0,"^",6):"  ",1:"No"),15)_" "_$$LJ($S($P($G(^HLMA(F,"P")),"^",1)'=1:"*",1:"")_F,18)_$$RJ($$COUNT(H,Q),10)_"   "_$P(NODE0,"^",5)
"RTN","HLQPURGE",189,0)
 ..D LINE(LINE)
"RTN","HLQPURGE",190,0)
 Q
"RTN","HLQPURGE",191,0)
 ;
"RTN","HLQPURGE",192,0)
PAUSE ;
"RTN","HLQPURGE",193,0)
 ;First scrolls to the bottom of the page, then does a screen pause.  Sets QUIT=1 if user decides to quit.
"RTN","HLQPURGE",194,0)
 ;
"RTN","HLQPURGE",195,0)
 D PAUSE2
"RTN","HLQPURGE",196,0)
 Q:QUIT
"RTN","HLQPURGE",197,0)
 W HDR(1),!,HDR(2)
"RTN","HLQPURGE",198,0)
 Q
"RTN","HLQPURGE",199,0)
PAUSE2 ;
"RTN","HLQPURGE",200,0)
 ;Screen pause without scrolling.  Sets QUIT=1 if user decides to quit.
"RTN","HLQPURGE",201,0)
 ;
"RTN","HLQPURGE",202,0)
 N DIR,X,Y
"RTN","HLQPURGE",203,0)
 S DIR(0)="E"
"RTN","HLQPURGE",204,0)
 D ^DIR
"RTN","HLQPURGE",205,0)
 I ('(+Y))!$D(DIRUT) S QUIT=1
"RTN","HLQPURGE",206,0)
 Q
"RTN","HLQPURGE",207,0)
 ;
"RTN","HLQPURGE",208,0)
LINE(LINE) ;Prints a line.
"RTN","HLQPURGE",209,0)
 ;
"RTN","HLQPURGE",210,0)
 I CRT,($Y>(IOSL-4)) D
"RTN","HLQPURGE",211,0)
 .D PAUSE
"RTN","HLQPURGE",212,0)
 .Q:QUIT
"RTN","HLQPURGE",213,0)
 .W @IOF
"RTN","HLQPURGE",214,0)
 .W HDR(1),!,HDR(2),!
"RTN","HLQPURGE",215,0)
 .W LINE
"RTN","HLQPURGE",216,0)
 ;
"RTN","HLQPURGE",217,0)
 E  I ('CRT),($Y>(IOSL-2)) D
"RTN","HLQPURGE",218,0)
 .W @IOF
"RTN","HLQPURGE",219,0)
 .W HDR(1),!,HDR(2)
"RTN","HLQPURGE",220,0)
 .W LINE
"RTN","HLQPURGE",221,0)
 E  W !,LINE
"RTN","HLQPURGE",222,0)
 Q
"RTN","HLQPURGE",223,0)
 ;
"RTN","HLQPURGE",224,0)
LJ(STRING,LEN) ;
"RTN","HLQPURGE",225,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLQPURGE",226,0)
RJ(STRING,LEN) ;
"RTN","HLQPURGE",227,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLQPURGE",228,0)
ONETCP ;Display one TCP link
"RTN","HLQPURGE",229,0)
 N IEN,DA,MSG,DIC,DIR,QUIT
"RTN","HLQPURGE",230,0)
 S QUIT=0
"RTN","HLQPURGE",231,0)
 S IEN=$$ASKLINK
"RTN","HLQPURGE",232,0)
 Q:'IEN
"RTN","HLQPURGE",233,0)
 Q:QUIT
"RTN","HLQPURGE",234,0)
 F DIR="I","O" D  Q:QUIT
"RTN","HLQPURGE",235,0)
 .S MSG=$O(^HLMA("AC",DIR,IEN,0))
"RTN","HLQPURGE",236,0)
 .I MSG D
"RTN","HLQPURGE",237,0)
 ..W @IOF,!!,"Count of messages on ",$S(DIR="I":"incoming",1:"outgoing")," queue: ",$$COUNT(IEN,DIR)
"RTN","HLQPURGE",238,0)
 ..W !!,"First pending message follows:",!
"RTN","HLQPURGE",239,0)
 ..S DIC="^HLMA("
"RTN","HLQPURGE",240,0)
 ..S DA=MSG
"RTN","HLQPURGE",241,0)
 ..D EN^DIQ
"RTN","HLQPURGE",242,0)
 ..D PAUSE2
"RTN","HLQPURGE",243,0)
 Q:QUIT
"RTN","HLQPURGE",244,0)
 W @IOF,!!,"Here is the TCP link:",!
"RTN","HLQPURGE",245,0)
 S DIC="^HLCS(870,"
"RTN","HLQPURGE",246,0)
 S DA=IEN
"RTN","HLQPURGE",247,0)
 D EN^DIQ
"RTN","HLQPURGE",248,0)
 Q
"RTN","HLUOPT1")
0^1^B61661726^B57283187
"RTN","HLUOPT1",1,0)
HLUOPT1 ;AISC/SAW - Purging Entries in file #772 and #773 ;12/30/2010
"RTN","HLUOPT1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**10,13,21,36,19,47,62,109,108,153**;Oct 13, 1995;Build 11
"RTN","HLUOPT1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLUOPT1",4,0)
 ;
"RTN","HLUOPT1",5,0)
 ; Purge data of the HL7 message in file #772 and #773.
"RTN","HLUOPT1",6,0)
 ;
"RTN","HLUOPT1",7,0)
 ; Patch 47 - For Purging Option scheduled on a recurring basis,
"RTN","HLUOPT1",8,0)
 ; numbers of days kept for various Status of message are stored
"RTN","HLUOPT1",9,0)
 ; in file #869.3, fields 41, 42, and 43.  Default values for these
"RTN","HLUOPT1",10,0)
 ; fields are 7, 30, and 90, respectively.
"RTN","HLUOPT1",11,0)
 ;
"RTN","HLUOPT1",12,0)
 ; Patch 36 - a message will never be purged if the new field, "Don't
"RTN","HLUOPT1",13,0)
 ; Purge" (#772,15), is set to 1.
"RTN","HLUOPT1",14,0)
 ;
"RTN","HLUOPT1",15,0)
PURGE ;
"RTN","HLUOPT1",16,0)
 ; HLPDT("COMP") - 'completed' status cutoff date
"RTN","HLUOPT1",17,0)
 ; HLPDT("WAIT") - 'awaiting ack' status cutoff date
"RTN","HLUOPT1",18,0)
 ; HLPDT("ERR")  - 'error' status cutoff date
"RTN","HLUOPT1",19,0)
 ;                 (=0 means don't delete msgs in 'error' status)
"RTN","HLUOPT1",20,0)
 ; HLPDT("ALL")  - all other status (except 'error') cutoff date
"RTN","HLUOPT1",21,0)
 N HLPDT,HLTASK,HLEXIT
"RTN","HLUOPT1",22,0)
 ;
"RTN","HLUOPT1",23,0)
 S (HLTASK,HLEXIT)=0
"RTN","HLUOPT1",24,0)
 D INIT(.HLPDT,.HLTASK,.HLEXIT) Q:HLEXIT
"RTN","HLUOPT1",25,0)
 ;
"RTN","HLUOPT1",26,0)
 ; HL*1.6*109 lock logic...
"RTN","HLUOPT1",27,0)
 L +^HL("HLUOPT1"):2 I '$T D:'$D(ZTQUEUED) LOCKTELL^HLUOPT4 QUIT  ;->
"RTN","HLUOPT1",28,0)
 L -^HL("HLUOPT1") ; Locked again at the top of DQ
"RTN","HLUOPT1",29,0)
 ;
"RTN","HLUOPT1",30,0)
 ; HL*1.6*109
"RTN","HLUOPT1",31,0)
 I '$D(ZTQUEUED) I $$BTE^HLCSMON("Press RETURN to "_$S(HLTASK:"queue job",1:"start purging")_", or enter '^' to exit... ",1) D  QUIT  ;->
"RTN","HLUOPT1",32,0)
 .  I HLTASK W "  no task started..."
"RTN","HLUOPT1",33,0)
 .  I 'HLTASK W "  exiting..."
"RTN","HLUOPT1",34,0)
 ;
"RTN","HLUOPT1",35,0)
 I HLTASK D TASKIT Q
"RTN","HLUOPT1",36,0)
 K HLTASK,HLEXIT ; not needed
"RTN","HLUOPT1",37,0)
 D DQ
"RTN","HLUOPT1",38,0)
 ;
"RTN","HLUOPT1",39,0)
 Q
"RTN","HLUOPT1",40,0)
 ;
"RTN","HLUOPT1",41,0)
INIT(HLPDT,HLTASK,HLEXIT) ; Get data from file #869.3
"RTN","HLUOPT1",42,0)
 D INIT^HLUOPT4 ; HL*1.6*109
"RTN","HLUOPT1",43,0)
 Q
"RTN","HLUOPT1",44,0)
 ;
"RTN","HLUOPT1",45,0)
TASKIT ; Queue task to run in the background
"RTN","HLUOPT1",46,0)
 N ZTDESC,ZTDTH,ZTIO,ZTRTN,ZTSAVE
"RTN","HLUOPT1",47,0)
 S ZTRTN="DQ^HLUOPT1",ZTIO="",ZTSAVE("HLPDT(")="",ZTDTH=$H
"RTN","HLUOPT1",48,0)
 S ZTDESC="Purge HL7 message text on or before "_$$FMTE^XLFDT(HLPDT("COMP"),"5D")
"RTN","HLUOPT1",49,0)
 D ^%ZTLOAD
"RTN","HLUOPT1",50,0)
 I $D(ZTSK) W !,"  Task #",ZTSK," queued to run now...",! Q  ; HL*1.6*109
"RTN","HLUOPT1",51,0)
 W !,"  Queuing of Purge task failed.",! ; HL*1.6*109
"RTN","HLUOPT1",52,0)
 Q
"RTN","HLUOPT1",53,0)
DQ ; Entry point for running purge of HL7 message text
"RTN","HLUOPT1",54,0)
 N HLDELCNT,HLEXIT,HLOOPCT
"RTN","HLUOPT1",55,0)
 ;
"RTN","HLUOPT1",56,0)
 S HLOOPCT=0
"RTN","HLUOPT1",57,0)
 ;
"RTN","HLUOPT1",58,0)
 ; HL*1.6*109
"RTN","HLUOPT1",59,0)
 N XTMP D XTMPBEGN^HLUOPT4
"RTN","HLUOPT1",60,0)
 ;
"RTN","HLUOPT1",61,0)
 ; Lock to ensures no other purge job can run...
"RTN","HLUOPT1",62,0)
 L +^HL("HLUOPT1"):10 I '$T D  QUIT  ;->
"RTN","HLUOPT1",63,0)
 .  D XTMPUPD^HLUOPT4(.XTMP,"NO-LOCK","DONE")
"RTN","HLUOPT1",64,0)
 .  I $D(ZTQUEUED) S ZTREQ="@"
"RTN","HLUOPT1",65,0)
 ;
"RTN","HLUOPT1",66,0)
 ; Purge 773s...
"RTN","HLUOPT1",67,0)
 S (HLDELCNT,HLEXIT)=0
"RTN","HLUOPT1",68,0)
 D CHK773(.HLPDT,.HLDELCNT,.HLEXIT)
"RTN","HLUOPT1",69,0)
 ;
"RTN","HLUOPT1",70,0)
 ; Update piece 4 of file's zero node...
"RTN","HLUOPT1",71,0)
 D UPDP4(773)
"RTN","HLUOPT1",72,0)
 ;
"RTN","HLUOPT1",73,0)
 ; Purge 772s...
"RTN","HLUOPT1",74,0)
 I 'HLEXIT D CHK772(.HLPDT,.HLDELCNT,.HLEXIT)
"RTN","HLUOPT1",75,0)
 ;
"RTN","HLUOPT1",76,0)
 ; Update piece 4 of file's zero node...
"RTN","HLUOPT1",77,0)
 D UPDP4(772)
"RTN","HLUOPT1",78,0)
 ;
"RTN","HLUOPT1",79,0)
 ; HL*1.6*109
"RTN","HLUOPT1",80,0)
 L -^HL("HLUOPT1")
"RTN","HLUOPT1",81,0)
 ;
"RTN","HLUOPT1",82,0)
 D XTMPUPD^HLUOPT4(.XTMP,"FINISHED","DONE")
"RTN","HLUOPT1",83,0)
 I $D(ZTQUEUED) S ZTREQ="@" Q
"RTN","HLUOPT1",84,0)
 ;
"RTN","HLUOPT1",85,0)
 W !!,"  #",HLDELCNT," entries purged...",! ; HL*1.6*109
"RTN","HLUOPT1",86,0)
 ;
"RTN","HLUOPT1",87,0)
 Q
"RTN","HLUOPT1",88,0)
 ;
"RTN","HLUOPT1",89,0)
UPDP4(FNO) ; Update piece 4 of file's zero node...
"RTN","HLUOPT1",90,0)
 N GBL,NODE,NODEL,P4
"RTN","HLUOPT1",91,0)
 S GBL=$S(+FNO=772:"^HL(772,0)",+FNO=773:"^HLMA(0)",1:"") QUIT:GBL']""  ;->
"RTN","HLUOPT1",92,0)
 S NODEL=$G(XTMP(+FNO,"DEL")) QUIT:NODEL'>0  ;->
"RTN","HLUOPT1",93,0)
 L +@GBL:30 ; If don't get lock, update piece 4 anyway...
"RTN","HLUOPT1",94,0)
 S NODE=$G(@GBL) ; Get node...
"RTN","HLUOPT1",95,0)
 S P4=$P(NODE,U,4)-NODEL,P4=$S(P4>0:+P4,1:"") ; Recalc piece 4...
"RTN","HLUOPT1",96,0)
 S $P(NODE,U,4)=P4 ; Reset node's piece 4...
"RTN","HLUOPT1",97,0)
 S @GBL=NODE ; Store in file's zero node...
"RTN","HLUOPT1",98,0)
 L -@GBL
"RTN","HLUOPT1",99,0)
 Q
"RTN","HLUOPT1",100,0)
 ;
"RTN","HLUOPT1",101,0)
CHK773(HLPDT,HLDELCNT,HLEXIT) ; Check file 773
"RTN","HLUOPT1",102,0)
 N FPDATE,HLIEN,HLPTR,HLMADT,HLY,HLMADT1,HLLT773
"RTN","HLUOPT1",103,0)
 ;
"RTN","HLUOPT1",104,0)
 ; HL*1.6*109
"RTN","HLUOPT1",105,0)
 I '$G(HLTASK) W !,"Looping through file 773..."
"RTN","HLUOPT1",106,0)
 D XTMPUPD^HLUOPT4(.XTMP,"RUNNING","START-773")
"RTN","HLUOPT1",107,0)
 ;
"RTN","HLUOPT1",108,0)
 ;calculate cuttoff date for records reserved by Fast Purge - records with a more recent FAST PURGE DT/TM then this should be left to the Fast Purge to delete
"RTN","HLUOPT1",109,0)
 S FPDATE=$$FMADD^XLFDT(DT,-2)
"RTN","HLUOPT1",110,0)
 ;
"RTN","HLUOPT1",111,0)
 S HLLT773=$O(^HLMA(";"),-1) ; last ien for 773
"RTN","HLUOPT1",112,0)
 S HLIEN=0
"RTN","HLUOPT1",113,0)
 F  S HLIEN=$O(^HLMA(HLIEN)) Q:'HLIEN  D  Q:HLEXIT  Q:$$FAIL(773)  ;HL*1.6*109
"RTN","HLUOPT1",114,0)
 .N NODE0,NODEP
"RTN","HLUOPT1",115,0)
 . D CHK4STOP(.HLEXIT) Q:HLEXIT
"RTN","HLUOPT1",116,0)
 . S XTMP(773,"REV")=$G(XTMP(773,"REV"))+1,XTMP(773,"LAST")=HLIEN,XTMP(773,"FAIL")=$G(XTMP(773,"FAIL"))+1 ; HL*1.6*109
"RTN","HLUOPT1",117,0)
 . ;
"RTN","HLUOPT1",118,0)
 . ;check if the record is reserved for FAST PURGE
"RTN","HLUOPT1",119,0)
 . I ($P($G(^HLMA(HLIEN,2)),"^",2)\1)>FPDATE Q
"RTN","HLUOPT1",120,0)
 . ;
"RTN","HLUOPT1",121,0)
 . S NODE0=$G(^HLMA(HLIEN,0))
"RTN","HLUOPT1",122,0)
 . S HLPTR=+NODE0 Q:'HLPTR
"RTN","HLUOPT1",123,0)
 . S HLMADT=+$G(^HL(772,HLPTR,0))
"RTN","HLUOPT1",124,0)
 . ;HLY=status, HLMADT1=processed date
"RTN","HLUOPT1",125,0)
 . S NODEP=$G(^HLMA(HLIEN,"P"))
"RTN","HLUOPT1",126,0)
 . S HLY=+NODEP,HLMADT1=+$G(^("S"))
"RTN","HLUOPT1",127,0)
 .;** P153 START CJM
"RTN","HLUOPT1",128,0)
 . ;Delete incoming duplicate records as if completed, despite error status
"RTN","HLUOPT1",129,0)
 . I HLY>3,HLY<7,'(HLMADT1>HLPDT("COMP")),$P(NODE0,"^",3)="I",$P(NODEP,"^",4)=109 D KILL773(HLIEN,HLLT773,.HLDELCNT) Q
"RTN","HLUOPT1",130,0)
 .;** P153 END CJM
"RTN","HLUOPT1",131,0)
 . ;error status, quit if flag set to no
"RTN","HLUOPT1",132,0)
 . I HLY>3,HLY<8,'HLPDT("ERR") Q
"RTN","HLUOPT1",133,0)
 . ;check if date entered is less than purge all date
"RTN","HLUOPT1",134,0)
 . I HLMADT<HLPDT("ALL") D KILL773(HLIEN,HLLT773,.HLDELCNT) Q
"RTN","HLUOPT1",135,0)
 . ;pending, being generated, awaiting processing, or no processed date
"RTN","HLUOPT1",136,0)
 . I HLY=1!(HLY>7)!('HLMADT1) Q
"RTN","HLUOPT1",137,0)
 . ;awaiting ack, no purge date or date>purge date
"RTN","HLUOPT1",138,0)
 . I HLY=2,HLMADT1>HLPDT("WAIT") Q
"RTN","HLUOPT1",139,0)
 . ;successfully transmitted
"RTN","HLUOPT1",140,0)
 . I HLY=3,HLMADT1>HLPDT("COMP") Q
"RTN","HLUOPT1",141,0)
 . ;error status
"RTN","HLUOPT1",142,0)
 . I HLY>3,HLY<8,HLMADT1>HLPDT("ERR") Q
"RTN","HLUOPT1",143,0)
 . D KILL773(HLIEN,HLLT773,.HLDELCNT)
"RTN","HLUOPT1",144,0)
 D XTMPUPD^HLUOPT4(.XTMP,"RUNNING","END-773") ; HL*1.6*109
"RTN","HLUOPT1",145,0)
 Q
"RTN","HLUOPT1",146,0)
KILL773(HLIEN,HLLT773,HLDELCNT) ; delete in file 773
"RTN","HLUOPT1",147,0)
 ;
"RTN","HLUOPT1",148,0)
 ; quit if don't purge flag is set or the entry is the last one
"RTN","HLUOPT1",149,0)
 Q:$G(^HLMA(HLIEN,2))!(HLIEN=HLLT773)
"RTN","HLUOPT1",150,0)
 ;
"RTN","HLUOPT1",151,0)
 S X=$G(^HLMA(+HLIEN,0)),X=+$G(^HL(772,+X,0)),XTMP(773,"LAST","TIME")=$S(X?7N1"."1.N:+X,1:"")
"RTN","HLUOPT1",152,0)
 ;
"RTN","HLUOPT1",153,0)
 D DEL773^HLUOPT3(HLIEN) ; Purge w/direct kills...
"RTN","HLUOPT1",154,0)
 ;
"RTN","HLUOPT1",155,0)
 S HLDELCNT=HLDELCNT+1
"RTN","HLUOPT1",156,0)
 ;
"RTN","HLUOPT1",157,0)
 S XTMP(773,"DEL")=$G(XTMP(773,"DEL"))+1,XTMP(773,"FAIL")=0
"RTN","HLUOPT1",158,0)
 ;
"RTN","HLUOPT1",159,0)
 Q
"RTN","HLUOPT1",160,0)
 ;
"RTN","HLUOPT1",161,0)
CHK772(HLPDT,HLDELCNT,HLEXIT) ; Check file 772 for parents and children
"RTN","HLUOPT1",162,0)
 N FPDATE,HLOOP2,HLPTR,HLINK,HLIEN,HLMADT,HLY,HLLT772
"RTN","HLUOPT1",163,0)
 ;
"RTN","HLUOPT1",164,0)
 ; HL*1.6*109
"RTN","HLUOPT1",165,0)
 I '$G(HLTASK) W !,"Looping through file 772..."
"RTN","HLUOPT1",166,0)
 D XTMPUPD^HLUOPT4(.XTMP,"RUNNING","START-772")
"RTN","HLUOPT1",167,0)
 ;
"RTN","HLUOPT1",168,0)
 ;calculate cuttoff date for records reserved by Fast Purge - records with a more recent FAST PURGE DT/TM then this should be left to the Fast Purge to delete
"RTN","HLUOPT1",169,0)
 S FPDATE=$$FMADD^XLFDT(DT,-2)
"RTN","HLUOPT1",170,0)
 ;
"RTN","HLUOPT1",171,0)
 S HLLT772=$O(^HL(772,";"),-1) ; last ien for 772
"RTN","HLUOPT1",172,0)
 F HLOOP2=1:1:2 D  Q:HLEXIT  ; Kill children first, then parents
"RTN","HLUOPT1",173,0)
 . S XTMP(772,"FAIL")=0 ; HL*1.6*109
"RTN","HLUOPT1",174,0)
 . S HLPTR=0
"RTN","HLUOPT1",175,0)
 . F  S HLPTR=$O(^HL(772,"B",HLPTR)) Q:HLPTR'>0  D  Q:HLEXIT  Q:$$FAIL(772)  ; HL*1.6*109
"RTN","HLUOPT1",176,0)
 . . D CHK4STOP(.HLEXIT) Q:HLEXIT
"RTN","HLUOPT1",177,0)
 . . S HLIEN=0
"RTN","HLUOPT1",178,0)
 . . F  S HLIEN=$O(^HL(772,"B",HLPTR,HLIEN)) Q:'HLIEN  D
"RTN","HLUOPT1",179,0)
 . . . S XTMP(772,"REV")=$G(XTMP(772,"REV"))+1,XTMP(772,"LAST")=HLIEN,XTMP(772,"FAIL")=$G(XTMP(772,"FAIL"))+1 ; HL*1.6*109
"RTN","HLUOPT1",180,0)
 ... ;
"RTN","HLUOPT1",181,0)
 ... ;check if the record is reserved for FAST PURGE
"RTN","HLUOPT1",182,0)
 ... I ($P($G(^HL(772,+HLIEN,2)),"^",2)\1)>FPDATE Q
"RTN","HLUOPT1",183,0)
 ... ;
"RTN","HLUOPT1",184,0)
 . . . S HLMADT=+$G(^HL(772,+HLIEN,0)) Q:'HLMADT
"RTN","HLUOPT1",185,0)
 . . . I HLMADT>HLPDT("COMP") Q
"RTN","HLUOPT1",186,0)
 . . . S HLY=$P($G(^HL(772,HLIEN,"P")),U)
"RTN","HLUOPT1",187,0)
 . . . I HLY?1U S HLY=$TR(HLY,"PASE",1234)
"RTN","HLUOPT1",188,0)
 . . . I HLY>3,HLY<8,'HLPDT("ERR") Q
"RTN","HLUOPT1",189,0)
 . . . I HLMADT<HLPDT("ALL") D KILL772(HLIEN,HLLT772,.HLDELCNT) Q
"RTN","HLUOPT1",190,0)
 . . . I HLY=3,HLMADT>HLPDT("COMP") Q
"RTN","HLUOPT1",191,0)
 . . . I HLY=2,HLMADT>HLPDT("WAIT") Q
"RTN","HLUOPT1",192,0)
 . . . I HLY>3,HLY<8,HLMADT>HLPDT("ERR") Q
"RTN","HLUOPT1",193,0)
 . . . I HLY=1!(HLY>7) Q
"RTN","HLUOPT1",194,0)
 . . . I $O(^HL(772,"AI",HLIEN,HLIEN)) Q
"RTN","HLUOPT1",195,0)
 . . . D KILL772(HLIEN,HLLT772,.HLDELCNT)
"RTN","HLUOPT1",196,0)
 D XTMPUPD^HLUOPT4(.XTMP,"RUNNING","END-772") ; HL*1.6*109
"RTN","HLUOPT1",197,0)
 S HLINK=0
"RTN","HLUOPT1",198,0)
 F  S HLINK=$O(^HL(772,"A-XMIT-OUT",HLINK)) Q:'HLINK  D
"RTN","HLUOPT1",199,0)
 . S HLIEN=0
"RTN","HLUOPT1",200,0)
 . F  S HLIEN=$O(^HL(772,"A-XMIT-OUT",HLINK,HLIEN)) Q:'HLIEN  D
"RTN","HLUOPT1",201,0)
 . . I '$D(^HL(772,HLIEN)) K ^HL(772,"A-XMIT-OUT",HLINK,HLIEN)
"RTN","HLUOPT1",202,0)
 Q
"RTN","HLUOPT1",203,0)
KILL772(HLIEN,HLLT772,HLDELCNT) ;
"RTN","HLUOPT1",204,0)
 ;
"RTN","HLUOPT1",205,0)
 ; quit if the corresponding entry in #773 exists
"RTN","HLUOPT1",206,0)
 I $O(^HLMA("B",HLIEN,0)) Q
"RTN","HLUOPT1",207,0)
 ;
"RTN","HLUOPT1",208,0)
 ; quit if don't purge flag is set or the entry is the last one
"RTN","HLUOPT1",209,0)
 Q:+$G(^HL(772,HLIEN,2))!(HLIEN=HLLT772)
"RTN","HLUOPT1",210,0)
 ;
"RTN","HLUOPT1",211,0)
 N XMDUZ,XMK,XMZ,DIK,DA,HLX
"RTN","HLUOPT1",212,0)
 ;
"RTN","HLUOPT1",213,0)
 S HLX=$G(^HL(772,HLIEN,0))
"RTN","HLUOPT1",214,0)
 S XMZ=$P(HLX,U,5)
"RTN","HLUOPT1",215,0)
 I XMZ S XMK=1,XMDUZ=.5 D KLQ^XMA1B
"RTN","HLUOPT1",216,0)
 ;
"RTN","HLUOPT1",217,0)
 S XTMP(772,"LAST","TIME")=$S(+HLX?7N1"."1.N:+HLX,1:"")
"RTN","HLUOPT1",218,0)
 ;
"RTN","HLUOPT1",219,0)
 D DEL772^HLUOPT3(+HLIEN)
"RTN","HLUOPT1",220,0)
 ;
"RTN","HLUOPT1",221,0)
 S HLDELCNT=HLDELCNT+1
"RTN","HLUOPT1",222,0)
 S XTMP(772,"DEL")=$G(XTMP(772,"DEL"))+1,XTMP(772,"FAIL")=0 ; HL*1.6*109
"RTN","HLUOPT1",223,0)
 ;
"RTN","HLUOPT1",224,0)
 Q
"RTN","HLUOPT1",225,0)
 ;
"RTN","HLUOPT1",226,0)
CHK4STOP(HLEXIT) ;
"RTN","HLUOPT1",227,0)
 ; HL*1.6*109 modified from 60 to 120...
"RTN","HLUOPT1",228,0)
 ;
"RTN","HLUOPT1",229,0)
 S HLOOPCT=HLOOPCT+1
"RTN","HLUOPT1",230,0)
 I '$D(ZTQUEUED) W:'(HLOOPCT#2000) "."
"RTN","HLUOPT1",231,0)
 ;
"RTN","HLUOPT1",232,0)
 S:$G(HLEXIT("LASTCHK"))']"" HLEXIT("LASTCHK")=$H
"RTN","HLUOPT1",233,0)
 ;
"RTN","HLUOPT1",234,0)
 Q:$$HDIFF^XLFDT($H,$G(HLEXIT("LASTCHK")),2)<120
"RTN","HLUOPT1",235,0)
 ;
"RTN","HLUOPT1",236,0)
 ; HL*1.6*109 modified...
"RTN","HLUOPT1",237,0)
 I $$S^%ZTLOAD D  Q
"RTN","HLUOPT1",238,0)
 .  S HLEXIT=1
"RTN","HLUOPT1",239,0)
 .  D XTMPUPD^HLUOPT4(.XTMP,"ABORTED-TASKMAN","CHK4STOP")
"RTN","HLUOPT1",240,0)
 ;
"RTN","HLUOPT1",241,0)
 S HLEXIT("LASTCHK")=$H
"RTN","HLUOPT1",242,0)
 ;
"RTN","HLUOPT1",243,0)
 D XTMPUPD^HLUOPT4(.XTMP,"RUNNING","CHK4STOP") ; HL*1.6*109
"RTN","HLUOPT1",244,0)
 ;
"RTN","HLUOPT1",245,0)
 Q
"RTN","HLUOPT1",246,0)
 ;
"RTN","HLUOPT1",247,0)
FAIL(FILE) ; Has number entries w/o purging any been exceeded?
"RTN","HLUOPT1",248,0)
 ; **P153 START CJM **
"RTN","HLUOPT1",249,0)
 ;This check is causing the purge to fail
"RTN","HLUOPT1",250,0)
 ;QUIT $S($G(XTMP(FILE,"FAIL"))>200000:1,1:"")
"RTN","HLUOPT1",251,0)
 Q ""
"RTN","HLUOPT1",252,0)
 ; **p153 end cjm **
"RTN","HLUOPT1",253,0)
 ;
"RTN","HLUTIL2")
0^13^B30814753^B29544975
"RTN","HLUTIL2",1,0)
HLUTIL2 ;ALB/MFK/MTC/JC - VARIOUS HL7 UTILITIES ;12/30/2010
"RTN","HLUTIL2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,43,57,59,120,153**;;Build 11
"RTN","HLUTIL2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLUTIL2",4,0)
 ;
"RTN","HLUTIL2",5,0)
ITEM(IEN,ROUTINE) ; Return data from ITEM multiple in protocol file
"RTN","HLUTIL2",6,0)
 ; INPUT : IEN - Internal Entry Number for 101 (Protocol) file.
"RTN","HLUTIL2",7,0)
 ;         ROUTINE - name of a routine to run (either PTR or TYPE)
"RTN","HLUTIL2",8,0)
 ;OUTPUT : HLARY - Array of IENs from ITEM multiple
"RTN","HLUTIL2",9,0)
 ;  HLARY is of the form:
"RTN","HLUTIL2",10,0)
 ; HLARY(0)=Total number of items found
"RTN","HLUTIL2",11,0)
 ; HLARY(IEN)=Results from function
"RTN","HLUTIL2",12,0)
 N ITEM,LINE,MSG,PTR
"RTN","HLUTIL2",13,0)
 S IEN=$G(IEN)
"RTN","HLUTIL2",14,0)
 Q:(IEN="")
"RTN","HLUTIL2",15,0)
 S ROUTINE=$G(ROUTINE)
"RTN","HLUTIL2",16,0)
 S ROUTINE=$S(ROUTINE="PTR":1,ROUTINE="TYPE":2,ROUTINE=1:1,ROUTINE=2:2,1:"")
"RTN","HLUTIL2",17,0)
 Q:(ROUTINE="")
"RTN","HLUTIL2",18,0)
 S ITEM="",MSG=0
"RTN","HLUTIL2",19,0)
 ;  Loop through IENs within Subscriber multiple
"RTN","HLUTIL2",20,0)
 F  S ITEM=$O(^ORD(101,IEN,775,ITEM)) Q:(ITEM="")  D
"RTN","HLUTIL2",21,0)
 .S PTR=$P($G(^ORD(101,IEN,775,ITEM,0)),"^",1)
"RTN","HLUTIL2",22,0)
 .;  Call type to get info on that item
"RTN","HLUTIL2",23,0)
 .S:(ROUTINE=1) LINE=$$PTR(PTR)
"RTN","HLUTIL2",24,0)
 .S:(ROUTINE=2) LINE=$$TYPE(PTR)
"RTN","HLUTIL2",25,0)
 .;  Make sure LINE isn't error code
"RTN","HLUTIL2",26,0)
 .I ((+LINE)>(-1)) S MSG=MSG+1 S HLARY(PTR)=LINE
"RTN","HLUTIL2",27,0)
 S HLARY(0)=MSG
"RTN","HLUTIL2",28,0)
 K ROUTINE
"RTN","HLUTIL2",29,0)
 Q
"RTN","HLUTIL2",30,0)
PTR(IEN) ;  Return pointer information if subscriber
"RTN","HLUTIL2",31,0)
 ; INPUT - IEN: IEN of protocol file
"RTN","HLUTIL2",32,0)
 ;OUTPUT - Line from ^ORD(101,IEN,770):
"RTN","HLUTIL2",33,0)
 ; CLIENT^LOGICAL_LINK (both pointers)
"RTN","HLUTIL2",34,0)
 N RETURN,LINE,TYPE
"RTN","HLUTIL2",35,0)
 S IEN=$G(IEN)
"RTN","HLUTIL2",36,0)
 Q:(IEN="") "-1"
"RTN","HLUTIL2",37,0)
 ;  Make sure this is a subscriber type
"RTN","HLUTIL2",38,0)
 S TYPE=$P($G(^ORD(101,IEN,0)),"^",4)
"RTN","HLUTIL2",39,0)
 Q:(TYPE'="S") "-2"
"RTN","HLUTIL2",40,0)
 S LINE=$G(^ORD(101,IEN,770))
"RTN","HLUTIL2",41,0)
 S RETURN=$P(LINE,"^",2)_"^"_$P(LINE,"^",7)
"RTN","HLUTIL2",42,0)
 Q RETURN
"RTN","HLUTIL2",43,0)
TYPE(IEN) ;  Return portions of protocol file
"RTN","HLUTIL2",44,0)
 ; INPUT - IEN: IEN of protocol file
"RTN","HLUTIL2",45,0)
 ;OUTPUT - Line containing the following information from the protocol
"RTN","HLUTIL2",46,0)
 ;         file (#101)
"RTN","HLUTIL2",47,0)
 ;
"RTN","HLUTIL2",48,0)
 ; Client ^ Message Type Received ^ Event Type ^ Message Structure ^
"RTN","HLUTIL2",49,0)
 ;  Processing ID ^ Logical Link Pointer ^ Accept Ack ^
"RTN","HLUTIL2",50,0)
 ;  Application Ack ^ Version ^ Message Type Generated
"RTN","HLUTIL2",51,0)
 ;
"RTN","HLUTIL2",52,0)
 N RETURN,CLP,MTPR,ETP,LINE,TYPE,CLIENT,EVENT,MTPEVP
"RTN","HLUTIL2",53,0)
 N ACCACK,APPACK,VERID,VERIDP,ACKP,ACKTYP,MTPG,MTNEVN
"RTN","HLUTIL2",54,0)
 ;-- check if ien was passed in
"RTN","HLUTIL2",55,0)
 S IEN=$G(IEN)
"RTN","HLUTIL2",56,0)
 Q:(IEN="") "-1"
"RTN","HLUTIL2",57,0)
 ;
"RTN","HLUTIL2",58,0)
 ;  Null any variables in case they don't exist
"RTN","HLUTIL2",59,0)
 S (CLIENT,TYPE,EVENT,ACCACK,APPACK,VERID,MTPG,MTNEVN)=""
"RTN","HLUTIL2",60,0)
 ;  Get line from protocol file
"RTN","HLUTIL2",61,0)
 S LINE=$G(^ORD(101,IEN,770))
"RTN","HLUTIL2",62,0)
 ;
"RTN","HLUTIL2",63,0)
 ;-- get client (application that will receive the message
"RTN","HLUTIL2",64,0)
 S CLP=$P(LINE,U,2)
"RTN","HLUTIL2",65,0)
 S:(CLP) CLIENT=$P($G(^HL(771,CLP,0)),U,1)
"RTN","HLUTIL2",66,0)
 ;
"RTN","HLUTIL2",67,0)
 ;-- get message type received & generated
"RTN","HLUTIL2",68,0)
 S MTPR=$P(LINE,U,3)
"RTN","HLUTIL2",69,0)
 S MTPG=$P(LINE,U,11)
"RTN","HLUTIL2",70,0)
 S:(MTPR) MTPR=$P($G(^HL(771.2,MTPR,0)),U,1)
"RTN","HLUTIL2",71,0)
 S:(MTPG) MTPG=$P($G(^HL(771.2,MTPG,0)),U,1)
"RTN","HLUTIL2",72,0)
 ;
"RTN","HLUTIL2",73,0)
 ;-- get event type
"RTN","HLUTIL2",74,0)
 S ETP=$P(LINE,U,4)
"RTN","HLUTIL2",75,0)
 S:(ETP) EVENT=$P($G(^HL(779.001,ETP,0)),U,1)
"RTN","HLUTIL2",76,0)
 ;
"RTN","HLUTIL2",77,0)
 ;-- get message structure code
"RTN","HLUTIL2",78,0)
 S MTPEVP=$P(LINE,U,5)
"RTN","HLUTIL2",79,0)
 S:(MTPEVP) MTNEVN=$P($G(^HL(779.005,MTPEVP,0)),U,1)
"RTN","HLUTIL2",80,0)
 ;
"RTN","HLUTIL2",81,0)
 ;-- accept acknowledgement
"RTN","HLUTIL2",82,0)
 S ACKP=$P(LINE,U,8)
"RTN","HLUTIL2",83,0)
 S:(ACKP) ACCACK=$P($G(^HL(779.003,ACKP,0)),U,1)
"RTN","HLUTIL2",84,0)
 ;
"RTN","HLUTIL2",85,0)
 ;-- application acknowledgement
"RTN","HLUTIL2",86,0)
 S ACKTYP=$P(LINE,U,9)
"RTN","HLUTIL2",87,0)
 S:(ACKTYP) APPACK=$P($G(^HL(779.003,ACKTYP,0)),U,1)
"RTN","HLUTIL2",88,0)
 ;
"RTN","HLUTIL2",89,0)
 ;-- version of HL7
"RTN","HLUTIL2",90,0)
 S VERIDP=$P(LINE,U,10)
"RTN","HLUTIL2",91,0)
 S:(VERIDP) VERID=$P($G(^HL(771.5,VERIDP,0)),U,1)
"RTN","HLUTIL2",92,0)
 ;
"RTN","HLUTIL2",93,0)
 ;-- build return string
"RTN","HLUTIL2",94,0)
 S RETURN=CLIENT_U_MTPR_U_EVENT
"RTN","HLUTIL2",95,0)
 ;-- 6 processing id, 7 logical link pointer
"RTN","HLUTIL2",96,0)
 S RETURN=RETURN_U_MTNEVN_U_$P(LINE,U,6)_U_$P(LINE,U,7)
"RTN","HLUTIL2",97,0)
 S RETURN=RETURN_U_ACCACK_U_APPACK_U_VERID_U_MTPG
"RTN","HLUTIL2",98,0)
 Q RETURN
"RTN","HLUTIL2",99,0)
 ;
"RTN","HLUTIL2",100,0)
MSGADM(IEN) ; RETURN DATE/TIME ENTERED AND MSGID FROM FILE 773
"RTN","HLUTIL2",101,0)
 N X
"RTN","HLUTIL2",102,0)
 Q:'$G(^HLMA(+$G(IEN),0)) "-1"  S X=^(0)
"RTN","HLUTIL2",103,0)
 Q $P($G(^HL(772,+X,0)),"^")_"^"_$P(X,"^",2)
"RTN","HLUTIL2",104,0)
 ;
"RTN","HLUTIL2",105,0)
APPPRM(IEN) ; RETURN DATA FROM THE APPLICATION PARAMETER FILE
"RTN","HLUTIL2",106,0)
 N LINE,COUNTRYP,COUNTRY
"RTN","HLUTIL2",107,0)
 S IEN=$G(IEN)
"RTN","HLUTIL2",108,0)
 Q:(IEN="")
"RTN","HLUTIL2",109,0)
 S LINE=$G(^HL(771,IEN,0))
"RTN","HLUTIL2",110,0)
 S COUNTRYP=$P(LINE,"^",7),COUNTRY=""
"RTN","HLUTIL2",111,0)
 ;
"RTN","HLUTIL2",112,0)
 ; patch HL*1.6*120 - for deleting "US" entry from #779.004
"RTN","HLUTIL2",113,0)
 ; I COUNTRYP]"" S COUNTRY=$P(^HL(779.004,COUNTRYP,0),"^",1)
"RTN","HLUTIL2",114,0)
 I COUNTRYP]"" S COUNTRY=$P($G(^HL(779.004,COUNTRYP,0)),"^",1)
"RTN","HLUTIL2",115,0)
 ;
"RTN","HLUTIL2",116,0)
 S APPPRM(IEN,0)=$P(LINE,"^",1)_"^"_$P(LINE,"^",3)_"^"_COUNTRY
"RTN","HLUTIL2",117,0)
 S APPPRM(IEN,"EC")=$G(^HL(771,IEN,"EC"))
"RTN","HLUTIL2",118,0)
 S:(APPPRM(IEN,"EC")="") APPPRM(IEN,"EC")="~|\&"
"RTN","HLUTIL2",119,0)
 S APPPRM(IEN,"FS")=$G(^HL(771,IEN,"FS"))
"RTN","HLUTIL2",120,0)
 S:(APPPRM(IEN,"FS")="") APPPRM(IEN,"FS")="^"
"RTN","HLUTIL2",121,0)
 Q
"RTN","HLUTIL2",122,0)
CLRQUE ; Clear a queue by menu option
"RTN","HLUTIL2",123,0)
 N DIC,DIR,DIRUT,HLDIR,HLERR,HLIEN,HLL,HLLTC,X,Y,TCP
"RTN","HLUTIL2",124,0)
 S TCP=$O(^HLCS(869.1,"B","TCP",0))
"RTN","HLUTIL2",125,0)
 S DIC("S")="I $P(^(0),U,3)'=TCP"
"RTN","HLUTIL2",126,0)
 S DIC="^HLCS(870,",DIC(0)="AEQMZ"
"RTN","HLUTIL2",127,0)
 D ^DIC Q:Y<0
"RTN","HLUTIL2",128,0)
 K DIC S HLIEN=+Y,HLL=$P(Y(0),U,3)
"RTN","HLUTIL2",129,0)
 L +^HLCS(870,HLIEN):1 E  W !!,"Couldn't Lock Record, Try later.",! Q
"RTN","HLUTIL2",130,0)
 S DIR(0)="S^B:BOTH QUEUES;I:IN QUEUE;O:OUT QUEUE",DIR("?")="Select the queue (in, out, or both) you would like cleared"
"RTN","HLUTIL2",131,0)
 S DIR("A")="Enter which queue to clear",DIR("B")="B"
"RTN","HLUTIL2",132,0)
 D ^DIR K DIR
"RTN","HLUTIL2",133,0)
 S HLDIR=$S(Y="I":"IN",Y="O":"OUT",Y="B":"BOTH",1:1)
"RTN","HLUTIL2",134,0)
 I HLDIR=1!$D(DIRUT) L -^HLCS(870,HLIEN) Q
"RTN","HLUTIL2",135,0)
 ;HLLTC= TCP service type
"RTN","HLUTIL2",136,0)
 S:HLL HLLTC=$P($G(^HLCS(870,HLIEN,400)),U,3)
"RTN","HLUTIL2",137,0)
 ;TCP link
"RTN","HLUTIL2",138,0)
 I $G(HLLTC)]"" D  L -^HLCS(870,HLIEN) Q
"RTN","HLUTIL2",139,0)
 . ;multiple server, set STATE and SHUTDOWN LLP?
"RTN","HLUTIL2",140,0)
 . S:HLLTC="M" X=^HLCS(870,HLIEN,0),$P(X,U,5)="0 server",$P(X,U,15)=0,^(0)=X
"RTN","HLUTIL2",141,0)
 . I HLDIR="BOTH" D  Q
"RTN","HLUTIL2",142,0)
 .. F X="IN","OUT" D CLRQUET(X)
"RTN","HLUTIL2",143,0)
 . ;do one que
"RTN","HLUTIL2",144,0)
 . D CLRQUET(HLDIR)
"RTN","HLUTIL2",145,0)
 ;
"RTN","HLUTIL2",146,0)
 I HLDIR="BOTH" D
"RTN","HLUTIL2",147,0)
 . S HLERR=$$CLEARQUE^HLCSQUE(HLIEN,"OUT")
"RTN","HLUTIL2",148,0)
 . I HLERR W !,"Error in clearing out queue:",$P(HLERR,"^",2)
"RTN","HLUTIL2",149,0)
 . S HLERR=$$CLEARQUE^HLCSQUE(HLIEN,"IN")
"RTN","HLUTIL2",150,0)
 . I HLERR W !,"Error in clearing in queue:",$P(HLERR,"^",2)
"RTN","HLUTIL2",151,0)
 I HLDIR'="BOTH" S HLERR=$$CLEARQUE^HLCSQUE(HLIEN,HLDIR)
"RTN","HLUTIL2",152,0)
 L -^HLCS(870,HLIEN)
"RTN","HLUTIL2",153,0)
 Q
"RTN","HLUTIL2",154,0)
CLRQUET(Y) ;subroutine for TCP links, Y=IN or OUT
"RTN","HLUTIL2",155,0)
 Q:Y'="IN"&(Y'="OUT")
"RTN","HLUTIL2",156,0)
 N C,N,X
"RTN","HLUTIL2",157,0)
 S N=$E(Y),X=0
"RTN","HLUTIL2",158,0)
 ;get count of what is pending
"RTN","HLUTIL2",159,0)
 F C=0:1 S X=$O(^HLMA("AC",N,HLIEN,X)) Q:'X
"RTN","HLUTIL2",160,0)
 ;reset counters for messages
"RTN","HLUTIL2",161,0)
 S ^HLCS(870,HLIEN,Y_" QUEUE BACK POINTER")=C,^(Y_" QUEUE FRONT POINTER")=0
"RTN","HLUTIL2",162,0)
 Q
"RTN","HLUTIL2",163,0)
 ;
"RTN","HLUTIL2",164,0)
SHGLLP ; Show Gross LLP Error
"RTN","HLUTIL2",165,0)
 N DIC,IEN,ERR
"RTN","HLUTIL2",166,0)
 S DIC="^HLCS(870,"
"RTN","HLUTIL2",167,0)
 S DIC(0)="AEQM"
"RTN","HLUTIL2",168,0)
 D ^DIC K DIC
"RTN","HLUTIL2",169,0)
 S IEN=$P(Y,"^",1)
"RTN","HLUTIL2",170,0)
 S ERR=$P($G(^HLCS(870,IEN,0)),"^",19)
"RTN","HLUTIL2",171,0)
 W:(ERR'="") !,"Error: "_$P($G(^HL(771.7,ERR,0)),"^",1),!
"RTN","HLUTIL2",172,0)
 W:(ERR="") !,"No Gross LLP error found",!
"RTN","HLUTIL2",173,0)
 Q
"RTN","HLUTIL2",174,0)
CLGLLP ; Clear Gross LLP error
"RTN","HLUTIL2",175,0)
 N DIC,IEN,ERR,DA,DR
"RTN","HLUTIL2",176,0)
 S DIC="^HLCS(870,"
"RTN","HLUTIL2",177,0)
 S DIC(0)="AEQM"
"RTN","HLUTIL2",178,0)
 D ^DIC K DIC
"RTN","HLUTIL2",179,0)
 S IEN=$P(Y,"^",1)
"RTN","HLUTIL2",180,0)
 Q:(IEN<0)
"RTN","HLUTIL2",181,0)
 S DIE="^HLCS(870,"
"RTN","HLUTIL2",182,0)
 S DA=IEN
"RTN","HLUTIL2",183,0)
 S DR="18///@"
"RTN","HLUTIL2",184,0)
 D ^DIE K DIE
"RTN","HLUTIL2",185,0)
 Q
"UP",772,772.02,-1)
772^IN
"UP",772,772.02,0)
772.02
"UP",773,773.01,-1)
773^MSH
"UP",773,773.01,0)
773.01
"UP",870,870.01,-1)
870^2
"UP",870,870.01,0)
870.01
"UP",870,870.019,-1)
870^1
"UP",870,870.019,0)
870.019
"VER")
8.0^22.0
"^DD",772,772,200,0)
MESSAGE TEXT^772.02^^IN;0
"^DD",772,772,200,21,0)
^^2^2^3100420^^
"^DD",772,772,200,21,1,0)
The actual text of the incoming HL7 message(s).
"^DD",772,772,200,21,2,0)

"^DD",772,772,200,23,0)
^^1^1^3100420^
"^DD",772,772,200,23,1,0)

"^DD",772,772,200,"DT")
2940715
"^DD",772,772.02,0)
MESSAGE TEXT SUB-FIELD^^.01^1
"^DD",772,772.02,0,"DT")
3100420
"^DD",772,772.02,0,"NM","MESSAGE TEXT")

"^DD",772,772.02,0,"UP")
772
"^DD",772,772.02,.01,0)
MESSAGE TEXT^WLx^^0;1^Q
"^DD",772,772.02,.01,3)
The text of the incoming messages for this transmission.
"^DD",772,772.02,.01,"DT")
3100420
"^DD",773,773,200,0)
MSH^773.01^^MSH;0
"^DD",773,773,200,"DT")
3040614
"^DD",773,773.01,0)
MSH SUB-FIELD^^.01^1
"^DD",773,773.01,0,"DT")
3101201
"^DD",773,773.01,0,"NM","MSH")

"^DD",773,773.01,0,"UP")
773
"^DD",773,773.01,.01,0)
MSH^WLx^^0;1^Q
"^DD",773,773.01,.01,21,0)
^^1^1^2980423^
"^DD",773,773.01,.01,21,1,0)
This is the message header, MSH, for this message.
"^DD",773,773.01,.01,"DT")
3101201
"^DD",870,870,22,0)
RETENTION TIME QUEUED STUB RCD^NJ2,0^^0;22^K:+X'=X!(X>60)!(X<5)!(X?.E1"."1.N) X
"^DD",870,870,22,3)
Type a number between 5 and 60, 0 decimal digits.
"^DD",870,870,22,21,0)
^^10^10^3101117^^
"^DD",870,870,22,21,1,0)
The field represents the time in minutes for how long a stub record must 
"^DD",870,870,22,21,2,0)
remain as such before that record is changed to a unused status.  The 
"^DD",870,870,22,21,3,0)
default time is 10 minutes.
"^DD",870,870,22,21,4,0)
 
"^DD",870,870,22,21,5,0)
This field is compared to DATE/TIME STUB RCD FOUND.  If the time 
"^DD",870,870,22,21,6,0)
elapsed since the DATE/TIME STUB RCD FOUND is greater than the number 
"^DD",870,870,22,21,7,0)
of minutes found in this field, then the STATUS (870.019,1) is changed to
"^DD",870,870,22,21,8,0)
unused if it is an incoming message.  If it is an outgoing message then
"^DD",870,870,22,21,9,0)
the STATUS (870.01,1) is changed to unused.
"^DD",870,870,22,21,10,0)

"^DD",870,870,22,23,0)
^^1^1^3101117^
"^DD",870,870,22,23,1,0)

"^DD",870,870,22,"DT")
3101117
"^DD",870,870.01,1,0)
STATUS^S^P:PENDING;D:DONE PROCESSING;S:STUB RECORD;U:UNUSED STUB RECORD;^0;2^Q
"^DD",870,870.01,1,1,0)
^.1^^0
"^DD",870,870.01,1,3)
This is the status of an individual message in the queue. These statuses control the flow and processing of the message.
"^DD",870,870.01,1,21,0)
^^12^12^3100219^
"^DD",870,870.01,1,21,1,0)
Status of a particular message. Can be Stub, Pending, Done or Unused.
"^DD",870,870.01,1,21,2,0)
These statuses control the processing of a message. For example, a stub
"^DD",870,870.01,1,21,3,0)
record is created when a message is enqueued, it cannot be processed
"^DD",870,870.01,1,21,4,0)
until its status is changed from a 'stub' to 'pending', this is
"^DD",870,870.01,1,21,5,0)
the last thing HLCS1 does when dequeueing a message from file #772
"^DD",870,870.01,1,21,6,0)
and enqueueing it into file #870.  Finally, once the message has 
"^DD",870,870.01,1,21,7,0)
been processed, its status is changed to 'done'.  Also, the effect of
"^DD",870,870.01,1,21,8,0)
setting the 'UNUSED STUB RECORD' status is to remove the record from the
"^DD",870,870.01,1,21,9,0)
queue and not to block the transmission of other messages that are pending
"^DD",870,870.01,1,21,10,0)
on the queue.  The 'UNUSED STUB RECORD' status will get set if the stub
"^DD",870,870.01,1,21,11,0)
record goes unused for a period of time as determined by the 'RETENTION
"^DD",870,870.01,1,21,12,0)
TIME QUEUED STUB RCD' parameter.
"^DD",870,870.01,1,"DT")
3100128
"^DD",870,870.01,10,0)
DATE/TIME STUB RCD FOUND^D^^0;10^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",870,870.01,10,21,0)
^^2^2^3091230^
"^DD",870,870.01,10,21,1,0)
A system date/time is entered into this field when a stub record is 
"^DD",870,870.01,10,21,2,0)
found.
"^DD",870,870.01,10,"DT")
3091230
"^DD",870,870.019,1,0)
STATUS^S^P:PENDING;D:DONE PROCESSING;S:STUB RECORD;U:UNUSED STUB RECORD;^0;2^Q
"^DD",870,870.019,1,1,0)
^.1
"^DD",870,870.019,1,1,1,0)
870^AISTAT
"^DD",870,870.019,1,1,1,1)
S ^HLCS(870,"AISTAT",$E(X,1,30),DA(1),DA)=""
"^DD",870,870.019,1,1,1,2)
K ^HLCS(870,"AISTAT",$E(X,1,30),DA(1),DA)
"^DD",870,870.019,1,1,1,"%D",0)
^.101^2^2^3001115^^^
"^DD",870,870.019,1,1,1,"%D",1,0)
Used to quickly identify links with messages in any status,
"^DD",870,870.019,1,1,1,"%D",2,0)
thus improving performance.
"^DD",870,870.019,1,1,1,"DT")
3000508
"^DD",870,870.019,1,3)
This is the status of an individual message in the queue. These statuses control the flow and processing of the message.
"^DD",870,870.019,1,21,0)
^^12^12^3100219^
"^DD",870,870.019,1,21,1,0)
Status of a particular message. Can be Stub, Pending, Done or Unused.
"^DD",870,870.019,1,21,2,0)
These statuses control the processing of a message. For example, a
"^DD",870,870.019,1,21,3,0)
stub record is created when a message is enqueued, and cannot be
"^DD",870,870.019,1,21,4,0)
processed until its status is changed from 'stub' to 'pending'.
"^DD",870,870.019,1,21,5,0)
Changing this status is the last thing the Low Layer Protocol does
"^DD",870,870.019,1,21,6,0)
after reading in a message.  Finally, once the message has been
"^DD",870,870.019,1,21,7,0)
processed, its status is changed to 'done'. Also, the effect of setting
"^DD",870,870.019,1,21,8,0)
the 'UNUSED STUB RECORD' status is to remove the record from the queue and
"^DD",870,870.019,1,21,9,0)
not to block the transmission of other messages that are pending on the
"^DD",870,870.019,1,21,10,0)
queue.  The 'UNUSED STUB RECORD' status will get set if the stub record
"^DD",870,870.019,1,21,11,0)
goes unused for a period of time as determined by the 'RETENTION TIME
"^DD",870,870.019,1,21,12,0)
QUEUED STUB RCD' parameter.
"^DD",870,870.019,1,"DT")
3100201
"^DD",870,870.019,10,0)
DATE/TIME STUB RCD FOUND^D^^0;10^S %DT="E" D ^%DT S X=Y K:Y<1 X
"^DD",870,870.019,10,21,0)
^^2^2^3091230^
"^DD",870,870.019,10,21,1,0)
A system date/time is entered into this field when a stub record is 
"^DD",870,870.019,10,21,2,0)
found.
"^DD",870,870.019,10,"DT")
3091230
"BLD",1470,6)
^122
**END**
**END**
