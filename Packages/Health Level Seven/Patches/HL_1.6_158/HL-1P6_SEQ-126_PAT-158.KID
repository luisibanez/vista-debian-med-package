Released HL*1.6*158 SEQ #126
Extracted from mail message
**KIDS**:HL*1.6*158^

**INSTALL NAME**
HL*1.6*158
"BLD",1629,0)
HL*1.6*158^HEALTH LEVEL SEVEN^0^3120717^y
"BLD",1629,1,0)
^^2^2^3111118^
"BLD",1629,1,1,0)
See the National Patch Module on Forum for the patch description.
"BLD",1629,1,2,0)

"BLD",1629,4,0)
^9.64PA^870^4
"BLD",1629,4,778,0)
778
"BLD",1629,4,778,222)
y^n^f^^^^n
"BLD",1629,4,779.1,0)
779.1
"BLD",1629,4,779.1,222)
y^n^f^^^^n
"BLD",1629,4,779.2,0)
779.2
"BLD",1629,4,779.2,222)
y^n^f^^^^n^^n
"BLD",1629,4,779.2,224)

"BLD",1629,4,870,0)
870
"BLD",1629,4,870,2,0)
^9.641^870^1
"BLD",1629,4,870,2,870,0)
HL LOGICAL LINK  (File-top level)
"BLD",1629,4,870,2,870,1,0)
^9.6411^24^1
"BLD",1629,4,870,2,870,1,24,0)
DO NOT PING
"BLD",1629,4,870,222)
y^n^p^^^^n^^n
"BLD",1629,4,870,224)

"BLD",1629,4,"APDD",870,870)

"BLD",1629,4,"APDD",870,870,24)

"BLD",1629,4,"B",778,778)

"BLD",1629,4,"B",779.1,779.1)

"BLD",1629,4,"B",779.2,779.2)

"BLD",1629,4,"B",870,870)

"BLD",1629,6.3)
14
"BLD",1629,"ABPKG")
n
"BLD",1629,"INI")
PRE^HLOP158
"BLD",1629,"INID")
^n^n
"BLD",1629,"INIT")
POST^HLOP158
"BLD",1629,"KRN",0)
^9.67PA^9002226^21
"BLD",1629,"KRN",.4,0)
.4
"BLD",1629,"KRN",.401,0)
.401
"BLD",1629,"KRN",.402,0)
.402
"BLD",1629,"KRN",.402,"NM",0)
^9.68A^1^1
"BLD",1629,"KRN",.402,"NM",1,0)
HLO RETENTION TIME    FILE #779.2^779.2^0
"BLD",1629,"KRN",.402,"NM","B","HLO RETENTION TIME    FILE #779.2",1)

"BLD",1629,"KRN",.403,0)
.403
"BLD",1629,"KRN",.5,0)
.5
"BLD",1629,"KRN",.84,0)
.84
"BLD",1629,"KRN",3.6,0)
3.6
"BLD",1629,"KRN",3.8,0)
3.8
"BLD",1629,"KRN",9.2,0)
9.2
"BLD",1629,"KRN",9.8,0)
9.8
"BLD",1629,"KRN",9.8,"NM",0)
^9.68A^25^24
"BLD",1629,"KRN",9.8,"NM",1,0)
HLOF778^^0^B32326577
"BLD",1629,"KRN",9.8,"NM",2,0)
HLOFILER^^0^B27084628
"BLD",1629,"KRN",9.8,"NM",3,0)
HLOSRVR^^0^B82216599
"BLD",1629,"KRN",9.8,"NM",5,0)
HLOQUE^^0^B154240206
"BLD",1629,"KRN",9.8,"NM",6,0)
HLOPING^^0^B28571657
"BLD",1629,"KRN",9.8,"NM",7,0)
HLOAPI1^^0^B99684875
"BLD",1629,"KRN",9.8,"NM",8,0)
HLOAPI2^^0^B76156297
"BLD",1629,"KRN",9.8,"NM",9,0)
HLOCLNT^^0^B81537005
"BLD",1629,"KRN",9.8,"NM",10,0)
HLOCLNT1^^0^B23616126
"BLD",1629,"KRN",9.8,"NM",11,0)
HLOCLNT2^^0^B34928918
"BLD",1629,"KRN",9.8,"NM",12,0)
HLOCLNT3^^0^B5589114
"BLD",1629,"KRN",9.8,"NM",13,0)
HLOF778A^^0^B76735588
"BLD",1629,"KRN",9.8,"NM",14,0)
HLOPROC^^0^B28479466
"BLD",1629,"KRN",9.8,"NM",15,0)
HLOSITE^^0^B9605158
"BLD",1629,"KRN",9.8,"NM",16,0)
HLOSRVR1^^0^B68927877
"BLD",1629,"KRN",9.8,"NM",17,0)
HLOSRVR2^^0^B5343067
"BLD",1629,"KRN",9.8,"NM",18,0)
HLOUSR^^0^B121713479
"BLD",1629,"KRN",9.8,"NM",19,0)
HLOUSR3^^0^B69134170
"BLD",1629,"KRN",9.8,"NM",20,0)
HLOAPI3^^0^B108017449
"BLD",1629,"KRN",9.8,"NM",21,0)
HLOUSR7^^0^B25426797
"BLD",1629,"KRN",9.8,"NM",22,0)
HLOP158^^0^B829320
"BLD",1629,"KRN",9.8,"NM",23,0)
HLUCM001^^0^B50315331
"BLD",1629,"KRN",9.8,"NM",24,0)
HLOAPP^^0^B19865517
"BLD",1629,"KRN",9.8,"NM",25,0)
HLOASUB1^^0^B94636014
"BLD",1629,"KRN",9.8,"NM","B","HLOAPI1",7)

"BLD",1629,"KRN",9.8,"NM","B","HLOAPI2",8)

"BLD",1629,"KRN",9.8,"NM","B","HLOAPI3",20)

"BLD",1629,"KRN",9.8,"NM","B","HLOAPP",24)

"BLD",1629,"KRN",9.8,"NM","B","HLOASUB1",25)

"BLD",1629,"KRN",9.8,"NM","B","HLOCLNT",9)

"BLD",1629,"KRN",9.8,"NM","B","HLOCLNT1",10)

"BLD",1629,"KRN",9.8,"NM","B","HLOCLNT2",11)

"BLD",1629,"KRN",9.8,"NM","B","HLOCLNT3",12)

"BLD",1629,"KRN",9.8,"NM","B","HLOF778",1)

"BLD",1629,"KRN",9.8,"NM","B","HLOF778A",13)

"BLD",1629,"KRN",9.8,"NM","B","HLOFILER",2)

"BLD",1629,"KRN",9.8,"NM","B","HLOP158",22)

"BLD",1629,"KRN",9.8,"NM","B","HLOPING",6)

"BLD",1629,"KRN",9.8,"NM","B","HLOPROC",14)

"BLD",1629,"KRN",9.8,"NM","B","HLOQUE",5)

"BLD",1629,"KRN",9.8,"NM","B","HLOSITE",15)

"BLD",1629,"KRN",9.8,"NM","B","HLOSRVR",3)

"BLD",1629,"KRN",9.8,"NM","B","HLOSRVR1",16)

"BLD",1629,"KRN",9.8,"NM","B","HLOSRVR2",17)

"BLD",1629,"KRN",9.8,"NM","B","HLOUSR",18)

"BLD",1629,"KRN",9.8,"NM","B","HLOUSR3",19)

"BLD",1629,"KRN",9.8,"NM","B","HLOUSR7",21)

"BLD",1629,"KRN",9.8,"NM","B","HLUCM001",23)

"BLD",1629,"KRN",19,0)
19
"BLD",1629,"KRN",19,"NM",0)
^9.68A^2^2
"BLD",1629,"KRN",19,"NM",1,0)
HLO MESSAGE RETENTION TIME^^0
"BLD",1629,"KRN",19,"NM",2,0)
HLO APPLICATION REGISTRY MENU^^2
"BLD",1629,"KRN",19,"NM","B","HLO APPLICATION REGISTRY MENU",2)

"BLD",1629,"KRN",19,"NM","B","HLO MESSAGE RETENTION TIME",1)

"BLD",1629,"KRN",19.1,0)
19.1
"BLD",1629,"KRN",101,0)
101
"BLD",1629,"KRN",409.61,0)
409.61
"BLD",1629,"KRN",771,0)
771
"BLD",1629,"KRN",779.2,0)
779.2
"BLD",1629,"KRN",870,0)
870
"BLD",1629,"KRN",8989.51,0)
8989.51
"BLD",1629,"KRN",8989.52,0)
8989.52
"BLD",1629,"KRN",8994,0)
8994
"BLD",1629,"KRN",9002226,0)
9002226
"BLD",1629,"KRN","B",.4,.4)

"BLD",1629,"KRN","B",.401,.401)

"BLD",1629,"KRN","B",.402,.402)

"BLD",1629,"KRN","B",.403,.403)

"BLD",1629,"KRN","B",.5,.5)

"BLD",1629,"KRN","B",.84,.84)

"BLD",1629,"KRN","B",3.6,3.6)

"BLD",1629,"KRN","B",3.8,3.8)

"BLD",1629,"KRN","B",9.2,9.2)

"BLD",1629,"KRN","B",9.8,9.8)

"BLD",1629,"KRN","B",19,19)

"BLD",1629,"KRN","B",19.1,19.1)

"BLD",1629,"KRN","B",101,101)

"BLD",1629,"KRN","B",409.61,409.61)

"BLD",1629,"KRN","B",771,771)

"BLD",1629,"KRN","B",779.2,779.2)

"BLD",1629,"KRN","B",870,870)

"BLD",1629,"KRN","B",8989.51,8989.51)

"BLD",1629,"KRN","B",8989.52,8989.52)

"BLD",1629,"KRN","B",8994,8994)

"BLD",1629,"KRN","B",9002226,9002226)

"BLD",1629,"QDEF")
^^^^NO^^^^NO^^NO
"BLD",1629,"QUES",0)
^9.62^^
"BLD",1629,"REQB",0)
^9.611^5^4
"BLD",1629,"REQB",1,0)
HL*1.6*152^2
"BLD",1629,"REQB",2,0)
HL*1.6*153^2
"BLD",1629,"REQB",4,0)
HL*1.6*155^2
"BLD",1629,"REQB",5,0)
HL*1.6*157^2
"BLD",1629,"REQB","B","HL*1.6*152",1)

"BLD",1629,"REQB","B","HL*1.6*153",2)

"BLD",1629,"REQB","B","HL*1.6*155",4)

"BLD",1629,"REQB","B","HL*1.6*157",5)

"FIA",778)
HLO MESSAGES
"FIA",778,0)
^HLB(
"FIA",778,0,0)
778O
"FIA",778,0,1)
y^n^f^^^^n
"FIA",778,0,10)

"FIA",778,0,11)

"FIA",778,0,"RLRO")

"FIA",778,0,"VR")
1.6^HL
"FIA",778,778)
0
"FIA",778,778.03)
0
"FIA",779.1)
HLO SYSTEM PARAMETERS
"FIA",779.1,0)
^HLD(779.1,
"FIA",779.1,0,0)
779.1
"FIA",779.1,0,1)
y^n^f^^^^n
"FIA",779.1,0,10)

"FIA",779.1,0,11)

"FIA",779.1,0,"RLRO")

"FIA",779.1,0,"VR")
1.6^HL
"FIA",779.1,779.1)
0
"FIA",779.2)
HLO APPLICATION REGISTRY
"FIA",779.2,0)
^HLD(779.2,
"FIA",779.2,0,0)
779.2
"FIA",779.2,0,1)
y^n^f^^^^n^^n
"FIA",779.2,0,10)

"FIA",779.2,0,11)

"FIA",779.2,0,"RLRO")

"FIA",779.2,0,"VR")
1.6^HL
"FIA",779.2,779.2)
0
"FIA",779.2,779.21)
0
"FIA",870)
HL LOGICAL LINK
"FIA",870,0)
^HLCS(870,
"FIA",870,0,0)
870
"FIA",870,0,1)
y^n^p^^^^n^^n
"FIA",870,0,10)

"FIA",870,0,11)

"FIA",870,0,"RLRO")

"FIA",870,0,"VR")
1.6^HL
"FIA",870,870)
1
"FIA",870,870,24)

"INI")
PRE^HLOP158
"INIT")
POST^HLOP158
"IX",779.2,779.2,"C",0)
779.2^C^Uniqueness Index for Key 'A' of File #779.2^R^^F^IR^I^779.2^^^^^LS
"IX",779.2,779.2,"C",1)
S ^HLD(779.2,"C",X,DA)=""
"IX",779.2,779.2,"C",2)
K ^HLD(779.2,"C",X,DA)
"IX",779.2,779.2,"C",2.5)
K ^HLD(779.2,"C")
"IX",779.2,779.2,"C",11.1,0)
^.114IA^1^1
"IX",779.2,779.2,"C",11.1,1,0)
1^F^779.2^.01^^1
"IX",779.2,779.21,"C",0)
779.21^C^action by message type& event,with version not specified^MU^^R^IR^I^779.21^^^^^LS
"IX",779.2,779.21,"C",.1,0)
^^4^4^3060626^
"IX",779.2,779.21,"C",.1,1,0)
This index is used to find the application action by message type and event
"IX",779.2,779.21,"C",.1,2,0)
in cases where the application has chosen NOT to also specify the action
"IX",779.2,779.21,"C",.1,3,0)
according to the HL7 version.
"IX",779.2,779.21,"C",.1,4,0)

"IX",779.2,779.21,"C",1)
S:$P(^HLD(779.2,DA(1),1,DA,0),"^",6)="" ^HLD(779.2,DA(1),1,"C",X(1),X(2),DA)=""
"IX",779.2,779.21,"C",1.4)

"IX",779.2,779.21,"C",2)
K ^HLD(779.2,DA(1),1,"C",X(1),X(2),DA)
"IX",779.2,779.21,"C",2.4)

"IX",779.2,779.21,"C",2.5)
K ^HLD(779.2,DA(1),1,"C")
"IX",779.2,779.21,"C",11.1,0)
^.114IA^2^2
"IX",779.2,779.21,"C",11.1,1,0)
1^F^779.21^.01^^1
"IX",779.2,779.21,"C",11.1,2,0)
2^F^779.21^.02^^2^F
"IX",779.2,779.21,"D",0)
779.21^D^lookup message type including version^MU^^R^IR^I^779.21^^^^^LS
"IX",779.2,779.21,"D",1)
S ^HLD(779.2,DA(1),1,"D",X(1),X(2),X(3),DA)="" K ^HLD(779.2,DA(1),1,"C",X2(1),X2(2),DA)
"IX",779.2,779.21,"D",2)
K ^HLD(779.2,DA(1),1,"D",X(1),X(2),X(3),DA)  S:((X1(1)=X2(1))&(X1(2)=X2(2))&(X2(3)="")) ^HLD(779.2,DA(1),1,"C",X2(1),X2(2),DA)=""
"IX",779.2,779.21,"D",2.5)
K ^HLD(779.2,DA(1),1,"D")
"IX",779.2,779.21,"D",11.1,0)
^.114IA^3^3
"IX",779.2,779.21,"D",11.1,1,0)
1^F^779.21^.01^30^1^F
"IX",779.2,779.21,"D",11.1,2,0)
2^F^779.21^.02^30^2^F
"IX",779.2,779.21,"D",11.1,3,0)
3^F^779.21^.06^30^3^F
"KEY",779.2,779.2,"A",0)
779.2^A^P^68
"KEY",779.2,779.2,"A",2,0)
^.312IA^1^1
"KEY",779.2,779.2,"A",2,1,0)
.01^779.2^1
"KEYPTR",779.2,779.2,"A")
779.2^C
"KRN",.402,115,-1)
0^1
"KRN",.402,115,0)
HLO RETENTION TIME^3120222.1218^@^779.2^^@^3120626
"KRN",.402,115,"DR",1,779.2)
.13;1;
"KRN",.402,115,"DR",2,779.21)
.08;
"KRN",19,1412,-1)
2^2
"KRN",19,1412,0)
HLO APPLICATION REGISTRY MENU^APPLICATION REGISTRY MENU^^M^1000213^^^^^^y^9
"KRN",19,1412,10,0)
^19.01IP^4^4
"KRN",19,1412,10,4,0)
1454^RET^4
"KRN",19,1412,10,4,"^")
HLO MESSAGE RETENTION TIME
"KRN",19,1412,"U")
APPLICATION REGISTRY MENU
"KRN",19,1454,-1)
0^1
"KRN",19,1454,0)
HLO MESSAGE RETENTION TIME^EDIT MESSAGE RETENTION TIME^^E^^^^^^^y^HEALTH LEVEL SEVEN
"KRN",19,1454,1,0)
^19.06^3^3^3120222^^
"KRN",19,1454,1,1,0)
This option may be used by an application developer to specify the minimum
"KRN",19,1454,1,2,0)
time that an application's messages should be retained before being purged. 
"KRN",19,1454,1,3,0)

"KRN",19,1454,10.1)
EDIT RETENTION TIME
"KRN",19,1454,30)
HLD(779.2,
"KRN",19,1454,31)
AEMQL
"KRN",19,1454,50)
HLD(779.2,
"KRN",19,1454,51)
[HLO RETENTION TIME]
"KRN",19,1454,"U")
EDIT MESSAGE RETENTION TIME
"MBREQ")
0
"ORD",7,.402)
.402;7;;;EDEOUT^DIFROMSO(.402,DA,"",XPDA);FPRE^DIFROMSI(.402,"",XPDA);EPRE^DIFROMSI(.402,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.402,DA,"",XPDA);DEL^DIFROMSK(.402,"",%)
"ORD",7,.402,0)
INPUT TEMPLATE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",9,-1)
1^1
"PKG",9,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN^
"PKG",9,20,0)
^9.402P^^
"PKG",9,22,0)
^9.49I^1^1
"PKG",9,22,1,0)
1.6^2980130^2980130^6
"PKG",9,22,1,"PAH",1,0)
158^3120717
"PKG",9,22,1,"PAH",1,1,0)
^^2^2^3120717
"PKG",9,22,1,"PAH",1,1,1,0)
See the National Patch Module on Forum for the patch description.
"PKG",9,22,1,"PAH",1,1,2,0)

"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
24
"RTN","HLOAPI1")
0^7^B99684875^B101211192
"RTN","HLOAPI1",1,0)
HLOAPI1 ;;ALB/CJM-HL7 - Developer API's for sending & receiving messages(continued) ;03/12/2012
"RTN","HLOAPI1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132,134,137,146,158**;Oct 13, 1995;Build 14
"RTN","HLOAPI1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI1",4,0)
 ;
"RTN","HLOAPI1",5,0)
SENDONE(HLMSTATE,PARMS,WHOTO,ERROR) ;Sends the message to a single receiving application.
"RTN","HLOAPI1",6,0)
 ;;
"RTN","HLOAPI1",7,0)
 ;;Input:
"RTN","HLOAPI1",8,0)
 ;;HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it
"RTN","HLOAPI1",9,0)
 ;;PARMS( *pass by reference*
"RTN","HLOAPI1",10,0)
 ;;  "APP ACK RESPONSE")=<tag^routine> to call when the app ack is received (optional)
"RTN","HLOAPI1",11,0)
 ;;    (NOTE: For batch messages, HLO best supports returning application
"RTN","HLOAPI1",12,0)
 ;;     acknowledgments via a batch response.  However, non-VistA systems
"RTN","HLOAPI1",13,0)
 ;;     may return individual messages as application acknowledgments to
"RTN","HLOAPI1",14,0)
 ;;     messages within the original batch message, so for applications
"RTN","HLOAPI1",15,0)
 ;;     sending batch messages might best code the "APP ACK RESPONSE"
"RTN","HLOAPI1",16,0)
 ;;     routine to first check whether the response message is a batch.
"RTN","HLOAPI1",17,0)
 ;; 
"RTN","HLOAPI1",18,0)
 ;;  "ACCEPT ACK RESPONSE")=<tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI1",19,0)
 ;;  "ACCEPT ACK TYPE") = <AL,NE> (optional, defaults to AL)
"RTN","HLOAPI1",20,0)
 ;;  "APP ACK TYPE") = <AL,NE> (optional, defaults to NE)
"RTN","HLOAPI1",21,0)
 ;;  "FAILURE RESPONSE" - <tag>^<routine> (optional) The sending application routine to execute when the transmission of the message fails, i.e., the message can not be sent or no commit ack is received.
"RTN","HLOAPI1",22,0)
 ;;  "QUEUE" - (optional) An application can name its own private queue - just a string up to 20 characters, it should be namespaced.
"RTN","HLOAPI1",23,0)
 ;;  "SECURITY")=security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI1",24,0)
 ;;  "SEQUENCE QUEUE") (optional) sequence queue to use, up to 30 characters, shoud lbe namespaced.  Requires that application acks be used.
"RTN","HLOAPI1",25,0)
 ;;  "SENDING APPLICATION")=name of sending app (required, 60 maximum length)
"RTN","HLOAPI1",26,0)
 ;;
"RTN","HLOAPI1",27,0)
 ;;  WHOTO (required,pass by reference) an array specifying a single recipient. These subscripts are allowed:
"RTN","HLOAPI1",28,0)
 ;;
"RTN","HLOAPI1",29,0)
 ;;    "RECEIVING APPLICATION" - (string, 60 char max, required)
"RTN","HLOAPI1",30,0)
 ;;
"RTN","HLOAPI1",31,0)
 ;;  EXACTLY ONE of these parameters must be provided to identify the Receiving Facility:
"RTN","HLOAPI1",32,0)
 ;;
"RTN","HLOAPI1",33,0)
 ;;   "FACILITY LINK IEN" - ien of the logical link 
"RTN","HLOAPI1",34,0)
 ;;   "FACILITY LINK NAME" - name of the logical link 
"RTN","HLOAPI1",35,0)
 ;;   "INSTITUTION IEN" - ptr to the INSTITUTION file
"RTN","HLOAPI1",36,0)
 ;;   "STATION NUMBER" -  station # with suffix
"RTN","HLOAPI1",37,0)
 ;;
"RTN","HLOAPI1",38,0)
 ;;  EXACTLY ONE of these MAY be provided - optionally - to identify the interface engine to route the message through:
"RTN","HLOAPI1",39,0)
 ;;
"RTN","HLOAPI1",40,0)
 ;;   *"IE LINK IEN" (obsolete)  ptr to a logical link for the interface engine 
"RTN","HLOAPI1",41,0)
 ;;   *"IE LINK NAME" (obsolete) name of the logical link for the interface engine
"RTN","HLOAPI1",42,0)
 ;;   "MIDDLEWARE LINK IEN" -  ptr to a logical link for the middleware 
"RTN","HLOAPI1",43,0)
 ;;   "MIDDLEWARE LINK NAME" - the name of the logical link for the middleware
"RTN","HLOAPI1",44,0)
 ;;
"RTN","HLOAPI1",45,0)
 ;;Output:
"RTN","HLOAPI1",46,0)
 ;;  Function returns the ien of the message in file 778 on success, 0 on failure
"RTN","HLOAPI1",47,0)
 ;;   HLMSTATE() - (pass by reference, required) This array is used by the HL7 package to track the progress of the message.  The application MUST NOT touch it!
"RTN","HLOAPI1",48,0)
 ;;   ERROR (pass by reference, optional) - on failure, will contain an error message
"RTN","HLOAPI1",49,0)
 ;;   PARMS - left undefined when the function returns
"RTN","HLOAPI1",50,0)
 ;;   WHOTO - left undefined when the function returns
"RTN","HLOAPI1",51,0)
 ;;
"RTN","HLOAPI1",52,0)
 ;;
"RTN","HLOAPI1",53,0)
 N SUCCESS,ERR1,ERR2
"RTN","HLOAPI1",54,0)
 S SUCCESS=0
"RTN","HLOAPI1",55,0)
 D
"RTN","HLOAPI1",56,0)
 .I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) S ERROR="MESSAGE NOT YET CREATED" Q
"RTN","HLOAPI1",57,0)
 .;;
"RTN","HLOAPI1",58,0)
 .I $$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERR1)&$$CHKWHO^HLOAPI2(.HLMSTATE,.WHOTO,.ERR2) D
"RTN","HLOAPI1",59,0)
 ..I $$SEND(.HLMSTATE,.ERROR) S SUCCESS=1
"RTN","HLOAPI1",60,0)
 .E  D
"RTN","HLOAPI1",61,0)
 ..S ERROR=$G(ERR1)_": "_$G(ERR2)
"RTN","HLOAPI1",62,0)
 ..D DONTSEND(.HLMSTATE,ERROR)
"RTN","HLOAPI1",63,0)
 K PARMS,WHOTO
"RTN","HLOAPI1",64,0)
 Q $S(SUCCESS:HLMSTATE("IEN"),1:0)
"RTN","HLOAPI1",65,0)
 ;;
"RTN","HLOAPI1",66,0)
SENDMANY(HLMSTATE,PARMS,WHOTO) ;;
"RTN","HLOAPI1",67,0)
 ;;Sends the message to a list of receiving applications
"RTN","HLOAPI1",68,0)
 ;;
"RTN","HLOAPI1",69,0)
 ;;Input: Same as for $$SENDONE, except WHOTO is a list.
"RTN","HLOAPI1",70,0)
 ;;  WHOTO (pass by reference)
"RTN","HLOAPI1",71,0)
 ;;    Specifies a list of recipients.  Each recipient should be on the
"RTN","HLOAPI1",72,0)
 ;;    list as WHOTO(i), where i=1,2,3,4, etc. for as many messages as to
"RTN","HLOAPI1",73,0)
 ;;    send.  At each subscript WHOTO(i), the same lower level subscripts
"RTN","HLOAPI1",74,0)
 ;;    may be defined as in the $$SENDONE API.  For example:
"RTN","HLOAPI1",75,0)
 ;;
"RTN","HLOAPI1",76,0)
 ;;      WHOTO(1,"FACILITY LINK NAME")="VAALB"
"RTN","HLOAPI1",77,0)
 ;;      WHOTO(1,"RECEIVING APPLICATION")="MPI"
"RTN","HLOAPI1",78,0)
 ;;      WHOTO(2,"STATION NUMBER")=500
"RTN","HLOAPI1",79,0)
 ;;      WHOTO(2,"RECEIVING APPLICATION")="MPI"
"RTN","HLOAPI1",80,0)
 ;;
"RTN","HLOAPI1",81,0)
 ;;
"RTN","HLOAPI1",82,0)
 ;;Output:
"RTN","HLOAPI1",83,0)
 ;;  Function returns 1 if a message is queued to be sent to each intended recipient, 0 otherwise
"RTN","HLOAPI1",84,0)
 ;;  PARMS - left undefined when the function returns
"RTN","HLOAPI1",85,0)
 ;;  WHOTO (pass by reference) returns the status of each message to be sent in the format:
"RTN","HLOAPI1",86,0)
 ;;    (<i>,"QUEUED")= <1 if queued to be sent, 0 otherwise)
"RTN","HLOAPI1",87,0)
 ;;   (<i>,"IEN")=<ien, file 778>
"RTN","HLOAPI1",88,0)
 ;;   (<i>,"ERROR")= error message if an error was encountered (status=0), not defined otherwise
"RTN","HLOAPI1",89,0)
 ;;
"RTN","HLOAPI1",90,0)
 ;;
"RTN","HLOAPI1",91,0)
 N ERROR,RETURN,WHO,STATE,I
"RTN","HLOAPI1",92,0)
 S RETURN=1
"RTN","HLOAPI1",93,0)
 I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) D  K PARMS Q 0
"RTN","HLOAPI1",94,0)
 .S ERROR="MESSAGE NOT YET CREATED"
"RTN","HLOAPI1",95,0)
 .S I=0 F  S I=$O(WHOTO(I)) Q:'I  S WHOTO(I,"QUEUED")=0,WHOTO(I,"IEN")=0,WHOTO(I,"ERROR")=ERROR
"RTN","HLOAPI1",96,0)
 ;;
"RTN","HLOAPI1",97,0)
 I '$$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERROR) D  K PARMS Q 0
"RTN","HLOAPI1",98,0)
 .S I=0 F  S I=$O(WHOTO(I)) Q:'I  D
"RTN","HLOAPI1",99,0)
 ..K WHO M WHO=WHOTO(I)
"RTN","HLOAPI1",100,0)
 ..K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",101,0)
 ..S WHOTO(I,"QUEUED")=0
"RTN","HLOAPI1",102,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",103,0)
 ..S WHOTO(I,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",104,0)
 ..S WHOTO(I,"ERROR")=ERROR
"RTN","HLOAPI1",105,0)
 ;;
"RTN","HLOAPI1",106,0)
 S I=0 F  S I=$O(WHOTO(I)) Q:'I  D
"RTN","HLOAPI1",107,0)
 .K WHO M WHO=WHOTO(I)
"RTN","HLOAPI1",108,0)
 .K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",109,0)
 .S ERROR=""
"RTN","HLOAPI1",110,0)
 .I $$CHKWHO^HLOAPI2(.STATE,.WHO,.ERROR) D
"RTN","HLOAPI1",111,0)
 ..I $$SEND(.STATE,.ERROR) D
"RTN","HLOAPI1",112,0)
 ...S WHOTO(I,"QUEUED")=1
"RTN","HLOAPI1",113,0)
 ...S WHOTO(I,"IEN")=STATE("IEN")
"RTN","HLOAPI1",114,0)
 ...S WHOTO(I,"ERROR")=""
"RTN","HLOAPI1",115,0)
 ..E  D
"RTN","HLOAPI1",116,0)
 ...S WHOTO(I,"QUEUED")=0
"RTN","HLOAPI1",117,0)
 ...S WHOTO(I,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",118,0)
 ...S WHOTO(I,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",119,0)
 ...S RETURN=0
"RTN","HLOAPI1",120,0)
 .E  D  ;;who not adequately determined
"RTN","HLOAPI1",121,0)
 ..S WHOTO(I,"QUEUED")=0,RETURN=0
"RTN","HLOAPI1",122,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",123,0)
 ..S WHOTO(I,"IEN")=$G(STATE("IEN")),WHOTO(I,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",124,0)
 K PARMS
"RTN","HLOAPI1",125,0)
 Q RETURN
"RTN","HLOAPI1",126,0)
 ;;
"RTN","HLOAPI1",127,0)
SENDSUB(HLMSTATE,PARMS,MESSAGES) ;;
"RTN","HLOAPI1",128,0)
 ;;Sends the message to a list of receiving applications based on the HL7 Subscription Registry
"RTN","HLOAPI1",129,0)
 ;;
"RTN","HLOAPI1",130,0)
 ;;Input:
"RTN","HLOAPI1",131,0)
 ;;  HLMSTATE (pass by reference, required) same as $$SENDMANY
"RTN","HLOAPI1",132,0)
 ;;  PARMS (pass by reference, required) same as $$SENDMANY, with one additional subscript:
"RTN","HLOAPI1",133,0)
 ;;    "SUBSCRIPTION IEN" - the ien of an entry in the HL7 Subscription Registry, defining the intended recipients of this message
"RTN","HLOAPI1",134,0)
 ;;
"RTN","HLOAPI1",135,0)
 ;;Output:
"RTN","HLOAPI1",136,0)
 ;;  Function returns 1 if a message is queued to be sent to each intended recipient, 0 otherwise
"RTN","HLOAPI1",137,0)
 ;;  PARMS - left undefined when the function returns
"RTN","HLOAPI1",138,0)
 ;;  MESSAGES (pass by reference) returns the status of each message to be sent in this format, where subien is the ien of the recipient in the RECIPEINTS subfile of the HL7 Subscription Registry
"RTN","HLOAPI1",139,0)
 ;;   (<subien>,"QUEUED")= <1 if queued to be sent, 0 otherwise)
"RTN","HLOAPI1",140,0)
 ;;   (<subien>,"IEN")=<ien, file 778>
"RTN","HLOAPI1",141,0)
 ;;   (<subien>,"ERROR")= error message if an error was encountered (status=0), not defined otherwise
"RTN","HLOAPI1",142,0)
 ;;
"RTN","HLOAPI1",143,0)
 ;;
"RTN","HLOAPI1",144,0)
 K MESSAGES
"RTN","HLOAPI1",145,0)
 N ERROR,RETURN,STATE,SUBIEN,WHO
"RTN","HLOAPI1",146,0)
 ;;
"RTN","HLOAPI1",147,0)
 S RETURN=1
"RTN","HLOAPI1",148,0)
 ;;
"RTN","HLOAPI1",149,0)
 ;;
"RTN","HLOAPI1",150,0)
 I '$G(HLMSTATE("BODY")),'$G(HLMSTATE("UNSTORED LINES")) S ERROR="MESSAGE NOT YET CREATED" K PARMS Q 0
"RTN","HLOAPI1",151,0)
 I '$G(PARMS("SUBSCRIPTION IEN")) S ERROR="SUBSCRIPTION REGISTRY IEN NOT PROVIDED" K PARMS Q 0
"RTN","HLOAPI1",152,0)
 ;;
"RTN","HLOAPI1",153,0)
 I '$$CHKPARMS^HLOAPI2(.HLMSTATE,.PARMS,.ERROR) D  K PARMS Q 0
"RTN","HLOAPI1",154,0)
 .S SUBIEN=0 F  S SUBIEN=$$NEXT^HLOASUB(PARMS("SUBSCRIPTION IEN"),.WHO) Q:'SUBIEN  D
"RTN","HLOAPI1",155,0)
 ..N SARY,HARY
"RTN","HLOAPI1",156,0)
 ..S HARY="STATE(""HDR"")"
"RTN","HLOAPI1",157,0)
 ..S SARY="STATE(""STATUS"")"
"RTN","HLOAPI1",158,0)
 ..K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",159,0)
 ..;;move parameters into HLMSTATE
"RTN","HLOAPI1",160,0)
 ..S @SARY@("LINK IEN")=WHO("LINK IEN")
"RTN","HLOAPI1",161,0)
 ..S @SARY@("LINK NAME")=WHO("LINK NAME")
"RTN","HLOAPI1",162,0)
 ..S @HARY@("RECEIVING APPLICATION")=WHO("RECEIVING APPLICATION")
"RTN","HLOAPI1",163,0)
 ..M @HARY@("RECEIVING FACILITY")=WHO("RECEIVING FACILITY")
"RTN","HLOAPI1",164,0)
 ..D DONTSEND(.STATE,$G(ERROR))
"RTN","HLOAPI1",165,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=0
"RTN","HLOAPI1",166,0)
 ..S MESSAGES(SUBIEN,"IEN")=$G(STATE("IEN"))
"RTN","HLOAPI1",167,0)
 ..S MESSAGES(SUBIEN,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",168,0)
 ;;
"RTN","HLOAPI1",169,0)
 F  S SUBIEN=$$NEXT^HLOASUB(PARMS("SUBSCRIPTION IEN"),.WHO) Q:'SUBIEN  D
"RTN","HLOAPI1",170,0)
 .N SARY,HARY
"RTN","HLOAPI1",171,0)
 .S HARY="STATE(""HDR"")"
"RTN","HLOAPI1",172,0)
 .S SARY="STATE(""STATUS"")"
"RTN","HLOAPI1",173,0)
 .K STATE M STATE=HLMSTATE S STATE("IEN")=""
"RTN","HLOAPI1",174,0)
 .;;move parameters into HLMSTATE
"RTN","HLOAPI1",175,0)
 .S @SARY@("LINK IEN")=WHO("LINK IEN")
"RTN","HLOAPI1",176,0)
 .S @SARY@("LINK NAME")=WHO("LINK NAME")
"RTN","HLOAPI1",177,0)
 .S @HARY@("RECEIVING APPLICATION")=WHO("RECEIVING APPLICATION")
"RTN","HLOAPI1",178,0)
 .M @HARY@("RECEIVING FACILITY")=WHO("RECEIVING FACILITY")
"RTN","HLOAPI1",179,0)
 .S ERROR=""
"RTN","HLOAPI1",180,0)
 .I $$SEND(.STATE,.ERROR) D
"RTN","HLOAPI1",181,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=1
"RTN","HLOAPI1",182,0)
 .E  D
"RTN","HLOAPI1",183,0)
 ..S MESSAGES(SUBIEN,"QUEUED")=0,RETURN=0
"RTN","HLOAPI1",184,0)
 .S MESSAGES(SUBIEN,"IEN")=$G(STATE("IEN")),MESSAGES(SUBIEN,"ERROR")=$G(ERROR)
"RTN","HLOAPI1",185,0)
 K PARMS
"RTN","HLOAPI1",186,0)
 Q RETURN
"RTN","HLOAPI1",187,0)
 ;;
"RTN","HLOAPI1",188,0)
SEND(HLMSTATE,ERROR) ;
"RTN","HLOAPI1",189,0)
 ;;
"RTN","HLOAPI1",190,0)
 K ERROR
"RTN","HLOAPI1",191,0)
 I HLMSTATE("UNSTORED LINES"),'$$SAVEMSG^HLOF777(.HLMSTATE) S ERROR="$$SAVE^HLOF777 FAILED!" Q 0
"RTN","HLOAPI1",192,0)
 ;;
"RTN","HLOAPI1",193,0)
 I '$$SAVEMSG^HLOF778(.HLMSTATE) S ERROR="$$SAVE^HLOF778 FAILED!" Q 0
"RTN","HLOAPI1",194,0)
 I HLMSTATE("BATCH"),$L($G(HLMSTATE("STATUS","SEQUENCE QUEUE"))) S ERROR="SEQUENCE QUEUES NOT SUPPORTED FOR BATCH MESSAGES" Q 0
"RTN","HLOAPI1",195,0)
 I $L($G(HLMSTATE("STATUS","SEQUENCE QUEUE"))) D
"RTN","HLOAPI1",196,0)
 .S HLMSTATE("STATUS","MOVED TO OUT QUEUE")=$$SQUE^HLOQUE(HLMSTATE("STATUS","SEQUENCE QUEUE"),HLMSTATE("STATUS","LINK NAME"),$G(HLMSTATE("STATUS","PORT")),HLMSTATE("STATUS","QUEUE"),HLMSTATE("IEN")) D:HLMSTATE("STATUS","MOVED TO OUT QUEUE")
"RTN","HLOAPI1",197,0)
 ..S $P(^HLB(HLMSTATE("IEN"),5),"^",2)=1
"RTN","HLOAPI1",198,0)
 E  D
"RTN","HLOAPI1",199,0)
 .D OUTQUE^HLOQUE(HLMSTATE("STATUS","LINK NAME"),$G(HLMSTATE("STATUS","PORT")),HLMSTATE("STATUS","QUEUE"),HLMSTATE("IEN"))
"RTN","HLOAPI1",200,0)
 Q HLMSTATE("IEN")
"RTN","HLOAPI1",201,0)
 ;
"RTN","HLOAPI1",202,0)
DONTSEND(HLMSTATE,ERROR) ;
"RTN","HLOAPI1",203,0)
 ;;This procedure does NOT send a message.  Rather, it creates an entry in file 778 with the status ER.  
"RTN","HLOAPI1",204,0)
 ;;Input:
"RTN","HLOAPI1",205,0)
 ;;       HLMSTATE - pass-by-reference
"RTN","HLOAPI1",206,0)
 ;;       ERROR (optional, pass-by-value) error text to store with the message
"RTN","HLOAPI1",207,0)
 ;;Output: none
"RTN","HLOAPI1",208,0)
 ;;
"RTN","HLOAPI1",209,0)
 D:HLMSTATE("UNSTORED LINES") SAVEMSG^HLOF777(.HLMSTATE)
"RTN","HLOAPI1",210,0)
 ;;
"RTN","HLOAPI1",211,0)
 S HLMSTATE("STATUS")="ER"
"RTN","HLOAPI1",212,0)
 ;
"RTN","HLOAPI1",213,0)
 S HLMSTATE("STATUS","ERROR TEXT")=$G(ERROR)
"RTN","HLOAPI1",214,0)
 D SAVEMSG^HLOF778(.HLMSTATE)
"RTN","HLOAPI1",215,0)
 D SETPURGE^HLOF778A($G(HLMSTATE("IEN")),"ER",$S($G(HLMSTATE("ACK TO IEN")):HLMSTATE("ACK TO IEN"),1:""))
"RTN","HLOAPI1",216,0)
 Q
"RTN","HLOAPI2")
0^8^B76156297^B76422316
"RTN","HLOAPI2",1,0)
HLOAPI2 ;ALB/CJM/OAK/RBN-HL7 - Developer API's for sending application acks ;07/12/2012
"RTN","HLOAPI2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131,133,134,137,138,146,158**;Oct 13, 1995;Build 14
"RTN","HLOAPI2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI2",4,0)
 ;
"RTN","HLOAPI2",5,0)
ACK(HLMSTATE,PARMS,ACK,ERROR) ;; Default behavior is to return a general
"RTN","HLOAPI2",6,0)
 ;;application ack. The application may optionally specify the message
"RTN","HLOAPI2",7,0)
 ;;type and event or call $$ADDSEG^HLOAPI to add segments.
"RTN","HLOAPI2",8,0)
 ;;A generic MSA segment (components 1-3) is added automatically IF the
"RTN","HLOAPI2",9,0)
 ;;application doesn't call $$ADDSEG^HLOAPI to add an MSA segment as the
"RTN","HLOAPI2",10,0)
 ;;FIRST segment following the header.
"RTN","HLOAPI2",11,0)
 ;;$$SENDACK must be called when the ack is completed. The return
"RTN","HLOAPI2",12,0)
 ;;destination is determined automatically from the original message
"RTN","HLOAPI2",13,0)
 ;;
"RTN","HLOAPI2",14,0)
 ;;This API should NOT be called for batch messages, use $$BATCHACK instead.
"RTN","HLOAPI2",15,0)
 ;;Input:
"RTN","HLOAPI2",16,0)
 ;;  HLMSTATE (pass by reference, required) the array obtained by calling $$STARTMSG^HLOPRS when parsing the original message 
"RTN","HLOAPI2",17,0)
 ;;  PARMS (pass by reference) These subscripts may be defined:
"RTN","HLOAPI2",18,0)
 ;;    "ACK CODE" (required) MSA1[ {AA,AE,AR}
"RTN","HLOAPI2",19,0)
 ;;    "ERROR MESSAGE" - MSA3, should be used only if AE or AR
"RTN","HLOAPI2",20,0)
 ;;    "ACCEPT ACK RESPONSE" - the <tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI2",21,0)
 ;;    "ACCEPT ACK TYPE" - {AL,NE} (optional, defaults to AL)
"RTN","HLOAPI2",22,0)
 ;;    "CONTINUATION POINTER" (optional)indicates a fragmented message
"RTN","HLOAPI2",23,0)
 ;;    "COUNTRY" - the 3 character country code (optional)
"RTN","HLOAPI2",24,0)
 ;;    "EVENT" - the 3 character event type (optional, defaults to the event code of the original message)
"RTN","HLOAPI2",25,0)
 ;;    "ENCODING CHARACTERS" - the four HL7 encoding characters (optional,defaults to "^~\&"
"RTN","HLOAPI2",26,0)
 ;;    "FAILURE RESPONSE" (optional) the <tag>^<routine> that the sending application routine should execute if the transmission of the message fails, i.e., the message can not be sent or a requested commit ack is not received.
"RTN","HLOAPI2",27,0)
 ;;    "FIELD SEPARATOR" - field separator (optional, defaults to "|")
"RTN","HLOAPI2",28,0)
 ;;    "MESSAGE TYPE" - if not defined, ACK is used
"RTN","HLOAPI2",29,0)
 ;;    "MESSAGE STRUCTURE" (optional)
"RTN","HLOAPI2",30,0)
 ;;    "RETURN LINK NAME" (optional)
"RTN","HLOAPI2",31,0)
 ;;    "RETURN LINK IEN" (optional)
"RTN","HLOAPI2",32,0)
 ;;    "QUEUE" - (optional) An application can name its own private queue (a string under 20 characters,namespaced). The default is the name of the queue of the original message
"RTN","HLOAPI2",33,0)
 ;;    "SECURITY" (optional) security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI2",34,0)
 ;;    "VERSION" - the HL7 Version ID (optional, defaults to 2.4)
"RTN","HLOAPI2",35,0)
 ;;Output:
"RTN","HLOAPI2",36,0)
 ;;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI2",37,0)
 ;;  PARMS - left undefined when the function returns
"RTN","HLOAPI2",38,0)
 ;;  ACK (pass by reference, required) the acknowledgment message being built.
"RTN","HLOAPI2",39,0)
 ;;  ERROR (pass by reference) error msg
"RTN","HLOAPI2",40,0)
 ;;  
"RTN","HLOAPI2",41,0)
 N I,SEG,TOLINK,SUCCESS
"RTN","HLOAPI2",42,0)
 S SUCCESS=0,(TOLINK,ERROR)=""
"RTN","HLOAPI2",43,0)
 ;
"RTN","HLOAPI2",44,0)
 D
"RTN","HLOAPI2",45,0)
 .N PORT S PORT=""
"RTN","HLOAPI2",46,0)
 .I $G(PARMS("ACK CODE"))'="AA",$G(PARMS("ACK CODE"))'="AE",$G(PARMS("ACK CODE"))'="AR" S ERROR="INVALID ACK CODE" Q
"RTN","HLOAPI2",47,0)
 .;
"RTN","HLOAPI2",48,0)
 .I '$G(HLMSTATE("IEN")) S ERROR="ORIGINAL MESSAGE TO ACKNOWLEDGE IS NOT IDENTIFIED" Q
"RTN","HLOAPI2",49,0)
 .I $G(HLMSTATE("BATCH")) S ERROR="BATCH ACKNOWLEDGMENTS MUST USE $$BATCHACK^HLOAPI3" Q
"RTN","HLOAPI2",50,0)
 .;
"RTN","HLOAPI2",51,0)
 .I $G(HLMSTATE("HDR","MESSAGE CONTROL ID"))="" S ERROR="MESSAGE CONTROL ID MUST EXIST TO RETURN AN APPLICATION ACK" Q
"RTN","HLOAPI2",52,0)
 .S PARMS("MESSAGE TYPE")=$G(PARMS("MESSAGE TYPE"),"ACK")
"RTN","HLOAPI2",53,0)
 .S:PARMS("MESSAGE TYPE")="ACK" PARMS("MESSAGE STRUCTURE")="ACK"
"RTN","HLOAPI2",54,0)
 .S PARMS("EVENT")=$G(PARMS("EVENT"),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOAPI2",55,0)
 .I $$NEWMSG^HLOAPI(.PARMS,.ACK)  ;can't fail!
"RTN","HLOAPI2",56,0)
 .;
"RTN","HLOAPI2",57,0)
 .;if the return link can not be determined, the HL Logical Link file has a problem that must be fixed at the site
"RTN","HLOAPI2",58,0)
 .I $G(PARMS("RETURN LINK IEN")) D
"RTN","HLOAPI2",59,0)
 ..S TOLINK=$P($G(^HLCS(870,PARMS("RETURN LINK IEN"),0)),"^")
"RTN","HLOAPI2",60,0)
 ..S PORT=$$PORT2^HLOTLNK(TOLINK)
"RTN","HLOAPI2",61,0)
 .E  I $L($G(PARMS("RETURN LINK NAME"))) D
"RTN","HLOAPI2",62,0)
 ..S TOLINK=PARMS("RETURN LINK NAME")
"RTN","HLOAPI2",63,0)
 ..S PORT=$$PORT2^HLOTLNK(TOLINK)
"RTN","HLOAPI2",64,0)
 .E  D
"RTN","HLOAPI2",65,0)
 ..S TOLINK=$$ACKLINK(.HLMSTATE,.PORT)
"RTN","HLOAPI2",66,0)
 .I (TOLINK="")!('PORT) S ERROR="TRANSMISSION LINK FOR APPLICATION ACK CANNOT BE DETERMINED" Q
"RTN","HLOAPI2",67,0)
 .;
"RTN","HLOAPI2",68,0)
 .S ACK("HDR","APP ACK TYPE")="NE"
"RTN","HLOAPI2",69,0)
 .S ACK("HDR","ACCEPT ACK TYPE")=$G(PARMS("ACCEPT ACK TYPE"),"AL")
"RTN","HLOAPI2",70,0)
 .S ACK("STATUS","QUEUE")=$G(PARMS("QUEUE"),$G(HLMSTATE("STATUS","QUEUE")))
"RTN","HLOAPI2",71,0)
 .S ACK("STATUS","PORT")=PORT
"RTN","HLOAPI2",72,0)
 .S ACK("HDR","SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI2",73,0)
 .S ACK("HDR","SENDING APPLICATION")=$G(HLMSTATE("HDR","RECEIVING APPLICATION"))
"RTN","HLOAPI2",74,0)
 .S ACK("HDR","RECEIVING APPLICATION")=$G(HLMSTATE("HDR","SENDING APPLICATION"))
"RTN","HLOAPI2",75,0)
 .F I=1:1:3 S ACK("HDR","RECEIVING FACILITY",I)=$G(HLMSTATE("HDR","SENDING FACILITY",I))
"RTN","HLOAPI2",76,0)
 .S ACK("ACK TO","STATUS")=$S(PARMS("ACK CODE")="AA":"SU",1:"ER")
"RTN","HLOAPI2",77,0)
 .S ACK("ACK TO")=$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOAPI2",78,0)
 .S ACK("ACK TO IEN")=HLMSTATE("IEN")
"RTN","HLOAPI2",79,0)
 .S ACK("STATUS","LINK NAME")=TOLINK
"RTN","HLOAPI2",80,0)
 .S ACK("LINE COUNT")=0
"RTN","HLOAPI2",81,0)
 . ;; Next line modified for HL*1.6*138 - RBN
"RTN","HLOAPI2",82,0)
 .;;S ACK("MSA")="MSA"_ACK("HDR","FIELD SEPARATOR")_PARMS("ACK CODE")_ACK("HDR","FIELD SEPARATOR")_$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))_ACK("HDR","FIELD SEPARATOR")_$G(PARMS("ERROR MESSAGE"))
"RTN","HLOAPI2",83,0)
 .S ACK("MSA")="MSA"_ACK("HDR","FIELD SEPARATOR")_PARMS("ACK CODE")_ACK("HDR","FIELD SEPARATOR")_$G(HLMSTATE("HDR","MESSAGE CONTROL ID"))_ACK("HDR","FIELD SEPARATOR")_$$ESCAPE^HLOPBLD(.HLMSTATE,$G(PARMS("ERROR MESSAGE")))
"RTN","HLOAPI2",84,0)
 .S SUCCESS=1
"RTN","HLOAPI2",85,0)
 K PARMS
"RTN","HLOAPI2",86,0)
 K:'SUCCESS ACK
"RTN","HLOAPI2",87,0)
 Q SUCCESS
"RTN","HLOAPI2",88,0)
 ;
"RTN","HLOAPI2",89,0)
SENDACK(ACK,ERROR) ;;This is used to signal that an application acknowledgment is complete.
"RTN","HLOAPI2",90,0)
 ;;Input:
"RTN","HLOAPI2",91,0)
 ;;  ACK (pass by reference,required) An array that contains the acknowledgment msg
"RTN","HLOAPI2",92,0)
 ;;Output:
"RTN","HLOAPI2",93,0)
 ;; Function returns 1 on success, 0 on failure
"RTN","HLOAPI2",94,0)
 ;; ERROR (pass by reference) error msg
"RTN","HLOAPI2",95,0)
 ;;
"RTN","HLOAPI2",96,0)
 N SEG
"RTN","HLOAPI2",97,0)
 ;if the application added its own MSA, then the ACK("MSA") node was killed
"RTN","HLOAPI2",98,0)
 I $D(ACK("MSA")) S SEG(1)=ACK("MSA") D ADDSEG^HLOMSG(.ACK,.SEG)
"RTN","HLOAPI2",99,0)
 ;
"RTN","HLOAPI2",100,0)
 I $$SEND^HLOAPI1(.ACK,.ERROR) Q 1
"RTN","HLOAPI2",101,0)
 Q 0
"RTN","HLOAPI2",102,0)
 ;
"RTN","HLOAPI2",103,0)
ACKLINK(HLMSTATE,PORT) ; Finds the link & port to return the application ack to.
"RTN","HLOAPI2",104,0)
 N LINK
"RTN","HLOAPI2",105,0)
 S LINK=$$RTRNLNK^HLOAPP($G(HLMSTATE("HDR","RECEIVING APPLICATION")))
"RTN","HLOAPI2",106,0)
 I LINK]"" S PORT=$$PORT2^HLOTLNK(LINK) Q LINK
"RTN","HLOAPI2",107,0)
 S LINK=$$RTRNLNK^HLOTLNK($G(HLMSTATE("HDR","SENDING FACILITY",1)),$G(HLMSTATE("HDR","SENDING FACILITY",2)),$G(HLMSTATE("HDR","SENDING FACILITY",3)))
"RTN","HLOAPI2",108,0)
 S:$G(HLMSTATE("HDR","SENDING FACILITY",3))="DNS" PORT=$P(HLMSTATE("HDR","SENDING FACILITY",2),":",2)
"RTN","HLOAPI2",109,0)
 I LINK]"",'PORT S PORT=$$PORT2^HLOTLNK(LINK)
"RTN","HLOAPI2",110,0)
 Q LINK
"RTN","HLOAPI2",111,0)
 ;
"RTN","HLOAPI2",112,0)
CHKPARMS(HLMSTATE,PARMS,ERROR) ;
"RTN","HLOAPI2",113,0)
 N LEN,SARY,HARY
"RTN","HLOAPI2",114,0)
 ;
"RTN","HLOAPI2",115,0)
 ;shortcut to reference the header sub-array
"RTN","HLOAPI2",116,0)
 S HARY="HLMSTATE(""HDR"")"
"RTN","HLOAPI2",117,0)
 ;
"RTN","HLOAPI2",118,0)
 ;shortcut to reference the status sub-array
"RTN","HLOAPI2",119,0)
 S SARY="HLMSTATE(""STATUS"")"
"RTN","HLOAPI2",120,0)
 ;
"RTN","HLOAPI2",121,0)
 S ERROR=""
"RTN","HLOAPI2",122,0)
 I $G(PARMS("ACCEPT ACK TYPE"))="" S PARMS("ACCEPT ACK TYPE")="AL"
"RTN","HLOAPI2",123,0)
 I $G(PARMS("APP ACK TYPE"))="" S PARMS("APP ACK TYPE")="NE"
"RTN","HLOAPI2",124,0)
 I PARMS("ACCEPT ACK TYPE")'="NE",PARMS("ACCEPT ACK TYPE")'="AL" S ERROR="INVALID ACCEPT ACKNOWLEDGMENT TYPE"
"RTN","HLOAPI2",125,0)
 I PARMS("APP ACK TYPE")'="NE",PARMS("APP ACK TYPE")'="AL" S ERROR="INVALID APPLICATION ACKNOWLEDGMENT TYPE"
"RTN","HLOAPI2",126,0)
 S LEN=$L($G(PARMS("QUEUE")))
"RTN","HLOAPI2",127,0)
 I $G(PARMS("QUEUE"))["^" S ERROR="QUEUE NAME MAY NOT CONTAIN '^'"
"RTN","HLOAPI2",128,0)
 I LEN>20 S ERROR="QUEUE PARAMETER IS MAX 20 LENGTH",PARMS("QUEUE")=$E(PARMS("QUEUE"),1,20)
"RTN","HLOAPI2",129,0)
 I 'LEN S PARMS("QUEUE")="DEFAULT"
"RTN","HLOAPI2",130,0)
 D
"RTN","HLOAPI2",131,0)
 .N APPIEN
"RTN","HLOAPI2",132,0)
 .I $G(PARMS("SENDING APPLICATION"))="" D  Q
"RTN","HLOAPI2",133,0)
 ..S ERROR="SENDING APPLICATION IS REQUIRED"
"RTN","HLOAPI2",134,0)
 ..S PARMS("SENDING APPLICATION")=""
"RTN","HLOAPI2",135,0)
 .E  D  Q:'APPIEN
"RTN","HLOAPI2",136,0)
 ..S APPIEN=$$GETIEN^HLOAPP(PARMS("SENDING APPLICATION"))
"RTN","HLOAPI2",137,0)
 ..I 'APPIEN S ERROR="SENDING APPLICATION NOT FOUND IN THE HLO APPLICATION REGISTRY"
"RTN","HLOAPI2",138,0)
 .I $L($G(PARMS("SEQUENCE QUEUE"))) D
"RTN","HLOAPI2",139,0)
 ..I ($L(PARMS("SEQUENCE QUEUE"))>30) S ERROR="SEQUENCE QUEUE NAME > 30 CHARACTERS" Q
"RTN","HLOAPI2",140,0)
 ..I PARMS("SEQUENCE QUEUE")["^" S ERROR="SEQUENCE QUEUE NAME MAY NOT CONTAIN '^'" Q
"RTN","HLOAPI2",141,0)
 ..I $G(PARMS("APP ACK TYPE"))'="AL" S ERROR="SEQUENCE QUEUES REQUIRE AN APPLICATION ACKNOWLEDGMENT" Q
"RTN","HLOAPI2",142,0)
 ..I $G(PARMS("ACCEPT ACK TYPE"))'="AL" S ERROR="SEQUENCE QUEUES REQUIRE AN ACCEPT ACKNOWLEDGMENT" Q
"RTN","HLOAPI2",143,0)
 ;
"RTN","HLOAPI2",144,0)
 ;move parameters into HLMSTATE
"RTN","HLOAPI2",145,0)
 S @HARY@("ACCEPT ACK TYPE")=PARMS("ACCEPT ACK TYPE")
"RTN","HLOAPI2",146,0)
 S @HARY@("APP ACK TYPE")=PARMS("APP ACK TYPE")
"RTN","HLOAPI2",147,0)
 S @HARY@("SENDING APPLICATION")=$E(PARMS("SENDING APPLICATION"),1,60)
"RTN","HLOAPI2",148,0)
 S @HARY@("SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI2",149,0)
 S @SARY@("APP ACK RESPONSE")=$G(PARMS("APP ACK RESPONSE"))
"RTN","HLOAPI2",150,0)
 S @SARY@("ACCEPT ACK RESPONSE")=$G(PARMS("ACCEPT ACK RESPONSE"))
"RTN","HLOAPI2",151,0)
 S @SARY@("FAILURE RESPONSE")=$G(PARMS("FAILURE RESPONSE"))
"RTN","HLOAPI2",152,0)
 S @SARY@("QUEUE")=PARMS("QUEUE")
"RTN","HLOAPI2",153,0)
 S @SARY@("SEQUENCE QUEUE")=$G(PARMS("SEQUENCE QUEUE"))
"RTN","HLOAPI2",154,0)
 Q:$L(ERROR) 0
"RTN","HLOAPI2",155,0)
 Q 1
"RTN","HLOAPI2",156,0)
 ;
"RTN","HLOAPI2",157,0)
 ;
"RTN","HLOAPI2",158,0)
SETCODE(SEG,VALUE,FIELD,COMP,REP) ; Implements SETCNE and SETCWE
"RTN","HLOAPI2",159,0)
 ;
"RTN","HLOAPI2",160,0)
 N SUB,VAR
"RTN","HLOAPI2",161,0)
 Q:'$G(FIELD)
"RTN","HLOAPI2",162,0)
 S:'$G(REP) REP=1
"RTN","HLOAPI2",163,0)
 I '$G(COMP) D
"RTN","HLOAPI2",164,0)
 .S VAR="COMP",SUB=1
"RTN","HLOAPI2",165,0)
 E  D
"RTN","HLOAPI2",166,0)
 .S VAR="SUB"
"RTN","HLOAPI2",167,0)
 S @VAR=1,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ID"))
"RTN","HLOAPI2",168,0)
 S @VAR=2,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("TEXT"))
"RTN","HLOAPI2",169,0)
 S @VAR=3,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("SYSTEM"))
"RTN","HLOAPI2",170,0)
 S @VAR=4,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE ID"))
"RTN","HLOAPI2",171,0)
 S @VAR=5,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE TEXT"))
"RTN","HLOAPI2",172,0)
 S @VAR=6,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE SYSTEM"))
"RTN","HLOAPI2",173,0)
 S @VAR=7,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("SYSTEM VERSION"))
"RTN","HLOAPI2",174,0)
 S @VAR=8,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ALTERNATE SYSTEM VERSION"))
"RTN","HLOAPI2",175,0)
 S @VAR=9,SEG(FIELD,REP,COMP,SUB)=$G(VALUE("ORIGINAL TEXT"))
"RTN","HLOAPI2",176,0)
 Q
"RTN","HLOAPI2",177,0)
 ;
"RTN","HLOAPI2",178,0)
CHKWHO(HLMSTATE,WHOTO,ERROR) ;
"RTN","HLOAPI2",179,0)
 N RETURN,I
"RTN","HLOAPI2",180,0)
 S RETURN=1
"RTN","HLOAPI2",181,0)
 I '$$CHECKWHO^HLOASUB1(.WHOTO,.RETURN,.ERROR) S RETURN=0
"RTN","HLOAPI2",182,0)
 ;
"RTN","HLOAPI2",183,0)
 ;move parameters into HLMSTATE
"RTN","HLOAPI2",184,0)
 S HLMSTATE("STATUS","LINK IEN")=$G(RETURN("LINK IEN"))
"RTN","HLOAPI2",185,0)
 S HLMSTATE("STATUS","LINK NAME")=$G(RETURN("LINK NAME"))
"RTN","HLOAPI2",186,0)
 ;** P158 START **
"RTN","HLOAPI2",187,0)
 ;S HLMSTATE("STATUS","PORT")=$P($G(RETURN("RECEIVING FACILITY",2)),":",2)
"RTN","HLOAPI2",188,0)
 S HLMSTATE("STATUS","PORT")=$G(RETURN("LINK PORT"))
"RTN","HLOAPI2",189,0)
 ;** P158 END **
"RTN","HLOAPI2",190,0)
 S HLMSTATE("HDR","RECEIVING APPLICATION")=$G(RETURN("RECEIVING APPLICATION"))
"RTN","HLOAPI2",191,0)
 F I=1:1:3 S HLMSTATE("HDR","RECEIVING FACILITY",I)=$G(RETURN("RECEIVING FACILITY",I))
"RTN","HLOAPI2",192,0)
 Q RETURN
"RTN","HLOAPI3")
0^20^B108017449^B99815060
"RTN","HLOAPI3",1,0)
HLOAPI3 ;ALB/CJM-HL7 - Developer API's for sending application acks ;07/17/2012
"RTN","HLOAPI3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,133,134,137,138,158**;Oct 13, 1995;Build 14
"RTN","HLOAPI3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPI3",4,0)
 ;
"RTN","HLOAPI3",5,0)
BATCHACK(HLMSTATE,PARMS,ACK,ERROR) ;; Starts a batch message that is the response to a batch message. Individual acks are placed in the batch by calling $$ADDACK.
"RTN","HLOAPI3",6,0)
 ;;$$SENDACK^HLOAPI2 must be called when the batch of acks is complete. The return destination is determined automatically from the original message.
"RTN","HLOAPI3",7,0)
 ;;
"RTN","HLOAPI3",8,0)
 ;;Input:
"RTN","HLOAPI3",9,0)
 ;;  HLMSTATE (pass by reference, required) the array obtained by calling $$STARTMSG^HLOPRS when parsing the original message 
"RTN","HLOAPI3",10,0)
 ;;  PARMS (optional, pass by reference) These subscripts may be defined:
"RTN","HLOAPI3",11,0)
 ;;    "ACCEPT ACK RESPONSE")=<tag^routine> to call when the commit ack is received (optional)
"RTN","HLOAPI3",12,0)
 ;;    "ACCEPT ACK TYPE") = <AL,NE> (optional, defaults to AL)
"RTN","HLOAPI3",13,0)
 ;;    "COUNTRY") - a 3 character country code from the HL7 standard table (optional)
"RTN","HLOAPI3",14,0)
 ;;     "ENCODING CHARACTERS" - the 4 HL7 encoding characters (optional,defaults to "^~\&"
"RTN","HLOAPI3",15,0)
 ;;    "FAILURE RESPONSE" (optional) the <tag>^<routine> that the sending application routine should execute if the transmission of the message fails, i.e., the message can not be sent or a requested commit ack is not received.
"RTN","HLOAPI3",16,0)
 ;;     "FIELD SEPARATOR" - the field separator (optional, defaults to "|")
"RTN","HLOAPI3",17,0)
 ;;    "RETURN LINK NAME" (optional)
"RTN","HLOAPI3",18,0)
 ;;    "RETURN LINK IEN" (optional)
"RTN","HLOAPI3",19,0)
 ;;     "QUEUE" (optional) An application can name a private queue (a string under 20 characters, namespaced). The default is the name of the queue of the original message
"RTN","HLOAPI3",20,0)
 ;;     "SECURITY" - security information to include in the header segment, SEQ 8 (optional)
"RTN","HLOAPI3",21,0)
 ;;    "VERSION" - the HL7 Version ID (optional, defaults to 2.4)
"RTN","HLOAPI3",22,0)
 ;;Output:
"RTN","HLOAPI3",23,0)
 ;;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",24,0)
 ;;  PARMS - left undefined upon completion
"RTN","HLOAPI3",25,0)
 ;;  ACK (pass by reference, required) the batch acknowledgment message being built.
"RTN","HLOAPI3",26,0)
 ;;  ERROR (pass by reference) error message
"RTN","HLOAPI3",27,0)
 ;;  
"RTN","HLOAPI3",28,0)
 ;
"RTN","HLOAPI3",29,0)
 N I,TOLINK,SUCCESS
"RTN","HLOAPI3",30,0)
 S SUCCESS=0
"RTN","HLOAPI3",31,0)
 S TOLINK=""
"RTN","HLOAPI3",32,0)
 ;
"RTN","HLOAPI3",33,0)
 D
"RTN","HLOAPI3",34,0)
 .N PORT S PORT=""
"RTN","HLOAPI3",35,0)
 .I '$G(HLMSTATE("IEN")) S ERROR="ORIGINAL MESSAGE TO ACKNOWLEDGMENT IS NOT IDENTIFIED" Q
"RTN","HLOAPI3",36,0)
 .;if the return link can not be determined, the HL Logical Link file has a problem
"RTN","HLOAPI3",37,0)
 .I $G(PARMS("RETURN LINK IEN")) D
"RTN","HLOAPI3",38,0)
 ..S TOLINK=$P($G(^HLCS(870,PARMS("RETURN LINK IEN"),0)),"^")
"RTN","HLOAPI3",39,0)
 ..S PORT=$$PORT2^HLOTLNK(TOLINK)
"RTN","HLOAPI3",40,0)
 .E  I $L($G(PARMS("RETURN LINK NAME"))) D
"RTN","HLOAPI3",41,0)
 ..S TOLINK=PARMS("RETURN LINK NAME")
"RTN","HLOAPI3",42,0)
 ..S PORT=$$PORT2^HLOTLNK(TOLINK)
"RTN","HLOAPI3",43,0)
 .E  D
"RTN","HLOAPI3",44,0)
 ..S TOLINK=$$ACKLINK^HLOAPI2(.HLMSTATE,.PORT)
"RTN","HLOAPI3",45,0)
 .I (TOLINK="")!('PORT) S ERROR="TRANSMISSION LINK FOR APPLICATION ACK CANNOT BE DETERMINED" Q
"RTN","HLOAPI3",46,0)
 .;
"RTN","HLOAPI3",47,0)
 .I $$NEWBATCH^HLOAPI(.PARMS,.ACK)  ;can't fail!
"RTN","HLOAPI3",48,0)
 .S ACK("STATUS","QUEUE")=$G(PARMS("QUEUE"),$G(HLMSTATE("STATUS","QUEUE")))
"RTN","HLOAPI3",49,0)
 .I ACK("STATUS","QUEUE")="" S ACK("STATUS","QUEUE")="DEFAULT"
"RTN","HLOAPI3",50,0)
 .;
"RTN","HLOAPI3",51,0)
 .S ACK("STATUS","PORT")=PORT
"RTN","HLOAPI3",52,0)
 .S ACK("HDR","SECURITY")=$G(PARMS("SECURITY"))
"RTN","HLOAPI3",53,0)
 .S ACK("HDR","SENDING APPLICATION")=$G(HLMSTATE("HDR","RECEIVING APPLICATION"))
"RTN","HLOAPI3",54,0)
 .S ACK("HDR","RECEIVING APPLICATION")=$G(HLMSTATE("HDR","SENDING APPLICATION"))
"RTN","HLOAPI3",55,0)
 .F I=1:1:3 S ACK("HDR","RECEIVING FACILITY",I)=$G(HLMSTATE("HDR","SENDING FACILITY",I))
"RTN","HLOAPI3",56,0)
 .S ACK("HDR","APP ACK TYPE")="NE"
"RTN","HLOAPI3",57,0)
 .S ACK("HDR","ACCEPT ACK TYPE")=$G(PARMS("ACCEPT ACK TYPE"),"AL")
"RTN","HLOAPI3",58,0)
 .S ACK("ACK TO")=$G(HLMSTATE("HDR","BATCH CONTROL ID"))
"RTN","HLOAPI3",59,0)
 .S ACK("ACK TO IEN")=HLMSTATE("IEN")
"RTN","HLOAPI3",60,0)
 .S ACK("ACK TO","BODY")=$G(HLMSTATE("BODY"))
"RTN","HLOAPI3",61,0)
 .S ACK("STATUS","LINK NAME")=TOLINK
"RTN","HLOAPI3",62,0)
 .S ACK("LINE COUNT")=0
"RTN","HLOAPI3",63,0)
 .S SUCCESS=1
"RTN","HLOAPI3",64,0)
 K PARMS
"RTN","HLOAPI3",65,0)
 Q SUCCESS
"RTN","HLOAPI3",66,0)
 ;
"RTN","HLOAPI3",67,0)
ADDACK(ACK,PARMS,ERROR) ;;This API adds an application acknowledgment to a batch
"RTN","HLOAPI3",68,0)
 ;;of acknowledgments that was started by calling $$BATCHACK.
"RTN","HLOAPI3",69,0)
 ;;The Default behavior is to return a general application ack.
"RTN","HLOAPI3",70,0)
 ;;The application may optionally specify the message
"RTN","HLOAPI3",71,0)
 ;;type and event and/or call $$ADDSEG^HLOAPI to add segments.
"RTN","HLOAPI3",72,0)
 ;;A generic MSA segment (components 1-3) will be added automatically
"RTN","HLOAPI3",73,0)
 ;;if the application doesn't call $$ADDSEG^HLOAPI to add an MSA segment
"RTN","HLOAPI3",74,0)
 ;;as the FIRST segment following the MSH segment.
"RTN","HLOAPI3",75,0)
 ;;$$SENDACK^HLOAPI2 must be called when the batch is complete.
"RTN","HLOAPI3",76,0)
 ;;
"RTN","HLOAPI3",77,0)
 ;;Input:
"RTN","HLOAPI3",78,0)
 ;;  ACK (pass by reference,required) the batch of acks that is being built 
"RTN","HLOAPI3",79,0)
 ;;  PARMS (pass by reference) These subscripts may be defined:
"RTN","HLOAPI3",80,0)
 ;;    "ACK CODE" (required) MSA1[ {AA,AE,AR}
"RTN","HLOAPI3",81,0)
 ;;    "ERROR MESSAGE" (optional) MSA3, should be used only if AE or AR
"RTN","HLOAPI3",82,0)
 ;;    "EVENT" - 3 character event type (optional, defaults to the event code of the original message)
"RTN","HLOAPI3",83,0)
 ;;    "MESSAGE CONTROL ID" (required) this is the message control id of the original individual message within the batch which is being acknowledged
"RTN","HLOAPI3",84,0)
 ;;    "MESSAGE STRUCTURE" (optional)
"RTN","HLOAPI3",85,0)
 ;;    "MESSAGE TYPE" (optional, defaults to ACK)
"RTN","HLOAPI3",86,0)
 ;;    "SECURITY" (optional) security information to include in the header segment SEQ 8
"RTN","HLOAPI3",87,0)
 ;;Output:
"RTN","HLOAPI3",88,0)
 ;;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",89,0)
 ;;  ACK (pass by reference, required) The batch, updated with another ack
"RTN","HLOAPI3",90,0)
 ;;  PARMS  - left undefined when this function returns
"RTN","HLOAPI3",91,0)
 ;;  ERROR (pass by reference) error msg
"RTN","HLOAPI3",92,0)
 ;;
"RTN","HLOAPI3",93,0)
 ;
"RTN","HLOAPI3",94,0)
 N SUB,SUCCESS
"RTN","HLOAPI3",95,0)
 S SUCCESS=0
"RTN","HLOAPI3",96,0)
 D
"RTN","HLOAPI3",97,0)
 .I $G(PARMS("ACK CODE"))'="AA",$G(PARMS("ACK CODE"))'="AE",$G(PARMS("ACK CODE"))'="AR" S ERROR="INVALID ACK CODE" Q
"RTN","HLOAPI3",98,0)
 .;
"RTN","HLOAPI3",99,0)
 .I $G(PARMS("MESSAGE CONTROL ID"))="" S ERROR="MESSAGE CONTROL ID MUST EXIST TO RETURN AN APPLICATION ACK" Q
"RTN","HLOAPI3",100,0)
 .S SUB=""
"RTN","HLOAPI3",101,0)
 .F  S SUB=$O(^HLB("AE",PARMS("MESSAGE CONTROL ID"),SUB)) Q:SUB=""  I $P(SUB,"^")=ACK("ACK TO IEN"),$P(SUB,"^",2) S PARMS("ACK TO IEN")=SUB Q
"RTN","HLOAPI3",102,0)
 .S PARMS("MESSAGE TYPE")=$G(PARMS("MESSAGE TYPE"),"ACK")
"RTN","HLOAPI3",103,0)
 .S:PARMS("MESSAGE TYPE")="ACK" PARMS("MESSAGE STRUCTURE")="ACK"
"RTN","HLOAPI3",104,0)
 .S PARMS("EVENT")=$G(PARMS("EVENT"))
"RTN","HLOAPI3",105,0)
 .I PARMS("EVENT")="",ACK("ACK TO","BODY"),$P(SUB,"^",2) S PARMS("EVENT")=$P($G(^HLA(ACK("ACK TO","BODY"),2,$P(SUB,"^",2),0)),"^",3)
"RTN","HLOAPI3",106,0)
 .S PARMS("ACK TO")=PARMS("MESSAGE CONTROL ID")
"RTN","HLOAPI3",107,0)
 .S PARMS("ACK TO","STATUS")=$S(PARMS("ACK CODE")="AA":"SU",1:"ER")
"RTN","HLOAPI3",108,0)
 .Q:'$$ADDMSG^HLOAPI(.ACK,.PARMS,.ERROR)
"RTN","HLOAPI3",109,0)
 .;Next line modified for HL*1.6*138 - RBN
"RTN","HLOAPI3",110,0)
 .;S ACK("MSA")="MSA|"_PARMS("ACK CODE")_"|"_PARMS("MESSAGE CONTROL ID")_"|"_$G(PARMS("ERROR MESSAGE"))
"RTN","HLOAPI3",111,0)
 .S ACK("MSA")="MSA|"_PARMS("ACK CODE")_"|"_PARMS("MESSAGE CONTROL ID")_"|"_$$ESCAPE^HLOPBLD(.ACK,$G(PARMS("ERROR MESSAGE")))
"RTN","HLOAPI3",112,0)
 .S SUCCESS=1
"RTN","HLOAPI3",113,0)
 K PARMS
"RTN","HLOAPI3",114,0)
 Q SUCCESS
"RTN","HLOAPI3",115,0)
 ;
"RTN","HLOAPI3",116,0)
RESEND(MSGIEN,ERROR) ;;  Retransmit message
"RTN","HLOAPI3",117,0)
 ;;This message will re-transmit an out-going message. It copies a copy the message, reusing all the original parameters. Then the message is requeued.
"RTN","HLOAPI3",118,0)
 ;;
"RTN","HLOAPI3",119,0)
 ;;Input:
"RTN","HLOAPI3",120,0)
 ;;  MSGIEN - the ien (file #778) of the message that is to be sent
"RTN","HLOAPI3",121,0)
 ;;Output:
"RTN","HLOAPI3",122,0)
 ;;  Function returns the ien of the message in file 778 on success, 0 on failure
"RTN","HLOAPI3",123,0)
 ;;  ERROR (pass by reference, optional)an error message
"RTN","HLOAPI3",124,0)
 ;;
"RTN","HLOAPI3",125,0)
 N MSG,SUB,HDR
"RTN","HLOAPI3",126,0)
 I '$$STARTMSG^HLOPRS(.MSG,MSGIEN) S ERROR="MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",127,0)
 I MSG("DIRECTION")'="OUT" S ERROR="MESSAGE IS NOT OUTGOING" Q 0
"RTN","HLOAPI3",128,0)
 I MSG("STATUS","LINK NAME")="" S ERROR="LINK NOT DEFINED" Q 0
"RTN","HLOAPI3",129,0)
 I MSG("BATCH") D
"RTN","HLOAPI3",130,0)
 .N MSH
"RTN","HLOAPI3",131,0)
 .D NEXTMSG^HLOPRS(.MSG,.MSH)
"RTN","HLOAPI3",132,0)
 .S MSG("HDR","VERSION")=MSH("VERSION")
"RTN","HLOAPI3",133,0)
 F SUB="ID","IEN","DT/TM","ACK BY","STATUS" S MSG(SUB)=""
"RTN","HLOAPI3",134,0)
 F SUB="PURGE" K MSG("STATUS",SUB)
"RTN","HLOAPI3",135,0)
 D GETSYS^HLOAPI(.MSG)
"RTN","HLOAPI3",136,0)
 I $$SAVEMSG^HLOF778(.MSG) D OUTQUE^HLOQUE(MSG("STATUS","LINK NAME"),$G(MSG("STATUS","PORT")),MSG("STATUS","QUEUE"),MSG("IEN")) Q +MSG("IEN")
"RTN","HLOAPI3",137,0)
 Q 0
"RTN","HLOAPI3",138,0)
 ;
"RTN","HLOAPI3",139,0)
SETPURGE(MSGIEN,TIME) ;;  Set message up for purging.
"RTN","HLOAPI3",140,0)
 ;;Resets the purge date/time.
"RTN","HLOAPI3",141,0)
 ;;Input:
"RTN","HLOAPI3",142,0)
 ;;   MSGIEN (required) ien of the message, file #778
"RTN","HLOAPI3",143,0)
 ;;   TIME (required) dt/time to set the purge time to
"RTN","HLOAPI3",144,0)
 ;;Output:
"RTN","HLOAPI3",145,0)
 ;;   Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",146,0)
 ;;   
"RTN","HLOAPI3",147,0)
 N NODE,OLDTIME,HLDIR,DAYS
"RTN","HLOAPI3",148,0)
 Q:'$G(MSGIEN) 0
"RTN","HLOAPI3",149,0)
 Q:'$G(TIME) 0
"RTN","HLOAPI3",150,0)
 S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOAPI3",151,0)
 Q:NODE="" 0
"RTN","HLOAPI3",152,0)
 S OLDTIME=$P(NODE,"^",9)
"RTN","HLOAPI3",153,0)
 ;
"RTN","HLOAPI3",154,0)
 ;applications may delay the purge, but not purge sooner
"RTN","HLOAPI3",155,0)
 I OLDTIME,OLDTIME>TIME Q 0
"RTN","HLOAPI3",156,0)
 ;
"RTN","HLOAPI3",157,0)
 I OLDTIME D  Q 1
"RTN","HLOAPI3",158,0)
 .S HLDIR=$S($E($P(NODE,"^",4))="I":"IN",1:"OUT")
"RTN","HLOAPI3",159,0)
 .K ^HLB("AD",HLDIR,OLDTIME,MSGIEN)
"RTN","HLOAPI3",160,0)
 .S $P(^HLB(MSGIEN,0),"^",9)=TIME
"RTN","HLOAPI3",161,0)
 .S ^HLB("AD",HLDIR,TIME,MSGIEN)=""
"RTN","HLOAPI3",162,0)
 ;
"RTN","HLOAPI3",163,0)
 ;if the message isn't yet scheduled for purge, use TIME to set the retention time
"RTN","HLOAPI3",164,0)
 S DAYS=$$FMDIFF^XLFDT(TIME,$$NOW^XLFDT,3)+1
"RTN","HLOAPI3",165,0)
 I DAYS>$P(NODE,"^",22) S $P(^HLB(MSGIEN,0),"^",22)=DAYS
"RTN","HLOAPI3",166,0)
 Q 1
"RTN","HLOAPI3",167,0)
 ;
"RTN","HLOAPI3",168,0)
REPROC(MSGIEN,ERROR) ;;  Reprocess message.
"RTN","HLOAPI3",169,0)
 ;;This message will re-process an incoming message by placing it on an incoming queue. If successful the message will be purged.
"RTN","HLOAPI3",170,0)
 ;;
"RTN","HLOAPI3",171,0)
 ;;Input:
"RTN","HLOAPI3",172,0)
 ;;  MSGIEN - the ien (file #778) of the message that is to be processed
"RTN","HLOAPI3",173,0)
 ;;Output:
"RTN","HLOAPI3",174,0)
 ;;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",175,0)
 ;;  ERROR (pass by reference, optional) an error message
"RTN","HLOAPI3",176,0)
 ;;
"RTN","HLOAPI3",177,0)
 N MSG,HDR,ACTION,QUEUE,FROM
"RTN","HLOAPI3",178,0)
 ;
"RTN","HLOAPI3",179,0)
 I '$$STARTMSG^HLOPRS(.MSG,MSGIEN) S ERROR="MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",180,0)
 I MSG("DIRECTION")'="IN" S ERROR="MESSAGE IS NOT INCOMING" Q 0
"RTN","HLOAPI3",181,0)
 M HDR=MSG("HDR")
"RTN","HLOAPI3",182,0)
 ;** START HL*1.6*138 CJM
"RTN","HLOAPI3",183,0)
 ;I $G(MSG("ACK TO"))]"" S ACTION=MSG("STATUS","APP ACK RESPONSE")
"RTN","HLOAPI3",184,0)
 S ACTION=MSG("STATUS","ACTION")
"RTN","HLOAPI3",185,0)
 S QUEUE=MSG("STATUS","QUEUE")
"RTN","HLOAPI3",186,0)
 ;** END HL*1.6*138 CJM
"RTN","HLOAPI3",187,0)
 I ACTION="",'$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE),$G(MSG("ACK TO"))="" S ERROR="RECEIVING APPLICATION NOT DEFINED"
"RTN","HLOAPI3",188,0)
 ;If this message references an earlier message, get the action specified by the original message
"RTN","HLOAPI3",189,0)
 I ACTION="",$G(MSG("ACK TO"))]"" D
"RTN","HLOAPI3",190,0)
 .N NODE,IEN
"RTN","HLOAPI3",191,0)
 .S IEN=$O(^HLB("B",$P(MSG("ACK TO"),"-"),0))
"RTN","HLOAPI3",192,0)
 .S:IEN NODE=$G(^HLB(IEN,0))
"RTN","HLOAPI3",193,0)
 .I ($P(NODE,"^",11)]"") S ACTION=$P(NODE,"^",10,11),QUEUE=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")
"RTN","HLOAPI3",194,0)
 I ACTION="" S ERROR="NO ACTION SPECIFIED FOR RECEIVING APPLICATION" Q 0
"RTN","HLOAPI3",195,0)
 S FROM=$S(MSG("HDR","SENDING FACILITY",2)]"":MSG("HDR","SENDING FACILITY",2),1:MSG("HDR","SENDING FACILITY",1))
"RTN","HLOAPI3",196,0)
 D INQUE^HLOQUE(FROM,QUEUE,MSGIEN,ACTION,1)
"RTN","HLOAPI3",197,0)
 Q 1
"RTN","HLOAPI3",198,0)
 ;
"RTN","HLOAPI3",199,0)
PROCNOW(MSGIEN,PURGE,ERROR) ;;
"RTN","HLOAPI3",200,0)
 ;;This message will re-process an incoming message immediately.
"RTN","HLOAPI3",201,0)
 ;;
"RTN","HLOAPI3",202,0)
 ;;Input:
"RTN","HLOAPI3",203,0)
 ;;  MSGIEN - the ien (file #778) of the message that is to be processed
"RTN","HLOAPI3",204,0)
 ;;Output:
"RTN","HLOAPI3",205,0)
 ;;  Function returns 1 on success, 0 on failure
"RTN","HLOAPI3",206,0)
 ;;  PURGE (optional) a date/time to purge the message
"RTN","HLOAPI3",207,0)
 ;;  ERROR (pass by reference, optional) an error message
"RTN","HLOAPI3",208,0)
 ;;
"RTN","HLOAPI3",209,0)
 N MSG,HDR,ACTION,MCODE,HLMSGIEN
"RTN","HLOAPI3",210,0)
 ;
"RTN","HLOAPI3",211,0)
 S ERROR=""
"RTN","HLOAPI3",212,0)
 I '$$STARTMSG^HLOPRS(.MSG,MSGIEN) S ERROR="MESSAGE NOT FOUND" Q 0
"RTN","HLOAPI3",213,0)
 I MSG("DIRECTION")'="IN" S ERROR="MESSAGE IS NOT INCOMING" Q 0
"RTN","HLOAPI3",214,0)
 M HDR=MSG("HDR")
"RTN","HLOAPI3",215,0)
 ;** START HL*1.6*138 CJM
"RTN","HLOAPI3",216,0)
 ;I $G(MSG("ACK TO"))]"" S ACTION=MSG("STATUS","APP ACK RESPONSE")
"RTN","HLOAPI3",217,0)
 S ACTION=MSG("STATUS","ACTION")
"RTN","HLOAPI3",218,0)
 ;** END HL*1.6*138 CJM
"RTN","HLOAPI3",219,0)
 I ACTION="",'$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE),$G(MSG("ACK TO"))="" S ERROR="RECEIVING APPLICATION NOT DEFINED" Q 0
"RTN","HLOAPI3",220,0)
 ;If this message references an earlier message, get the action specified by the original message
"RTN","HLOAPI3",221,0)
 I $G(ACTION)="",$G(MSG("ACK TO IEN")) S ACTION=$P($G(^HLB(+MSG("ACK TO IEN"),0)),"^",10,11) I $P(ACTION,"^",2)="" S ERROR="ACTION SPECIFIED BY ORIGINAL APPLICATION NOT FOUND" Q 0
"RTN","HLOAPI3",222,0)
 I $P(ACTION,"^",2)="" S ERROR="ACTION SPECIFIED BY APPLICATION NOT FOUND" Q 0
"RTN","HLOAPI3",223,0)
 D:$G(PURGE)
"RTN","HLOAPI3",224,0)
 .K:MSG("STATUS","PURGE") ^HLB("AD","IN",MSG("STATUS","PURGE"),MSGIEN)
"RTN","HLOAPI3",225,0)
 .S $P(^HLB(MSGIEN,0),"^",9)=PURGE
"RTN","HLOAPI3",226,0)
 .S ^HLB("AD","IN",PURGE,MSGIEN)=""
"RTN","HLOAPI3",227,0)
 .I $G(MSG("ACK TO IEN")),$D(^HLB(MSG("ACK TO IEN"),0)) K ^HLB("AD","OUT",MSG("STATUS","PURGE"),MSG("ACK TO IEN")) S $P(^HLB(MSG("ACK TO IEN"),0),"^",9)=PURGE,^HLB("AD","OUT",PURGE,MSG("ACK TO IEN"))=""
"RTN","HLOAPI3",228,0)
 S HLMSGIEN=MSGIEN
"RTN","HLOAPI3",229,0)
 S $P(^HLB(MSGIEN,0),"^",19)=1
"RTN","HLOAPI3",230,0)
 S MCODE="D "_ACTION
"RTN","HLOAPI3",231,0)
 X MCODE
"RTN","HLOAPI3",232,0)
 Q 1
"RTN","HLOAPI3",233,0)
 ;
"RTN","HLOAPI3",234,0)
 ;
"RTN","HLOAPI3",235,0)
 ;
"RTN","HLOAPI3",236,0)
 ;
"RTN","HLOAPI3",237,0)
 ;
"RTN","HLOAPI3",238,0)
 ;
"RTN","HLOAPI3",239,0)
 ;
"RTN","HLOAPP")
0^24^B19865517^B13112019
"RTN","HLOAPP",1,0)
HLOAPP ;ALB/CJM-HL7 -Application Registry ;02/23/2012
"RTN","HLOAPP",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132,137,139,158**;Oct 13, 1995;Build 14
"RTN","HLOAPP",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOAPP",4,0)
 ;
"RTN","HLOAPP",5,0)
GETIEN(NAME) ;given the application name, it finds the ien.  Returns 0 on failure
"RTN","HLOAPP",6,0)
 Q:'$L($G(NAME)) 0
"RTN","HLOAPP",7,0)
 Q +$O(^HLD(779.2,"C",$E(NAME,1,60),0))
"RTN","HLOAPP",8,0)
 ;
"RTN","HLOAPP",9,0)
ACTION(HEADER,ACTION,QUEUE) ;Given the parsed header of a message it returns both the action that should be performed in response to the message and the incoming queue that it should be placed on.
"RTN","HLOAPP",10,0)
 ;
"RTN","HLOAPP",11,0)
 ;** do not implement the Pass Immediate parameter **
"RTN","HLOAPP",12,0)
 ;ACTION(HEADER,ACTION,QUEUE,IMMEDIATE);Given the parsed header of a message it returns both the action that should be performed in response to the message and the incoming queue that it should be placed on.
"RTN","HLOAPP",13,0)
 ;
"RTN","HLOAPP",14,0)
 ;Input:
"RTN","HLOAPP",15,0)
 ;  HEADER() subscripts are used: "RECEIVING APPLICATION","SEGMENT TYPE", "MESSAGE TYPE", "EVENT", "VERSION"
"RTN","HLOAPP",16,0)
 ;Output:
"RTN","HLOAPP",17,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOAPP",18,0)
 ;  ACTION (pass by reference) <tag>^<rtn>
"RTN","HLOAPP",19,0)
 ;  QUEUE (pass by reference) returns the named queue if there is one, else "DEFAULT"
"RTN","HLOAPP",20,0)
 ;
"RTN","HLOAPP",21,0)
 ;** do not implement the Pass Immediate parameter **
"RTN","HLOAPP",22,0)
 ;  IMMEDIATE (pass by reference, optional) returns 1 if the application wants its messages passed to the incoming queue immediately, 0 otherwise
"RTN","HLOAPP",23,0)
 ;
"RTN","HLOAPP",24,0)
 N IEN
"RTN","HLOAPP",25,0)
 S (ACTION,QUEUE)=""
"RTN","HLOAPP",26,0)
 S IEN=$$GETIEN(HEADER("RECEIVING APPLICATION"))
"RTN","HLOAPP",27,0)
 Q:'$G(IEN) 0
"RTN","HLOAPP",28,0)
 I $G(HEADER("SEGMENT TYPE"))="BHS" D
"RTN","HLOAPP",29,0)
 .S NODE=$G(^HLD(779.2,IEN,0))
"RTN","HLOAPP",30,0)
 .I $P(NODE,"^",5)]"" D
"RTN","HLOAPP",31,0)
 ..S ACTION=$P(NODE,"^",4,5)
"RTN","HLOAPP",32,0)
 .E  I $P(NODE,"^",7)]"" S ACTION=$P(NODE,"^",6,7)
"RTN","HLOAPP",33,0)
 .I $P(NODE,"^",8)]"" D
"RTN","HLOAPP",34,0)
 ..S QUEUE=$P(NODE,"^",8)
"RTN","HLOAPP",35,0)
 .E  I $P(NODE,"^",3)]"" S QUEUE=$P(NODE,"^",3)
"RTN","HLOAPP",36,0)
 E  I HEADER("SEGMENT TYPE")="MSH" D
"RTN","HLOAPP",37,0)
 .I HEADER("MESSAGE TYPE")'="",HEADER("EVENT")'="" D
"RTN","HLOAPP",38,0)
 ..N SUBIEN,NODE
"RTN","HLOAPP",39,0)
 ..;did the application specify an action for the particular version of this message?
"RTN","HLOAPP",40,0)
 ..I HEADER("VERSION")'="" S SUBIEN=$O(^HLD(779.2,IEN,1,"D",HEADER("MESSAGE TYPE"),HEADER("EVENT"),HEADER("VERSION"),0))
"RTN","HLOAPP",41,0)
 ..;if not, look on the "C" index
"RTN","HLOAPP",42,0)
 ..S:'$G(SUBIEN) SUBIEN=$O(^HLD(779.2,IEN,1,"C",HEADER("MESSAGE TYPE"),HEADER("EVENT"),0))
"RTN","HLOAPP",43,0)
 ..;
"RTN","HLOAPP",44,0)
 ..I SUBIEN D
"RTN","HLOAPP",45,0)
 ...S NODE=$G(^HLD(779.2,IEN,1,SUBIEN,0))
"RTN","HLOAPP",46,0)
 ...I $P(NODE,"^",5)]"" S ACTION=$P(NODE,"^",4,5)
"RTN","HLOAPP",47,0)
 ...I $P(NODE,"^",3)]"" S QUEUE=$P(NODE,"^",3)
"RTN","HLOAPP",48,0)
 ...;
"RTN","HLOAPP",49,0)
 ...;** do not implement the Pass ImMediate parameter **
"RTN","HLOAPP",50,0)
 ...;S IMMEDIATE=$P(NODE,"^",8)
"RTN","HLOAPP",51,0)
 ...;
"RTN","HLOAPP",52,0)
 ..I ACTION="" S NODE=$G(^HLD(779.2,IEN,0)) I $P(NODE,"^",7)]"" S ACTION=$P(NODE,"^",6,7)
"RTN","HLOAPP",53,0)
 ..I QUEUE="" S NODE=$G(^HLD(779.2,IEN,0)) I $P(NODE,"^",3)]"" S QUEUE=$P(NODE,"^",3)
"RTN","HLOAPP",54,0)
 I QUEUE="" S QUEUE="DEFAULT"
"RTN","HLOAPP",55,0)
 ;
"RTN","HLOAPP",56,0)
 ;** do not implement the Pass Immediate parameter **
"RTN","HLOAPP",57,0)
 ;I $G(IMMEDIATE)'=1 S IMMEDIATE=0
"RTN","HLOAPP",58,0)
 ;
"RTN","HLOAPP",59,0)
 I ACTION="" Q 0
"RTN","HLOAPP",60,0)
 Q 1
"RTN","HLOAPP",61,0)
 ;
"RTN","HLOAPP",62,0)
RTRNLNK(APPNAME) ;
"RTN","HLOAPP",63,0)
 ;given the name of a receiving application, this returns the return
"RTN","HLOAPP",64,0)
 ;link for application acks if one is provided.  Otherwise, return
"RTN","HLOAPP",65,0)
 ;acks are routed based on the information provide in the message hdr
"RTN","HLOAPP",66,0)
 ;
"RTN","HLOAPP",67,0)
 Q:(APPNAME="") ""
"RTN","HLOAPP",68,0)
 N IEN
"RTN","HLOAPP",69,0)
 S IEN=$$GETIEN(APPNAME)
"RTN","HLOAPP",70,0)
 Q:IEN $P($G(^HLD(779.2,IEN,0)),"^",2)
"RTN","HLOAPP",71,0)
 Q ""
"RTN","HLOAPP",72,0)
 ;
"RTN","HLOAPP",73,0)
RTRNPORT(APPNAME) ;
"RTN","HLOAPP",74,0)
 ;Given the name of the sending application, IF the application has its
"RTN","HLOAPP",75,0)
 ;own listener, its port # is returned.  Application acks should be
"RTN","HLOAPP",76,0)
 ;returned using that port
"RTN","HLOAPP",77,0)
 Q:(APPNAME="") ""
"RTN","HLOAPP",78,0)
 N IEN,LINK
"RTN","HLOAPP",79,0)
 S IEN=$$GETIEN(APPNAME)
"RTN","HLOAPP",80,0)
 Q:'IEN ""
"RTN","HLOAPP",81,0)
 S LINK=$P($G(^HLD(779.2,IEN,0)),"^",9)
"RTN","HLOAPP",82,0)
 Q:'LINK ""
"RTN","HLOAPP",83,0)
 Q $$PORT^HLOTLNK(LINK)
"RTN","HLOAPP",84,0)
 ;
"RTN","HLOAPP",85,0)
ACTIVE(APP,MSGTYPE,EVENT,VERSION) ;
"RTN","HLOAPP",86,0)
 ;Returns 1 if the message's INACTIVE flag has NOT been set.
"RTN","HLOAPP",87,0)
 ;
"RTN","HLOAPP",88,0)
 ;Input:
"RTN","HLOAPP",89,0)
 ;  APP (required) the name of the sending application
"RTN","HLOAPP",90,0)
 ;  MSGTYPE (required) 3 character HL7 message type
"RTN","HLOAPP",91,0)
 ;  EVENT (required) 3 character HL7 event
"RTN","HLOAPP",92,0)
 ;  VERSION (optional) HL7 version ID as it appears in the message header
"RTN","HLOAPP",93,0)
 ;Output:
"RTN","HLOAPP",94,0)
 ;  Function returns 1 if the message type specified by the input parameters has not been set to INACTIVE.  It returns 0 otherwise.
"RTN","HLOAPP",95,0)
 ;
"RTN","HLOAPP",96,0)
 N IEN,ACTIVE,SUBIEN
"RTN","HLOAPP",97,0)
 S ACTIVE=1
"RTN","HLOAPP",98,0)
 S IEN=$$GETIEN($G(APP))
"RTN","HLOAPP",99,0)
 Q:'$G(IEN) ACTIVE
"RTN","HLOAPP",100,0)
 Q:$G(MSGTYPE)="" ACTIVE
"RTN","HLOAPP",101,0)
 Q:$G(EVENT)="" ACTIVE
"RTN","HLOAPP",102,0)
 ;did the application specify an action for the particular version of this message?
"RTN","HLOAPP",103,0)
 I $G(VERSION)'="" S SUBIEN=$O(^HLD(779.2,IEN,1,"D",MSGTYPE,EVENT,VERSION,0))
"RTN","HLOAPP",104,0)
 ;if not, look on the "C" index
"RTN","HLOAPP",105,0)
 S:'$G(SUBIEN) SUBIEN=$O(^HLD(779.2,IEN,1,"C",MSGTYPE,EVENT,0))
"RTN","HLOAPP",106,0)
 ;
"RTN","HLOAPP",107,0)
 S:SUBIEN ACTIVE='(+$P($G(^HLD(779.2,IEN,1,SUBIEN,0)),"^",7))
"RTN","HLOAPP",108,0)
 Q ACTIVE
"RTN","HLOAPP",109,0)
 ;
"RTN","HLOAPP",110,0)
EXCEPT(APPNAME) ;
"RTN","HLOAPP",111,0)
 ;returns the exception handler (tag^routine) that should be invoked
"RTN","HLOAPP",112,0)
 ;when an applicaiton's messages are being sequenced and an app ack
"RTN","HLOAPP",113,0)
 ;is not timely received
"RTN","HLOAPP",114,0)
 ;
"RTN","HLOAPP",115,0)
 N IEN,RTN
"RTN","HLOAPP",116,0)
 S IEN=$$GETIEN($G(APPNAME))
"RTN","HLOAPP",117,0)
 I IEN S RTN=$P($G(^HLD(779.2,IEN,0)),"^",10,11)
"RTN","HLOAPP",118,0)
 I $L($G(RTN))>1 Q RTN
"RTN","HLOAPP",119,0)
 Q "DEFAULT^HLOAPP"
"RTN","HLOAPP",120,0)
 ;
"RTN","HLOAPP",121,0)
DEFAULT ;default exception handler if the app doesn't specify one
"RTN","HLOAPP",122,0)
 S ^TMP("HLO SEQUENCING EXCEPTION",$J,$$NOW^XLFDT,+$G(HLMSGIEN))=""
"RTN","HLOAPP",123,0)
 Q
"RTN","HLOAPP",124,0)
 ;
"RTN","HLOAPP",125,0)
TIMEOUT(APPNAME) ;
"RTN","HLOAPP",126,0)
 N IEN,TIME
"RTN","HLOAPP",127,0)
 S IEN=$$GETIEN($G(APPNAME))
"RTN","HLOAPP",128,0)
 I IEN S TIME=$P($G(^HLD(779.2,IEN,0)),"^",12)
"RTN","HLOAPP",129,0)
 Q:'$G(TIME) 10
"RTN","HLOAPP",130,0)
 Q TIME
"RTN","HLOAPP",131,0)
 ;
"RTN","HLOAPP",132,0)
RTNTN(APP,MSGTYPE,EVENT,VERSION) ;
"RTN","HLOAPP",133,0)
 ;Returns the retention time for this message, if specified.
"RTN","HLOAPP",134,0)
 ;
"RTN","HLOAPP",135,0)
 ;Input:
"RTN","HLOAPP",136,0)
 ;  APP (required) the name of the sending application
"RTN","HLOAPP",137,0)
 ;  MSGTYPE (required) 3 character HL7 message type
"RTN","HLOAPP",138,0)
 ;  EVENT (required) 3 character HL7 event
"RTN","HLOAPP",139,0)
 ;  VERSION (optional) HL7 version ID as it appears in the message header
"RTN","HLOAPP",140,0)
 ;Output:
"RTN","HLOAPP",141,0)
 ;  Function returns retention time if spcified, 0 otherwise
"RTN","HLOAPP",142,0)
 ;
"RTN","HLOAPP",143,0)
 N IEN,RET,SUBIEN
"RTN","HLOAPP",144,0)
 S RET=0
"RTN","HLOAPP",145,0)
 S IEN=$$GETIEN($G(APP))
"RTN","HLOAPP",146,0)
 Q:'$G(IEN) RET
"RTN","HLOAPP",147,0)
 I $L($G(MSGTYPE)),$L($G(EVENT)) D
"RTN","HLOAPP",148,0)
 .;did the application specify an action for the particular version of this message?
"RTN","HLOAPP",149,0)
 .I $G(VERSION)'="" S SUBIEN=$O(^HLD(779.2,IEN,1,"D",MSGTYPE,EVENT,VERSION,0)) I SUBIEN S RET=$P($G(^HLD(779.2,IEN,1,SUBIEN,0)),"^",8)
"RTN","HLOAPP",150,0)
 .;if not, look on the "C" index
"RTN","HLOAPP",151,0)
 .S:'RET SUBIEN=$O(^HLD(779.2,IEN,1,"C",MSGTYPE,EVENT,0)) I SUBIEN S RET=$P($G(^HLD(779.2,IEN,1,SUBIEN,0)),"^",8)
"RTN","HLOAPP",152,0)
 ;
"RTN","HLOAPP",153,0)
 S:'RET RET=+$P($G(^HLD(779.2,IEN,0)),"^",13)
"RTN","HLOAPP",154,0)
 Q RET
"RTN","HLOAPP",155,0)
 ;
"RTN","HLOAPP",156,0)
 ;
"RTN","HLOAPP",157,0)
 ;
"RTN","HLOAPP",158,0)
 ;
"RTN","HLOAPP",159,0)
 ;
"RTN","HLOAPP",160,0)
 ;
"RTN","HLOASUB1")
0^25^B94636014^B91573157
"RTN","HLOASUB1",1,0)
HLOASUB1 ;IRMFO-ALB/CJM/RBN - Subscription Registry (continued) ;07/12/2012
"RTN","HLOASUB1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,138,146,147,158**;Oct 13, 1995;Build 14
"RTN","HLOASUB1",3,0)
 ;Per VHA Directive 10-93-142, this routine should not be modified.
"RTN","HLOASUB1",4,0)
 ;
"RTN","HLOASUB1",5,0)
INDEX(IEN,PARMARY) ;
"RTN","HLOASUB1",6,0)
 ;Allows an application to optionally index its subscriptions.
"RTN","HLOASUB1",7,0)
 ;so that it can find find them without storing the ien.
"RTN","HLOASUB1",8,0)
 ;
"RTN","HLOASUB1",9,0)
 ;Input:
"RTN","HLOASUB1",10,0)
 ;  IEN - ien of the entry
"RTN","HLOASUB1",11,0)
 ;  PARMARY (pass by reference) An array of up to 6 lookup values with
"RTN","HLOASUB1",12,0)
 ;which to build the index.  The format is: PARMARY(1)=<first parameter>,
"RTN","HLOASUB1",13,0)
 ; up to PARMARY(6)
"RTN","HLOASUB1",14,0)
 ;Output:
"RTN","HLOASUB1",15,0)
 ;  function returns 1 on success, 0 otherwise
"RTN","HLOASUB1",16,0)
 ;  PARMARY - left undefined
"RTN","HLOASUB1",17,0)
 ;
"RTN","HLOASUB1",18,0)
 N OWNER,I,NODE
"RTN","HLOASUB1",19,0)
 Q:'$G(IEN) 0
"RTN","HLOASUB1",20,0)
 S OWNER=$P($G(^HLD(779.4,IEN,0)),"^",2)
"RTN","HLOASUB1",21,0)
 Q:'$L(OWNER) 0
"RTN","HLOASUB1",22,0)
 D KILLAH(IEN)
"RTN","HLOASUB1",23,0)
 F I=1:1:6 S:'$L($G(PARMARY(I))) PARMARY(I)=" "
"RTN","HLOASUB1",24,0)
 D SETAH(IEN,OWNER,.PARMARY)
"RTN","HLOASUB1",25,0)
 S NODE=""
"RTN","HLOASUB1",26,0)
 F I=1:1:6 S NODE=NODE_$G(PARMARY(I))_"^"
"RTN","HLOASUB1",27,0)
 S ^HLD(779.4,IEN,3)=NODE
"RTN","HLOASUB1",28,0)
 K PARMARY
"RTN","HLOASUB1",29,0)
 Q 1
"RTN","HLOASUB1",30,0)
 ;
"RTN","HLOASUB1",31,0)
SETAH(IEN,OWNER,PARMS) ;
"RTN","HLOASUB1",32,0)
 Q:'$G(IEN)
"RTN","HLOASUB1",33,0)
 Q:'$L($G(OWNER))
"RTN","HLOASUB1",34,0)
 N INDEX
"RTN","HLOASUB1",35,0)
 S INDEX="^HLD(779.4,""AH"",OWNER,"
"RTN","HLOASUB1",36,0)
 F I=1:1:6 D
"RTN","HLOASUB1",37,0)
 .S:'$L($G(PARMS(I))) PARMS(I)=" "
"RTN","HLOASUB1",38,0)
 .S INDEX=INDEX_""""_PARMS(I)_""","
"RTN","HLOASUB1",39,0)
 S INDEX=$E(INDEX,1,$L(INDEX)-1)_")"
"RTN","HLOASUB1",40,0)
 S @INDEX=IEN
"RTN","HLOASUB1",41,0)
 Q
"RTN","HLOASUB1",42,0)
 ;
"RTN","HLOASUB1",43,0)
SETAH1(DA,OWNER,X1,X2,X3,X4,X5,X6) ;
"RTN","HLOASUB1",44,0)
 Q:'$G(DA)
"RTN","HLOASUB1",45,0)
 Q:'$L($G(OWNER))
"RTN","HLOASUB1",46,0)
 N PARMS,I
"RTN","HLOASUB1",47,0)
 F I=1:1:6 I $L($G(@("X"_I))) S PARMS(I)=@("X"_I)
"RTN","HLOASUB1",48,0)
 D SETAH(DA,OWNER,.PARMS)
"RTN","HLOASUB1",49,0)
 Q
"RTN","HLOASUB1",50,0)
 ;
"RTN","HLOASUB1",51,0)
KILLAH1(OWNER,LOOKUP1,LOOKUP2,LOOKUP3,LOOKUP4,LOOKUP5,LOOKUP6) ;
"RTN","HLOASUB1",52,0)
 Q:'$L(OWNER)
"RTN","HLOASUB1",53,0)
 N I,INDEX
"RTN","HLOASUB1",54,0)
 S INDEX="^HLD(779.4,""AH"",OWNER"
"RTN","HLOASUB1",55,0)
 F I=1:1:6 D
"RTN","HLOASUB1",56,0)
 .S:'$L($G(@("LOOKUP"_I))) @("LOOKUP"_I)=" "
"RTN","HLOASUB1",57,0)
 .S INDEX=INDEX_","_""""_@("LOOKUP"_I)_""""
"RTN","HLOASUB1",58,0)
 S INDEX=INDEX_")"
"RTN","HLOASUB1",59,0)
 K @INDEX
"RTN","HLOASUB1",60,0)
 Q
"RTN","HLOASUB1",61,0)
 ;
"RTN","HLOASUB1",62,0)
KILLAH(IEN) ;kills the AH x~ref on file 779.4 for a particular subscription registry entry=ien
"RTN","HLOASUB1",63,0)
 Q:'$G(IEN)
"RTN","HLOASUB1",64,0)
 N OWNER,X1,X2,X3,X4,X5,X6,I,NODE
"RTN","HLOASUB1",65,0)
 S OWNER=$P($G(^HLD(779.4,IEN,0)),"^",2)
"RTN","HLOASUB1",66,0)
 Q:'$L(OWNER)
"RTN","HLOASUB1",67,0)
 S NODE=$G(^HLD(779.4,IEN,3))
"RTN","HLOASUB1",68,0)
 F I=1:1:6 I $L($P(NODE,"^",I)) S @("X"_I)=$P(NODE,"^",I)
"RTN","HLOASUB1",69,0)
 D KILLAH1(OWNER,.X1,.X2,.X3,.X4,.X5,.X6)
"RTN","HLOASUB1",70,0)
 Q
"RTN","HLOASUB1",71,0)
 ;
"RTN","HLOASUB1",72,0)
FIND(OWNER,PARMARY) ;
"RTN","HLOASUB1",73,0)
 ;Allows an application to find a subscription
"RTN","HLOASUB1",74,0)
 ;list.  The application must maintain a private index in order to
"RTN","HLOASUB1",75,0)
 ;utilize this function, via $$INDEX^HLOASUB()
"RTN","HLOASUB1",76,0)
 ;
"RTN","HLOASUB1",77,0)
 ;Input:
"RTN","HLOASUB1",78,0)
 ;  OWNER - owning application name
"RTN","HLOASUB1",79,0)
 ;  PARMARY  **pass by reference** an array of up to 6 lookup value with which the index was built.  The format is: PARMARY(1)=<first parameter>, PARMARY(2)=<second parameter>  If PARMARY(i)=null, the parameter will be ignored
"RTN","HLOASUB1",80,0)
 ;Output:
"RTN","HLOASUB1",81,0)
 ;  function returns the ien of the subscription list if found, 0 otherwise
"RTN","HLOASUB1",82,0)
 ; PARMARY - left undefined
"RTN","HLOASUB1",83,0)
 ;
"RTN","HLOASUB1",84,0)
 N OK S OK=0
"RTN","HLOASUB1",85,0)
 ;
"RTN","HLOASUB1",86,0)
 D
"RTN","HLOASUB1",87,0)
 .Q:'$D(PARMARY)
"RTN","HLOASUB1",88,0)
 .Q:'$L($G(OWNER))
"RTN","HLOASUB1",89,0)
 .N INDEX,I
"RTN","HLOASUB1",90,0)
 .S INDEX="^HLD(779.4,""AH"",OWNER"
"RTN","HLOASUB1",91,0)
 .F I=1:1:6 D
"RTN","HLOASUB1",92,0)
 ..S:'$L($G(PARMARY(I))) PARMARY(I)=" "
"RTN","HLOASUB1",93,0)
 ..S INDEX=INDEX_","_""""_PARMARY(I)_""""
"RTN","HLOASUB1",94,0)
 .S INDEX=INDEX_")"
"RTN","HLOASUB1",95,0)
 .S OK=+$G(@INDEX)
"RTN","HLOASUB1",96,0)
 K PARMARY
"RTN","HLOASUB1",97,0)
 Q OK
"RTN","HLOASUB1",98,0)
 ;
"RTN","HLOASUB1",99,0)
UPD(FILE,DA,DATA,ERROR) ;File data into an existing record.
"RTN","HLOASUB1",100,0)
 ; Input:
"RTN","HLOASUB1",101,0)
 ;   FILE - File or sub-file number
"RTN","HLOASUB1",102,0)
 ;   DA - Traditional DA array, with same meaning.
"RTN","HLOASUB1",103,0)
 ;            Pass by reference.
"RTN","HLOASUB1",104,0)
 ;   DATA - Data array to file (pass by reference)
"RTN","HLOASUB1",105,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","HLOASUB1",106,0)
 ;
"RTN","HLOASUB1",107,0)
 ; Output:
"RTN","HLOASUB1",108,0)
 ;  Function Value -     0=error and 1=no error
"RTN","HLOASUB1",109,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLOASUB1",110,0)
 ;
"RTN","HLOASUB1",111,0)
 ; Example: To update a record in subfile 2.0361 in record with ien=353,
"RTN","HLOASUB1",112,0)
 ;          subrecord ien=68, with the field .01 value = 21:
"RTN","HLOASUB1",113,0)
 ;    S DATA(.01)=21,DA=68,DA(1)=353 I $$UPD(2.0361,.DA,.DATA,.ERROR) W !,"DONE"
"RTN","HLOASUB1",114,0)
 ;
"RTN","HLOASUB1",115,0)
 N FDA,FIELD,IENS,ERRORS
"RTN","HLOASUB1",116,0)
 ;
"RTN","HLOASUB1",117,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","HLOASUB1",118,0)
 ;FDA - the FDA array as defined by FM
"RTN","HLOASUB1",119,0)
 ;
"RTN","HLOASUB1",120,0)
 I '$G(DA) S ERROR="IEN OF RECORD TO BE UPDATED NOT SPECIFIED" Q 0
"RTN","HLOASUB1",121,0)
 S IENS=$$IENS^DILF(.DA)
"RTN","HLOASUB1",122,0)
 S FIELD=0
"RTN","HLOASUB1",123,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","HLOASUB1",124,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","HLOASUB1",125,0)
 D FILE^DIE("","FDA","ERRORS(1)")
"RTN","HLOASUB1",126,0)
 I +$G(DIERR) D
"RTN","HLOASUB1",127,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","HLOASUB1",128,0)
 E  D
"RTN","HLOASUB1",129,0)
 .S ERROR=""
"RTN","HLOASUB1",130,0)
 ;
"RTN","HLOASUB1",131,0)
 D CLEAN^DILF
"RTN","HLOASUB1",132,0)
 Q $S(+$G(DIERR):0,1:1)
"RTN","HLOASUB1",133,0)
 ;
"RTN","HLOASUB1",134,0)
ADD(FILE,DA,DATA,ERROR,IEN) ;
"RTN","HLOASUB1",135,0)
 ;Description: Creates a new record and files the data.
"RTN","HLOASUB1",136,0)
 ; Input:
"RTN","HLOASUB1",137,0)
 ;   FILE - File or sub-file number
"RTN","HLOASUB1",138,0)
 ;   DA - Traditional FileMan DA array with same
"RTN","HLOASUB1",139,0)
 ;            meaning. Pass by reference.  Only needed if adding to a
"RTN","HLOASUB1",140,0)
 ;            subfile.
"RTN","HLOASUB1",141,0)
 ;   DATA - Data array to file, pass by reference
"RTN","HLOASUB1",142,0)
 ;          Format: DATA(<field #>)=<value>
"RTN","HLOASUB1",143,0)
 ;   IEN - internal entry number to use (optional)
"RTN","HLOASUB1",144,0)
 ;
"RTN","HLOASUB1",145,0)
 ; Output:
"RTN","HLOASUB1",146,0)
 ;   Function Value - If no error then it returns the ien of the created record, else returns NULL.
"RTN","HLOASUB1",147,0)
 ;  DA - returns the ien of the new record, NULL if none created.  If needed, pass by reference.
"RTN","HLOASUB1",148,0)
 ;  ERROR - optional error message - if needed, pass by reference
"RTN","HLOASUB1",149,0)
 ;
"RTN","HLOASUB1",150,0)
 ; Example: To add a record in subfile 2.0361 in the record with ien=353
"RTN","HLOASUB1",151,0)
 ;          with the field .01 value = 21:
"RTN","HLOASUB1",152,0)
 ;  S DATA(.01)=21,DA(1)=353 I $$ADD(2.0361,.DA,.DATA) W !,"DONE"
"RTN","HLOASUB1",153,0)
 ;
"RTN","HLOASUB1",154,0)
 ; Example: If creating a record not in a subfile, would look like this:
"RTN","HLOASUB1",155,0)
 ;          S DATA(.01)=21 I $$ADD(867,,.DATA) W !,"DONE"
"RTN","HLOASUB1",156,0)
 ;
"RTN","HLOASUB1",157,0)
 N FDA,FIELD,IENA,IENS,ERRORS
"RTN","HLOASUB1",158,0)
 ;
"RTN","HLOASUB1",159,0)
 ;IENS - Internal Entry Number String defined by FM
"RTN","HLOASUB1",160,0)
 ;IENA - the Internal Entry Number Array defined by FM
"RTN","HLOASUB1",161,0)
 ;FDA - the FDA array defined by FM
"RTN","HLOASUB1",162,0)
 ;IEN - the ien of the new record
"RTN","HLOASUB1",163,0)
 ;
"RTN","HLOASUB1",164,0)
 S DA="+1"
"RTN","HLOASUB1",165,0)
 S IENS=$$IENS^DILF(.DA)
"RTN","HLOASUB1",166,0)
 S FIELD=0
"RTN","HLOASUB1",167,0)
 F  S FIELD=$O(DATA(FIELD)) Q:'FIELD  D
"RTN","HLOASUB1",168,0)
 .S FDA(FILE,IENS,FIELD)=$G(DATA(FIELD))
"RTN","HLOASUB1",169,0)
 I $G(IEN) S IENA(1)=IEN
"RTN","HLOASUB1",170,0)
 D UPDATE^DIE("","FDA","IENA","ERRORS(1)")
"RTN","HLOASUB1",171,0)
 I +$G(DIERR) D
"RTN","HLOASUB1",172,0)
 .S ERROR=$G(ERRORS(1,"DIERR",1,"TEXT",1))
"RTN","HLOASUB1",173,0)
 .S IEN=""
"RTN","HLOASUB1",174,0)
 E  D
"RTN","HLOASUB1",175,0)
 .S IEN=IENA(1)
"RTN","HLOASUB1",176,0)
 .S ERROR=""
"RTN","HLOASUB1",177,0)
 D CLEAN^DILF
"RTN","HLOASUB1",178,0)
 S DA=IEN
"RTN","HLOASUB1",179,0)
 Q IEN
"RTN","HLOASUB1",180,0)
 ;
"RTN","HLOASUB1",181,0)
DELETE(FILE,DA,ERROR)   ;Delete an existing record.
"RTN","HLOASUB1",182,0)
 N DATA
"RTN","HLOASUB1",183,0)
 S DATA(.01)="@"
"RTN","HLOASUB1",184,0)
 Q $$UPD(FILE,.DA,.DATA,.ERROR)
"RTN","HLOASUB1",185,0)
 Q
"RTN","HLOASUB1",186,0)
 ;
"RTN","HLOASUB1",187,0)
STATNUM(IEN) ;
"RTN","HLOASUB1",188,0)
 ;Description:  Given an ien to the Institution file, returns as the function value the station number. If IEN is NOT passed in, it assumes the local site.  Returns "" on failure.
"RTN","HLOASUB1",189,0)
 ;
"RTN","HLOASUB1",190,0)
 N STATION,RETURN
"RTN","HLOASUB1",191,0)
 S RETURN=""
"RTN","HLOASUB1",192,0)
 I $G(IEN) D
"RTN","HLOASUB1",193,0)
 .Q:'$D(^DIC(4,IEN,0))
"RTN","HLOASUB1",194,0)
 .S STATION=$P($$NNT^XUAF4(IEN),"^",2)
"RTN","HLOASUB1",195,0)
 .S RETURN=$S(+STATION:STATION,1:"")
"RTN","HLOASUB1",196,0)
 E  D
"RTN","HLOASUB1",197,0)
 .S RETURN=$P($$SITE^VASITE(),"^",3)
"RTN","HLOASUB1",198,0)
 Q RETURN
"RTN","HLOASUB1",199,0)
 ;
"RTN","HLOASUB1",200,0)
CHECKWHO(WHO,PARMS,ERROR) ;
"RTN","HLOASUB1",201,0)
 ;Checks the parameters provided in WHO() (see $$ADD).  They must resolve
"RTN","HLOASUB1",202,0)
 ;the link, receiving app and receiving facility.
"RTN","HLOASUB1",203,0)
 ;INPUT:
"RTN","HLOASUB1",204,0)
 ;  WHO - (required, pass by reference) - see $$ADD.
"RTN","HLOASUB1",205,0)
 ;
"RTN","HLOASUB1",206,0)
 ;  WHO("PORT") - if this is valued, it will be used as the remote port
"RTN","HLOASUB1",207,0)
 ;    to connect with rather than the port associated with the link
"RTN","HLOASUB1",208,0)
 ;Output:
"RTN","HLOASUB1",209,0)
 ;  Function returns 1 if the input is resolved successfully, 0 otherwise
"RTN","HLOASUB1",210,0)
 ;    PARMS - (pass by reference)  These subscripts are returned:
"RTN","HLOASUB1",211,0)
 ;     "LINK IEN" - ien of the link overwhich to transmit (could be middleware)
"RTN","HLOASUB1",212,0)
 ;     "LINK NAME" - name of the link
"RTN","HLOASUB1",213,0)
 ;     "LINK PORT" - port #
"RTN","HLOASUB1",214,0)
 ;     "RECEIVING APPLICATION"  - name of the receiving app
"RTN","HLOASUB1",215,0)
 ;     "RECEIVING FACILITY",1)  - component 1
"RTN","HLOASUB1",216,0)
 ;     "RECEIVING FACILITY",2) - component 2
"RTN","HLOASUB1",217,0)
 ;     "RECEIVING FACILITY",3) - component 3
"RTN","HLOASUB1",218,0)
 ;     "RECEIVING FACILITY","LINK IEN") - ien of facility
"RTN","HLOASUB1",219,0)
 ;   ERROR - (pass by reference) - if unsuccessful, an error message is returned.
"RTN","HLOASUB1",220,0)
 ;
"RTN","HLOASUB1",221,0)
 N OK
"RTN","HLOASUB1",222,0)
 K ERROR
"RTN","HLOASUB1",223,0)
 S OK=1
"RTN","HLOASUB1",224,0)
 S PARMS("LINK IEN")="",PARMS("LINK NAME")=""
"RTN","HLOASUB1",225,0)
 ;must identify the receiving app
"RTN","HLOASUB1",226,0)
 ;
"RTN","HLOASUB1",227,0)
 D
"RTN","HLOASUB1",228,0)
 .N LEN
"RTN","HLOASUB1",229,0)
 .S LEN=$L($G(WHO("RECEIVING APPLICATION")))
"RTN","HLOASUB1",230,0)
 .I 'LEN S OK=0
"RTN","HLOASUB1",231,0)
 .E  I LEN>60 S OK=0
"RTN","HLOASUB1",232,0)
 .S:'OK ERROR="RECEIVING APPLICATION NOT VALID"
"RTN","HLOASUB1",233,0)
 .S PARMS("RECEIVING APPLICATION")=$G(WHO("RECEIVING APPLICATION"))
"RTN","HLOASUB1",234,0)
 ;
"RTN","HLOASUB1",235,0)
 ;find the station # if Institution ien known
"RTN","HLOASUB1",236,0)
 S:$G(WHO("INSTITUTION IEN")) WHO("STATION NUMBER")=$$STATNUM^HLOASUB1(WHO("INSTITUTION IEN"))
"RTN","HLOASUB1",237,0)
 ;
"RTN","HLOASUB1",238,0)
 ;if destination link specified by name, get its ien
"RTN","HLOASUB1",239,0)
 I '$G(WHO("FACILITY LINK IEN")),$L($G(WHO("FACILITY LINK NAME"))) S WHO("FACILITY LINK IEN")=$O(^HLCS(870,"B",WHO("FACILITY LINK NAME"),0))
"RTN","HLOASUB1",240,0)
 ;
"RTN","HLOASUB1",241,0)
 ;if destination link not specified, find it based on station #
"RTN","HLOASUB1",242,0)
 I $L($G(WHO("STATION NUMBER"))),'$G(WHO("FACILITY LINK IEN")) S WHO("FACILITY LINK IEN")=$$FINDLINK^HLOTLNK(WHO("STATION NUMBER"))
"RTN","HLOASUB1",243,0)
 ;
"RTN","HLOASUB1",244,0)
 ;if station # not known, find it based on destination link
"RTN","HLOASUB1",245,0)
 I '$L($G(WHO("STATION NUMBER"))),$G(WHO("FACILITY LINK IEN")) S WHO("STATION NUMBER")=$$STATNUM^HLOTLNK(WHO("FACILITY LINK IEN"))
"RTN","HLOASUB1",246,0)
 ;
"RTN","HLOASUB1",247,0)
 S PARMS("RECEIVING FACILITY",1)=$G(WHO("STATION NUMBER"))
"RTN","HLOASUB1",248,0)
 ;
"RTN","HLOASUB1",249,0)
 ;if the destination link is known, get the domain
"RTN","HLOASUB1",250,0)
 S PARMS("RECEIVING FACILITY",2)=$S($G(WHO("FACILITY LINK IEN")):$$DOMAIN^HLOTLNK(WHO("FACILITY LINK IEN")),1:"")
"RTN","HLOASUB1",251,0)
 ;
"RTN","HLOASUB1",252,0)
 ;**P146 START CJM
"RTN","HLOASUB1",253,0)
 S PARMS("RECEIVING FACILITY","LINK IEN")=$G(WHO("FACILITY LINK IEN"))
"RTN","HLOASUB1",254,0)
 ;**P146 END CJM
"RTN","HLOASUB1",255,0)
 ;
"RTN","HLOASUB1",256,0)
 S PARMS("RECEIVING FACILITY",3)="DNS"
"RTN","HLOASUB1",257,0)
 ;
"RTN","HLOASUB1",258,0)
 ;find the link to send over - need name & ien
"RTN","HLOASUB1",259,0)
 I $G(WHO("MIDDLEWARE LINK IEN")) S WHO("IE LINK IEN")=WHO("MIDDLEWARE LINK IEN")
"RTN","HLOASUB1",260,0)
 I $L($G(WHO("MIDDLEWARE LINK NAME"))) S WHO("IE LINK NAME")=WHO("MIDDLEWARE LINK NAME")
"RTN","HLOASUB1",261,0)
 I $G(WHO("IE LINK IEN")) D
"RTN","HLOASUB1",262,0)
 .S PARMS("LINK IEN")=WHO("IE LINK IEN")
"RTN","HLOASUB1",263,0)
 .S PARMS("LINK NAME")=$P($G(^HLCS(870,PARMS("LINK IEN"),0)),"^")
"RTN","HLOASUB1",264,0)
 .I OK,'$L(PARMS("LINK NAME")) S OK=0,ERROR="MIDDLEWARE LOGICAL LINK PROVIDED BUT NOT FOUND"
"RTN","HLOASUB1",265,0)
 E  I $L($G(WHO("IE LINK NAME"))) D
"RTN","HLOASUB1",266,0)
 .S PARMS("LINK NAME")=WHO("IE LINK NAME")
"RTN","HLOASUB1",267,0)
 .S PARMS("LINK IEN")=$O(^HLCS(870,"B",WHO("IE LINK NAME"),0))
"RTN","HLOASUB1",268,0)
 .I OK,'PARMS("LINK IEN") S OK=0,ERROR="MIDDLEWARE LOGICAL LINK PROVIDED BUT NOT FOUND"
"RTN","HLOASUB1",269,0)
 E  I $G(WHO("FACILITY LINK IEN")) D
"RTN","HLOASUB1",270,0)
 .S PARMS("LINK IEN")=WHO("FACILITY LINK IEN")
"RTN","HLOASUB1",271,0)
 .S PARMS("LINK NAME")=$P($G(^HLCS(870,PARMS("LINK IEN"),0)),"^")
"RTN","HLOASUB1",272,0)
 .I OK,'$L(PARMS("LINK NAME")) S OK=0,ERROR="RECEIVING FACILITY LOGICAL LINK NOT FOUND"
"RTN","HLOASUB1",273,0)
 E  I $L($G(WHO("FACILITY LINK NAME"))) D
"RTN","HLOASUB1",274,0)
 .S PARMS("LINK NAME")=WHO("FACILITY LINK NAME")
"RTN","HLOASUB1",275,0)
 .S PARMS("LINK IEN")=$O(^HLCS(870,"B",WHO("FACILITY LINK NAME"),0))
"RTN","HLOASUB1",276,0)
 .;; ** Start HL*1.6*138 - RBN **
"RTN","HLOASUB1",277,0)
 .;I OK,'PARMS("LINK IEN") S OK=0,ERROR="RECEIVING FACILITY LOGICAL LINK NOT FOUND"
"RTN","HLOASUB1",278,0)
 .I OK,'PARMS("LINK IEN") S OK=0,ERROR="NEITHER THE RECEIVING FACILITY STATION # NOR THE DOMAIN IS SPECIFIED. AT LEAST ONE OR THE OTHER MUST BE SPECIFIED."
"RTN","HLOASUB1",279,0)
 .;; ** Start HL*1.6*138 - RBN **
"RTN","HLOASUB1",280,0)
 I OK,(('PARMS("LINK IEN"))!(PARMS("LINK NAME")="")) S OK=0,ERROR="LOGICAL LINK TO TRANSMIT OVER NOT SPECIFIED"
"RTN","HLOASUB1",281,0)
 ;
"RTN","HLOASUB1",282,0)
 ;need the station # or domain for msg header
"RTN","HLOASUB1",283,0)
ZB25 I OK,'$L(PARMS("RECEIVING FACILITY",2)),'PARMS("RECEIVING FACILITY",1) S OK=0,ERROR="NEITHER THE RECEIVING FACILITY STATION # NOR THE DOMAIN IS SPECIFIED. AT LEAST ONE OR THE OTHER MUST BE SPECIFIED."
"RTN","HLOASUB1",284,0)
 ;
"RTN","HLOASUB1",285,0)
 ;append the port#
"RTN","HLOASUB1",286,0)
 I '$G(WHO("PORT")) S PARMS("RECEIVING FACILITY",2)=PARMS("RECEIVING FACILITY",2)_":"_$$PORT^HLOTLNK($G(WHO("FACILITY LINK IEN")))
"RTN","HLOASUB1",287,0)
 E  S PARMS("RECEIVING FACILITY",2)=PARMS("RECEIVING FACILITY",2)_":"_WHO("PORT")
"RTN","HLOASUB1",288,0)
 ;**P158 START **
"RTN","HLOASUB1",289,0)
 I $G(WHO("PORT")) S PARMS("LINK PORT")=WHO("PORT")
"RTN","HLOASUB1",290,0)
 E  I $G(PARMS("LINK IEN")) S PARMS("LINK PORT")=$$PORT^HLOTLNK(PARMS("LINK IEN"))
"RTN","HLOASUB1",291,0)
 ;**P158 END **
"RTN","HLOASUB1",292,0)
 ;
"RTN","HLOASUB1",293,0)
 Q OK
"RTN","HLOASUB1",294,0)
 ;
"RTN","HLOASUB1",295,0)
 ;**P146 START CJM
"RTN","HLOASUB1",296,0)
ONLIST(IEN,WHO) ;
"RTN","HLOASUB1",297,0)
 ;Description:
"RTN","HLOASUB1",298,0)
 ;  Determines if a recipient is already on the subscriber list
"RTN","HLOASUB1",299,0)
 ;
"RTN","HLOASUB1",300,0)
 ;Input:
"RTN","HLOASUB1",301,0)
 ;  IEN - ien of subscription
"RTN","HLOASUB1",302,0)
 ;  WHO (pass by reference) Identifies the recipient. The allows
"RTN","HLOASUB1",303,0)
 ;      subscripts are the same as in ADD^HLOASUB.
"RTN","HLOASUB1",304,0)
 ;
"RTN","HLOASUB1",305,0)
 ;Output:
"RTN","HLOASUB1",306,0)
 ;   Function returns 0 if not on the subscription list, otherwise
"RTN","HLOASUB1",307,0)
 ;      returns the ien of the subscriber on the subscription list.
"RTN","HLOASUB1",308,0)
 ;
"RTN","HLOASUB1",309,0)
 N PARMS,SUBIEN,TLINK
"RTN","HLOASUB1",310,0)
 S SUBIEN=0
"RTN","HLOASUB1",311,0)
 ;
"RTN","HLOASUB1",312,0)
 ;resolve input parameters
"RTN","HLOASUB1",313,0)
 I '$$CHECKWHO(.WHO,.PARMS) Q 0
"RTN","HLOASUB1",314,0)
 ;
"RTN","HLOASUB1",315,0)
 ;check the "AE" xref
"RTN","HLOASUB1",316,0)
 S SUBIEN=$O(^HLD(779.4,IEN,2,"AE",PARMS("RECEIVING APPLICATION"),+$G(PARMS("RECEIVING FACILITY","LINK IEN")),+$G(PARMS("LINK IEN")),0))
"RTN","HLOASUB1",317,0)
 I SUBIEN Q SUBIEN
"RTN","HLOASUB1",318,0)
 I PARMS("RECEIVING FACILITY","LINK IEN")=PARMS("LINK IEN") S SUBIEN=$O(^HLD(779.4,IEN,2,"AE",PARMS("RECEIVING APPLICATION"),+$G(PARMS("RECEIVING FACILITY","LINK IEN")),0,0))
"RTN","HLOASUB1",319,0)
 I SUBIEN Q SUBIEN
"RTN","HLOASUB1",320,0)
 ;
"RTN","HLOASUB1",321,0)
 ;check the "AD" xref
"RTN","HLOASUB1",322,0)
 I PARMS("LINK IEN"),PARMS("LINK IEN")'=PARMS("RECEIVING FACILITY","LINK IEN") D
"RTN","HLOASUB1",323,0)
 .S TLINK=PARMS("LINK IEN")
"RTN","HLOASUB1",324,0)
 E  S TLINK=PARMS("RECEIVING FACILITY","LINK IEN")
"RTN","HLOASUB1",325,0)
 ;
"RTN","HLOASUB1",326,0)
 Q +$O(^HLD(779.4,IEN,2,"AD",PARMS("RECEIVING APPLICATION"),+TLINK,PARMS("RECEIVING FACILITY",1)_PARMS("RECEIVING FACILITY",2)_PARMS("RECEIVING FACILITY",3),0))
"RTN","HLOASUB1",327,0)
 ;
"RTN","HLOASUB1",328,0)
 ;**P146 END CJM
"RTN","HLOCLNT")
0^9^B81537005^B82958166
"RTN","HLOCLNT",1,0)
HLOCLNT ;ALB/CJM- Client for sending messages - 10/4/94 1pm ;02/29/2012
"RTN","HLOCLNT",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134,137,139,143,147,155,158**;Oct 13, 1995;Build 14
"RTN","HLOCLNT",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT",4,0)
 ;
"RTN","HLOCLNT",5,0)
 ;GET WORK function for the process running under the Process Manager
"RTN","HLOCLNT",6,0)
GETWORK(QUE) ;
"RTN","HLOCLNT",7,0)
 ;Input:
"RTN","HLOCLNT",8,0)
 ;  QUE - (pass by reference) These subscripts are used:
"RTN","HLOCLNT",9,0)
 ;    ("LINK")  - <link name>_":"_<port> last obtained
"RTN","HLOCLNT",10,0)
 ;    ("QUEUE") - name of the queue last obtained
"RTN","HLOCLNT",11,0)
 ;Output:
"RTN","HLOCLNT",12,0)
 ;  Function returns 1 if success, 0 if no more work
"RTN","HLOCLNT",13,0)
 ;  QUE -  updated to identify next queue of messages to process.
"RTN","HLOCLNT",14,0)
 ;    ("LINK") - <link name>_":"_<port>
"RTN","HLOCLNT",15,0)
 ;    ("QUEUE") - the named queue on the link
"RTN","HLOCLNT",16,0)
 ;    ("DOWN") - =1 means that the last OPEN attempt failed
"RTN","HLOCLNT",17,0)
 ;
"RTN","HLOCLNT",18,0)
 N LINK,QUEUE
"RTN","HLOCLNT",19,0)
 S LINK=$G(QUE("LINK")),QUEUE=$G(QUE("QUEUE"))
"RTN","HLOCLNT",20,0)
TRY I (LINK]""),(QUEUE]"") D
"RTN","HLOCLNT",21,0)
 .L -^HLB("QUEUE","OUT",LINK,QUEUE)
"RTN","HLOCLNT",22,0)
 .I $$IFSHUT^HLOTLNK($P(LINK,":")) S QUEUE="" Q
"RTN","HLOCLNT",23,0)
 .I '$$CNNCTD(LINK),$$FAILING(.LINK) S QUEUE="" Q
"RTN","HLOCLNT",24,0)
 .F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0  Q:$T
"RTN","HLOCLNT",25,0)
 I (LINK]""),(QUEUE="") D
"RTN","HLOCLNT",26,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",27,0)
 ..Q:$$IFSHUT^HLOTLNK($P(LINK,":"))
"RTN","HLOCLNT",28,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",29,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",30,0)
 I LINK="" D
"RTN","HLOCLNT",31,0)
 .F  S LINK=$O(^HLB("QUEUE","OUT",LINK)) Q:LINK=""  D  Q:$L(QUEUE)
"RTN","HLOCLNT",32,0)
 ..Q:$$IFSHUT^HLOTLNK($P(LINK,":"))
"RTN","HLOCLNT",33,0)
 ..I '$$CNNCTD(LINK),$$FAILING(.LINK) Q
"RTN","HLOCLNT",34,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","OUT",LINK,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("OUT",QUEUE) L +^HLB("QUEUE","OUT",LINK,QUEUE):0 Q:$T
"RTN","HLOCLNT",35,0)
 S QUE("LINK")=LINK,QUE("QUEUE")=QUEUE,QUE("DOWN")=$G(LINK("DOWN"))
"RTN","HLOCLNT",36,0)
 ;
"RTN","HLOCLNT",37,0)
 ;** P147 START CJM
"RTN","HLOCLNT",38,0)
 I $L(QUEUE),($R(100)>$$GETPRTY^HLOQUE(QUE("QUEUE"),QUE("LINK"))) G TRY
"RTN","HLOCLNT",39,0)
 ;** P148 END CJM
"RTN","HLOCLNT",40,0)
 ;
"RTN","HLOCLNT",41,0)
 Q:$L(QUEUE) 1
"RTN","HLOCLNT",42,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",43,0)
 Q 0
"RTN","HLOCLNT",44,0)
 ;
"RTN","HLOCLNT",45,0)
FAILING(LINK) ;
"RTN","HLOCLNT",46,0)
 ;Returns 1 if the link has failed in the last 30 seconds, 0 otherwise
"RTN","HLOCLNT",47,0)
 ;Also returns LINK("DOWN")=1 if the link was failing > 30 seconds ago, not yet known if its up
"RTN","HLOCLNT",48,0)
 ;
"RTN","HLOCLNT",49,0)
 N LASTTIME,SET
"RTN","HLOCLNT",50,0)
 S LINK("DOWN")=0
"RTN","HLOCLNT",51,0)
 S LASTTIME=$G(^HLB("QUEUE","OUT",LINK))
"RTN","HLOCLNT",52,0)
 S SET=$S(LASTTIME]"":1,1:0)
"RTN","HLOCLNT",53,0)
 I SET D
"RTN","HLOCLNT",54,0)
 .I $$HDIFF^XLFDT($H,LASTTIME,2)>30 S ^HLB("QUEUE","OUT",LINK)="",SET=0,LINK("DOWN")=1
"RTN","HLOCLNT",55,0)
 I $D(^HLTMP("FAILING LINKS",LINK)) S LINK("DOWN")=1
"RTN","HLOCLNT",56,0)
 Q SET
"RTN","HLOCLNT",57,0)
 ;
"RTN","HLOCLNT",58,0)
LINKDOWN(HLCSTATE) ;
"RTN","HLOCLNT",59,0)
 N TO
"RTN","HLOCLNT",60,0)
 D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",61,0)
 I $D(HLCSTATE("LINK","NAME")),$D(HLCSTATE("LINK","PORT")) D
"RTN","HLOCLNT",62,0)
 .S TO=HLCSTATE("LINK","NAME")_":"_HLCSTATE("LINK","PORT")
"RTN","HLOCLNT",63,0)
 .S ^HLB("QUEUE","OUT",TO)=$H
"RTN","HLOCLNT",64,0)
 .S:'$D(^HLTMP("FAILING LINKS",TO)) ^HLTMP("FAILING LINKS",TO)=$H
"RTN","HLOCLNT",65,0)
 Q
"RTN","HLOCLNT",66,0)
 ;
"RTN","HLOCLNT",67,0)
ERROR ;error trap
"RTN","HLOCLNT",68,0)
ZB3 ;
"RTN","HLOCLNT",69,0)
 ;
"RTN","HLOCLNT",70,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOCLNT",71,0)
 ;
"RTN","HLOCLNT",72,0)
 D END
"RTN","HLOCLNT",73,0)
 D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",74,0)
 ;
"RTN","HLOCLNT",75,0)
 ;return to the Process Manager error trap
"RTN","HLOCLNT",76,0)
 D UNWIND^%ZTER
"RTN","HLOCLNT",77,0)
 Q:$QUIT "" Q
"RTN","HLOCLNT",78,0)
 ;
"RTN","HLOCLNT",79,0)
DOWORK(QUEUE) ;sends the messages on the queue
"RTN","HLOCLNT",80,0)
ZB0 ;
"RTN","HLOCLNT",81,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOCLNT"
"RTN","HLOCLNT",82,0)
 N MSGIEN,DEQUE,SUCCESS,MSGCOUNT,MAXIMUM
"RTN","HLOCLNT",83,0)
 S DEQUE=0
"RTN","HLOCLNT",84,0)
 S SUCCESS=1
"RTN","HLOCLNT",85,0)
 ;
"RTN","HLOCLNT",86,0)
 ;
"RTN","HLOCLNT",87,0)
 I '$$CNNCTD(QUEUE("LINK")),'$$CONNECT^HLOCLNT1($P(QUEUE("LINK"),":"),$P(QUEUE("LINK"),":",2),30,.HLCSTATE) Q
"RTN","HLOCLNT",88,0)
 S (MSGCOUNT,MSGIEN)=0
"RTN","HLOCLNT",89,0)
 S MAXIMUM=$$GETPRTY^HLOQUE(QUEUE("QUEUE"),QUEUE("LINK"))*2
"RTN","HLOCLNT",90,0)
 F  S MSGIEN=$O(^HLB("QUEUE","OUT",QUEUE("LINK"),QUEUE("QUEUE"),MSGIEN)) D  Q:'SUCCESS  Q:MSGCOUNT>MAXIMUM  Q:$$STOPPED^HLOQUE("OUT",QUEUE("QUEUE"))  Q:$$IFSHUT^HLOTLNK($P(QUEUE("LINK"),":"))
"RTN","HLOCLNT",91,0)
 .S:'MSGIEN SUCCESS=0
"RTN","HLOCLNT",92,0)
ZB4 .;
"RTN","HLOCLNT",93,0)
 .Q:'SUCCESS
"RTN","HLOCLNT",94,0)
 .N UPDATE
"RTN","HLOCLNT",95,0)
 .S ^HLB(MSGIEN,"TRIES")=$G(^HLB(MSGIEN,"TRIES"))+1
"RTN","HLOCLNT",96,0)
 .S SUCCESS=0
"RTN","HLOCLNT",97,0)
 .S:$$TRANSMIT(.HLCSTATE,MSGIEN,.UPDATE) SUCCESS=1
"RTN","HLOCLNT",98,0)
 .Q:('SUCCESS)!('$D(UPDATE))
"RTN","HLOCLNT",99,0)
 .D DEQUE(.UPDATE)
"RTN","HLOCLNT",100,0)
 .S MSGCOUNT=MSGCOUNT+1
"RTN","HLOCLNT",101,0)
 .D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",102,0)
 .;
"RTN","HLOCLNT",103,0)
 .;if the queue was on the down list, and not since shutdown, mark it as up, since a message has been successfully transmitted across it
"RTN","HLOCLNT",104,0)
 .I $G(QUEUE("DOWN"))!$$FAILING(QUEUE("LINK")),'$$IFSHUT^HLOTLNK(QUEUE("LINK")) S QUEUE("DOWN")=0,^HLB("QUEUE","OUT",QUEUE("LINK"))="" K ^HLTMP("FAILING LINKS",QUEUE("LINK"))
"RTN","HLOCLNT",105,0)
 ;
"RTN","HLOCLNT",106,0)
ZB5 ;
"RTN","HLOCLNT",107,0)
END ;
"RTN","HLOCLNT",108,0)
 ;** P155 START
"RTN","HLOCLNT",109,0)
 I HLCSTATE("LINK","SINGLE THREADED"),HLCSTATE("CONNECTED") D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT",110,0)
 ;** P155 END
"RTN","HLOCLNT",111,0)
 ;
"RTN","HLOCLNT",112,0)
 D DEQUE()
"RTN","HLOCLNT",113,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOCLNT",114,0)
 Q
"RTN","HLOCLNT",115,0)
CNNCTD(LINK) ;
"RTN","HLOCLNT",116,0)
 ;Connected to LINK?  HLCSTATE must be defined, LINK=<link name>:<port>
"RTN","HLOCLNT",117,0)
 ;
"RTN","HLOCLNT",118,0)
 I ($G(HLCSTATE("LINK","NAME"))=$P(LINK,":")),($G(HLCSTATE("LINK","PORT"))=$P(LINK,":",2)),$G(HLCSTATE("CONNECTED")) Q 1
"RTN","HLOCLNT",119,0)
 Q 0
"RTN","HLOCLNT",120,0)
 ;
"RTN","HLOCLNT",121,0)
DEQUE(UPDATE) ;
"RTN","HLOCLNT",122,0)
ZB25 ;
"RTN","HLOCLNT",123,0)
 I $D(UPDATE) S DEQUE=DEQUE+1,DEQUE(+UPDATE)=$P(UPDATE,"^",2,99) S:$G(UPDATE("MSA"))]"" DEQUE(+UPDATE,"MSA")=UPDATE("MSA") S:$G(UPDATE("ACTION"))]"" DEQUE(+UPDATE,"ACTION")=UPDATE("ACTION")
"RTN","HLOCLNT",124,0)
 I '$D(UPDATE)!(DEQUE>15) D
"RTN","HLOCLNT",125,0)
 .N MSGIEN S MSGIEN=0
"RTN","HLOCLNT",126,0)
 .F  S MSGIEN=$O(DEQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOCLNT",127,0)
 ..N NODE,TIME
"RTN","HLOCLNT",128,0)
 ..D DEQUE^HLOQUE(QUEUE("LINK"),QUEUE("QUEUE"),"OUT",MSGIEN)
"RTN","HLOCLNT",129,0)
 ..S TIME=$P(DEQUE(MSGIEN),"^")
"RTN","HLOCLNT",130,0)
 ..Q:'TIME
"RTN","HLOCLNT",131,0)
 ..S NODE=QUEUE("LINK")_"^"_QUEUE("QUEUE")_"^"_$P(DEQUE(MSGIEN),"^",2,99)
"RTN","HLOCLNT",132,0)
 ..S ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN)=NODE
"RTN","HLOCLNT",133,0)
 ..S:$G(DEQUE(MSGIEN,"MSA"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"MSA")=DEQUE(MSGIEN,"MSA")
"RTN","HLOCLNT",134,0)
 ..S:$G(DEQUE(MSGIEN,"ACTION"))]"" ^HLTMP("CLIENT UPDATES",$J,TIME,MSGIEN,"ACTION")=DEQUE(MSGIEN,"ACTION")
"RTN","HLOCLNT",135,0)
 .K DEQUE S DEQUE=0
"RTN","HLOCLNT",136,0)
 Q
"RTN","HLOCLNT",137,0)
 ;
"RTN","HLOCLNT",138,0)
TRANSMIT(HLCSTATE,MSGIEN,UPDATE) ;
"RTN","HLOCLNT",139,0)
 ;Transmits a single message and if a commit ack was requested reads it.  Updates file 778 with the result.  Queues for the infiler the application accept action if one was requested.
"RTN","HLOCLNT",140,0)
 ;Input:
"RTN","HLOCLNT",141,0)
 ;   HLCSTATE (pass by reference)
"RTN","HLOCLNT",142,0)
 ;   MSGIEN - ien, file 778, of message to be transmitted
"RTN","HLOCLNT",143,0)
 ;Output:
"RTN","HLOCLNT",144,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT",145,0)
 ;  UPDATE - (pass by reference) to contain updates needed for message
"RTN","HLOCLNT",146,0)
 ;
"RTN","HLOCLNT",147,0)
 N HLMSTATE,MSA,HDR,SUCCESS
"RTN","HLOCLNT",148,0)
 ;
"RTN","HLOCLNT",149,0)
 S SUCCESS=0
"RTN","HLOCLNT",150,0)
 S HLCSTATE("ATTEMPT")=0
"RTN","HLOCLNT",151,0)
 ;
"RTN","HLOCLNT",152,0)
 ;start saving updates needed after the message is transmitted
"RTN","HLOCLNT",153,0)
 S UPDATE=MSGIEN
"RTN","HLOCLNT",154,0)
 Q:'$$GETMSG^HLOCLNT2(MSGIEN,.HLMSTATE) 1  ;returns 1 so the message will be removed from the queue
"RTN","HLOCLNT",155,0)
 I HLMSTATE("DT/TM"),HLMSTATE("STATUS","ACCEPTED")!(HLMSTATE("HDR","ACCEPT ACK TYPE")="NE") D  Q 1  ;the message was already transmitted
"RTN","HLOCLNT",156,0)
ZB20 .;**P143 START CJM
"RTN","HLOCLNT",157,0)
 .;**P143 END CJM
"RTN","HLOCLNT",158,0)
 ;
"RTN","HLOCLNT",159,0)
 ;**P143 START CJM
"RTN","HLOCLNT",160,0)
 I HLMSTATE("ACK BY")]"",HLMSTATE("STATUS")]"",$G(^HLB(MSGIEN,"TRIES"))>1 Q 1  ;The app ack was already returned, so don't keep transmitting
"RTN","HLOCLNT",161,0)
 ;**P143 END CJM
"RTN","HLOCLNT",162,0)
 ;
"RTN","HLOCLNT",163,0)
 S UPDATE=UPDATE_"^"_$$NOW^XLFDT
"RTN","HLOCLNT",164,0)
RETRY D
"RTN","HLOCLNT",165,0)
 .S HLCSTATE("ATTEMPT")=HLCSTATE("ATTEMPT")+1
"RTN","HLOCLNT",166,0)
 .I 'HLCSTATE("CONNECTED") D OPEN^HLOT(.HLCSTATE) Q:'HLCSTATE("CONNECTED")
"RTN","HLOCLNT",167,0)
 .;
"RTN","HLOCLNT",168,0)
 .;try to send the message
"RTN","HLOCLNT",169,0)
 .;
"RTN","HLOCLNT",170,0)
 .;
"RTN","HLOCLNT",171,0)
 .Q:'$$WRITEMSG^HLOCLNT1(.HLCSTATE,.HLMSTATE)
"RTN","HLOCLNT",172,0)
 .;does the message need an accept ack?
"RTN","HLOCLNT",173,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" D
"RTN","HLOCLNT",174,0)
 ..N FS
"RTN","HLOCLNT",175,0)
 ..Q:'$$READACK^HLOCLNT1(.HLCSTATE,.HDR,.MSA)
"RTN","HLOCLNT",176,0)
 ..;does the MSA refer to the correct control id?
"RTN","HLOCLNT",177,0)
 ..S FS=$E(HDR(1),4)
"RTN","HLOCLNT",178,0)
 ..I $P(MSA,FS,3)'=HLMSTATE("ID") D  Q
"RTN","HLOCLNT",179,0)
ZB21 ...;
"RTN","HLOCLNT",180,0)
 ..N ACKID,ACKCODE
"RTN","HLOCLNT",181,0)
 ..S ACKCODE=$P(MSA,FS,2)
"RTN","HLOCLNT",182,0)
 ..S ACKID=$S($E(HDR(1),1,3)="MSH":$P(HDR(2),FS,5),1:$P(HDR(2),FS,6))
"RTN","HLOCLNT",183,0)
 ..S $P(UPDATE,"^",5)=1
"RTN","HLOCLNT",184,0)
 ..S UPDATE("MSA")=ACKID_"^"_MSA
"RTN","HLOCLNT",185,0)
 ..;**P158 START CJM - allow "AA" in place of "CA"
"RTN","HLOCLNT",186,0)
 ..I '(ACKCODE="CA"),'(ACKCODE="AA") D
"RTN","HLOCLNT",187,0)
 ...S $P(UPDATE,"^",3)="ER",$P(UPDATE,"^",4)=1
"RTN","HLOCLNT",188,0)
ZB22 ...;
"RTN","HLOCLNT",189,0)
 ...;
"RTN","HLOCLNT",190,0)
 ..I (ACKCODE="CA")!(ACKCODE="AA"),HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=1
"RTN","HLOCLNT",191,0)
 ..I ($P(UPDATE,"^",3)="ER") S $P(UPDATE,"^",6)=$P(HLMSTATE("HDR",1),FS,5) ;errors need the application for xref
"RTN","HLOCLNT",192,0)
 ..;
"RTN","HLOCLNT",193,0)
 ..;if it's from a sequence queue, timestamp the queue
"RTN","HLOCLNT",194,0)
 ..I $L($G(HLMSTATE("STATUS","SEQUENCE QUEUE"))) D
"RTN","HLOCLNT",195,0)
 ...L +^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")):200
"RTN","HLOCLNT",196,0)
 ...I $P($G(^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE"))),"^")'=MSGIEN L -^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")) Q
"RTN","HLOCLNT",197,0)
 ...I ACKCODE="CA" D
"RTN","HLOCLNT",198,0)
 ....S $P(^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")),"^",2)=$$FMADD^XLFDT($P(UPDATE,"^",2),,,$$TIMEOUT^HLOAPP($$GETSAP^HLOCLNT2(MSGIEN))) L -^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE"))
"RTN","HLOCLNT",199,0)
ZB23 ....;
"RTN","HLOCLNT",200,0)
 ...;if the message wasn't accepted, need to notify without waiting
"RTN","HLOCLNT",201,0)
 ...S $P(^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE")),"^",2)=$P(UPDATE,"^",2)
"RTN","HLOCLNT",202,0)
 ...L -^HLB("QUEUE","SEQUENCE",HLMSTATE("STATUS","SEQUENCE QUEUE"))
"RTN","HLOCLNT",203,0)
 ..;
"RTN","HLOCLNT",204,0)
 ..;does the app need notification of accept ack?
"RTN","HLOCLNT",205,0)
 ..S UPDATE("ACTION")=HLMSTATE("ACCEPT ACK RESPONSE")
"RTN","HLOCLNT",206,0)
 ..;
"RTN","HLOCLNT",207,0)
 ..S SUCCESS=1
"RTN","HLOCLNT",208,0)
 .E  D  ;accept ack wasn't requested
"RTN","HLOCLNT",209,0)
 ..S SUCCESS=1
"RTN","HLOCLNT",210,0)
 ..I HLMSTATE("HDR","APP ACK TYPE")="NE" S $P(UPDATE,"^",3)="SU",$P(UPDATE,"^",4)=1
"RTN","HLOCLNT",211,0)
 ;
"RTN","HLOCLNT",212,0)
 I 'SUCCESS,'HLCSTATE("CONNECTED"),(HLCSTATE("ATTEMPT")<2) G RETRY
"RTN","HLOCLNT",213,0)
 I SUCCESS D
"RTN","HLOCLNT",214,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOCLNT",215,0)
 .;if this is an ack to a message need to purge the original message, so store its ien with the purge indicator
"RTN","HLOCLNT",216,0)
 .S:$G(HLMSTATE("ACK TO IEN")) $P(UPDATE,"^",4)=$P(UPDATE,"^",4)_"-"_HLMSTATE("ACK TO IEN")
"RTN","HLOCLNT",217,0)
 I ('HLCSTATE("CONNECTED"))!('SUCCESS) D LINKDOWN(.HLCSTATE)
"RTN","HLOCLNT",218,0)
 Q SUCCESS
"RTN","HLOCLNT1")
0^10^B23616126^B35977020
"RTN","HLOCLNT1",1,0)
HLOCLNT1 ;IRMFO-ALB/CJM/RBN - Writing messages, reading acks;03/24/2004  14:43 ;02/27/2012
"RTN","HLOCLNT1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134,137,139,146,155,158**;Oct 13, 1995;Build 14
"RTN","HLOCLNT1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT1",4,0)
 ;
"RTN","HLOCLNT1",5,0)
 ;
"RTN","HLOCLNT1",6,0)
WRITEMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOCLNT1",7,0)
 ;Description:  This function uses the services offered by the transport layer to send a message over an open communication channel.
"RTN","HLOCLNT1",8,0)
 ;
"RTN","HLOCLNT1",9,0)
 ;Input:
"RTN","HLOCLNT1",10,0)
 ;  HLCSTATE (pass by reference, required) Defines the LLP & its state
"RTN","HLOCLNT1",11,0)
 ;  HLMSTATE (pass by reference, required) The message
"RTN","HLOCLNT1",12,0)
 ;Output:
"RTN","HLOCLNT1",13,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",14,0)
 ;
"RTN","HLOCLNT1",15,0)
ZB6 ;
"RTN","HLOCLNT1",16,0)
 N SEG,QUIT,HDR
"RTN","HLOCLNT1",17,0)
 S QUIT=0
"RTN","HLOCLNT1",18,0)
 I '$G(HLMSTATE("IEN")) S QUIT=1 G ZB7
"RTN","HLOCLNT1",19,0)
 S HDR(1)=HLMSTATE("HDR",1),HDR(2)=HLMSTATE("HDR",2)
"RTN","HLOCLNT1",20,0)
 I '$$WRITEHDR^HLOT(.HLCSTATE,.HDR) S QUIT=1 G ZB7
"RTN","HLOCLNT1",21,0)
 I HLMSTATE("BATCH") D
"RTN","HLOCLNT1",22,0)
 .N LAST S LAST=0
"RTN","HLOCLNT1",23,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT1",24,0)
 .F  Q:'$$NEXTMSG^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",25,0)
 ..S LAST=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOCLNT1",26,0)
 ..I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",27,0)
 ..F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",28,0)
 ...I '$$WRITESEG^HLOT(.HLCSTATE,.SEG) S QUIT=1 Q
"RTN","HLOCLNT1",29,0)
 .K SEG S SEG(1)="BTS"_HLMSTATE("HDR","FIELD SEPARATOR")_LAST
"RTN","HLOCLNT1",30,0)
 .S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",31,0)
 E  D
"RTN","HLOCLNT1",32,0)
 .F  Q:'$$HLNEXT^HLOMSG(.HLMSTATE,.SEG)  D  Q:QUIT
"RTN","HLOCLNT1",33,0)
 ..S:'$$WRITESEG^HLOT(.HLCSTATE,.SEG) QUIT=1
"RTN","HLOCLNT1",34,0)
 S:'$$ENDMSG^HLOT(.HLCSTATE) QUIT=1
"RTN","HLOCLNT1",35,0)
ZB7 ;
"RTN","HLOCLNT1",36,0)
 Q 'QUIT
"RTN","HLOCLNT1",37,0)
 ;
"RTN","HLOCLNT1",38,0)
READACK(HLCSTATE,HDR,MSA) ;
"RTN","HLOCLNT1",39,0)
 ;Description:  This function uses the services offered by the transport layer to read an accept ack.
"RTN","HLOCLNT1",40,0)
 ;
"RTN","HLOCLNT1",41,0)
 ;Input:
"RTN","HLOCLNT1",42,0)
 ;  HLCSTATE (pass by reference, required) Defines the communication channel and its state.
"RTN","HLOCLNT1",43,0)
 ;Output:
"RTN","HLOCLNT1",44,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT1",45,0)
 ;  HDR (pass by reference) the message header:
"RTN","HLOCLNT1",46,0)
 ;   HDR(1) is components 1-6
"RTN","HLOCLNT1",47,0)
 ;   HDR(2) is components 7-end
"RTN","HLOCLNT1",48,0)
 ;  MSA (pass by reference) the MSA segment as an unsubscripted variable
"RTN","HLOCLNT1",49,0)
 ;
"RTN","HLOCLNT1",50,0)
ZB8 ;
"RTN","HLOCLNT1",51,0)
 N SEG,SUCCESS
"RTN","HLOCLNT1",52,0)
 S SUCCESS=0
"RTN","HLOCLNT1",53,0)
 K HDR,MSA,MAX,I
"RTN","HLOCLNT1",54,0)
 S MAX=HLCSTATE("SYSTEM","MAXSTRING")-40 ;MAX is the maximum that can be safely stored on a node, leaving room for the other fields stored with MSA seg
"RTN","HLOCLNT1",55,0)
 G:'$$READHDR^HLOT(.HLCSTATE,.HDR) ZB9
"RTN","HLOCLNT1",56,0)
 F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOCLNT1",57,0)
 .I $E($E(SEG(1),1,3)_$E($G(SEG(2)),1,3),1,3)="MSA" D
"RTN","HLOCLNT1",58,0)
 ..S MSA=""
"RTN","HLOCLNT1",59,0)
 ..F I=1:1 Q:'$D(SEG(I))  S MSA=MSA_$S((MAX-$L(MSA))<1:"",1:$E(SEG(I),1,MAX))
"RTN","HLOCLNT1",60,0)
 I $D(MSA),HLCSTATE("MESSAGE ENDED") D  S SUCCESS=1
"RTN","HLOCLNT1",61,0)
 .D SPLITHDR^HLOSRVR1(.HDR)
"RTN","HLOCLNT1",62,0)
 .S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1
"RTN","HLOCLNT1",63,0)
ZB9 Q SUCCESS
"RTN","HLOCLNT1",64,0)
 ;
"RTN","HLOCLNT1",65,0)
CONNECT(LINK,PORT,TIMEOUT,HLCSTATE) ;
"RTN","HLOCLNT1",66,0)
ZB1 ;sets up HLCSTATE() and opens a client connection
"RTN","HLOCLNT1",67,0)
 ;Input:
"RTN","HLOCLNT1",68,0)
 ;  LINK - name of the link to connect to
"RTN","HLOCLNT1",69,0)
 ;  PORT (optional) port # to connect to, defaults to that specified by the link
"RTN","HLOCLNT1",70,0)
 ;  TIMEOUT (optional) specifies the open timeout in seconds, defaults to 30
"RTN","HLOCLNT1",71,0)
 ;Output:
"RTN","HLOCLNT1",72,0)
 ;   HLCSTATE - array to hold the connection state
"RTN","HLOCLNT1",73,0)
 ;
"RTN","HLOCLNT1",74,0)
 I '$G(HLCSTATE("CONNECTED")) S HLCSTATE("CONNECTED")=0
"RTN","HLOCLNT1",75,0)
 I HLCSTATE("CONNECTED") D  G:HLCSTATE("CONNECTED") ZB2
"RTN","HLOCLNT1",76,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",($G(HLCSTATE("LINK","NAME"))'=LINK) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",77,0)
 .I $G(HLCSTATE("LINK","NAME"))]"",$G(PORT),($G(HLCSTATE("LINK","PORT"))'=PORT) D CLOSE^HLOT(.HLCSTATE) Q
"RTN","HLOCLNT1",78,0)
 .I (HLCSTATE("SYSTEM","OS")="CACHE") D  Q
"RTN","HLOCLNT1",79,0)
 ..U HLCSTATE("DEVICE") S HLCSTATE("CONNECTED")=($ZA\8192#2)
"RTN","HLOCLNT1",80,0)
 ..I 'HLCSTATE("CONNECTED") D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",81,0)
 .;D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",82,0)
 K HLCSTATE
"RTN","HLOCLNT1",83,0)
 N ARY,NODE
"RTN","HLOCLNT1",84,0)
 I '$$GETLINK^HLOTLNK(LINK,.ARY) S HLCSTATE("LINK","NAME")=LINK,HLCSTATE("LINK","PORT")=$G(PORT) D LINKDOWN^HLOCLNT(.HLCSTATE) G ZB2
"RTN","HLOCLNT1",85,0)
 M HLCSTATE("LINK")=ARY
"RTN","HLOCLNT1",86,0)
ZB24 ;
"RTN","HLOCLNT1",87,0)
 I HLCSTATE("LINK","SHUTDOWN") S HLCSTATE("CONNECTED")=0 D LINKDOWN^HLOCLNT(.HLCSTATE) G ZB2
"RTN","HLOCLNT1",88,0)
 ;overlay the port if supplied from the queue
"RTN","HLOCLNT1",89,0)
 S:$G(PORT) HLCSTATE("LINK","PORT")=PORT
"RTN","HLOCLNT1",90,0)
 ;
"RTN","HLOCLNT1",91,0)
 ; *** Begin HL*1.6*146 - RBN ***
"RTN","HLOCLNT1",92,0)
 ;S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOCLNT1",93,0)
 ;get the dynamic value of the client read timeout
"RTN","HLOCLNT1",94,0)
 D GETTIME^HLOTCP(.HLCSTATE)
"RTN","HLOCLNT1",95,0)
 ; *** End HL*1.6*146 - RBN ***
"RTN","HLOCLNT1",96,0)
 ; ;
"RTN","HLOCLNT1",97,0)
 S HLCSTATE("OPEN TIMEOUT")=$S($G(TIMEOUT):TIMEOUT,1:30)
"RTN","HLOCLNT1",98,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOCLNT1",99,0)
 S HLCSTATE("READ")="" ;where the reads are stored
"RTN","HLOCLNT1",100,0)
 ;
"RTN","HLOCLNT1",101,0)
 ;HLCSTATE("BUFFER",<seg>,<line>) serves as a write buffer so that a lot can be written all at once
"RTN","HLOCLNT1",102,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of BYTES in buffer
"RTN","HLOCLNT1",103,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOCLNT1",104,0)
 ;
"RTN","HLOCLNT1",105,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOCLNT1",106,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOCLNT1",107,0)
 S HLCSTATE("SERVER")=0
"RTN","HLOCLNT1",108,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOCLNT1",109,0)
 I HLCSTATE("SYSTEM","OS")="" D LINKDOWN^HLOCLNT(.HLCSTATE) G ZB2
"RTN","HLOCLNT1",110,0)
 D
"RTN","HLOCLNT1",111,0)
 .N SYS
"RTN","HLOCLNT1",112,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOCLNT1",113,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOCLNT1",114,0)
 .S HLCSTATE("SYSTEM","MAXSTRING")=SYS("MAXSTRING")
"RTN","HLOCLNT1",115,0)
 .S HLCSTATE("SYSTEM","NORMAL PURGE")=SYS("NORMAL PURGE")
"RTN","HLOCLNT1",116,0)
 .S HLCSTATE("SYSTEM","ERROR PURGE")=SYS("ERROR PURGE")
"RTN","HLOCLNT1",117,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOCLNT1",118,0)
 .S HLCSTATE("OPEN")="OPEN^HLOTCP"
"RTN","HLOCLNT1",119,0)
 E  ;no other LLP implemented
"RTN","HLOCLNT1",120,0)
 D OPEN^HLOT(.HLCSTATE)
"RTN","HLOCLNT1",121,0)
 ;
"RTN","HLOCLNT1",122,0)
 ;mark the failure time for the link so other processes know not to try for a while
"RTN","HLOCLNT1",123,0)
 I 'HLCSTATE("CONNECTED"),'HLCSTATE("LINK","SINGLE THREADED") D LINKDOWN^HLOCLNT(.HLCSTATE)
"RTN","HLOCLNT1",124,0)
 I 'HLCSTATE("CONNECTED"),HLCSTATE("LINK","SINGLE THREADED"),'HLCSTATE("LOCK FAILED") D LINKDOWN^HLOCLNT(.HLCSTATE)
"RTN","HLOCLNT1",125,0)
ZB2 ;
"RTN","HLOCLNT1",126,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOCLNT1",127,0)
 ;
"RTN","HLOCLNT1",128,0)
 ;
"RTN","HLOCLNT1",129,0)
 ;
"RTN","HLOCLNT1",130,0)
 ;
"RTN","HLOCLNT2")
0^11^B34928918^B39313138
"RTN","HLOCLNT2",1,0)
HLOCLNT2 ;ALB/CJM- Performs message updates for the client - 10/4/94 1pm ;03/07/2012
"RTN","HLOCLNT2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,133,134,137,143,158**;Oct 13, 1995;Build 14
"RTN","HLOCLNT2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT2",4,0)
 ;
"RTN","HLOCLNT2",5,0)
GETWORK(WORK) ;
"RTN","HLOCLNT2",6,0)
 ;
"RTN","HLOCLNT2",7,0)
 N OLD,DOLLARJ,SUCCESS,NOW
"RTN","HLOCLNT2",8,0)
 S SUCCESS=0
"RTN","HLOCLNT2",9,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOCLNT2",10,0)
 S (OLD,DOLLARJ)=$G(WORK("DOLLARJ"))
"RTN","HLOCLNT2",11,0)
 F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  D  Q:SUCCESS
"RTN","HLOCLNT2",12,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",13,0)
 .Q:'$T
"RTN","HLOCLNT2",14,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",15,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",16,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",17,0)
 ;
"RTN","HLOCLNT2",18,0)
 I OLD'="",'SUCCESS F  S DOLLARJ=$O(^HLTMP("CLIENT UPDATES",DOLLARJ)) Q:DOLLARJ=""  Q:DOLLARJ>OLD  D  Q:SUCCESS
"RTN","HLOCLNT2",19,0)
 .L +^HLTMP("CLIENT UPDATES",DOLLARJ):0
"RTN","HLOCLNT2",20,0)
 .Q:'$T
"RTN","HLOCLNT2",21,0)
 .N TIME S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,""))
"RTN","HLOCLNT2",22,0)
 .I $$FMDIFF^XLFDT(NOW,TIME,2)<2 L -^HLTMP("CLIENT UPDATES",DOLLARJ) Q
"RTN","HLOCLNT2",23,0)
 .S SUCCESS=1
"RTN","HLOCLNT2",24,0)
 S WORK("DOLLARJ")=DOLLARJ,WORK("NOW")=NOW
"RTN","HLOCLNT2",25,0)
 Q $S($L(WORK("DOLLARJ")):1,1:0)
"RTN","HLOCLNT2",26,0)
 ;
"RTN","HLOCLNT2",27,0)
DOWORK(WORK) ;
"RTN","HLOCLNT2",28,0)
 ;
"RTN","HLOCLNT2",29,0)
 N DOLLARJ,TIME,IEN,PARMS,SYSTEM
"RTN","HLOCLNT2",30,0)
 S TIME=""
"RTN","HLOCLNT2",31,0)
 S DOLLARJ=WORK("DOLLARJ")
"RTN","HLOCLNT2",32,0)
 D SYSPARMS^HLOSITE(.SYSTEM)
"RTN","HLOCLNT2",33,0)
 F  S TIME=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME)) Q:TIME=""  Q:$$FMDIFF^XLFDT(WORK("NOW"),TIME,2)<2  D
"RTN","HLOCLNT2",34,0)
 .S IEN=0
"RTN","HLOCLNT2",35,0)
 .F  S IEN=$O(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)) Q:'IEN  D
"RTN","HLOCLNT2",36,0)
 ..N NODE
"RTN","HLOCLNT2",37,0)
 ..S NODE=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN))
"RTN","HLOCLNT2",38,0)
 ..S PARMS("LINK")=$P(NODE,"^")
"RTN","HLOCLNT2",39,0)
 ..S PARMS("QUEUE")=$P(NODE,"^",2)
"RTN","HLOCLNT2",40,0)
 ..S PARMS("STATUS")=$P(NODE,"^",3)
"RTN","HLOCLNT2",41,0)
 ..S PARMS("PURGE")=$P(NODE,"^",4)
"RTN","HLOCLNT2",42,0)
 ..S PARMS("ACK TO IEN")=+$P($P(NODE,"^",4),"-",2)
"RTN","HLOCLNT2",43,0)
 ..S PARMS("ACCEPT ACK")=$P(NODE,"^",5)
"RTN","HLOCLNT2",44,0)
 ..S PARMS("RECEIVING APP")=$P(NODE,"^",6)
"RTN","HLOCLNT2",45,0)
 ..S:PARMS("RECEIVING APP")="" PARMS("RECEIVING APP")="UNKNOWN RECEIVING APPLICATION"
"RTN","HLOCLNT2",46,0)
 ..S PARMS("MSA")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"MSA"))
"RTN","HLOCLNT2",47,0)
 ..S PARMS("ACTION")=$G(^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN,"ACTION"))
"RTN","HLOCLNT2",48,0)
 ..D UPDATE(IEN,TIME,.PARMS)
"RTN","HLOCLNT2",49,0)
 ..K ^HLTMP("CLIENT UPDATES",DOLLARJ,TIME,IEN)
"RTN","HLOCLNT2",50,0)
 L -^HLTMP("CLIENT UPDATES",DOLLARJ)
"RTN","HLOCLNT2",51,0)
 Q
"RTN","HLOCLNT2",52,0)
 ;
"RTN","HLOCLNT2",53,0)
UPDATE(MSGIEN,TIME,PARMS) ;
"RTN","HLOCLNT2",54,0)
 S:PARMS("STATUS")]"" $P(^HLB(MSGIEN,0),"^",20)=PARMS("STATUS")
"RTN","HLOCLNT2",55,0)
 I PARMS("STATUS")="ER" D
"RTN","HLOCLNT2",56,0)
 .S ^HLB("ERRORS",PARMS("RECEIVING APP"),TIME,MSGIEN_"^")=""
"RTN","HLOCLNT2",57,0)
 .D COUNT^HLOESTAT("OUT",PARMS("RECEIVING APP"),$$GETSAP(MSGIEN),$$GETMTYPE(MSGIEN))
"RTN","HLOCLNT2",58,0)
 S:PARMS("ACCEPT ACK") $P(^HLB(MSGIEN,0),"^",17)=PARMS("ACCEPT ACK")
"RTN","HLOCLNT2",59,0)
 S $P(^HLB(MSGIEN,0),"^",16)=TIME
"RTN","HLOCLNT2",60,0)
 S:PARMS("MSA")]"" ^HLB(MSGIEN,4)=TIME_"^"_PARMS("MSA")
"RTN","HLOCLNT2",61,0)
 I PARMS("PURGE"),PARMS("ACTION")="" D SETPURGE^HLOF778A(MSGIEN,PARMS("STATUS"),PARMS("ACK TO IEN"))
"RTN","HLOCLNT2",62,0)
 D:PARMS("ACTION")]""
"RTN","HLOCLNT2",63,0)
 .N PURGE
"RTN","HLOCLNT2",64,0)
 .S PURGE=PARMS("PURGE")
"RTN","HLOCLNT2",65,0)
 .S:PARMS("ACK TO IEN") PURGE("ACKTOIEN")=PARMS("ACK TO IEN")
"RTN","HLOCLNT2",66,0)
 .D INQUE^HLOQUE(PARMS("LINK"),PARMS("QUEUE"),MSGIEN,PARMS("ACTION"),.PURGE)
"RTN","HLOCLNT2",67,0)
 Q
"RTN","HLOCLNT2",68,0)
 ;
"RTN","HLOCLNT2",69,0)
GETMSG(IEN,MSG) ;
"RTN","HLOCLNT2",70,0)
 ;
"RTN","HLOCLNT2",71,0)
 ;Description: given the message ien=MSGIEN (required), it returns the MSG array containing information about the message, defined below.
"RTN","HLOCLNT2",72,0)
 ;Input:
"RTN","HLOCLNT2",73,0)
 ;  IEN - the ien of the message in file 778
"RTN","HLOCLNT2",74,0)
 ;Output:
"RTN","HLOCLNT2",75,0)
 ;  Function returns 1 on success, 0 on failure
"RTN","HLOCLNT2",76,0)
 ;  MSG (pass by reference, required) These are the subscripts returned:
"RTN","HLOCLNT2",77,0)
 ;    "ACCEPT ACK RESPONSE" - if the sending app requested notification of the accept ack, this is the routine to perform
"RTN","HLOCLNT2",78,0)
 ;    "ACK TO IEN" - if this is an app ack to a message not in a batch, this is the ien of the original message
"RTN","HLOCLNT2",79,0)
 ;    "ACK BY"
"RTN","HLOCLNT2",80,0)
 ;    "STATUS"
"RTN","HLOCLNT2",81,0)
 ;    "BATCH"  = 1 if this is a batch message, 0  if not
"RTN","HLOCLNT2",82,0)
 ;    "CURRENT MESSAGE" - defined only for batch messages -  a counterused during building and parsing messages to indicate the current message.  It will be set to 0 initially.
"RTN","HLOCLNT2",83,0)
 ;    "BODY" - ptr to file 778 which contains the body of the message.
"RTN","HLOCLNT2",84,0)
 ;    "LINE COUNT" -  a counter used during writing of the
"RTN","HLOCLNT2",85,0)
 ;     messages to indicate the current line. For
"RTN","HLOCLNT2",86,0)
 ;     batch messages where each message within the batch is stored
"RTN","HLOCLNT2",87,0)
 ;     separately, this field indicates the position within the current
"RTN","HLOCLNT2",88,0)
 ;     individual message
"RTN","HLOCLNT2",89,0)
 ;    "HDR" at these lower subscripts:
"RTN","HLOCLNT2",90,0)
 ;       1    - components 1-6
"RTN","HLOCLNT2",91,0)
 ;       2    - components 7-end
"RTN","HLOCLNT2",92,0)
 ;       "ACCEPT ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT2",93,0)
 ;       "APP ACK TYPE" = "AL" or "NE"
"RTN","HLOCLNT2",94,0)
 ;       "MESSAGE CONTROL ID" - defined if NOT batch
"RTN","HLOCLNT2",95,0)
 ;       "BATCH CONTROL ID" - defined if batch
"RTN","HLOCLNT2",96,0)
 ;
"RTN","HLOCLNT2",97,0)
 ;    "ID" - message id from the header
"RTN","HLOCLNT2",98,0)
 ;    "IEN" - ien, file 778
"RTN","HLOCLNT2",99,0)
 ;    "STATUS","SEQUENCE QUEUE")=name of the sequence queue (optional)
"RTN","HLOCLNT2",100,0)
 ;
"RTN","HLOCLNT2",101,0)
 K MSG
"RTN","HLOCLNT2",102,0)
 Q:'$G(IEN) 0
"RTN","HLOCLNT2",103,0)
 N NODE,FS,CS,REP,SUBCOMP,ESCAPE
"RTN","HLOCLNT2",104,0)
 S MSG("IEN")=IEN
"RTN","HLOCLNT2",105,0)
 S NODE=$G(^HLB(IEN,0))
"RTN","HLOCLNT2",106,0)
 S MSG("BODY")=$P(NODE,"^",2)
"RTN","HLOCLNT2",107,0)
 S MSG("ID")=$P(NODE,"^")
"RTN","HLOCLNT2",108,0)
 Q:'MSG("BODY") 0
"RTN","HLOCLNT2",109,0)
 ;
"RTN","HLOCLNT2",110,0)
 S MSG("ACK BY")=$P(NODE,"^",7)
"RTN","HLOCLNT2",111,0)
 S MSG("STATUS")=$P(NODE,"^",20)
"RTN","HLOCLNT2",112,0)
 ;
"RTN","HLOCLNT2",113,0)
 ;
"RTN","HLOCLNT2",114,0)
 S MSG("STATUS","ACCEPTED")=$P(NODE,"^",17)
"RTN","HLOCLNT2",115,0)
 S MSG("DT/TM")=$P(NODE,"^",16)
"RTN","HLOCLNT2",116,0)
 S MSG("STATUS","QUEUE")=$P(NODE,"^",6)
"RTN","HLOCLNT2",117,0)
 I MSG("STATUS","QUEUE")="" S MSG("STATUS","QUEUE")="DEFAULT"
"RTN","HLOCLNT2",118,0)
 S MSG("ACCEPT ACK RESPONSE")=$P(NODE,"^",12,13)
"RTN","HLOCLNT2",119,0)
 I MSG("ACCEPT ACK RESPONSE")="^" S MSG("ACCEPT ACK RESPONSE")=""
"RTN","HLOCLNT2",120,0)
 ;
"RTN","HLOCLNT2",121,0)
 S MSG("BATCH")=+$P($G(^HLA(MSG("BODY"),0)),"^",2)
"RTN","HLOCLNT2",122,0)
 I MSG("BATCH") D
"RTN","HLOCLNT2",123,0)
 .S MSG("BATCH","CURRENT MESSAGE")=0
"RTN","HLOCLNT2",124,0)
 E  D
"RTN","HLOCLNT2",125,0)
 .N ACKTO
"RTN","HLOCLNT2",126,0)
 .S ACKTO=$P(NODE,"^",3)
"RTN","HLOCLNT2",127,0)
 .I ACKTO]"" S ACKTO=$$ACKTOIEN^HLOMSG1(MSG("ID"),ACKTO)
"RTN","HLOCLNT2",128,0)
 .I ACKTO,+ACKTO=ACKTO S MSG("ACK TO IEN")=ACKTO
"RTN","HLOCLNT2",129,0)
 S MSG("LINE COUNT")=0
"RTN","HLOCLNT2",130,0)
 S MSG("HDR",1)=$G(^HLB(IEN,1))
"RTN","HLOCLNT2",131,0)
 S MSG("HDR",2)=$G(^HLB(IEN,2))
"RTN","HLOCLNT2",132,0)
 S FS=$E(MSG("HDR",1),4)
"RTN","HLOCLNT2",133,0)
 S CS=$E(MSG("HDR",1),5)
"RTN","HLOCLNT2",134,0)
 S REP=$E(MSG("HDR",1),6)
"RTN","HLOCLNT2",135,0)
 S ESCAPE=$E(MSG("HDR",1),7)
"RTN","HLOCLNT2",136,0)
 S SUBCOMP=$E(MSG("HDR",1),8)
"RTN","HLOCLNT2",137,0)
 S MSG("HDR","FIELD SEPARATOR")=FS
"RTN","HLOCLNT2",138,0)
 S MSG("HDR","SENDING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(MSG("HDR",1),FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOCLNT2",139,0)
 S MSG("HDR","RECEIVING APPLICATION")=$$DESCAPE^HLOPRS1($P($P(MSG("HDR",1),FS,5),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOCLNT2",140,0)
 I 'MSG("BATCH") D
"RTN","HLOCLNT2",141,0)
 .S MSG("HDR","MESSAGE TYPE")=$P($P(MSG("HDR",2),FS,4),CS)
"RTN","HLOCLNT2",142,0)
 .S MSG("HDR","EVENT")=$P($P(MSG("HDR",2),FS,4),CS,2)
"RTN","HLOCLNT2",143,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P(MSG("HDR",2),FS,10),1,2)
"RTN","HLOCLNT2",144,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P(MSG("HDR",2),FS,11),1,2)
"RTN","HLOCLNT2",145,0)
 .S MSG("HDR","MESSAGE CONTROL ID")=MSG("ID")
"RTN","HLOCLNT2",146,0)
 E  D
"RTN","HLOCLNT2",147,0)
 .S MSG("HDR","BATCH CONTROL ID")=MSG("ID")
"RTN","HLOCLNT2",148,0)
 .S MSG("HDR","ACCEPT ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"ACCEPT ACK TYPE=",2),1,2)
"RTN","HLOCLNT2",149,0)
 .S MSG("HDR","APP ACK TYPE")=$E($P($P(MSG("HDR",2),FS,4),"APP ACK TYPE=",2),1,2)
"RTN","HLOCLNT2",150,0)
 S MSG("STATUS","SEQUENCE QUEUE")=$P($G(^HLB(IEN,5)),"^")
"RTN","HLOCLNT2",151,0)
 Q 1
"RTN","HLOCLNT2",152,0)
 ;
"RTN","HLOCLNT2",153,0)
GETMTYPE(MSGIEN) ;returns <message type>~<event> OR "BATCH"
"RTN","HLOCLNT2",154,0)
 Q:'$G(MSGIEN) "UNKNOWN"
"RTN","HLOCLNT2",155,0)
 N FS,CS,HDR1,HDR2
"RTN","HLOCLNT2",156,0)
 S HDR1=$G(^HLB(IEN,1))
"RTN","HLOCLNT2",157,0)
 I $E(HDR1,1,3)="BHS" Q "BATCH"
"RTN","HLOCLNT2",158,0)
 S HDR2=$G(^HLB(IEN,2))
"RTN","HLOCLNT2",159,0)
 S FS=$E(HDR1,4)
"RTN","HLOCLNT2",160,0)
 S CS=$E(HDR1,5)
"RTN","HLOCLNT2",161,0)
 Q $P($P(HDR2,FS,4),CS)_"~"_$P($P(HDR2,FS,4),CS,2)
"RTN","HLOCLNT2",162,0)
 ;
"RTN","HLOCLNT2",163,0)
GETEVENT(MSGIEN) ; returns event if not a batch message
"RTN","HLOCLNT2",164,0)
 Q:'$G(MSGIEN) ""
"RTN","HLOCLNT2",165,0)
 N FS,CS,HDR1,HDR2
"RTN","HLOCLNT2",166,0)
 S HDR1=$G(^HLB(MSGIEN,1))
"RTN","HLOCLNT2",167,0)
 I $E(HDR1,1,3)="BHS" Q ""
"RTN","HLOCLNT2",168,0)
 S HDR2=$G(^HLB(MSGIEN,2))
"RTN","HLOCLNT2",169,0)
 S FS=$E(HDR1,4)
"RTN","HLOCLNT2",170,0)
 S CS=$E(HDR1,5)
"RTN","HLOCLNT2",171,0)
 Q $P($P(HDR2,FS,4),CS,2)
"RTN","HLOCLNT2",172,0)
 ;
"RTN","HLOCLNT2",173,0)
GETSAP(MSGIEN) ;
"RTN","HLOCLNT2",174,0)
 ;
"RTN","HLOCLNT2",175,0)
 ;
"RTN","HLOCLNT2",176,0)
 Q:'$G(MSGIEN) "UNKNOWN"
"RTN","HLOCLNT2",177,0)
 N FS,CS,HDR1,REP,ESCAPE,SUBCOMP
"RTN","HLOCLNT2",178,0)
 S HDR1=$G(^HLB(MSGIEN,1))
"RTN","HLOCLNT2",179,0)
 S FS=$E(HDR1,4)
"RTN","HLOCLNT2",180,0)
 S CS=$E(HDR1,5)
"RTN","HLOCLNT2",181,0)
 S REP=$E(HDR1,6)
"RTN","HLOCLNT2",182,0)
 S ESCAPE=$E(HDR1,7)
"RTN","HLOCLNT2",183,0)
 S SUBCOMP=$E(HDR1,8)
"RTN","HLOCLNT2",184,0)
 Q $$DESCAPE^HLOPRS1($P($P(HDR1,FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOCLNT3")
0^12^B5589114^B5637938
"RTN","HLOCLNT3",1,0)
HLOCLNT3 ;ALB/CJM- Updates messages missing application acks - 10/4/94 1pm ;03/12/2012
"RTN","HLOCLNT3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,134,137,158**;Oct 13, 1995;Build 14
"RTN","HLOCLNT3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOCLNT3",4,0)
 ;
"RTN","HLOCLNT3",5,0)
DOWORK(WORK) ;
"RTN","HLOCLNT3",6,0)
 ;
"RTN","HLOCLNT3",7,0)
 N CUTOFF,MSGIEN,QUIT,NOW,SYSPURGE
"RTN","HLOCLNT3",8,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOCLNT3",9,0)
 S QUIT=0
"RTN","HLOCLNT3",10,0)
 D SYSPURGE^HLOSITE(.SYSPURGE)
"RTN","HLOCLNT3",11,0)
 S PURGE=$$FMADD^XLFDT($$NOW^XLFDT,SYSPURGE("ERROR"))
"RTN","HLOCLNT3",12,0)
 ;
"RTN","HLOCLNT3",13,0)
 ;7 day wait for an application ack is more than reasonable
"RTN","HLOCLNT3",14,0)
 S CUTOFF=$$FMADD^XLFDT(NOW,-7)
"RTN","HLOCLNT3",15,0)
 ;
"RTN","HLOCLNT3",16,0)
 S MSGIEN=+$G(^HLTMP("LAST IEN CHECKED FOR MISSING APPLICATION ACK"))
"RTN","HLOCLNT3",17,0)
 F  S MSGIEN=$O(^HLB(MSGIEN)) Q:'MSGIEN  Q:MSGIEN>99999999999  D  Q:QUIT
"RTN","HLOCLNT3",18,0)
 .N MSG,HDR
"RTN","HLOCLNT3",19,0)
 .Q:'$$GETMSG^HLOMSG(MSGIEN,.MSG)
"RTN","HLOCLNT3",20,0)
 .Q:'MSG("DT/TM")
"RTN","HLOCLNT3",21,0)
 .Q:'MSG("BODY")
"RTN","HLOCLNT3",22,0)
 .I MSG("DT/TM")>CUTOFF S:MSG("DT/TM CREATED")>CUTOFF QUIT=1,MSGIEN=MSGIEN-1 Q
"RTN","HLOCLNT3",23,0)
 .Q:MSG("STATUS")'=""
"RTN","HLOCLNT3",24,0)
 .Q:MSG("DIRECTION")'="OUT"
"RTN","HLOCLNT3",25,0)
 .Q:MSG("BATCH")
"RTN","HLOCLNT3",26,0)
 .Q:MSG("STATUS","APP ACK'D")
"RTN","HLOCLNT3",27,0)
 .;Q:MSG("STATUS","APP ACK RESPONSE")=""
"RTN","HLOCLNT3",28,0)
 .;message has been in a incomplete status for a longtime, pending an application ack - set status to error and schedule for purging
"RTN","HLOCLNT3",29,0)
 .S $P(^HLB(MSGIEN,0),"^",9)=PURGE
"RTN","HLOCLNT3",30,0)
 .S ^HLB("AD","OUT",PURGE,MSGIEN)=""
"RTN","HLOCLNT3",31,0)
 .S $P(^HLB(MSGIEN,0),"^",20)="ER"
"RTN","HLOCLNT3",32,0)
 .S $P(^HLB(MSGIEN,0),"^",21)="MISSING APPLICATION ACKNOWLEDGMENT"
"RTN","HLOCLNT3",33,0)
 .M HDR=MSG("HDR")
"RTN","HLOCLNT3",34,0)
 .Q:'$$PARSEHDR^HLOPRS(.HDR)
"RTN","HLOCLNT3",35,0)
 .S ^HLB("ERRORS",$S($L(HDR("RECEIVING APPLICATION")):HDR("RECEIVING APPLICATION"),1:"UNKNOWN"),NOW,MSGIEN)=""
"RTN","HLOCLNT3",36,0)
 .D COUNT^HLOESTAT("OUT",HDR("RECEIVING APPLICATION"),HDR("SENDING APPLICATION"),$S(MSG("BATCH"):"BATCH",1:$G(HDR("MESSAGE TYPE"))),$G(HDR("EVENT")))
"RTN","HLOCLNT3",37,0)
 S:MSGIEN>99999999999 MSGIEN=0
"RTN","HLOCLNT3",38,0)
 S ^HLTMP("LAST IEN CHECKED FOR MISSING APPLICATION ACK")=MSGIEN
"RTN","HLOCLNT3",39,0)
 Q
"RTN","HLOF778")
0^1^B32326577^B31915800
"RTN","HLOF778",1,0)
HLOF778 ;ALB/CJM-HL7 - Saving messages to file 778 ;03/07/2012
"RTN","HLOF778",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,137,138,158**;Oct 13, 1995;Build 14
"RTN","HLOF778",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOF778",4,0)
 ;
"RTN","HLOF778",5,0)
 ;
"RTN","HLOF778",6,0)
SAVEMSG(HLMSTATE) ;
"RTN","HLOF778",7,0)
 ;If a record has not yet been created in file 778, then it will be created. Will file any segments into 777 not yet stored.  For batch messages, will store the MSH segments in 778 as the individual messages are stored in 777.
"RTN","HLOF778",8,0)
 ;Input:
"RTN","HLOF778",9,0)
 ;  HLMSTATE (pass by reference) - contains information about the message
"RTN","HLOF778",10,0)
 ;    These subscripts must be defined:
"RTN","HLOF778",11,0)
 ;  ("BATCH")=1 if batch, 0 otherwise
"RTN","HLOF778",12,0)
 ;  ("BATCH","BTS")=BTS segment if end of batch reached
"RTN","HLOF778",13,0)
 ;  ("BODY")=ien file 777 if stored
"RTN","HLOF778",14,0)
 ;  ("DIRECTION")=<"IN" or "OUT">
"RTN","HLOF778",15,0)
 ;  ("IEN")=ien,file 778 if stored
"RTN","HLOF778",16,0)
 ;  ("UNSTORED LINES") - count of lines to be stored.  The lines are at the a lower subscript level <msg>,<segment>,<line>=<line to be stored>
"RTN","HLOF778",17,0)
 ;  ("UNSTORED MSH") For batch messages, set to 1 if there are MSH in cache. Cached MSH at ("UNSTORED MSH",<subfile ien>,<1 & 2>)
"RTN","HLOF778",18,0)
 ;
"RTN","HLOF778",19,0)
 ;Output:
"RTN","HLOF778",20,0)
 ;  Function - returns the ien of the msg (file 778)
"RTN","HLOF778",21,0)
 ;  HLMSTATE
"RTN","HLOF778",22,0)
 ;   ("BODY") - set to ien, file 777 if newly created
"RTN","HLOF778",23,0)
 ;   ("IEN") - set to ien, file 778 if newly created
"RTN","HLOF778",24,0)
 ;   ("UNSTORED LINES")-set to 0 as this function will store them
"RTN","HLOF778",25,0)
 ;   ("UNSTORED MSH")- set to 0 as this function will store it
"RTN","HLOF778",26,0)
 ;
"RTN","HLOF778",27,0)
 ;
"RTN","HLOF778",28,0)
 I '$D(HLMSTATE("DT/TM")) S HLMSTATE("DT/TM")=$S(HLMSTATE("DIRECTION")="IN":$$NOW^XLFDT,1:"")
"RTN","HLOF778",29,0)
 ;
"RTN","HLOF778",30,0)
 ;insure that 777 entry created & all segments stored
"RTN","HLOF778",31,0)
 I ('HLMSTATE("BODY"))!($G(HLMSTATE("UNSTORED LINES")))!($L($G(HLMSTATE("BATCH","BTS")))),'$$SAVEMSG^HLOF777(.HLMSTATE) Q 0
"RTN","HLOF778",32,0)
 ;
"RTN","HLOF778",33,0)
 ;insure 778 entry created
"RTN","HLOF778",34,0)
 I 'HLMSTATE("IEN") Q:'$$NEW^HLOF778A(.HLMSTATE) 0
"RTN","HLOF778",35,0)
 ;
"RTN","HLOF778",36,0)
 ;for batch messages, store MSH segments in 778
"RTN","HLOF778",37,0)
 I HLMSTATE("BATCH") D
"RTN","HLOF778",38,0)
 .N IEN S IEN=HLMSTATE("IEN")
"RTN","HLOF778",39,0)
 .;
"RTN","HLOF778",40,0)
 .;incoming messages cache the MSH segments in memory
"RTN","HLOF778",41,0)
 .I HLMSTATE("DIRECTION")="IN",HLMSTATE("UNSTORED MSH") D
"RTN","HLOF778",42,0)
 ..N ORDER S ORDER=0
"RTN","HLOF778",43,0)
 ..F  S ORDER=$O(HLMSTATE("UNSTORED MSH",ORDER)) Q:'ORDER  D
"RTN","HLOF778",44,0)
 ...N FS,MSGID
"RTN","HLOF778",45,0)
 ...S FS=$E(HLMSTATE("UNSTORED MSH",ORDER,1),4)
"RTN","HLOF778",46,0)
 ...S MSGID=$P(HLMSTATE("UNSTORED MSH",ORDER,2),FS,5)
"RTN","HLOF778",47,0)
 ...S ^HLB(IEN,3,ORDER,0)=ORDER_"^"_MSGID_"^"_$G(HLMSTATE("BATCH","ACK TO",ORDER))
"RTN","HLOF778",48,0)
 ...S ^HLB(IEN,3,ORDER,1)=HLMSTATE("UNSTORED MSH",ORDER,1)
"RTN","HLOF778",49,0)
 ...S ^HLB(IEN,3,ORDER,2)=HLMSTATE("UNSTORED MSH",ORDER,2)
"RTN","HLOF778",50,0)
 ...S ^HLB(IEN,3,"B",ORDER,ORDER)=""
"RTN","HLOF778",51,0)
 ...I MSGID]"" S ^HLB("AE",MSGID,IEN_"^"_ORDER)="" ;whole file index for individual message id
"RTN","HLOF778",52,0)
 ..K HLMSTATE("UNSTORED MSH") S HLMSTATE("UNSTORED MSH")=0
"RTN","HLOF778",53,0)
 .;
"RTN","HLOF778",54,0)
 .;
"RTN","HLOF778",55,0)
 .I HLMSTATE("DIRECTION")="OUT" D
"RTN","HLOF778",56,0)
 ..;must build the MSH segments!
"RTN","HLOF778",57,0)
 ..N HDR,FS,MSG,CS
"RTN","HLOF778",58,0)
 ..S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOF778",59,0)
 ..S CS=$E(HLMSTATE("HDR","ENCODING CHARACTERS"),1)
"RTN","HLOF778",60,0)
 ..S HLMSTATE("HDR","MESSAGE TYPE")="   "
"RTN","HLOF778",61,0)
 ..S HLMSTATE("HDR","EVENT")="   "
"RTN","HLOF778",62,0)
 ..D BUILDHDR^HLOPBLD1(.HLMSTATE,"MSH",.HDR)
"RTN","HLOF778",63,0)
 ..S HLMSTATE("BATCH","CURRENT MESSAGE")=$O(^HLB(HLMSTATE("IEN"),3,"B",";"),-1)
"RTN","HLOF778",64,0)
 ..F  Q:'$$NEXTMSG(.HLMSTATE,.MSG)  D
"RTN","HLOF778",65,0)
 ...N MSGID,CUR
"RTN","HLOF778",66,0)
 ...S CUR=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOF778",67,0)
 ...S MSGID=HLMSTATE("HDR","BATCH CONTROL ID")_"-"_CUR
"RTN","HLOF778",68,0)
 ...S $P(HDR(2),FS,4)=MSG("MESSAGE TYPE")_CS_MSG("EVENT")
"RTN","HLOF778",69,0)
 ...S $P(HDR(2),FS,5)=MSGID
"RTN","HLOF778",70,0)
 ...S ^HLB(IEN,3,CUR,0)=CUR_"^"_MSGID_"^"_$G(HLMSTATE("BATCH","ACK TO",CUR))
"RTN","HLOF778",71,0)
 ...S ^HLB(IEN,3,CUR,1)=HDR(1)
"RTN","HLOF778",72,0)
 ...S ^HLB(IEN,3,CUR,2)=HDR(2)
"RTN","HLOF778",73,0)
 ...S ^HLB(IEN,3,"B",CUR,CUR)=""
"RTN","HLOF778",74,0)
 ...S ^HLB("AE",MSGID,IEN_"^"_CUR)="" ;whole file index for individual message id
"RTN","HLOF778",75,0)
 ..;
"RTN","HLOF778",76,0)
 .;if the messages are application acks, then update the original message
"RTN","HLOF778",77,0)
 .N SUBIEN S SUBIEN=0
"RTN","HLOF778",78,0)
 .F  S SUBIEN=$O(HLMSTATE("BATCH","ACK TO",SUBIEN)) Q:'SUBIEN  I $G(HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN"))]"" D
"RTN","HLOF778",79,0)
 ..N ACKTO
"RTN","HLOF778",80,0)
 ..M ACKTO=HLMSTATE("BATCH","ACK TO",SUBIEN)
"RTN","HLOF778",81,0)
 ..;
"RTN","HLOF778",82,0)
 ..;for outgoing msgs, we just created the msgid, for incoming msgs we already had it
"RTN","HLOF778",83,0)
 ..S:HLMSTATE("DIRECTION")="OUT" ACKTO("ACK BY")=HLMSTATE("HDR","BATCH CONTROL ID")_"-"_SUBIEN
"RTN","HLOF778",84,0)
 ..;
"RTN","HLOF778",85,0)
 ..D ACKTO(.HLMSTATE,.ACKTO)
"RTN","HLOF778",86,0)
 .K HLMSTATE("BATCH","ACK TO")
"RTN","HLOF778",87,0)
 ;
"RTN","HLOF778",88,0)
 ;if the msg is an app ack, update the original if not done already
"RTN","HLOF778",89,0)
 I $G(HLMSTATE("ACK TO IEN"))]"",'$G(HLMSTATE("ACK TO","DONE")) D
"RTN","HLOF778",90,0)
 .N ACKTO
"RTN","HLOF778",91,0)
 .M ACKTO=HLMSTATE("ACK TO")
"RTN","HLOF778",92,0)
 .S ACKTO("IEN")=HLMSTATE("ACK TO IEN")
"RTN","HLOF778",93,0)
 .S ACKTO("ACK BY")=$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOF778",94,0)
 .D ACKTO(.HLMSTATE,.ACKTO)
"RTN","HLOF778",95,0)
 .S HLMSTATE("ACK TO","DONE")=1 ;so the update isn't done again
"RTN","HLOF778",96,0)
 Q HLMSTATE("IEN")
"RTN","HLOF778",97,0)
 ;
"RTN","HLOF778",98,0)
NEXTMSG(HLMSTATE,MSG) ;
"RTN","HLOF778",99,0)
 ;Traverses file 777 to return the next message in the batch - as
"RTN","HLOF778",100,0)
 ;indicated by HLMSTATE("BATCH","CURRENT MESSAGE")  Set to 0 to start,
"RTN","HLOF778",101,0)
 ;returns 0 when there are no more messages
"RTN","HLOF778",102,0)
 ;
"RTN","HLOF778",103,0)
 ;Input:  HLMSTATE (pass by reference,required)
"RTN","HLOF778",104,0)
 ;Output:
"RTN","HLOF778",105,0)
 ;  HLMSTATE
"RTN","HLOF778",106,0)
 ;     ("BATCH","CURRENT MESSAGE")
"RTN","HLOF778",107,0)
 ;  MSG -pass by reference:
"RTN","HLOF778",108,0)
 ;     ("EVENT")
"RTN","HLOF778",109,0)
 ;     ("MESSAGE TYPE")
"RTN","HLOF778",110,0)
 ;
"RTN","HLOF778",111,0)
 ;
"RTN","HLOF778",112,0)
 N SUBIEN,NODE
"RTN","HLOF778",113,0)
 K MSG
"RTN","HLOF778",114,0)
 Q:'$G(HLMSTATE("BODY")) 0
"RTN","HLOF778",115,0)
 S SUBIEN=$O(^HLA(HLMSTATE("BODY"),2,HLMSTATE("BATCH","CURRENT MESSAGE")))
"RTN","HLOF778",116,0)
 Q:'SUBIEN 0
"RTN","HLOF778",117,0)
 S NODE=$G(^HLA(HLMSTATE("BODY"),2,SUBIEN,0))
"RTN","HLOF778",118,0)
 S MSG("MESSAGE TYPE")=$P(NODE,"^",2)
"RTN","HLOF778",119,0)
 S MSG("EVENT")=$P(NODE,"^",3)
"RTN","HLOF778",120,0)
 S HLMSTATE("BATCH","CURRENT MESSAGE")=SUBIEN
"RTN","HLOF778",121,0)
 Q SUBIEN
"RTN","HLOF778",122,0)
 ;
"RTN","HLOF778",123,0)
ACKTO(HLMSTATE,ACKTO) ;if this is an application ack, update the original message - but do not overlay if already valued
"RTN","HLOF778",124,0)
 ;ACKTO = (msgid of msg being ack'd)
"RTN","HLOF778",125,0)
 ;        uses these subscripts ("IEN")=ien^subien,("ACK BY")=msgid of acking msg,("STATUS")=status for the initial msg determined by the ack)
"RTN","HLOF778",126,0)
 ;
"RTN","HLOF778",127,0)
 N STATUS,IEN,SUBIEN,NODE,SKIP
"RTN","HLOF778",128,0)
 S SKIP=0
"RTN","HLOF778",129,0)
 S STATUS=$G(ACKTO("STATUS"))
"RTN","HLOF778",130,0)
 S IEN=+ACKTO("IEN"),SUBIEN=$P(ACKTO("IEN"),"^",2)
"RTN","HLOF778",131,0)
 S NODE=$G(^HLB(IEN,0))
"RTN","HLOF778",132,0)
 I 'SUBIEN D
"RTN","HLOF778",133,0)
 .;ack is to a message NOT in a batch
"RTN","HLOF778",134,0)
 .I $P(NODE,"^",7)'="",$P(NODE,"^",7)'=ACKTO("ACK BY") S SKIP=1 Q
"RTN","HLOF778",135,0)
 .I STATUS="" S STATUS="SU"
"RTN","HLOF778",136,0)
 .S $P(^HLB(IEN,0),"^",7)=ACKTO("ACK BY")
"RTN","HLOF778",137,0)
 .S $P(^HLB(IEN,0),"^",18)=1
"RTN","HLOF778",138,0)
 .S $P(^HLB(IEN,0),"^",20)=STATUS
"RTN","HLOF778",139,0)
 .S $P(^HLB(IEN,0),"^",21)=$G(ACKTO("ERROR TEXT"))
"RTN","HLOF778",140,0)
 E  D
"RTN","HLOF778",141,0)
 .;ack is to a message that IS in a batch
"RTN","HLOF778",142,0)
 .S $P(^HLB(IEN,3,SUBIEN,0),"^",4)=$G(ACKTO("ACK BY"))
"RTN","HLOF778",143,0)
 .S $P(^HLB(IEN,3,SUBIEN,0),"^",5)=STATUS
"RTN","HLOF778",144,0)
 I (STATUS="ER"),'SKIP D
"RTN","HLOF778",145,0)
 .N APP
"RTN","HLOF778",146,0)
 .S APP=HLMSTATE("HDR","RECEIVING APPLICATION")
"RTN","HLOF778",147,0)
 .I APP="" S APP="UNKNOWN"
"RTN","HLOF778",148,0)
 .S ^HLB("ERRORS",APP,$$NOW^XLFDT,ACKTO("IEN"))=""
"RTN","HLOF778",149,0)
 .;don't count the error - the app ack was already counted as an error.
"RTN","HLOF778",150,0)
 .D COUNT^HLOESTAT("IN",$G(HLMSTATE("HDR","RECEIVING APPLICATION")),$G(HLMSTATE("HDR","SENDING APPLICATION")),$S(HLMSTATE("BATCH"):"BATCH",1:$G(HLMSTATE("HDR","MESSAGE TYPE"))),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOF778",151,0)
 Q
"RTN","HLOF778A")
0^13^B76735588^B40090633
"RTN","HLOF778A",1,0)
HLOF778A ;ALB/CJM-HL7 - Saving messages to file 778 (continued) ;03/13/2012
"RTN","HLOF778A",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,137,138,158**;Oct 13, 1995;Build 14
"RTN","HLOF778A",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOF778A",4,0)
 ;
"RTN","HLOF778A",5,0)
 ;
"RTN","HLOF778A",6,0)
NEW(HLMSTATE) ;
"RTN","HLOF778A",7,0)
 ;This function creates a new entry in file 778.
"RTN","HLOF778A",8,0)
 ;Input:
"RTN","HLOF778A",9,0)
 ;   HLMSTATE (required, pass by reference) These subscripts are expected:
"RTN","HLOF778A",10,0)
 ;
"RTN","HLOF778A",11,0)
 ;Output - the function returns the ien of the newly created record
"RTN","HLOF778A",12,0)
 ;
"RTN","HLOF778A",13,0)
 N IEN,NODE,ID,STAT,RTNTN,APP
"RTN","HLOF778A",14,0)
 S STAT="HLMSTATE(""STATUS"")"
"RTN","HLOF778A",15,0)
 S IEN=$$NEWIEN(HLMSTATE("DIRECTION"),$$TCP)
"RTN","HLOF778A",16,0)
 Q:'IEN 0
"RTN","HLOF778A",17,0)
 S HLMSTATE("IEN")=IEN
"RTN","HLOF778A",18,0)
 ;
"RTN","HLOF778A",19,0)
 D  ;build the message header
"RTN","HLOF778A",20,0)
 .N HDR
"RTN","HLOF778A",21,0)
 .;for incoming messages the header segment should already exist
"RTN","HLOF778A",22,0)
 .;for outgoing messages must build the header segment
"RTN","HLOF778A",23,0)
 .I HLMSTATE("DIRECTION")="OUT" D  Q
"RTN","HLOF778A",24,0)
 ..I HLMSTATE("BATCH"),$G(HLMSTATE("ACK TO"))]"" S HLMSTATE("HDR","REFERENCE BATCH CONTROL ID")=HLMSTATE("ACK TO")
"RTN","HLOF778A",25,0)
 ..D BUILDHDR^HLOPBLD1(.HLMSTATE,$S(HLMSTATE("BATCH"):"BHS",1:"MSH"),.HDR)
"RTN","HLOF778A",26,0)
 ..S HLMSTATE("HDR",1)=HDR(1),HLMSTATE("HDR",2)=HDR(2)
"RTN","HLOF778A",27,0)
 ;
"RTN","HLOF778A",28,0)
 K ^HLB(IEN)
"RTN","HLOF778A",29,0)
 S ID=$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOF778A",30,0)
 S NODE=ID_"^"_HLMSTATE("BODY")_"^"_$G(HLMSTATE("ACK TO"))_"^"_$S(HLMSTATE("DIRECTION")="IN":"I",1:"O")_"^"
"RTN","HLOF778A",31,0)
 S $P(NODE,"^",5)=$G(@STAT@("LINK NAME"))
"RTN","HLOF778A",32,0)
 S $P(NODE,"^",6)=$G(@STAT@("QUEUE"))
"RTN","HLOF778A",33,0)
 S $P(NODE,"^",8)=$G(@STAT@("PORT"))
"RTN","HLOF778A",34,0)
 S $P(NODE,"^",20)=$G(@STAT)
"RTN","HLOF778A",35,0)
 S $P(NODE,"^",21)=$G(@STAT@("ERROR TEXT"))
"RTN","HLOF778A",36,0)
 S $P(NODE,"^",16)=HLMSTATE("DT/TM")
"RTN","HLOF778A",37,0)
 S APP=$S(HLMSTATE("DIRECTION")="OUT":HLMSTATE("HDR","SENDING APPLICATION"),1:HLMSTATE("HDR","RECEIVING APPLICATION"))
"RTN","HLOF778A",38,0)
 I HLMSTATE("BATCH") D
"RTN","HLOF778A",39,0)
 .S RTNTN=$$RTNTN^HLOAPP(APP)
"RTN","HLOF778A",40,0)
 E  D
"RTN","HLOF778A",41,0)
 .S RTNTN=$$RTNTN^HLOAPP(APP,HLMSTATE("HDR","MESSAGE TYPE"),HLMSTATE("HDR","EVENT"),HLMSTATE("HDR","VERSION"))
"RTN","HLOF778A",42,0)
 S $P(NODE,"^",22)=RTNTN
"RTN","HLOF778A",43,0)
 I HLMSTATE("BATCH"),HLMSTATE("SYSTEM","ERROR PURGE")>RTNTN S RTNTN=HLMSTATE("SYSTEM","ERROR PURGE")
"RTN","HLOF778A",44,0)
 I 'HLMSTATE("BATCH"),HLMSTATE("SYSTEM","NORMAL PURGE")>RTNTN S RTNTN=HLMSTATE("SYSTEM","NORMAL PURGE")
"RTN","HLOF778A",45,0)
 S HLMSTATE("RETENTION")=RTNTN
"RTN","HLOF778A",46,0)
 ;
"RTN","HLOF778A",47,0)
 I HLMSTATE("DIRECTION")="OUT" D
"RTN","HLOF778A",48,0)
 .S $P(NODE,"^",10)=$P($G(@STAT@("APP ACK RESPONSE")),"^")
"RTN","HLOF778A",49,0)
 .S $P(NODE,"^",11)=$P($G(@STAT@("APP ACK RESPONSE")),"^",2)
"RTN","HLOF778A",50,0)
 .S $P(NODE,"^",12)=$P($G(@STAT@("ACCEPT ACK RESPONSE")),"^")
"RTN","HLOF778A",51,0)
 .S $P(NODE,"^",13)=$P($G(@STAT@("ACCEPT ACK RESPONSE")),"^",2)
"RTN","HLOF778A",52,0)
 .S $P(NODE,"^",14)=$P($G(@STAT@("FAILURE RESPONSE")),"^")
"RTN","HLOF778A",53,0)
 .S $P(NODE,"^",15)=$P($G(@STAT@("FAILURE RESPONSE")),"^",2)
"RTN","HLOF778A",54,0)
 .;
"RTN","HLOF778A",55,0)
 .;for outgoing set these x-refs now, for incoming msgs set them later
"RTN","HLOF778A",56,0)
 .S ^HLB("B",ID,IEN)=""
"RTN","HLOF778A",57,0)
 .S ^HLB("C",HLMSTATE("BODY"),IEN)=""
"RTN","HLOF778A",58,0)
 .I ($G(@STAT)="ER") D
"RTN","HLOF778A",59,0)
 ..S ^HLB("ERRORS",$S($L($G(HLMSTATE("HDR","RECEIVING APPLICATION"))):HLMSTATE("HDR","RECEIVING APPLICATION"),1:"UNKNOWN"),HLMSTATE("DT/TM CREATED"),IEN)=""
"RTN","HLOF778A",60,0)
 ..D COUNT^HLOESTAT("OUT",$G(HLMSTATE("HDR","RECEIVING APPLICATION")),$G(HLMSTATE("HDR","SENDING APPLICATION")),$S(HLMSTATE("BATCH"):"BATCH",1:$G(HLMSTATE("HDR","MESSAGE TYPE"))),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOF778A",61,0)
 .;
"RTN","HLOF778A",62,0)
 .;save some space for the ack
"RTN","HLOF778A",63,0)
 .S:($G(HLMSTATE("HDR","ACCEPT ACK TYPE"))="AL") ^HLB(IEN,4)="^^^                                                                 "
"RTN","HLOF778A",64,0)
 I $G(HLMSTATE("STATUS","PURGE")) S $P(NODE,"^",9)=HLMSTATE("STATUS","PURGE"),^HLB("AD","OUT",HLMSTATE("STATUS","PURGE"),HLMSTATE("IEN"))=""
"RTN","HLOF778A",65,0)
 S ^HLB(IEN,0)=NODE
"RTN","HLOF778A",66,0)
 ;
"RTN","HLOF778A",67,0)
 ;store the message header
"RTN","HLOF778A",68,0)
 S ^HLB(IEN,1)=HLMSTATE("HDR",1)
"RTN","HLOF778A",69,0)
 S ^HLB(IEN,2)=HLMSTATE("HDR",2)
"RTN","HLOF778A",70,0)
 ;
"RTN","HLOF778A",71,0)
 ;if the msg is an app ack, update the original msg
"RTN","HLOF778A",72,0)
 I $G(HLMSTATE("ACK TO IEN"))]"" D
"RTN","HLOF778A",73,0)
 .N ACKTO
"RTN","HLOF778A",74,0)
 .M ACKTO=HLMSTATE("ACK TO")
"RTN","HLOF778A",75,0)
 .S ACKTO("IEN")=HLMSTATE("ACK TO IEN")
"RTN","HLOF778A",76,0)
 .S ACKTO("ACK BY")=$S(HLMSTATE("BATCH"):HLMSTATE("HDR","BATCH CONTROL ID"),1:HLMSTATE("HDR","MESSAGE CONTROL ID"))
"RTN","HLOF778A",77,0)
 .D ACKTO^HLOF778(.HLMSTATE,.ACKTO)
"RTN","HLOF778A",78,0)
 .S HLMSTATE("ACK TO","DONE")=1 ;because the update was already done, otherwise it might be done again
"RTN","HLOF778A",79,0)
 ;
"RTN","HLOF778A",80,0)
 ;The "SEARCH" x-ref will be created asynchronously
"RTN","HLOF778A",81,0)
 S ^HLTMP("PENDING SEARCH X-REF",$J,HLMSTATE("DT/TM CREATED"),IEN)=""
"RTN","HLOF778A",82,0)
 ;
"RTN","HLOF778A",83,0)
 ;sequence q?
"RTN","HLOF778A",84,0)
 I HLMSTATE("DIRECTION")="OUT",$G(@STAT@("SEQUENCE QUEUE"))'="" S ^HLB(IEN,5)=@STAT@("SEQUENCE QUEUE")
"RTN","HLOF778A",85,0)
 ;
"RTN","HLOF778A",86,0)
 Q IEN
"RTN","HLOF778A",87,0)
 ;
"RTN","HLOF778A",88,0)
NEWIEN(DIR,TCP) ;
"RTN","HLOF778A",89,0)
 ;This function uses a counter to get the next available ien for file 778. There are 4 different counters, each assigned as range of numbers, selected via the input parameters. It does not create a record.
"RTN","HLOF778A",90,0)
 ;Inputs:
"RTN","HLOF778A",91,0)
 ;  DIR = "IN" or "OUT" (required)
"RTN","HLOF778A",92,0)
 ;  TCP = 1,0 (optional)
"RTN","HLOF778A",93,0)
 ;Output - the function returns the next available ien. Several counters are used:
"RTN","HLOF778A",94,0)
 ;
"RTN","HLOF778A",95,0)
 ;   <"OUT","TCP">
"RTN","HLOF778A",96,0)
 ;   <"OUT","NOT TCP">
"RTN","HLOF778A",97,0)
 ;   <"IN","TCP">
"RTN","HLOF778A",98,0)
 ;   <"IN","NOT TCP">
"RTN","HLOF778A",99,0)
 ;
"RTN","HLOF778A",100,0)
 N IEN,COUNTER,INC
"RTN","HLOF778A",101,0)
 I DIR="OUT" S INC=$S(+$G(TCP):0,1:100000000000)
"RTN","HLOF778A",102,0)
 I DIR="IN" S INC=$S(+$G(TCP):200000000000,1:300000000000)
"RTN","HLOF778A",103,0)
 S COUNTER=$NA(^HLC("FILE778",DIR,$S(+$G(TCP):"TCP",1:"NOT TCP")))
"RTN","HLOF778A",104,0)
AGAIN ;
"RTN","HLOF778A",105,0)
 S IEN=$$INC^HLOSITE(COUNTER,1)
"RTN","HLOF778A",106,0)
 I IEN>100000000000 D
"RTN","HLOF778A",107,0)
 .L +@COUNTER:200
"RTN","HLOF778A",108,0)
 .I $T,@COUNTER>100000000000 S @COUNTER=1,IEN=1
"RTN","HLOF778A",109,0)
 .L -@COUNTER
"RTN","HLOF778A",110,0)
 I IEN>100000000000 G AGAIN
"RTN","HLOF778A",111,0)
 Q (IEN+INC)
"RTN","HLOF778A",112,0)
 ;
"RTN","HLOF778A",113,0)
TCP() ;checks the link to see if its TCP, return 1 if yes, 0 if no or not defined
"RTN","HLOF778A",114,0)
 N IEN,TCP
"RTN","HLOF778A",115,0)
 S TCP=1
"RTN","HLOF778A",116,0)
 S IEN=$G(HLMSTATE("STATUS","LINK IEN"))
"RTN","HLOF778A",117,0)
 I IEN,$P($G(^HLCS(869.1,+$P($G(^HLCS(870,IEN,0)),"^",3),0)),"^")'="TCP" S TCP=0
"RTN","HLOF778A",118,0)
 Q TCP
"RTN","HLOF778A",119,0)
 ;
"RTN","HLOF778A",120,0)
GETWORK(WORK) ; Used by the Process Manager.
"RTN","HLOF778A",121,0)
 ;Are there any messages that need the "SEARCH" x-ref set?
"RTN","HLOF778A",122,0)
 ;Inputs:
"RTN","HLOF778A",123,0)
 ;  WORK (required, pass-by-reference)
"RTN","HLOF778A",124,0)
 ;    ("DOLLARJ")
"RTN","HLOF778A",125,0)
 ;    ("NOW") (required by the process manager, pass-by-reference)
"RTN","HLOF778A",126,0)
 ;
"RTN","HLOF778A",127,0)
 L +^HLTMP("PENDING SEARCH X-REF"):0
"RTN","HLOF778A",128,0)
 Q:'$T 0
"RTN","HLOF778A",129,0)
 N OLD,DOLLARJ,SUCCESS,NOW
"RTN","HLOF778A",130,0)
 S SUCCESS=0
"RTN","HLOF778A",131,0)
 S NOW=$$SEC^XLFDT($H)
"RTN","HLOF778A",132,0)
 S (OLD,DOLLARJ)=$G(WORK("DOLLARJ"))
"RTN","HLOF778A",133,0)
 F  S DOLLARJ=$O(^HLTMP("PENDING SEARCH X-REF",DOLLARJ)) Q:DOLLARJ=""  D  Q:SUCCESS
"RTN","HLOF778A",134,0)
 .N TIME S TIME=$O(^HLTMP("PENDING SEARCH X-REF",DOLLARJ,""))
"RTN","HLOF778A",135,0)
 .S:(NOW-$$SEC^XLFDT(TIME)>10) SUCCESS=1
"RTN","HLOF778A",136,0)
 ;
"RTN","HLOF778A",137,0)
 I OLD'="",'SUCCESS F  S DOLLARJ=$O(^HLTMP("PENDING SEARCH X-REF",DOLLARJ)) Q:DOLLARJ=""  Q:DOLLARJ>OLD  D  Q:SUCCESS
"RTN","HLOF778A",138,0)
 .N TIME S TIME=$O(^HLTMP("PENDING SEARCH X-REF",DOLLARJ,""))
"RTN","HLOF778A",139,0)
 .S:(NOW-$$SEC^XLFDT(TIME)>10) SUCCESS=1
"RTN","HLOF778A",140,0)
 S WORK("DOLLARJ")=DOLLARJ,WORK("NOW")=NOW
"RTN","HLOF778A",141,0)
 Q:WORK("DOLLARJ")]"" 1
"RTN","HLOF778A",142,0)
 L -^HLTMP("PENDING SEARCH X-REF")
"RTN","HLOF778A",143,0)
 Q 0
"RTN","HLOF778A",144,0)
 ;
"RTN","HLOF778A",145,0)
DOWORK(WORK) ;Used by the Process Manager
"RTN","HLOF778A",146,0)
 ;Sets the "SEARCH" x-ref, running 10 seconds behind when the message record was created.
"RTN","HLOF778A",147,0)
 ;
"RTN","HLOF778A",148,0)
 N MSGIEN,TIME
"RTN","HLOF778A",149,0)
 S TIME=0
"RTN","HLOF778A",150,0)
 F  S TIME=$O(^HLTMP("PENDING SEARCH X-REF",WORK("DOLLARJ"),TIME)) Q:'TIME  Q:((WORK("NOW")-$$SEC^XLFDT(TIME))<10)  D
"RTN","HLOF778A",151,0)
 .S MSGIEN=0
"RTN","HLOF778A",152,0)
 .F  S MSGIEN=$O(^HLTMP("PENDING SEARCH X-REF",WORK("DOLLARJ"),TIME,MSGIEN)) Q:'MSGIEN  D
"RTN","HLOF778A",153,0)
 ..N MSG
"RTN","HLOF778A",154,0)
 ..I $$GETMSG^HLOMSG(MSGIEN,.MSG) D
"RTN","HLOF778A",155,0)
 ...Q:'MSG("DT/TM CREATED")
"RTN","HLOF778A",156,0)
 ...I MSG("BATCH") D
"RTN","HLOF778A",157,0)
 ....N HDR
"RTN","HLOF778A",158,0)
 ....F  Q:'$$NEXTMSG^HLOMSG(.MSG,.HDR)  S MSG("HDR",1)=HDR(1),MSG("HDR",2)=HDR(2) D SET(.MSG)
"RTN","HLOF778A",159,0)
 ...E  D
"RTN","HLOF778A",160,0)
 ....D SET(.MSG)
"RTN","HLOF778A",161,0)
 ..K ^HLTMP("PENDING SEARCH X-REF",WORK("DOLLARJ"),TIME,MSGIEN)
"RTN","HLOF778A",162,0)
 L -^HLTMP("PENDING SEARCH X-REF")
"RTN","HLOF778A",163,0)
 Q
"RTN","HLOF778A",164,0)
 ;
"RTN","HLOF778A",165,0)
SET(MSG) ;
"RTN","HLOF778A",166,0)
 ;sets the ^HLB("SEARCH") x-ref
"RTN","HLOF778A",167,0)
 ;
"RTN","HLOF778A",168,0)
 N APP,FS,CS,IEN
"RTN","HLOF778A",169,0)
 I MSG("DIRECTION")'="IN",MSG("DIRECTION")'="OUT" Q
"RTN","HLOF778A",170,0)
 S FS=$E(MSG("HDR",1),4)
"RTN","HLOF778A",171,0)
 Q:FS=""
"RTN","HLOF778A",172,0)
 S CS=$E(MSG("HDR",1),5)
"RTN","HLOF778A",173,0)
 S APP=$S(MSG("DIRECTION")="IN":$P($P(MSG("HDR",1),FS,5),CS),1:$P($P(MSG("HDR",1),FS,3),CS))
"RTN","HLOF778A",174,0)
 I APP="" S APP="UNKNOWN"
"RTN","HLOF778A",175,0)
 I MSG("BATCH") D
"RTN","HLOF778A",176,0)
 .N VALUE
"RTN","HLOF778A",177,0)
 .S VALUE=$P(MSG("HDR",2),FS,4)
"RTN","HLOF778A",178,0)
 .S MSG("MESSAGE TYPE")=$P(VALUE,CS)
"RTN","HLOF778A",179,0)
 .S MSG("EVENT")=$P(VALUE,CS,2)
"RTN","HLOF778A",180,0)
 S:MSG("MESSAGE TYPE")="" MSG("MESSAGE TYPE")="<none>"
"RTN","HLOF778A",181,0)
 S:MSG("EVENT")="" MSG("EVENT")="<none>"
"RTN","HLOF778A",182,0)
 S IEN=MSG("IEN")
"RTN","HLOF778A",183,0)
 I MSG("BATCH") S IEN=IEN_"^"_MSG("BATCH","CURRENT MESSAGE")
"RTN","HLOF778A",184,0)
 S ^HLB("SEARCH",MSG("DIRECTION"),MSG("DT/TM CREATED"),APP,MSG("MESSAGE TYPE"),MSG("EVENT"),IEN)=""
"RTN","HLOF778A",185,0)
 Q
"RTN","HLOF778A",186,0)
 ;
"RTN","HLOF778A",187,0)
SETPURGE(MSG,MSGSTAT,MATE,MATESTAT) ;  Set message up for purging.
"RTN","HLOF778A",188,0)
 ;Resets the purge date/time.
"RTN","HLOF778A",189,0)
 ;Input:
"RTN","HLOF778A",190,0)
 ;  MSG (required) ien of the message, file #778
"RTN","HLOF778A",191,0)
 ;  MSGSTAT (required) the status
"RTN","HLOF778A",192,0)
 ;  MATE - ien of other message if this is a two-message transaction
"RTN","HLOF778A",193,0)
 ;  MATESTAT (optional) status of mate
"RTN","HLOF778A",194,0)
 ;Output:
"RTN","HLOF778A",195,0)
 ;   Function returns 1 on success, 0 on failure
"RTN","HLOF778A",196,0)
 ;   
"RTN","HLOF778A",197,0)
 N NODE,SYSPURGE,NEWPURGE
"RTN","HLOF778A",198,0)
 Q:'$G(MSG) 0
"RTN","HLOF778A",199,0)
 S NODE=$G(^HLB(MSG,0))
"RTN","HLOF778A",200,0)
 Q:NODE="" 0
"RTN","HLOF778A",201,0)
 Q:MSGSTAT="" 0
"RTN","HLOF778A",202,0)
 D SYSPURGE^HLOSITE(.SYSPURGE)
"RTN","HLOF778A",203,0)
 ;
"RTN","HLOF778A",204,0)
 S MSG("BODY")=+$P(NODE,"^",2)
"RTN","HLOF778A",205,0)
 S MSG("BATCH")=$S(MSG("BODY"):+$P($G(^HLA(MSG("BODY"),0)),"^",2),1:0)
"RTN","HLOF778A",206,0)
 S MSG("OLD PURGE")=$P(NODE,"^",9)
"RTN","HLOF778A",207,0)
 S MSG("DIR")=$S($E($P(NODE,"^",4))="I":"IN",1:"OUT")
"RTN","HLOF778A",208,0)
 S MSG("RETENTION")=+$P(NODE,"^",22)
"RTN","HLOF778A",209,0)
 I 'MSG("RETENTION") S MSG("RETENTION")=$S(MSG("BATCH"):SYSPURGE("ERROR"),1:SYSPURGE("NORMAL"))
"RTN","HLOF778A",210,0)
 ;
"RTN","HLOF778A",211,0)
 ;
"RTN","HLOF778A",212,0)
 I MATE D  I MATE,MATESTAT="" Q 0  ;don't purge if the mate doesn't have a status!
"RTN","HLOF778A",213,0)
 .S NODE=$G(^HLB(MATE,0))
"RTN","HLOF778A",214,0)
 .I NODE="" K MATE Q
"RTN","HLOF778A",215,0)
 .S MATE("BODY")=+$P(NODE,"^",2)
"RTN","HLOF778A",216,0)
 .S MATE("BATCH")=$S(MATE("BODY"):+$P($G(^HLA(MATE("BODY"),0)),"^",2),1:0)
"RTN","HLOF778A",217,0)
 .S MATE("OLD PURGE")=$P(NODE,"^",9)
"RTN","HLOF778A",218,0)
 .S MATE("DIR")=$S($E($P(NODE,"^",4))="I":"IN",1:"OUT")
"RTN","HLOF778A",219,0)
 .S MATE("RETENTION")=+$P(NODE,"^",22)
"RTN","HLOF778A",220,0)
 .I 'MATE("RETENTION") S MATE("RETENTION")=$S(MATE("BATCH"):SYSPURGE("ERROR"),1:SYSPURGE("NORMAL"))
"RTN","HLOF778A",221,0)
 .I $G(MATESTAT)="" S MATESTAT=$P(NODE,"^",20)
"RTN","HLOF778A",222,0)
 ;
"RTN","HLOF778A",223,0)
 ;determine purge time
"RTN","HLOF778A",224,0)
 S NEWPURGE=MSG("RETENTION")
"RTN","HLOF778A",225,0)
 I MSGSTAT="ER",SYSPURGE("ERROR")>NEWPURGE S NEWPURGE=SYSPURGE("ERROR")
"RTN","HLOF778A",226,0)
 I MATE D
"RTN","HLOF778A",227,0)
 .I MATE("RETENTION")>NEWPURGE S NEWPURGE=MATE("RETENTION")
"RTN","HLOF778A",228,0)
 .I MATESTAT="ER",SYSPURGE("ERROR")>NEWPURGE S NEWPURGE=SYSPURGE("ERROR")
"RTN","HLOF778A",229,0)
 ;
"RTN","HLOF778A",230,0)
 S NEWPURGE=$$FMADD^XLFDT($$NOW^XLFDT,NEWPURGE)
"RTN","HLOF778A",231,0)
 I NEWPURGE<MSG("OLD PURGE") S NEWPURGE=MSG("OLD PURGE")
"RTN","HLOF778A",232,0)
 I NEWPURGE<$G(MATE("OLD PURGE")) S NEWPURGE=MATE("OLD PURGE")
"RTN","HLOF778A",233,0)
 I MSG("OLD PURGE"),MSG("OLD PURGE")'=NEWPURGE D
"RTN","HLOF778A",234,0)
 .K ^HLB("AD",MSG("DIR"),MSG("OLD PURGE"),MSG)
"RTN","HLOF778A",235,0)
 .S $P(^HLB(MSG,0),"^",9)=NEWPURGE,^HLB("AD",MSG("DIR"),NEWPURGE,MSG)=""
"RTN","HLOF778A",236,0)
 I MATE,MATE("OLD PURGE"),MATE("OLD PURGE")'=NEWPURGE D
"RTN","HLOF778A",237,0)
 .K ^HLB("AD",MATE("DIR"),MATE("OLD PURGE"),MATE)
"RTN","HLOF778A",238,0)
 .S $P(^HLB(MATE,0),"^",9)=NEWPURGE,^HLB("AD",MATE("DIR"),NEWPURGE,MATE)=""
"RTN","HLOF778A",239,0)
 I 'MSG("OLD PURGE") S $P(^HLB(MSG,0),"^",9)=NEWPURGE,^HLB("AD",MSG("DIR"),NEWPURGE,MSG)=""
"RTN","HLOF778A",240,0)
 I MATE,'MATE("OLD PURGE") S $P(^HLB(MATE,0),"^",9)=NEWPURGE,^HLB("AD",MATE("DIR"),NEWPURGE,MATE)=""
"RTN","HLOF778A",241,0)
 Q 1
"RTN","HLOFILER")
0^2^B27084628^B29094813
"RTN","HLOFILER",1,0)
HLOFILER ;ALB/CJM- Passes messages on the incoming queue to the applications - 10/4/94 1pm ;03/12/2012
"RTN","HLOFILER",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,131,134,137,152,158**;Oct 13, 1995;Build 14
"RTN","HLOFILER",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOFILER",4,0)
 ;
"RTN","HLOFILER",5,0)
 ;GET WORK function for the process running under the Process Manager
"RTN","HLOFILER",6,0)
GETWORK(QUE) ;
"RTN","HLOFILER",7,0)
 ;Input:
"RTN","HLOFILER",8,0)
 ;  QUE - (pass by reference) These subscripts are used:
"RTN","HLOFILER",9,0)
 ;    ("FROM") - sending facility last obtained
"RTN","HLOFILER",10,0)
 ;    ("QUEUE") - name of the queue last obtained
"RTN","HLOFILER",11,0)
 ;Output:
"RTN","HLOFILER",12,0)
 ;  Function returns 1 if success, 0 if no more work
"RTN","HLOFILER",13,0)
 ;  QUE-  updated to identify next queu of messages to process.
"RTN","HLOFILER",14,0)
 ;
"RTN","HLOFILER",15,0)
 N FROM,QUEUE
"RTN","HLOFILER",16,0)
 S FROM=$G(QUE("FROM")),QUEUE=$G(QUE("QUEUE"))
"RTN","HLOFILER",17,0)
 I ($G(FROM)]""),($G(QUEUE)]"") D
"RTN","HLOFILER",18,0)
 .L -^HLB("QUEUE","IN",FROM,QUEUE)
"RTN","HLOFILER",19,0)
 .F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0  Q:$T
"RTN","HLOFILER",20,0)
 I ($G(FROM)]""),($G(QUEUE)="") D
"RTN","HLOFILER",21,0)
 .F  S FROM=$O(^HLB("QUEUE","IN",FROM)) Q:FROM=""  D  Q:($G(QUEUE)]"")
"RTN","HLOFILER",22,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0 Q:$T
"RTN","HLOFILER",23,0)
 I FROM="" D
"RTN","HLOFILER",24,0)
 .F  S FROM=$O(^HLB("QUEUE","IN",FROM)) Q:FROM=""  D  Q:($G(QUEUE)]"")
"RTN","HLOFILER",25,0)
 ..S QUEUE="" F  S QUEUE=$O(^HLB("QUEUE","IN",FROM,QUEUE)) Q:(QUEUE="")  I '$$STOPPED^HLOQUE("IN",QUEUE) L +^HLB("QUEUE","IN",FROM,QUEUE):0 Q:$T
"RTN","HLOFILER",26,0)
 S QUE("FROM")=FROM,QUE("QUEUE")=QUEUE
"RTN","HLOFILER",27,0)
 Q:(QUEUE]"") 1
"RTN","HLOFILER",28,0)
 Q 0
"RTN","HLOFILER",29,0)
 ;
"RTN","HLOFILER",30,0)
DOWORK(QUEUE) ;passes the messages on the queue to the application
"RTN","HLOFILER",31,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOFILER"
"RTN","HLOFILER",32,0)
 ;
"RTN","HLOFILER",33,0)
 N MSGIEN,DEQUE,QUE,COUNT
"RTN","HLOFILER",34,0)
 M QUE=QUEUE
"RTN","HLOFILER",35,0)
 S (DEQUE,COUNT)=0
"RTN","HLOFILER",36,0)
 S MSGIEN=0
"RTN","HLOFILER",37,0)
 ;
"RTN","HLOFILER",38,0)
 F  S MSGIEN=$O(^HLB("QUEUE","IN",QUEUE("FROM"),QUEUE("QUEUE"),MSGIEN)) Q:'MSGIEN  S COUNT=COUNT+1 Q:COUNT>1000  D  M QUEUE=QUE
"RTN","HLOFILER",39,0)
 .N MCODE,ACTION,QUE,PURGE,ORIG,NODE,COUNT
"RTN","HLOFILER",40,0)
 .N $ETRAP,$ESTACK S $ETRAP="G ERROR2^HLOFILER"
"RTN","HLOFILER",41,0)
 .S NODE=$G(^HLB("QUEUE","IN",QUEUE("FROM"),QUEUE("QUEUE"),MSGIEN))
"RTN","HLOFILER",42,0)
 .S ACTION=$P(NODE,"^",1,2)
"RTN","HLOFILER",43,0)
 .S PURGE=$P(NODE,"^",3)
"RTN","HLOFILER",44,0)
 .S ORIG("IEN")=$P(NODE,"^",4),ORIG("ACK BY")=$P(NODE,"^",5),ORIG("STATUS")=$P(NODE,"^",6)
"RTN","HLOFILER",45,0)
 .D DEQUE(MSGIEN,PURGE,.ORIG)
"RTN","HLOFILER",46,0)
 .I ACTION]"" D
"RTN","HLOFILER",47,0)
 ..N HLMSGIEN,MCODE,DEQUE,DUZ
"RTN","HLOFILER",48,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR3^HLOFILER"
"RTN","HLOFILER",49,0)
 ..S HLMSGIEN=MSGIEN
"RTN","HLOFILER",50,0)
 ..S MCODE="D "_ACTION
"RTN","HLOFILER",51,0)
 ..N MSGIEN,X
"RTN","HLOFILER",52,0)
 ..D DUZ^XUP(.5)
"RTN","HLOFILER",53,0)
 ..X MCODE
"RTN","HLOFILER",54,0)
 ..;kill the apps variables
"RTN","HLOFILER",55,0)
 ..D
"RTN","HLOFILER",56,0)
 ...N ZTSK
"RTN","HLOFILER",57,0)
 ...D KILL^XUSCLEAN
"RTN","HLOFILER",58,0)
 ;
"RTN","HLOFILER",59,0)
ENDWORK ;where the execution resumes upon an error
"RTN","HLOFILER",60,0)
 D DEQUE()
"RTN","HLOFILER",61,0)
 Q
"RTN","HLOFILER",62,0)
 ;
"RTN","HLOFILER",63,0)
DEQUE(MSGIEN,PURGE,ORIG) ;
"RTN","HLOFILER",64,0)
 ;Dequeues the message.  Also sets up the purge indicator and the completion status.
"RTN","HLOFILER",65,0)
 S:$G(MSGIEN) DEQUE=$G(DEQUE)+1,DEQUE(MSGIEN)=PURGE_"^"_ORIG("IEN")_"^"_ORIG("ACK BY")_"^"_ORIG("STATUS")
"RTN","HLOFILER",66,0)
 I '$G(MSGIEN)!($G(DEQUE)>25) S MSGIEN=0 D
"RTN","HLOFILER",67,0)
 .F  S MSGIEN=$O(DEQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOFILER",68,0)
 ..N NODE,PURGE,ORIG
"RTN","HLOFILER",69,0)
 ..S NODE=DEQUE(MSGIEN)
"RTN","HLOFILER",70,0)
 ..S PURGE=$P(NODE,"^"),ORIG("IEN")=$P(NODE,"^",2),ORIG("ACK BY")=$P(NODE,"^",3),ORIG("STATUS")=$P(NODE,"^",4)
"RTN","HLOFILER",71,0)
 ..D DEQUE^HLOQUE(QUEUE("FROM"),QUEUE("QUEUE"),"IN",MSGIEN)
"RTN","HLOFILER",72,0)
 ..S $P(^HLB(MSGIEN,0),"^",19)=1 ;sets the flag to show that the app handoff was done
"RTN","HLOFILER",73,0)
 ..;
"RTN","HLOFILER",74,0)
 ..;update original message
"RTN","HLOFILER",75,0)
 ..I ORIG("IEN"),$D(^HLB(ORIG("IEN"),0)) D
"RTN","HLOFILER",76,0)
 ...S:$L(ORIG("ACK BY")) $P(^HLB(ORIG("IEN"),0),"^",7)=ORIG("ACK BY"),$P(^HLB(ORIG("IEN"),0),"^",18)=1
"RTN","HLOFILER",77,0)
 ...S:$L(ORIG("STATUS")) $P(^HLB(ORIG("IEN"),0),"^",20)=ORIG("STATUS")
"RTN","HLOFILER",78,0)
 ..;
"RTN","HLOFILER",79,0)
ZB2 ..D:PURGE
"RTN","HLOFILER",80,0)
 ...N STATUS
"RTN","HLOFILER",81,0)
 ...S STATUS=$P(^HLB(MSGIEN,0),"^",20)
"RTN","HLOFILER",82,0)
 ...S:STATUS="" $P(^HLB(MSGIEN,0),"^",20)="SU",STATUS="SU"
"RTN","HLOFILER",83,0)
 ...D SETPURGE^HLOF778A(MSGIEN,STATUS,ORIG("IEN"),ORIG("STATUS"))
"RTN","HLOFILER",84,0)
 .K DEQUE S DEQUE=0
"RTN","HLOFILER",85,0)
 Q
"RTN","HLOFILER",86,0)
 ;
"RTN","HLOFILER",87,0)
ERROR ;error trap
"RTN","HLOFILER",88,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOFILER",89,0)
 N HOUR
"RTN","HLOFILER",90,0)
 S HOUR=$E($$NOW^XLFDT,1,10)
"RTN","HLOFILER",91,0)
 S ^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2))=$G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))+1
"RTN","HLOFILER",92,0)
 ;
"RTN","HLOFILER",93,0)
 D DEQUE()
"RTN","HLOFILER",94,0)
 ;
"RTN","HLOFILER",95,0)
 ;a lot of errors of the same type may indicate an endless loop
"RTN","HLOFILER",96,0)
 ;return to the Process Manager error trap
"RTN","HLOFILER",97,0)
 I ($G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))>30) Q:$QUIT "" Q
"RTN","HLOFILER",98,0)
 ;
"RTN","HLOFILER",99,0)
 ;while debugging quit on all errors - returns to the Process Manager error trap
"RTN","HLOFILER",100,0)
 I $G(^HLTMP("LOG ALL ERRORS")) Q:$QUIT "" Q
"RTN","HLOFILER",101,0)
 I $ECODE["EDITED" Q:$QUIT "" Q
"RTN","HLOFILER",102,0)
 ;
"RTN","HLOFILER",103,0)
 D ^%ZTER
"RTN","HLOFILER",104,0)
 D UNWIND^%ZTER
"RTN","HLOFILER",105,0)
 Q:$QUIT ""
"RTN","HLOFILER",106,0)
 Q
"RTN","HLOFILER",107,0)
 ;
"RTN","HLOFILER",108,0)
ERROR2 ;
"RTN","HLOFILER",109,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOFILER",110,0)
 ;
"RTN","HLOFILER",111,0)
 D DEQUE()
"RTN","HLOFILER",112,0)
 ;
"RTN","HLOFILER",113,0)
 ;may need to change the status to Error
"RTN","HLOFILER",114,0)
 D
"RTN","HLOFILER",115,0)
 .N NODE,RAPP,SAPP,FS,CS,REP,ESCAPE,SUBCOMP,HDR,DIR,NOW,SYS
"RTN","HLOFILER",116,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOFILER",117,0)
 .S NOW=$$NOW^XLFDT
"RTN","HLOFILER",118,0)
 .S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOFILER",119,0)
 .Q:NODE=""
"RTN","HLOFILER",120,0)
 .Q:$P(NODE,"^",20)="ER"
"RTN","HLOFILER",121,0)
 .S $P(NODE,"^",20)="ER",$P(NODE,"^",21)="APPLICATION ROUTINE ERROR"
"RTN","HLOFILER",122,0)
 .S DIR=$S($E($P(NODE,"^",4))="I":"IN",1:"OUT")
"RTN","HLOFILER",123,0)
 .I $P(NODE,"^",9) K ^HLB("AD",DIR,$P(NODE,"^",9),MSGIEN)
"RTN","HLOFILER",124,0)
 .S $P(NODE,"^",9)=$$FMADD^XLFDT(NOW,SYS("ERROR PURGE"))
"RTN","HLOFILER",125,0)
 .S ^HLB(MSGIEN,0)=NODE
"RTN","HLOFILER",126,0)
 .S ^HLB("AD",DIR,$P(NODE,"^",9),MSGIEN)=""
"RTN","HLOFILER",127,0)
 .S HDR=$G(^HLB(MSGIEN,1))
"RTN","HLOFILER",128,0)
 .S FS=$E(HDR,4)
"RTN","HLOFILER",129,0)
 .Q:FS=""
"RTN","HLOFILER",130,0)
 .S CS=$E(HDR,5)
"RTN","HLOFILER",131,0)
 .S REP=$E(HDR,6)
"RTN","HLOFILER",132,0)
 .S ESCAPE=$E(HDR,7)
"RTN","HLOFILER",133,0)
 .S SUBCOMP=$E(HDR,8)
"RTN","HLOFILER",134,0)
 .S RAPP=$$DESCAPE^HLOPRS1($P($P(HDR,FS,5),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOFILER",135,0)
 .I RAPP="" S RAPP="UNKNOWN"
"RTN","HLOFILER",136,0)
 .S SAPP=$$DESCAPE^HLOPRS1($P($P(HDR,FS,3),CS),FS,CS,SUBCOMP,REP,ESCAPE)
"RTN","HLOFILER",137,0)
 .S ^HLB("ERRORS",RAPP,NOW,MSGIEN)=""
"RTN","HLOFILER",138,0)
 .D COUNT^HLOESTAT(DIR,RAPP,SAPP,"UNKNOWN")
"RTN","HLOFILER",139,0)
 ;
"RTN","HLOFILER",140,0)
 ;kill the apps variables
"RTN","HLOFILER",141,0)
 D
"RTN","HLOFILER",142,0)
 .N ZTSK,MSGIEN,QUEUE
"RTN","HLOFILER",143,0)
 .D KILL^XUSCLEAN
"RTN","HLOFILER",144,0)
 ;
"RTN","HLOFILER",145,0)
 ;release all the locks the app may have set, except Taskman lock
"RTN","HLOFILER",146,0)
 L:$D(ZTSK) ^%ZTSCH("TASK",ZTSK):1
"RTN","HLOFILER",147,0)
 L:'$D(ZTSK)
"RTN","HLOFILER",148,0)
 ;reset HLO's lock
"RTN","HLOFILER",149,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOFILER",150,0)
 ;return to processing the next message on the queue
"RTN","HLOFILER",151,0)
 S $ECODE=""
"RTN","HLOFILER",152,0)
 ;
"RTN","HLOFILER",153,0)
 Q:$QUIT ""
"RTN","HLOFILER",154,0)
 Q
"RTN","HLOFILER",155,0)
ERROR3 ;error trap for application context
"RTN","HLOFILER",156,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOFILER",157,0)
 D ^%ZTER
"RTN","HLOFILER",158,0)
 S $ECODE=",UAPPLICATION ERROR,"
"RTN","HLOFILER",159,0)
 ;
"RTN","HLOFILER",160,0)
 ;drop to the ERROR2 error handler
"RTN","HLOFILER",161,0)
 Q:$QUIT ""
"RTN","HLOFILER",162,0)
 Q
"RTN","HLOFILER",163,0)
 ;
"RTN","HLOFILER",164,0)
 ;
"RTN","HLOFILER",165,0)
 ;
"RTN","HLOFILER",166,0)
 ;
"RTN","HLOFILER",167,0)
 ;
"RTN","HLOP158")
0^22^B829320^n/a
"RTN","HLOP158",1,0)
HLOP158 ;ALB/CJM-Pre & Post install ;07/12/2012
"RTN","HLOP158",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**158**;Oct 13, 1995;Build 14
"RTN","HLOP158",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOP158",4,0)
 ;
"RTN","HLOP158",5,0)
PRE ;
"RTN","HLOP158",6,0)
 I $P($G(^DD(779.1,.07,0)),"^")["(HOURS)" S ^TMP("HL*1.6*158")=1
"RTN","HLOP158",7,0)
 Q
"RTN","HLOP158",8,0)
POST ;
"RTN","HLOP158",9,0)
 I $G(^TMP("HL*1.6*158")) K ^TMP("HL*1.6*158") D
"RTN","HLOP158",10,0)
 .N PURGE
"RTN","HLOP158",11,0)
 .S PURGE=$P($G(^HLD(779.1,1,0)),"^",7)
"RTN","HLOP158",12,0)
 .I PURGE S PURGE=(PURGE\24)
"RTN","HLOP158",13,0)
 .I PURGE<3 S PURGE=3
"RTN","HLOP158",14,0)
 .S $P(^HLD(779.1,1,0),"^",7)=PURGE
"RTN","HLOP158",15,0)
NOPING N IEN
"RTN","HLOP158",16,0)
 S IEN=0
"RTN","HLOP158",17,0)
 F  S IEN=$O(^HLCS(870,IEN)) Q:'IEN  D
"RTN","HLOP158",18,0)
 .N LINK
"RTN","HLOP158",19,0)
 .S LINK=$P($G(^HLCS(870,IEN,0)),"^")
"RTN","HLOP158",20,0)
 .I $E(LINK,1)="V",LINK["VIE" S $P(^HLCS(870,IEN,0),"^",24)=1
"RTN","HLOP158",21,0)
 Q
"RTN","HLOPING")
0^6^B28571657^B25888835
"RTN","HLOPING",1,0)
HLOPING ;alb/cjm HLO PING UTILITY - 10/4/94 1pm ;07/12/2012
"RTN","HLOPING",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**147,155,158**;Oct 13, 1995;Build 14
"RTN","HLOPING",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPING",4,0)
 ;
"RTN","HLOPING",5,0)
 ;
"RTN","HLOPING",6,0)
PING ;
"RTN","HLOPING",7,0)
 I '$G(DUZ) W !,"Your DUZ must be set!" Q
"RTN","HLOPING",8,0)
 N LINK,CONF,HLCSTATE,PORT,LINK,HLODONE
"RTN","HLOPING",9,0)
 S HLODONE=0
"RTN","HLOPING",10,0)
 I $P($$VERSION^%ZOSV(1),"/",1)'["Cache" D  Q
"RTN","HLOPING",11,0)
 .W !!,"   Sorry, this tool can only be used under Cache",!!
"RTN","HLOPING",12,0)
 W !,"What HL Logical Link do you want to test?"
"RTN","HLOPING",13,0)
 S LINK=$$ASKLINK^HLOUSR
"RTN","HLOPING",14,0)
 Q:LINK=""
"RTN","HLOPING",15,0)
 I $$NOPING(LINK) W !,"That link does not allowing PINGING!" D PAUSE^VALM1 Q
"RTN","HLOPING",16,0)
 S PORT=$$ASKPORT(LINK)
"RTN","HLOPING",17,0)
 Q:'PORT
"RTN","HLOPING",18,0)
 L +^HLB("QUEUE","OUT",LINK_":"_PORT,"HLOPING"_$J):1
"RTN","HLOPING",19,0)
 D STOPQUE^HLOQUE("OUT","HLOPING"_$J)
"RTN","HLOPING",20,0)
 D BREAKS
"RTN","HLOPING",21,0)
 D CHECKAPP
"RTN","HLOPING",22,0)
 I $$ADDMSG(LINK) D
"RTN","HLOPING",23,0)
 .ZB /INTERRUPT:NORMAL ;disable CTRL-C breaks
"RTN","HLOPING",24,0)
 .S WORK("QUEUE")="HLOPING"_$J,WORK("LINK")=LINK_":"_PORT
"RTN","HLOPING",25,0)
 .D DOWORK^HLOCLNT(.WORK)
"RTN","HLOPING",26,0)
 .D:$G(HLCSTATE("CONNECTED")) CLOSE^HLOT(.HLCSTATE)
"RTN","HLOPING",27,0)
 .;
"RTN","HLOPING",28,0)
 .U $PRINCIPAL
"RTN","HLOPING",29,0)
 D PURGE(LINK_":"_PORT)
"RTN","HLOPING",30,0)
 ZB /CLEAR
"RTN","HLOPING",31,0)
 L -^HLB("QUEUE","OUT",LINK_":"_PORT,"HLOPING"_$J)
"RTN","HLOPING",32,0)
 D STARTQUE^HLOQUE("OUT","HLOPING"_$J)
"RTN","HLOPING",33,0)
 Q
"RTN","HLOPING",34,0)
 ;
"RTN","HLOPING",35,0)
NOPING(LINK) ;
"RTN","HLOPING",36,0)
 N IEN,RETURN
"RTN","HLOPING",37,0)
 S RETURN=1
"RTN","HLOPING",38,0)
 S IEN=$O(^HLCS(870,"B",LINK,0))
"RTN","HLOPING",39,0)
 I IEN S RETURN=$P($G(^HLCS(870,IEN,0)),"^",24)
"RTN","HLOPING",40,0)
 Q RETURN
"RTN","HLOPING",41,0)
 ;
"RTN","HLOPING",42,0)
ASKPORT(LINK) ;
"RTN","HLOPING",43,0)
 N IEN,NODE,HLOPORT,HL7PORT,DIR,X,Y
"RTN","HLOPING",44,0)
 S IEN=$O(^HLCS(870,"B",LINK,0))
"RTN","HLOPING",45,0)
 Q:'IEN ""
"RTN","HLOPING",46,0)
 S NODE=$G(^HLCS(870,IEN,400))
"RTN","HLOPING",47,0)
 S HLOPORT=$P(NODE,"^",8)
"RTN","HLOPING",48,0)
 S:'HLOPORT HLOPORT=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5001,1:5026)
"RTN","HLOPING",49,0)
 S HL7PORT=$P(NODE,"^",2)
"RTN","HLOPING",50,0)
 S:'HL7PORT HL7PORT=$S($P($G(^HLD(779.1,1,0)),"^",3)="P":5000,1:5025)
"RTN","HLOPING",51,0)
 W !,"Do you want to PING the port used by HLO or the one used by HL7 1.6?"
"RTN","HLOPING",52,0)
 S DIR(0)="S^1:HLO     --> Port #"_HLOPORT_";2:HL7 1.6 --> Port #"_HL7PORT
"RTN","HLOPING",53,0)
 S DIR("B")=1
"RTN","HLOPING",54,0)
 D ^DIR
"RTN","HLOPING",55,0)
 Q:'X ""
"RTN","HLOPING",56,0)
 Q:$D(DUOUT) ""
"RTN","HLOPING",57,0)
 Q:X=1 HLOPORT
"RTN","HLOPING",58,0)
 Q:X=2 HL7PORT
"RTN","HLOPING",59,0)
 Q ""
"RTN","HLOPING",60,0)
ADDMSG(LINK) ;
"RTN","HLOPING",61,0)
 N PARMS,MSG,SEG,ERROR
"RTN","HLOPING",62,0)
 S PARMS("MESSAGE TYPE")="ZZZ"
"RTN","HLOPING",63,0)
 S PARMS("EVENT")="ZZZ"
"RTN","HLOPING",64,0)
 I '$$NEWMSG^HLOAPI(.PARMS,.MSG,.ERROR) W !,"ERROR",ERROR Q 0
"RTN","HLOPING",65,0)
 D SET^HLOAPI(.SEG,"NTE",0)
"RTN","HLOPING",66,0)
 D SET^HLOAPI(.SEG,"This is a PING message to test connectivity. Sender DUZ: "_$G(DUZ),1)
"RTN","HLOPING",67,0)
 I '$$ADDSEG^HLOAPI(.MSG,.SEG,.ERROR) W !,"ERROR",ERROR Q 0
"RTN","HLOPING",68,0)
 S PARMS("SENDING APPLICATION")="HLO PING CLIENT",WHOTO("RECEIVING APPLICATION")="HLO PING SERVER",WHOTO("FACILITY LINK NAME")=LINK
"RTN","HLOPING",69,0)
 S PARMS("ACCEPT ACK TYPE")="AL"
"RTN","HLOPING",70,0)
 S PARMS("APP ACK TYPE")="NE"
"RTN","HLOPING",71,0)
 S PARMS("QUEUE")="HLOPING"_$J
"RTN","HLOPING",72,0)
 I '$$SENDONE^HLOAPI1(.MSG,.PARMS,.WHOTO,.ERROR) W !,"There is a problem in the setup!",!,ERROR Q 0
"RTN","HLOPING",73,0)
 Q 1
"RTN","HLOPING",74,0)
 ;
"RTN","HLOPING",75,0)
PURGE(LINK) ;
"RTN","HLOPING",76,0)
 N IEN
"RTN","HLOPING",77,0)
 S IEN=0
"RTN","HLOPING",78,0)
 F  S IEN=$O(^HLB("QUEUE","OUT",LINK,"HLOPING"_$J,IEN)) Q:'IEN  D DEQUE^HLOQUE(LINK,"HLOPING"_$J,"OUT",IEN),SETPURGE^HLOUSR7(IEN)
"RTN","HLOPING",79,0)
 Q
"RTN","HLOPING",80,0)
 ;
"RTN","HLOPING",81,0)
BREAKS ;
"RTN","HLOPING",82,0)
 ZB /CLEAR
"RTN","HLOPING",83,0)
 ;
"RTN","HLOPING",84,0)
 ZB SEND^HLOAPI1:"N":1:"S HLMSTATE(""STATUS"",""PORT"")="_PORT
"RTN","HLOPING",85,0)
 ZB CHECKWHO^HLOASUB1:"N":1:"S WHO(""PORT"")="_PORT
"RTN","HLOPING",86,0)
 ZB ZB25^HLOASUB1:"N":1:"D ZB25^HLOPING"
"RTN","HLOPING",87,0)
 ;set break in $$STOPPED^HLOQUE to circumvent shutdown of the queue
"RTN","HLOPING",88,0)
 ZB ZB0^HLOQUE:"N":1:"S RET=0"
"RTN","HLOPING",89,0)
 ;set break in $$IFSHUT^HLOTLNK to circumvent shutdown of the link
"RTN","HLOPING",90,0)
 ZB ZB0^HLOTLNK:"N":1:"S RET=0"
"RTN","HLOPING",91,0)
 ;set break at ZB1 in client ($$CONNECT)
"RTN","HLOPING",92,0)
 ;
"RTN","HLOPING",93,0)
 ZB ZB1^HLOCLNT1:"N":1:"D WRITE^HLOPING(""Trying to connect..."")"
"RTN","HLOPING",94,0)
 ;
"RTN","HLOPING",95,0)
 ;set break at ZB2 in client (end of $$CONNECT)
"RTN","HLOPING",96,0)
 ZB ZB2^HLOCLNT1:"N":1:"D ZB2^HLOPING"
"RTN","HLOPING",97,0)
 ;
"RTN","HLOPING",98,0)
 ;set break at ZB6 in client (start of $$TRANSMIT^HLOCLNT1)
"RTN","HLOPING",99,0)
 ZB ZB6^HLOCLNT1:"N":1:"D WRITE^HLOPING(""Sending PING ..."")"
"RTN","HLOPING",100,0)
 ;set break at ZB7 in client (end of $$TRANSMIT^HLOCLNT1)
"RTN","HLOPING",101,0)
 ZB ZB7^HLOCLNT1:"N":1:"D WRITE^HLOPING(""PING sent!"")"
"RTN","HLOPING",102,0)
 ;set break at ZB8 in client (start of $$READACK^HLOCLNT1)
"RTN","HLOPING",103,0)
 ZB ZB8^HLOCLNT1:"N":1:"D WRITE^HLOPING(""Reading acknowledgment...."")"
"RTN","HLOPING",104,0)
 ;set break at ZB9 in client (end of $$READACK^HLOCLNT1)
"RTN","HLOPING",105,0)
 ;
"RTN","HLOPING",106,0)
 ZB ZB9^HLOCLNT1:"N":1:"D ZB9^HLOPING"
"RTN","HLOPING",107,0)
 ;
"RTN","HLOPING",108,0)
 ;set break at ZB4 in client (FOR loop on the outgoing queue)
"RTN","HLOPING",109,0)
 ZB ZB4^HLOCLNT:"N":1:"S SUCCESS=0 I 'HLODONE S (SUCCESS,HLODONE)=1"
"RTN","HLOPING",110,0)
 ;
"RTN","HLOPING",111,0)
 ;set status to SU so that the PING doesn't appear on the error report
"RTN","HLOPING",112,0)
 ZB ZB22^HLOCLNT:"N":1:"S $P(UPDATE,""^"",3)=""SU"",$P(UPDATE,""^"",4)=1"
"RTN","HLOPING",113,0)
 ;
"RTN","HLOPING",114,0)
 ZB ZB24^HLOCLNT1:"N":1:"D ZB24^HLOPING"
"RTN","HLOPING",115,0)
 ZB ZB27^HLOT:"N":1:"D ZB27^HLOPING"
"RTN","HLOPING",116,0)
 ;
"RTN","HLOPING",117,0)
 ;set break at ZB3 in client (ERROR TRAP)
"RTN","HLOPING",118,0)
 ZB ZB3^HLOCLNT:"N":1:"D ZB3^HLOPING"
"RTN","HLOPING",119,0)
 Q
"RTN","HLOPING",120,0)
 ;
"RTN","HLOPING",121,0)
CHECKAPP ;
"RTN","HLOPING",122,0)
 I '$O(^HLD(779.2,"C","HLO PING CLIENT",0)) D
"RTN","HLOPING",123,0)
 .N DATA,ERROR
"RTN","HLOPING",124,0)
 .S DATA(.01)="HLO PING CLIENT"
"RTN","HLOPING",125,0)
 .D ADD^HLOASUB1(779.2,,.DATA)
"RTN","HLOPING",126,0)
 Q
"RTN","HLOPING",127,0)
WRITE(MSG) ;
"RTN","HLOPING",128,0)
 N OLD
"RTN","HLOPING",129,0)
 S OLD=$IO
"RTN","HLOPING",130,0)
 U $PRINCIPAL
"RTN","HLOPING",131,0)
 W !,MSG
"RTN","HLOPING",132,0)
 U OLD
"RTN","HLOPING",133,0)
 Q
"RTN","HLOPING",134,0)
ZB2 ;
"RTN","HLOPING",135,0)
 D WRITE($S('HLCSTATE("CONNECTED"):"Unable to Connect!",1:"Connected!"))
"RTN","HLOPING",136,0)
 ;!!!!!!!!!!!!
"RTN","HLOPING",137,0)
 ;F I=1:1:15 H 1
"RTN","HLOPING",138,0)
 Q
"RTN","HLOPING",139,0)
ZB3 ;
"RTN","HLOPING",140,0)
 N CON,MSG
"RTN","HLOPING",141,0)
 S CON=($ZA\8192#2)
"RTN","HLOPING",142,0)
 S MSG="Error encountered, $ECODE="_$ECODE
"RTN","HLOPING",143,0)
 D WRITE(MSG)
"RTN","HLOPING",144,0)
 S MSG=$S(CON:"           TCP connection still active",1:"          TCP connection was dropped")
"RTN","HLOPING",145,0)
 D WRITE(MSG)
"RTN","HLOPING",146,0)
 D ^%ZTER
"RTN","HLOPING",147,0)
 Q
"RTN","HLOPING",148,0)
ZB9 ;
"RTN","HLOPING",149,0)
 I $G(SUCCESS) D
"RTN","HLOPING",150,0)
 .D WRITE("Acknowledgment received!")
"RTN","HLOPING",151,0)
 E  D
"RTN","HLOPING",152,0)
 .D WRITE("Acknowledgment NOT returned!")
"RTN","HLOPING",153,0)
 ;!!!!!!!!!!!!
"RTN","HLOPING",154,0)
 ;H 50
"RTN","HLOPING",155,0)
 Q
"RTN","HLOPING",156,0)
ZB24 ;
"RTN","HLOPING",157,0)
 S HLCSTATE("LINK","SHUTDOWN")=0
"RTN","HLOPING",158,0)
 Q
"RTN","HLOPING",159,0)
ZB25 ;
"RTN","HLOPING",160,0)
 I '$L(PARMS("RECEIVING FACILITY",2)),'PARMS("RECEIVING FACILITY",1) S PARMS("RECEIVING FACILITY",2)="REMOTE FACILITY TO PING"
"RTN","HLOPING",161,0)
 Q
"RTN","HLOPING",162,0)
 ;
"RTN","HLOPING",163,0)
ZB27 ;
"RTN","HLOPING",164,0)
 Q:'$G(HLCSTATE("LOCK FAILED"))
"RTN","HLOPING",165,0)
 D WRITE("Remote server is single threaded and is locked by another process!")
"RTN","HLOPING",166,0)
 Q
"RTN","HLOPROC")
0^14^B28479466^B28480069
"RTN","HLOPROC",1,0)
HLOPROC ;ALB/CJM- Generic HL7 Process - 10/4/94 1pm ;03/26/2012
"RTN","HLOPROC",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,146,147,158**;Oct 13, 1995;Build 14
"RTN","HLOPROC",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOPROC",4,0)
 ;
"RTN","HLOPROC",5,0)
PROCESS ;queued entry point
"RTN","HLOPROC",6,0)
 ;
"RTN","HLOPROC",7,0)
 ;insure just one process manager
"RTN","HLOPROC",8,0)
 I PROCNAME="PROCESS MANAGER" N RUNNING L +^HLTMP(PROCNAME):1 S RUNNING='$T D  Q:RUNNING
"RTN","HLOPROC",9,0)
 .I 'RUNNING D
"RTN","HLOPROC",10,0)
 ..D SETNM^%ZOSV($E("HLOmgr:"_$J,1,17))
"RTN","HLOPROC",11,0)
 .E  D
"RTN","HLOPROC",12,0)
 ..L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",13,0)
 ..K:$D(ZTSK) ^HLTMP("HL7 QUEUED PROCESSES",ZTSK)
"RTN","HLOPROC",14,0)
 ..S ^HLC("HL7 PROCESS COUNTS","RUNNING","PROCESS MANAGER")=1
"RTN","HLOPROC",15,0)
 ..S ^HLC("HL7 PROCESS COUNTS","QUEUED","PROCESS MANAGER")=0
"RTN","HLOPROC",16,0)
 ..L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",17,0)
 ..S ZTREQ="@"
"RTN","HLOPROC",18,0)
 ;
"RTN","HLOPROC",19,0)
 ;invoke the framework process
"RTN","HLOPROC",20,0)
 D HL7PROC(PROCNAME)
"RTN","HLOPROC",21,0)
 ;
"RTN","HLOPROC",22,0)
 I PROCNAME="PROCESS MANAGER" L -^HLTMP(PROCNAME)
"RTN","HLOPROC",23,0)
 S ZTREQ="@"
"RTN","HLOPROC",24,0)
 Q
"RTN","HLOPROC",25,0)
 ;
"RTN","HLOPROC",26,0)
HL7PROC(PROCNAME) ;
"RTN","HLOPROC",27,0)
 ;This is the generic HL7 process used by all processes started under the HL7 Process Manager
"RTN","HLOPROC",28,0)
 ;Input:
"RTN","HLOPROC",29,0)
 ;  PROCNAME - the name of a process found in the HL7 Process Registry
"RTN","HLOPROC",30,0)
 ;  OUTPUT - none
"RTN","HLOPROC",31,0)
 ;
"RTN","HLOPROC",32,0)
 N PROCESS,HL7STOP,WORK
"RTN","HLOPROC",33,0)
 ;
"RTN","HLOPROC",34,0)
 S ^HL7TMP("HL7 PROCESS NAME",$J)=PROCNAME
"RTN","HLOPROC",35,0)
 ;
"RTN","HLOPROC",36,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",37,0)
 I $D(ZTQUEUED) D
"RTN","HLOPROC",38,0)
 .K:$D(ZTSK) ^HLTMP("HL7 QUEUED PROCESSES",ZTSK)
"RTN","HLOPROC",39,0)
 .I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","QUEUED",PROCNAME)))
"RTN","HLOPROC",40,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOPROC",41,0)
 I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)))
"RTN","HLOPROC",42,0)
 S ^HLTMP("HL7 RUNNING PROCESSES",$J)=$H_"^"_$G(ZTSK)_"^"_PROCNAME
"RTN","HLOPROC",43,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",44,0)
 ;
"RTN","HLOPROC",45,0)
 ;
"RTN","HLOPROC",46,0)
 I $$GETPROC(PROCNAME,.PROCESS),'$$CHK4STOP(.PROCESS) D
"RTN","HLOPROC",47,0)
 .S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",48,0)
 .;
"RTN","HLOPROC",49,0)
 .;should this task be made persistent?
"RTN","HLOPROC",50,0)
 .I PROCESS("PERSISTENT"),$G(ZTQUEUED),$$PSET^%ZTLOAD(ZTQUEUED)
"RTN","HLOPROC",51,0)
 .;
"RTN","HLOPROC",52,0)
 .S HL7STOP=0
"RTN","HLOPROC",53,0)
 .F  D  Q:HL7STOP
"RTN","HLOPROC",54,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOPROC"
"RTN","HLOPROC",55,0)
 ..N HL7TRIES,GOTWORK
"RTN","HLOPROC",56,0)
 ..F HL7TRIES=1:1 D  Q:GOTWORK  Q:$G(HL7STOP)
"RTN","HLOPROC",57,0)
 ...S GOTWORK=$$GETWORK(.PROCESS,.WORK)
"RTN","HLOPROC",58,0)
 ...Q:GOTWORK
"RTN","HLOPROC",59,0)
 ...;since there is no work, don't want another process starting
"RTN","HLOPROC",60,0)
 ...S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",61,0)
 ...H PROCESS("HANG")
"RTN","HLOPROC",62,0)
 ...S HL7STOP=$$CHK4STOP(.PROCESS,HL7TRIES)
"RTN","HLOPROC",63,0)
 ..Q:$G(HL7STOP)
"RTN","HLOPROC",64,0)
 ..I GOTWORK D DOWORK(.PROCESS,.WORK) S HL7TRIES=0
"RTN","HLOPROC",65,0)
 ..S:'$G(HL7STOP) HL7STOP=$$CHK4STOP(.PROCESS,.HL7TRIES)
"RTN","HLOPROC",66,0)
 ;
"RTN","HLOPROC",67,0)
 S $P(^HLD(779.3,PROCESS("IEN"),0),"^",6)=$$NOW^XLFDT
"RTN","HLOPROC",68,0)
 ;
"RTN","HLOPROC",69,0)
END ;
"RTN","HLOPROC",70,0)
 S HL7STOP=1
"RTN","HLOPROC",71,0)
 K ^HL7TMP("HL7 PROCESS NAME",$J)
"RTN","HLOPROC",72,0)
 L +HL7("COUNTING PROCESSES"):20
"RTN","HLOPROC",73,0)
 K ^HLTMP("HL7 RUNNING PROCESSES",$J)
"RTN","HLOPROC",74,0)
 I $$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCNAME)),1)
"RTN","HLOPROC",75,0)
 L -^HLTMP("HL7 RUNNING PROCESSES",$J)
"RTN","HLOPROC",76,0)
 L -HL7("COUNTING PROCESSES")
"RTN","HLOPROC",77,0)
 K ^TMP("HL7 ERRORS",$J)
"RTN","HLOPROC",78,0)
 ;
"RTN","HLOPROC",79,0)
 Q
"RTN","HLOPROC",80,0)
 ;
"RTN","HLOPROC",81,0)
ERROR ;error trap
"RTN","HLOPROC",82,0)
 ;
"RTN","HLOPROC",83,0)
 S $ETRAP="Q:$QUIT """" Q"
"RTN","HLOPROC",84,0)
 ;
"RTN","HLOPROC",85,0)
 ;quit back to the Taskman error trap on these errors
"RTN","HLOPROC",86,0)
 I ($ECODE["TOOMANYFILES")!($ECODE["EDITED") D  Q:$QUIT "" Q
"RTN","HLOPROC",87,0)
 .S:'$D(PROCNAME) PROCNAME=$G(^HL7TMP("HL7 PROCESS NAME",$J))
"RTN","HLOPROC",88,0)
 .D END
"RTN","HLOPROC",89,0)
 .D UNWIND^%ZTER
"RTN","HLOPROC",90,0)
 ;
"RTN","HLOPROC",91,0)
 ;don't log READ/WRITE errors unless logging is turned on, but do resume
"RTN","HLOPROC",92,0)
 ;execution
"RTN","HLOPROC",93,0)
 I '$G(^HLTMP("LOG ALL ERRORS")),($ECODE["READ")!($ECODE["NOTOPEN")!($ECODE["DEVNOTOPN")!($ECODE["WRITE")!($ECODE["OPENERR") D  Q:$QUIT "" Q
"RTN","HLOPROC",94,0)
 .S $ECODE=""
"RTN","HLOPROC",95,0)
 ;
"RTN","HLOPROC",96,0)
 ;add to the process's count for the type of error
"RTN","HLOPROC",97,0)
 N HOUR
"RTN","HLOPROC",98,0)
 S HOUR=$E($$NOW^XLFDT,1,10)
"RTN","HLOPROC",99,0)
 S ^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2))=$G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))+1
"RTN","HLOPROC",100,0)
 ;
"RTN","HLOPROC",101,0)
 ;a lot of errors of the same type may indicate an endless loop, so quit
"RTN","HLOPROC",102,0)
 ;to Taskman error trap to be on the safe side.
"RTN","HLOPROC",103,0)
 I $G(^TMP("HL7 ERRORS",$J,HOUR,$P($ECODE,",",2)))>30 D  Q:$QUIT "" Q
"RTN","HLOPROC",104,0)
 .S:'$D(PROCNAME) PROCNAME=$G(^HL7TMP("HL7 PROCESS NAME",$J))
"RTN","HLOPROC",105,0)
 .D END
"RTN","HLOPROC",106,0)
 .D UNWIND^%ZTER
"RTN","HLOPROC",107,0)
 ;
"RTN","HLOPROC",108,0)
 ;can log error and continue processing
"RTN","HLOPROC",109,0)
 D ^%ZTER
"RTN","HLOPROC",110,0)
 S $ECODE=""
"RTN","HLOPROC",111,0)
 Q:$QUIT "" Q
"RTN","HLOPROC",112,0)
 ;
"RTN","HLOPROC",113,0)
GETPROC(PROCNAME,PROCESS) ;
"RTN","HLOPROC",114,0)
 ;using PROCNAME to find the entry in the HL7 Process Registry, returns the entry as a subscripted array in .PROCESS
"RTN","HLOPROC",115,0)
 ;
"RTN","HLOPROC",116,0)
 ;Output: Function returns 0 on failure, 1 on success
"RTN","HLOPROC",117,0)
 ;
"RTN","HLOPROC",118,0)
 N IEN,NODE
"RTN","HLOPROC",119,0)
 S IEN=$O(^HLD(779.3,"B",PROCNAME,0))
"RTN","HLOPROC",120,0)
 Q:'IEN 0
"RTN","HLOPROC",121,0)
 S PROCESS("NAME")=PROCNAME
"RTN","HLOPROC",122,0)
 S PROCESS("IEN")=IEN
"RTN","HLOPROC",123,0)
 S NODE=$G(^HLD(779.3,IEN,0))
"RTN","HLOPROC",124,0)
 S PROCESS("MINIMUM")=+$P(NODE,"^",3)
"RTN","HLOPROC",125,0)
 S PROCESS("MAXIMUM")=+$P(NODE,"^",4)
"RTN","HLOPROC",126,0)
 S PROCESS("HANG")=+$P(NODE,"^",7)
"RTN","HLOPROC",127,0)
 I 'PROCESS("HANG") S PROCESS("HANG")=1
"RTN","HLOPROC",128,0)
 S PROCESS("GET WORK")=$P(NODE,"^",8,9)
"RTN","HLOPROC",129,0)
 S PROCESS("DO WORK")=$P(NODE,"^",10,11)
"RTN","HLOPROC",130,0)
 S PROCESS("MAX TRIES")=$P(NODE,"^",12)
"RTN","HLOPROC",131,0)
 I 'PROCESS("MAX TRIES") S PROCESS("MAX TRIES")=999
"RTN","HLOPROC",132,0)
 S PROCESS("PERSISTENT")=+$P(NODE,"^",13)
"RTN","HLOPROC",133,0)
 S PROCESS("LINK")=$P(NODE,"^",14)
"RTN","HLOPROC",134,0)
 Q 1
"RTN","HLOPROC",135,0)
 ;
"RTN","HLOPROC",136,0)
GETWORK(PROCESS,WORK) ;
"RTN","HLOPROC",137,0)
 N RETURN,XECUTE
"RTN","HLOPROC",138,0)
 I PROCESS("LINK")]"" S WORK("LINK")=PROCESS("LINK")
"RTN","HLOPROC",139,0)
 S XECUTE="S RETURN=$$"_PROCESS("GET WORK")_"(.WORK)"
"RTN","HLOPROC",140,0)
 D
"RTN","HLOPROC",141,0)
 .N PROCESS
"RTN","HLOPROC",142,0)
 .X XECUTE
"RTN","HLOPROC",143,0)
 Q RETURN
"RTN","HLOPROC",144,0)
 ;
"RTN","HLOPROC",145,0)
DOWORK(PROCESS,WORK) ;
"RTN","HLOPROC",146,0)
 N XECUTE
"RTN","HLOPROC",147,0)
 M PARMS=WORK
"RTN","HLOPROC",148,0)
 S XECUTE="D "_PROCESS("DO WORK")_"(.WORK)"
"RTN","HLOPROC",149,0)
 D
"RTN","HLOPROC",150,0)
 .N PROCESS,HL7TRIES,PARMS,PROCNAME
"RTN","HLOPROC",151,0)
 .X XECUTE
"RTN","HLOPROC",152,0)
 M WORK=PARMS
"RTN","HLOPROC",153,0)
 Q
"RTN","HLOPROC",154,0)
 ;
"RTN","HLOPROC",155,0)
CHK4STOP(PROCESS,HL7TRIES) ;
"RTN","HLOPROC",156,0)
 ;Determines if the process should stop, returns 1 if yes, 0 if no
"RTN","HLOPROC",157,0)
 ;
"RTN","HLOPROC",158,0)
 Q:$$CHKSTOP 1
"RTN","HLOPROC",159,0)
 Q:'$P($G(^HLD(779.3,PROCESS("IEN"),0)),"^",2) 1
"RTN","HLOPROC",160,0)
 I $G(HL7TRIES)>(PROCESS("MAX TRIES")-1),PROCESS("MINIMUM")<$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCESS("NAME"))) Q 1
"RTN","HLOPROC",161,0)
 Q:$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROCESS("NAME")))>PROCESS("MAXIMUM") 1
"RTN","HLOPROC",162,0)
 Q 0
"RTN","HLOPROC",163,0)
 ;
"RTN","HLOPROC",164,0)
CHKSTOP() ;has HL7 been requested to stop?
"RTN","HLOPROC",165,0)
 N RET
"RTN","HLOPROC",166,0)
 ;** P146 START CJM
"RTN","HLOPROC",167,0)
 ;Q '$P($G(^HLD(779.1,1,0)),"^",9)
"RTN","HLOPROC",168,0)
 S RET='$P($G(^HLD(779.1,1,0)),"^",9)
"RTN","HLOPROC",169,0)
ZB25 ;
"RTN","HLOPROC",170,0)
 Q RET
"RTN","HLOPROC",171,0)
 ;**P146 END CJM
"RTN","HLOQUE")
0^5^B154240206^B153912092
"RTN","HLOQUE",1,0)
HLOQUE ;ALB/CJM/OAK/PIJ/RBN- HL7 QUEUE MANAGEMENT - 10/4/94 1pm ;03/07/2012
"RTN","HLOQUE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,132,134,137,138,143,147,153,158**;Oct 13, 1995;Build 14
"RTN","HLOQUE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOQUE",4,0)
 ;
"RTN","HLOQUE",5,0)
INQUE(FROM,QNAME,IEN778,ACTION,PURGE,ORIG) ;
"RTN","HLOQUE",6,0)
 ;Will place the message=IEN778 on the IN queue, incoming
"RTN","HLOQUE",7,0)
 ;Input:
"RTN","HLOQUE",8,0)
 ;  FROM - sending facility from message header.
"RTN","HLOQUE",9,0)
 ;         For actions other than incoming messages, its the specified link.
"RTN","HLOQUE",10,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",11,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",12,0)
 ;  ACTION - <tag^routine> that should be executed for the application
"RTN","HLOQUE",13,0)
 ;  PURGE (optional) - +PURGE>0 indicates that the purge dt/tm needs to be set by the infiler. 
"RTN","HLOQUE",14,0)
 ;  ORIG - (optional, pass by reference)
"RTN","HLOQUE",15,0)
 ;     If ORIG("IEN") is set, it indicates that the the incomming message was an app ack, and the original message needs to be updated with the purge dtate, status (ORIG("STATUS")), and the msgid of the original (ORIG("ACK BY"))
"RTN","HLOQUE",16,0)
 ;Output: none
"RTN","HLOQUE",17,0)
 ;
"RTN","HLOQUE",18,0)
 N FLG
"RTN","HLOQUE",19,0)
ZB36 I $G(FROM)="" S FROM="UNKNOWN"
"RTN","HLOQUE",20,0)
 I $$RCNT^HLOSITE L +RECOUNT("IN",FROM,QNAME):20 S:$T FLG=1
"RTN","HLOQUE",21,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",22,0)
 S ^HLB("QUEUE","IN",FROM,QNAME,IEN778)=ACTION_"^"_$G(PURGE)_"^"_$G(ORIG("IEN"))_"^"_$G(ORIG("ACK BY"))_"^"_$G(ORIG("STATUS"))
"RTN","HLOQUE",23,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","IN",FROM,QNAME)))
"RTN","HLOQUE",24,0)
 L:$G(FLG) -RECOUNT("IN",FROM,QNAME)
"RTN","HLOQUE",25,0)
 Q
"RTN","HLOQUE",26,0)
 ;
"RTN","HLOQUE",27,0)
OUTQUE(LINKNAME,PORT,QNAME,IEN778) ;
"RTN","HLOQUE",28,0)
 ;Will place the message=IEN778 on the out-going queue
"RTN","HLOQUE",29,0)
 ;Input:
"RTN","HLOQUE",30,0)
 ;  LINKNAME = name of (.01) the logical link
"RTN","HLOQUE",31,0)
 ;  PORT (optional) the port to connect to
"RTN","HLOQUE",32,0)
 ;  QNAME - queue named by the application
"RTN","HLOQUE",33,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",34,0)
 ;Output: none
"RTN","HLOQUE",35,0)
 ;
"RTN","HLOQUE",36,0)
 ;
"RTN","HLOQUE",37,0)
 N SUB,FLG
"RTN","HLOQUE",38,0)
 S SUB=LINKNAME
"RTN","HLOQUE",39,0)
 I PORT S SUB=SUB_":"_PORT
"RTN","HLOQUE",40,0)
 I '$L($G(QNAME)) S QNAME="DEFAULT"
"RTN","HLOQUE",41,0)
 ;***Start HL*1.6*138 PIJ
"RTN","HLOQUE",42,0)
 ;if recount in progress, give it up to 20 seconds to finish - if it takes longer than that the recount won't be exact, but a longer delay is unreasonable
"RTN","HLOQUE",43,0)
 I $$RCNT^HLOSITE L +RECOUNT("OUT",SUB,QNAME):20 S:$T FLG=1
"RTN","HLOQUE",44,0)
 ;***End HL*1.6*138 PIJ"
"RTN","HLOQUE",45,0)
 S ^HLB("QUEUE","OUT",SUB,QNAME,IEN778)=""
"RTN","HLOQUE",46,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","OUT",SUB,QNAME)))
"RTN","HLOQUE",47,0)
 L:$G(FLG) -RECOUNT("OUT",SUB,QNAME)
"RTN","HLOQUE",48,0)
 Q
"RTN","HLOQUE",49,0)
 ;
"RTN","HLOQUE",50,0)
DEQUE(FROMORTO,QNAME,DIR,IEN778) ;
"RTN","HLOQUE",51,0)
 ;This routine will remove the message=IEN778 from its queue
"RTN","HLOQUE",52,0)
 ;Input:
"RTN","HLOQUE",53,0)
 ;  DIR = "IN" or "OUT", denoting the direction that the message is going in
"RTN","HLOQUE",54,0)
 ;  FROMORTO = for outgoing: the .01 field of the logical link
"RTN","HLOQUE",55,0)
 ;         for incoming: sending facility
"RTN","HLOQUE",56,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",57,0)
 ;Output: none
"RTN","HLOQUE",58,0)
 ;
"RTN","HLOQUE",59,0)
 Q:(FROMORTO="")
"RTN","HLOQUE",60,0)
 I ($G(QNAME)="") S QNAME="DEFAULT"
"RTN","HLOQUE",61,0)
 D
"RTN","HLOQUE",62,0)
 .I $E(DIR)="I" S DIR="IN" Q
"RTN","HLOQUE",63,0)
 .I $E(DIR)="O" S DIR="OUT" Q
"RTN","HLOQUE",64,0)
 I DIR'="IN",DIR'="OUT" Q
"RTN","HLOQUE",65,0)
 Q:'$G(IEN778)
"RTN","HLOQUE",66,0)
 D:$D(^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778))
"RTN","HLOQUE",67,0)
 .N FLG
"RTN","HLOQUE",68,0)
 .I $$RCNT^HLOSITE L +RECOUNT(DIR,FROMORTO,QNAME):20 S:$T FLG=1
"RTN","HLOQUE",69,0)
 .K ^HLB("QUEUE",DIR,FROMORTO,QNAME,IEN778)
"RTN","HLOQUE",70,0)
 .;don't let the count become negative
"RTN","HLOQUE",71,0)
 .I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT",DIR,FROMORTO,QNAME)),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT",DIR,FROMORTO,QNAME)))
"RTN","HLOQUE",72,0)
 .L:$G(FLG) -RECOUNT(DIR,FROMORTO,QNAME)
"RTN","HLOQUE",73,0)
 Q
"RTN","HLOQUE",74,0)
 ;
"RTN","HLOQUE",75,0)
STOPQUE(DIR,QUEUE) ;
"RTN","HLOQUE",76,0)
 ;This API is used to set a stop flag on a named queue.
"RTN","HLOQUE",77,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",78,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",79,0)
 ;
"RTN","HLOQUE",80,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",81,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",82,0)
 S ^HLTMP("STOPPED QUEUES",DIR,QUEUE)=1
"RTN","HLOQUE",83,0)
 Q
"RTN","HLOQUE",84,0)
STARTQUE(DIR,QUEUE) ;
"RTN","HLOQUE",85,0)
 ;This API is used to REMOVE the stop flag on a named queue.
"RTN","HLOQUE",86,0)
 ;DIR=<"IN" or "OUT">
"RTN","HLOQUE",87,0)
 ;QUEUE - the name of the queue to be stopped
"RTN","HLOQUE",88,0)
 ;
"RTN","HLOQUE",89,0)
 Q:$G(DIR)=""
"RTN","HLOQUE",90,0)
 Q:$G(QUEUE)=""
"RTN","HLOQUE",91,0)
 K ^HLTMP("STOPPED QUEUES",DIR,QUEUE)
"RTN","HLOQUE",92,0)
 Q
"RTN","HLOQUE",93,0)
STOPPED(DIR,QUEUE) ;
"RTN","HLOQUE",94,0)
 ;This API is used to DETERMINE if the stop flag on a named queue is set.
"RTN","HLOQUE",95,0)
 ;Input:
"RTN","HLOQUE",96,0)
 ;  DIR=<"IN" or "OUT">
"RTN","HLOQUE",97,0)
 ;  QUEUE - the name of the queue to be checked
"RTN","HLOQUE",98,0)
 ;Output:
"RTN","HLOQUE",99,0)
 ;  Function returns 1 if the queue is stopped, 0 otherwise
"RTN","HLOQUE",100,0)
 N RET
"RTN","HLOQUE",101,0)
 S RET=0
"RTN","HLOQUE",102,0)
 Q:$G(DIR)="" 0
"RTN","HLOQUE",103,0)
 Q:$G(QUEUE)="" 0
"RTN","HLOQUE",104,0)
 S:$G(^HLTMP("STOPPED QUEUES",DIR,QUEUE)) RET=1
"RTN","HLOQUE",105,0)
ZB0 Q RET
"RTN","HLOQUE",106,0)
 ;
"RTN","HLOQUE",107,0)
SQUE(SQUE,LINKNAME,PORT,QNAME,IEN778) ;
"RTN","HLOQUE",108,0)
 ;Will place the message=IEN778 on the sequencing queue. This is always done in the context of the application calling an HLO API to send a message.
"RTN","HLOQUE",109,0)
 ;Input:
"RTN","HLOQUE",110,0)
 ;  SQUE - name of the sequencing queue
"RTN","HLOQUE",111,0)
 ;  LINKNAME = name of (.01) the logical link
"RTN","HLOQUE",112,0)
 ;  PORT (optional) the port to connect to
"RTN","HLOQUE",113,0)
 ;  QNAME (optional) outgoing queue
"RTN","HLOQUE",114,0)
 ;  IEN778 = ien of the message in file 778
"RTN","HLOQUE",115,0)
 ;Output: 1 if placed on the outgoing queue, 0 if placed on the sequence queue
"RTN","HLOQUE",116,0)
 ;
"RTN","HLOQUE",117,0)
 N NEXT,MOVED,FLG
"RTN","HLOQUE",118,0)
 S MOVED=0
"RTN","HLOQUE",119,0)
 ;
"RTN","HLOQUE",120,0)
 ;keep a count of messages pending on sequence queues for the HLO System Monitor
"RTN","HLOQUE",121,0)
 ;
"RTN","HLOQUE",122,0)
 ;***Start HL*1.6*138 PIJ
"RTN","HLOQUE",123,0)
 ;if recount in progress, pause up to 20 seconds to finish - if it takes longer than that the recount won't be exact, but a longer delay is unreasonable
"RTN","HLOQUE",124,0)
 I $$RCNT^HLOSITE L +RECOUNT("SEQUENCE",SQUE):20 S:$T FLG=1
"RTN","HLOQUE",125,0)
 ;***End HL*1.6*138 PIJ
"RTN","HLOQUE",126,0)
 ;
"RTN","HLOQUE",127,0)
 ;** START 143 CJM
"RTN","HLOQUE",128,0)
 L +^HLB("QUEUE","SEQUENCE",SQUE):200
"RTN","HLOQUE",129,0)
 ;** END 143 CJM
"RTN","HLOQUE",130,0)
 ;
"RTN","HLOQUE",131,0)
 S NEXT=+$G(^HLB("QUEUE","SEQUENCE",SQUE))
"RTN","HLOQUE",132,0)
 I NEXT=IEN778 L -^HLB("QUEUE","SEQUENCE",SQUE) Q 0  ;already queued!
"RTN","HLOQUE",133,0)
 ;
"RTN","HLOQUE",134,0)
 ;increment the counter for all sequence queues
"RTN","HLOQUE",135,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")))
"RTN","HLOQUE",136,0)
 ;
"RTN","HLOQUE",137,0)
 ;*** Start HL*1.6*138 CJM
"RTN","HLOQUE",138,0)
 ;also keep counter for the individual queue
"RTN","HLOQUE",139,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)))
"RTN","HLOQUE",140,0)
 ;*** End HL*1.6*138 CJM
"RTN","HLOQUE",141,0)
 ;
"RTN","HLOQUE",142,0)
 ;** START 143 CJM
"RTN","HLOQUE",143,0)
 ;L +^HLB("QUEUE","SEQUENCE",SQUE):200
"RTN","HLOQUE",144,0)
 ;** END 143 CJM
"RTN","HLOQUE",145,0)
 ;
"RTN","HLOQUE",146,0)
 ;if the sequence queue is empty and not waiting on a message, then the message can be put directly on the outgoing queue, bypassing the sequence queue
"RTN","HLOQUE",147,0)
 I '$O(^HLB("QUEUE","SEQUENCE",SQUE,0)),'NEXT D
"RTN","HLOQUE",148,0)
 .S ^HLB("QUEUE","SEQUENCE",SQUE)=IEN778 ;to mean something moved to outgoing but not yet transmitted
"RTN","HLOQUE",149,0)
 .D OUTQUE(.LINKNAME,.PORT,.QNAME,IEN778)
"RTN","HLOQUE",150,0)
 .S MOVED=1
"RTN","HLOQUE",151,0)
 E  D
"RTN","HLOQUE",152,0)
 .;Put the message on the sequence queue.
"RTN","HLOQUE",153,0)
 .S ^HLB("QUEUE","SEQUENCE",SQUE,IEN778)=""
"RTN","HLOQUE",154,0)
 .;
"RTN","HLOQUE",155,0)
 .;**P143 START CJM
"RTN","HLOQUE",156,0)
 .I 'NEXT,$$ADVANCE(SQUE,"")
"RTN","HLOQUE",157,0)
 .;**P143 END CJM
"RTN","HLOQUE",158,0)
 .;
"RTN","HLOQUE",159,0)
 .;**P147 START CJM
"RTN","HLOQUE",160,0)
 .I NEXT,$L($P($G(^HLB(NEXT,0)),"^",7)) D ADVANCE(SQUE,NEXT)
"RTN","HLOQUE",161,0)
 .;**P147 END CJM
"RTN","HLOQUE",162,0)
 .;
"RTN","HLOQUE",163,0)
 L -^HLB("QUEUE","SEQUENCE",SQUE)
"RTN","HLOQUE",164,0)
 L:$G(FLG) -RECOUNT("SEQUENCE",SQUE)
"RTN","HLOQUE",165,0)
 Q MOVED
"RTN","HLOQUE",166,0)
 ;
"RTN","HLOQUE",167,0)
ADVANCE(SQUE,MSGIEN) ;
"RTN","HLOQUE",168,0)
 ;Will move the specified sequencing queue to the next message. 
"RTN","HLOQUE",169,0)
 ;Input:
"RTN","HLOQUE",170,0)
 ;  SQUE - name of the sequencing queue
"RTN","HLOQUE",171,0)
 ;  MSGIEN - the ien of the message upon which the sequence queue was waiting.  If it is NOT the correct ien, then the sequence queue will NOT be advance.
"RTN","HLOQUE",172,0)
 ;Output:
"RTN","HLOQUE",173,0)
 ;  Function - 1 if advanced, 0 if not
"RTN","HLOQUE",174,0)
 ;
"RTN","HLOQUE",175,0)
 N NODE,IEN778,LINKNAME,PORT,QNAME
"RTN","HLOQUE",176,0)
 Q:'$L($G(SQUE)) 0
"RTN","HLOQUE",177,0)
 ;
"RTN","HLOQUE",178,0)
 ;**P143 START CJM
"RTN","HLOQUE",179,0)
 ;Q:'$G(MSGIEN) 0
"RTN","HLOQUE",180,0)
 Q:'$D(MSGIEN) 0
"RTN","HLOQUE",181,0)
 ;**P143 END CJM
"RTN","HLOQUE",182,0)
 ;
"RTN","HLOQUE",183,0)
 L +^HLB("QUEUE","SEQUENCE",SQUE):200
"RTN","HLOQUE",184,0)
 ;
"RTN","HLOQUE",185,0)
 ;do not advance if the queue wasn't pending the message=MSGIEN
"RTN","HLOQUE",186,0)
 ;**P143 START CJM
"RTN","HLOQUE",187,0)
 ;I (MSGIEN'=$P($G(^HLB("QUEUE","SEQUENCE",SQUE)),"^")) L -^HLB("QUEUE","SEQUENCE",SQUE) Q 0
"RTN","HLOQUE",188,0)
 I ($G(MSGIEN)'=$P($G(^HLB("QUEUE","SEQUENCE",SQUE)),"^")) L -^HLB("QUEUE","SEQUENCE",SQUE) Q 0
"RTN","HLOQUE",189,0)
 ;**P143 END CJM
"RTN","HLOQUE",190,0)
 ;
"RTN","HLOQUE",191,0)
 ;decrement the count of messages pending on all sequence queues
"RTN","HLOQUE",192,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")))
"RTN","HLOQUE",193,0)
 ;
"RTN","HLOQUE",194,0)
 ;**Start HL*1.6*138 CJM
"RTN","HLOQUE",195,0)
 ;decrement the count of messages pending on this individual queue
"RTN","HLOQUE",196,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)))
"RTN","HLOQUE",197,0)
 ;**End HL*1.6*138 CJM
"RTN","HLOQUE",198,0)
 ;
"RTN","HLOQUE",199,0)
 S IEN778=0
"RTN","HLOQUE",200,0)
 ;look for the first message on the sequence que.  Make sure its valid, if not remove the invalid entry and keep looking.
"RTN","HLOQUE",201,0)
 F  S IEN778=$O(^HLB("QUEUE","SEQUENCE",SQUE,0)) Q:'IEN778  S NODE=$G(^HLB(IEN778,0)) Q:$L(NODE)  D
"RTN","HLOQUE",202,0)
 .;message does not exist! Remove from queue and try again.
"RTN","HLOQUE",203,0)
 .K ^HLB("QUEUE","SEQUENCE",SQUE,IEN778)
"RTN","HLOQUE",204,0)
 .I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE"))) ;decrement the count of messages pending sequence queues
"RTN","HLOQUE",205,0)
 .;**Start HL*1.6*138 CJM
"RTN","HLOQUE",206,0)
 .; also decrement the count of messages pending on this individual queue
"RTN","HLOQUE",207,0)
 .I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)),-1)<0,$$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE",SQUE)))
"RTN","HLOQUE",208,0)
 .;**End HL*1.6*138 CJM
"RTN","HLOQUE",209,0)
 ;
"RTN","HLOQUE",210,0)
 ;IEN778 is the next pending msg on this sequence queue
"RTN","HLOQUE",211,0)
 I IEN778 D
"RTN","HLOQUE",212,0)
 .;
"RTN","HLOQUE",213,0)
 .;parse out info needed to move to outgoing queue
"RTN","HLOQUE",214,0)
 .S LINKNAME=$P(NODE,"^",5),PORT=$P(NODE,"^",8),QNAME=$P(NODE,"^",6)
"RTN","HLOQUE",215,0)
 .;
"RTN","HLOQUE",216,0)
 .S ^HLB("QUEUE","SEQUENCE",SQUE)=IEN778 ;indicates this sequence queue is now waiting for msg=IEN778 before advancing.  The second pieces is the timer, but will not be set until the message=IEN778 is actually transmitted.
"RTN","HLOQUE",217,0)
 .K ^HLB("QUEUE","SEQUENCE",SQUE,IEN778) ;remove from sequence queue
"RTN","HLOQUE",218,0)
 .L -^HLB("QUEUE","SEQUENCE",SQUE)
"RTN","HLOQUE",219,0)
 .S $P(^HLB(IEN778,5),"^",2)=1
"RTN","HLOQUE",220,0)
 .D OUTQUE(.LINKNAME,$G(PORT),$G(QNAME),IEN778) ;move to outgoing queue
"RTN","HLOQUE",221,0)
 E  D
"RTN","HLOQUE",222,0)
 .K ^HLB("QUEUE","SEQUENCE",SQUE) ;this sequence queue is currently empty and not needed
"RTN","HLOQUE",223,0)
 .L -^HLB("QUEUE","SEQUENCE",SQUE)
"RTN","HLOQUE",224,0)
 Q 1
"RTN","HLOQUE",225,0)
 ;
"RTN","HLOQUE",226,0)
SEQCHK(WORK) ;functions under the HLO Process Manager
"RTN","HLOQUE",227,0)
 ;check sequence queues for timeout
"RTN","HLOQUE",228,0)
 N QUE,NOW
"RTN","HLOQUE",229,0)
 S NOW=$$NOW^XLFDT
"RTN","HLOQUE",230,0)
 S QUE=""
"RTN","HLOQUE",231,0)
 F  S QUE=$O(^HLB("QUEUE","SEQUENCE",QUE)) Q:QUE=""  D
"RTN","HLOQUE",232,0)
 .N NODE,MSGIEN,ACTION,NODE
"RTN","HLOQUE",233,0)
 .S NODE=$G(^HLB("QUEUE","SEQUENCE",QUE))
"RTN","HLOQUE",234,0)
 .Q:'$P(NODE,"^",2)
"RTN","HLOQUE",235,0)
 .Q:$P(NODE,"^",2)>NOW
"RTN","HLOQUE",236,0)
 .Q:$P(NODE,"^",3)
"RTN","HLOQUE",237,0)
 .L +^HLB("QUEUE","SEQUENCE",QUE):2
"RTN","HLOQUE",238,0)
 .;don't report if a lock wasn't obtained
"RTN","HLOQUE",239,0)
 .Q:'$T
"RTN","HLOQUE",240,0)
 .S NODE=$G(^HLB("QUEUE","SEQUENCE",QUE))
"RTN","HLOQUE",241,0)
 .I '$P(NODE,"^",2) L -^HLB("QUEUE","SEQUENCE",QUE) Q
"RTN","HLOQUE",242,0)
 .I ($P(NODE,"^",2)>NOW) L -^HLB("QUEUE","SEQUENCE",QUE) Q
"RTN","HLOQUE",243,0)
 .I $P(NODE,"^",3) L -^HLB("QUEUE","SEQUENCE",QUE) Q  ;exception already raised
"RTN","HLOQUE",244,0)
 .S MSGIEN=$P(NODE,"^")
"RTN","HLOQUE",245,0)
 .I 'MSGIEN L -^HLB("QUEUE","SEQUENCE",QUE) Q
"RTN","HLOQUE",246,0)
 .S ACTION=$$EXCEPT^HLOAPP($$GETSAP^HLOCLNT2(MSGIEN))
"RTN","HLOQUE",247,0)
 .S $P(^HLB(MSGIEN,5),"^",3)=1
"RTN","HLOQUE",248,0)
 .S $P(^HLB("QUEUE","SEQUENCE",QUE),"^",3)=1 ;indicates exception raised
"RTN","HLOQUE",249,0)
 .L -^HLB("QUEUE","SEQUENCE",QUE)
"RTN","HLOQUE",250,0)
 .D  ;call the application to take action
"RTN","HLOQUE",251,0)
 ..N HLMSGIEN,MCODE,DUZ,QUE,NOW
"RTN","HLOQUE",252,0)
 ..N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOQUE"
"RTN","HLOQUE",253,0)
 ..S HLMSGIEN=MSGIEN
"RTN","HLOQUE",254,0)
 ..S MCODE="D "_ACTION
"RTN","HLOQUE",255,0)
 ..N MSGIEN,X
"RTN","HLOQUE",256,0)
 ..D DUZ^XUP(.5)
"RTN","HLOQUE",257,0)
 ..X MCODE
"RTN","HLOQUE",258,0)
 ..;kill the apps variables
"RTN","HLOQUE",259,0)
 ..D
"RTN","HLOQUE",260,0)
 ...N ZTSK
"RTN","HLOQUE",261,0)
 ...D KILL^XUSCLEAN
"RTN","HLOQUE",262,0)
 Q
"RTN","HLOQUE",263,0)
ERROR ;error trap for application context
"RTN","HLOQUE",264,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","HLOQUE",265,0)
 D ^%ZTER
"RTN","HLOQUE",266,0)
 S $ECODE=",UAPPLICATION ERROR,"
"RTN","HLOQUE",267,0)
 ;
"RTN","HLOQUE",268,0)
 ;kill the apps variables
"RTN","HLOQUE",269,0)
 D
"RTN","HLOQUE",270,0)
 .N ZTSK,MSGIEN,QUEUE
"RTN","HLOQUE",271,0)
 .D KILL^XUSCLEAN
"RTN","HLOQUE",272,0)
 ;
"RTN","HLOQUE",273,0)
 ;release all the locks the app may have set, except Taskman lock
"RTN","HLOQUE",274,0)
 L:$D(ZTSK) ^%ZTSCH("TASK",ZTSK):1
"RTN","HLOQUE",275,0)
 L:'$D(ZTSK)
"RTN","HLOQUE",276,0)
 ;reset HLO's lock
"RTN","HLOQUE",277,0)
 L +^HLTMP("HL7 RUNNING PROCESSES",$J):0
"RTN","HLOQUE",278,0)
 ;return to processing the next message on the queue
"RTN","HLOQUE",279,0)
 D UNWIND^%ZTER
"RTN","HLOQUE",280,0)
 Q
"RTN","HLOQUE",281,0)
 ;
"RTN","HLOQUE",282,0)
 ; *** start HL*1.6*143 -  RBN ***
"RTN","HLOQUE",283,0)
 ;
"RTN","HLOQUE",284,0)
 ; IMPLEMENTATION OF HL0 QUEUE COUNT SUMMARY
"RTN","HLOQUE",285,0)
 ;
"RTN","HLOQUE",286,0)
QUECNT(QUEARRAY) ;
"RTN","HLOQUE",287,0)
 ; 
"RTN","HLOQUE",288,0)
 ; DESC  : Functions eturns the total number of messages on all the queues and an the QUEARRAY
"RTN","HLOQUE",289,0)
 ;        
"RTN","HLOQUE",290,0)
 ; INPUT : QUEARRAY - the array, passed by reference, to contain the queue counts. 
"RTN","HLOQUE",291,0)
 ;               
"RTN","HLOQUE",292,0)
 ; OUTPUT : Filled array
"RTN","HLOQUE",293,0)
 ;               
"RTN","HLOQUE",294,0)
 ;               Format:
"RTN","HLOQUE",295,0)
 ;             
"RTN","HLOQUE",296,0)
 ;               QUE("TOTAL") = Total number of messages on all queues.
"RTN","HLOQUE",297,0)
 ;               QUE("OUT")   = Total number of outgoing messages.
"RTN","HLOQUE",298,0)
 ;               QUE("IN")    = Total number of incoming messages.
"RTN","HLOQUE",299,0)
 ;               QUE("SEQ")   = Total number of messages on sequence queues.
"RTN","HLOQUE",300,0)
 ;               QUE("IN",link_name,queue_name) = Number of messages on given link and queue.
"RTN","HLOQUE",301,0)
 ;               QUE("OUT",link_name,queue_name) = Number of messages on given link and queue.
"RTN","HLOQUE",302,0)
 ;               QUE("SEQ",queue_name) = Number of messages on given sequence queue.
"RTN","HLOQUE",303,0)
 ; 
"RTN","HLOQUE",304,0)
 ; There are four possible calls ("entry points") to this API:
"RTN","HLOQUE",305,0)
 ;   1. QUECNT - returns the referenced array with all of the above data.
"RTN","HLOQUE",306,0)
 ;   2. IN     - returns only the data related to the IN queues.
"RTN","HLOQUE",307,0)
 ;   3. OUT    - returns only the data related to the OUT queues.
"RTN","HLOQUE",308,0)
 ;   4. SEQ    - returns only the data related to the SEQUENCE queues.
"RTN","HLOQUE",309,0)
 ;   
"RTN","HLOQUE",310,0)
 N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",311,0)
 S FLG=1
"RTN","HLOQUE",312,0)
 ; Get incomming counts
"RTN","HLOQUE",313,0)
 D IN(.QUEARRAY)
"RTN","HLOQUE",314,0)
 ; Get outgoing counts
"RTN","HLOQUE",315,0)
 D OUT(.QUEARRAY)
"RTN","HLOQUE",316,0)
 ; Get sequence counts
"RTN","HLOQUE",317,0)
 D SEQ(.QUEARRAY)
"RTN","HLOQUE",318,0)
 ;
"RTN","HLOQUE",319,0)
 ; Total messages on all queues
"RTN","HLOQUE",320,0)
 ; 
"RTN","HLOQUE",321,0)
 S QUEARRAY("TOTAL")=INCNT+OUTCNT+SEQCNT
"RTN","HLOQUE",322,0)
 Q QUEARRAY("TOTAL")
"RTN","HLOQUE",323,0)
 ;
"RTN","HLOQUE",324,0)
IN(QUEARRAY) ;
"RTN","HLOQUE",325,0)
 ; Count messages on incoming queues
"RTN","HLOQUE",326,0)
 ;
"RTN","HLOQUE",327,0)
 I '$G(FLG) N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",328,0)
 S (LINK,QUE)=""
"RTN","HLOQUE",329,0)
 S INCNT=0
"RTN","HLOQUE",330,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","IN",LINK)) Q:LINK=""  D
"RTN","HLOQUE",331,0)
 .  F  S QUE=$O(^HLC("QUEUECOUNT","IN",LINK,QUE)) Q:QUE=""  D
"RTN","HLOQUE",332,0)
 .  .  S INCNT=INCNT+^HLC("QUEUECOUNT","IN",LINK,QUE)
"RTN","HLOQUE",333,0)
 .  .  S QUEARRAY("IN",LINK,QUE)=^HLC("QUEUECOUNT","IN",LINK,QUE)
"RTN","HLOQUE",334,0)
 S QUEARRAY("IN")=INCNT
"RTN","HLOQUE",335,0)
 I '$G(FLG) Q INCNT
"RTN","HLOQUE",336,0)
 Q
"RTN","HLOQUE",337,0)
 ;
"RTN","HLOQUE",338,0)
OUT(QUEARRAY) ;
"RTN","HLOQUE",339,0)
 ; Count messages on outgoing queues
"RTN","HLOQUE",340,0)
 ;
"RTN","HLOQUE",341,0)
 I '$G(FLG) N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",342,0)
 S (LINK,QUE)=""
"RTN","HLOQUE",343,0)
 S OUTCNT=0
"RTN","HLOQUE",344,0)
 F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOQUE",345,0)
 .  F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOQUE",346,0)
 .  .  S OUTCNT=OUTCNT+^HLC("QUEUECOUNT","OUT",LINK,QUE)
"RTN","HLOQUE",347,0)
 .  .  S QUEARRAY("OUT",LINK,QUE)=^HLC("QUEUECOUNT","OUT",LINK,QUE)
"RTN","HLOQUE",348,0)
 S QUEARRAY("OUT")=OUTCNT
"RTN","HLOQUE",349,0)
 I '$G(FLG) Q OUTCNT
"RTN","HLOQUE",350,0)
 Q
"RTN","HLOQUE",351,0)
 ;
"RTN","HLOQUE",352,0)
SEQ(QUEARRAY) ;
"RTN","HLOQUE",353,0)
 ; Count messages on sequence queues
"RTN","HLOQUE",354,0)
 ;
"RTN","HLOQUE",355,0)
 I '$G(FLG) N TOTAL,INCNT,OUTCNT,SEQCNT,LINK,QUE,FLG
"RTN","HLOQUE",356,0)
 S QUE=""
"RTN","HLOQUE",357,0)
 S SEQCNT=0
"RTN","HLOQUE",358,0)
 F  S QUE=$O(^HLC("QUEUECOUNT","SEQUENCE",QUE)) Q:QUE=""  D
"RTN","HLOQUE",359,0)
 .  S SEQCNT=SEQCNT+^HLC("QUEUECOUNT","SEQUENCE",QUE)
"RTN","HLOQUE",360,0)
 .  S QUEARRAY("SEQ",QUE)=^HLC("QUEUECOUNT","SEQUENCE",QUE)
"RTN","HLOQUE",361,0)
 S QUEARRAY("SEQ")=^HLC("QUEUECOUNT","SEQUENCE")
"RTN","HLOQUE",362,0)
 I '$G(FLG) Q QUEARRAY("SEQ")
"RTN","HLOQUE",363,0)
 Q
"RTN","HLOQUE",364,0)
 ;
"RTN","HLOQUE",365,0)
 ; *** End HL*1.6*143 -  RBN ***
"RTN","HLOQUE",366,0)
 ;
"RTN","HLOQUE",367,0)
 ;** P147 START CJM
"RTN","HLOQUE",368,0)
RESETF(IEN) ;
"RTN","HLOQUE",369,0)
 ;resets the "F" index on the HLO Priority Queues file (#779.9) for
"RTN","HLOQUE",370,0)
 ;for record IEN
"RTN","HLOQUE",371,0)
 ;
"RTN","HLOQUE",372,0)
 N DA
"RTN","HLOQUE",373,0)
 S DA(1)=IEN
"RTN","HLOQUE",374,0)
 S DA=0
"RTN","HLOQUE",375,0)
 F  S DA=$O(^HLD(779.9,DA(1),1,DA)) Q:'DA  D
"RTN","HLOQUE",376,0)
 .N DATA
"RTN","HLOQUE",377,0)
 .S DATA(.01)=$P($G(^HLD(779.9,DA(1),1,DA,0)),"^")
"RTN","HLOQUE",378,0)
 .Q:DATA(.01)=""
"RTN","HLOQUE",379,0)
 .D UPD^HLOASUB1(779.91,.DA,.DATA)
"RTN","HLOQUE",380,0)
 Q
"RTN","HLOQUE",381,0)
 ;
"RTN","HLOQUE",382,0)
GETPRTY(QUEUE,LINK) ;
"RTN","HLOQUE",383,0)
 ;Inputs:
"RTN","HLOQUE",384,0)
 ;    QUEUE (required)
"RTN","HLOQUE",385,0)
 ;    LINK (required) the name of hte link, possibly with the port # appeded
"RTN","HLOQUE",386,0)
 ;
"RTN","HLOQUE",387,0)
 ;
"RTN","HLOQUE",388,0)
 N PRTY,LNK
"RTN","HLOQUE",389,0)
 S PRTY=0
"RTN","HLOQUE",390,0)
 S LNK=$P(LINK,":")
"RTN","HLOQUE",391,0)
 I $L(LNK) S PRTY=$G(^HLD(779.9,"F",QUEUE,"OUT",LNK))
"RTN","HLOQUE",392,0)
 I PRTY Q PRTY
"RTN","HLOQUE",393,0)
 S PRTY=$G(^HLD(779.9,"E",QUEUE,"OUT"))
"RTN","HLOQUE",394,0)
 Q:'PRTY 50
"RTN","HLOQUE",395,0)
 Q PRTY
"RTN","HLOQUE",396,0)
 ; 
"RTN","HLOQUE",397,0)
SETPRTY ;  User interface to set queue priority
"RTN","HLOQUE",398,0)
 ; 
"RTN","HLOQUE",399,0)
 N DIC,DA,DR,Y,DIE,QUEUE
"RTN","HLOQUE",400,0)
 S DIC="^HLD(779.9,"
"RTN","HLOQUE",401,0)
 S DIC(0)="QEAL"
"RTN","HLOQUE",402,0)
 S DIC("A")="Enter the name of an outgoing queue: "
"RTN","HLOQUE",403,0)
 S DIC("DR")=".01"
"RTN","HLOQUE",404,0)
 D ^DIC
"RTN","HLOQUE",405,0)
 I $G(DTOUT)!($G(DUOUT))!(Y=-1) D  Q
"RTN","HLOQUE",406,0)
 . K DIC,DA,DR,Y,DIE
"RTN","HLOQUE",407,0)
 S DA=+Y,QUEUE=$P(Y,"^",2)
"RTN","HLOQUE",408,0)
 I $$ASKYESNO^HLOUSR2("Do you want to set "_QUEUE_"'s priority for just one specific logical link","YES") D
"RTN","HLOQUE",409,0)
 .N DATA
"RTN","HLOQUE",410,0)
 .S DATA(.02)="OUT"
"RTN","HLOQUE",411,0)
 .D UPD^HLOASUB1(779.9,DA,.DATA)
"RTN","HLOQUE",412,0)
 .S DIC="^HLD(779.9,"_DA_",1,"
"RTN","HLOQUE",413,0)
 .S DA(1)=DA,DA=""
"RTN","HLOQUE",414,0)
 .;S DIC("DR")=.02
"RTN","HLOQUE",415,0)
 .S DIC(0)="QEAL"
"RTN","HLOQUE",416,0)
 .S DIC("A")="Select the specific link: "
"RTN","HLOQUE",417,0)
 .D ^DIC
"RTN","HLOQUE",418,0)
 .I Y>0 D
"RTN","HLOQUE",419,0)
 ..S DA=+Y
"RTN","HLOQUE",420,0)
 ..S DIE="^HLD(779.9,"_DA(1)_",1,"
"RTN","HLOQUE",421,0)
 ..S DR=.02
"RTN","HLOQUE",422,0)
 ..D ^DIE
"RTN","HLOQUE",423,0)
 E  D
"RTN","HLOQUE",424,0)
 .N DATA
"RTN","HLOQUE",425,0)
 .S DATA(.02)="OUT"
"RTN","HLOQUE",426,0)
 .S DATA(.03)=1
"RTN","HLOQUE",427,0)
 .D UPD^HLOASUB1(779.9,DA,.DATA)
"RTN","HLOQUE",428,0)
 .S DIE="^HLD(779.9,"
"RTN","HLOQUE",429,0)
 .S DR=.04
"RTN","HLOQUE",430,0)
 .D ^DIE
"RTN","HLOQUE",431,0)
 Q
"RTN","HLOQUE",432,0)
SETP(QUEUE,PRIORITY,LINK) ;
"RTN","HLOQUE",433,0)
 ;Description: API for setting an outgoing queue's priority
"RTN","HLOQUE",434,0)
 ;Input:
"RTN","HLOQUE",435,0)
 ;   QUEUE (required) the name of the queue
"RTN","HLOQUE",436,0)
 ;   PRIORITY (required) the priority, 20-100
"RTN","HLOQUE",437,0)
 ;   LINK (optional) name or IEN of an HL Logical Link. If specified, 
"RTN","HLOQUE",438,0)
 ;                   the priority will be applied only to the specific
"RTN","HLOQUE",439,0)
 ;                   link, otherwise the priority will be applied to all
"RTN","HLOQUE",440,0)
 ;                   queues named QUEUE
"RTN","HLOQUE",441,0)
 ;Output:
"RTN","HLOQUE",442,0)
 ;     function returns 1 on success, 0 on failure
"RTN","HLOQUE",443,0)
 ;
"RTN","HLOQUE",444,0)
 N LINKIEN,DA,DATA
"RTN","HLOQUE",445,0)
 S LINKIEN=0
"RTN","HLOQUE",446,0)
 S PRIORITY=+$G(PRIORITY)
"RTN","HLOQUE",447,0)
 I $G(PRIORITY)<20 Q 0
"RTN","HLOQUE",448,0)
 I PRIORITY>100 Q 0
"RTN","HLOQUE",449,0)
 I '$L($G(QUEUE)) Q 0
"RTN","HLOQUE",450,0)
 I $L(QUEUE)>20 Q 0
"RTN","HLOQUE",451,0)
 I $L($G(LINK)) D  Q:'LINKIEN 0
"RTN","HLOQUE",452,0)
 .S LINKIEN=0
"RTN","HLOQUE",453,0)
 .I LINK,$D(^HLCS(870,LINK,0)) S LINKIEN=LINK Q
"RTN","HLOQUE",454,0)
 .S LINKIEN=$O(^HLCS(870,"B",LINK,0))
"RTN","HLOQUE",455,0)
 S DA=$O(^HLD(779.9,"B",QUEUE,0))
"RTN","HLOQUE",456,0)
 I 'DA D
"RTN","HLOQUE",457,0)
 .S DATA(.02)="OUT"
"RTN","HLOQUE",458,0)
 .S DATA(.01)=QUEUE
"RTN","HLOQUE",459,0)
 .I 'LINKIEN S DATA(.03)=1,DATA(.04)=PRIORITY
"RTN","HLOQUE",460,0)
 .S DA=$$ADD^HLOASUB1(779.9,,.DATA)
"RTN","HLOQUE",461,0)
 E  I 'LINKIEN D  Q $$UPD^HLOASUB1(779.9,DA,.DATA)
"RTN","HLOQUE",462,0)
 .S DATA(.02)="OUT"
"RTN","HLOQUE",463,0)
 .S DATA(.03)=1
"RTN","HLOQUE",464,0)
 .S DATA(.04)=PRIORITY
"RTN","HLOQUE",465,0)
 Q:'DA 0
"RTN","HLOQUE",466,0)
 Q:'LINKIEN 1
"RTN","HLOQUE",467,0)
 S DA(1)=DA
"RTN","HLOQUE",468,0)
 S DA=$O(^HLD(779.9,DA(1),1,"B",LINKIEN,0))
"RTN","HLOQUE",469,0)
 K DATA
"RTN","HLOQUE",470,0)
 S DATA(.01)=LINKIEN
"RTN","HLOQUE",471,0)
 S DATA(.02)=PRIORITY
"RTN","HLOQUE",472,0)
 I DA Q $$UPD^HLOASUB1(779.91,.DA,.DATA)
"RTN","HLOQUE",473,0)
 I $$ADD^HLOASUB1(779.91,.DA,.DATA,.ERROR) Q 1
"RTN","HLOQUE",474,0)
 Q 0
"RTN","HLOQUE",475,0)
 ;**P147 END CJM
"RTN","HLOQUE",476,0)
 ;
"RTN","HLOQUE",477,0)
 ;
"RTN","HLOQUE",478,0)
 ;
"RTN","HLOQUE",479,0)
 ;
"RTN","HLOQUE",480,0)
 ;
"RTN","HLOQUE",481,0)
 ;
"RTN","HLOSITE")
0^15^B9605158^B8278014
"RTN","HLOSITE",1,0)
HLOSITE ;ALB/CJM/OAK/PIJ-HL7 - API for getting site parameters ;03/26/2012
"RTN","HLOSITE",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,138,147,153,158**;Oct 13, 1995;Build 14
"RTN","HLOSITE",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSITE",4,0)
 ;
"RTN","HLOSITE",5,0)
SYSPARMS(SYSTEM) ;Gets system parameters from file 779.1
"RTN","HLOSITE",6,0)
 ;Input: none
"RTN","HLOSITE",7,0)
 ;Output:  SYSTEM array (pass by reference)
"RTN","HLOSITE",8,0)
 ;
"RTN","HLOSITE",9,0)
 N NODE,LINK,PURGE
"RTN","HLOSITE",10,0)
 S NODE=$G(^HLD(779.1,1,0))
"RTN","HLOSITE",11,0)
 S SYSTEM("DOMAIN")=$P(NODE,"^")
"RTN","HLOSITE",12,0)
 S SYSTEM("STATION")=$P(NODE,"^",2)
"RTN","HLOSITE",13,0)
 S SYSTEM("PROCESSING ID")=$P(NODE,"^",3)
"RTN","HLOSITE",14,0)
 S SYSTEM("MAXSTRING")=$P(NODE,"^",4)
"RTN","HLOSITE",15,0)
 I ('SYSTEM("MAXSTRING"))!(SYSTEM("MAXSTRING")<256) D
"RTN","HLOSITE",16,0)
 .N OS S OS=^%ZOSF("OS")
"RTN","HLOSITE",17,0)
 .S SYSTEM("MAXSTRING")=$S(OS["OpenM":512,OS["DSM":512,1:256)
"RTN","HLOSITE",18,0)
 S SYSTEM("HL7 BUFFER")=$P(NODE,"^",5)
"RTN","HLOSITE",19,0)
 S:'SYSTEM("HL7 BUFFER") SYSTEM("HL7 BUFFER")=15000
"RTN","HLOSITE",20,0)
 S SYSTEM("USER BUFFER")=$P(NODE,"^",6)
"RTN","HLOSITE",21,0)
 S:'SYSTEM("USER BUFFER") SYSTEM("USER BUFFER")=5000
"RTN","HLOSITE",22,0)
 S SYSTEM("NORMAL PURGE")=$P(NODE,"^",7)
"RTN","HLOSITE",23,0)
 I 'SYSTEM("NORMAL PURGE") S SYSTEM("NORMAL PURGE")=3
"RTN","HLOSITE",24,0)
 S SYSTEM("ERROR PURGE")=$P(NODE,"^",8)
"RTN","HLOSITE",25,0)
 I 'SYSTEM("ERROR PURGE") S SYSTEM("ERROR PURGE")=7
"RTN","HLOSITE",26,0)
 S LINK=$P(NODE,"^",10)
"RTN","HLOSITE",27,0)
 S:LINK SYSTEM("PORT")=$$PORT^HLOTLNK(LINK)
"RTN","HLOSITE",28,0)
 S:'$G(SYSTEM("PORT")) SYSTEM("PORT")=$S(SYSTEM("PROCESSING ID")="P":5001,1:5026)
"RTN","HLOSITE",29,0)
 S SYSTEM("NODE")=$P(NODE,"^",13)
"RTN","HLOSITE",30,0)
 I SYSTEM("NODE") S SYSTEM("NODE")=$P($G(^%ZIS(14.7,SYSTEM("NODE"),0)),"^")
"RTN","HLOSITE",31,0)
 Q
"RTN","HLOSITE",32,0)
SYSPURGE(PURGE) ;returns system purge parameters
"RTN","HLOSITE",33,0)
 ;Output:  PURGE (pass by reference)
"RTN","HLOSITE",34,0)
 ;
"RTN","HLOSITE",35,0)
 N NODE
"RTN","HLOSITE",36,0)
 S NODE=$G(^HLD(779.1,1,0))
"RTN","HLOSITE",37,0)
 S PURGE("NORMAL")=$P(NODE,"^",7)
"RTN","HLOSITE",38,0)
 I 'PURGE("NORMAL") S PURGE("NORMAL")=3
"RTN","HLOSITE",39,0)
 S PURGE("ERROR")=$P(NODE,"^",8)
"RTN","HLOSITE",40,0)
 I 'PURGE("ERROR") S PURGE("ERROR")=7
"RTN","HLOSITE",41,0)
 Q
"RTN","HLOSITE",42,0)
 ;
"RTN","HLOSITE",43,0)
GETNODE() ;
"RTN","HLOSITE",44,0)
 N NODE
"RTN","HLOSITE",45,0)
 S NODE=$P($G(^HLD(779.1,1,0)),"^",13)
"RTN","HLOSITE",46,0)
 Q:NODE $P($G(^%ZIS(14.7,NODE,0)),"^")
"RTN","HLOSITE",47,0)
 Q ""
"RTN","HLOSITE",48,0)
 ;
"RTN","HLOSITE",49,0)
INC(VARIABLE,AMOUNT) ;
"RTN","HLOSITE",50,0)
 ;Increments VARIABLE by AMOUNT, using $I if available, otherwise by locking.
"RTN","HLOSITE",51,0)
 ;
"RTN","HLOSITE",52,0)
 N OS
"RTN","HLOSITE",53,0)
 ;if HLCSTATE has been defined, then we have already checked the OS, so use it.
"RTN","HLOSITE",54,0)
 I $D(HLCSTATE("SYSTEM","OS")) D
"RTN","HLOSITE",55,0)
 .S OS=HLCSTATE("SYSTEM","OS")
"RTN","HLOSITE",56,0)
 E  D
"RTN","HLOSITE",57,0)
 .S OS=^%ZOSF("OS")
"RTN","HLOSITE",58,0)
 I '$G(AMOUNT) S AMOUNT=1
"RTN","HLOSITE",59,0)
 I (OS["OpenM")!(OS["DSM")!(OS["CACHE") Q $I(@VARIABLE,AMOUNT)
"RTN","HLOSITE",60,0)
 L +VARIABLE:100
"RTN","HLOSITE",61,0)
 S @VARIABLE=@VARIABLE+AMOUNT
"RTN","HLOSITE",62,0)
 L -VARIABLE
"RTN","HLOSITE",63,0)
 Q @VARIABLE
"RTN","HLOSITE",64,0)
 ;
"RTN","HLOSITE",65,0)
COUNT778() ;
"RTN","HLOSITE",66,0)
 ;This function returns the # of records in file 778.
"RTN","HLOSITE",67,0)
 N COUNT,IEN
"RTN","HLOSITE",68,0)
 S (COUNT,IEN)=0
"RTN","HLOSITE",69,0)
 F  S IEN=$O(^HLB(IEN)) Q:'IEN  S COUNT=COUNT+1
"RTN","HLOSITE",70,0)
 Q COUNT
"RTN","HLOSITE",71,0)
COUNT777() ;
"RTN","HLOSITE",72,0)
 ;This function returns the # of records in file 777.
"RTN","HLOSITE",73,0)
 N COUNT,IEN
"RTN","HLOSITE",74,0)
 S (COUNT,IEN)=0
"RTN","HLOSITE",75,0)
 F  S IEN=$O(^HLA(IEN)) Q:'IEN  S COUNT=COUNT+1
"RTN","HLOSITE",76,0)
 Q COUNT
"RTN","HLOSITE",77,0)
 ;
"RTN","HLOSITE",78,0)
UPDCNTS(WORK) ;update the record counts for file 777,778
"RTN","HLOSITE",79,0)
 N COUNT
"RTN","HLOSITE",80,0)
 S COUNT=$$COUNT777^HLOSITE
"RTN","HLOSITE",81,0)
 S $P(^HLA(0),"^",4)=COUNT
"RTN","HLOSITE",82,0)
 S ^HLTMP("FILE 777 RECORD COUNT")=COUNT_"^"_$$NOW^XLFDT
"RTN","HLOSITE",83,0)
 S COUNT=$$COUNT778^HLOSITE
"RTN","HLOSITE",84,0)
 S $P(^HLB(0),"^",4)=COUNT
"RTN","HLOSITE",85,0)
 S ^HLTMP("FILE 778 RECORD COUNT")=COUNT_"^"_$$NOW^XLFDT
"RTN","HLOSITE",86,0)
 Q
"RTN","HLOSITE",87,0)
 ;;HL*1.6*138 start PIJ 10/26/2007
"RTN","HLOSITE",88,0)
RCNT(ST) ;This section sets or reads the recount flag.
"RTN","HLOSITE",89,0)
 ;; When ST="S" Flag is set
"RTN","HLOSITE",90,0)
 ;; When ST="U" Flag is unset
"RTN","HLOSITE",91,0)
 I $G(ST)="S" S $P(^HLD(779.1,1,0),"^",11)=1
"RTN","HLOSITE",92,0)
 I $G(ST)="U" S $P(^HLD(779.1,1,0),"^",11)=0
"RTN","HLOSITE",93,0)
 Q $P($G(^HLD(779.1,1,0)),"^",11)
"RTN","HLOSITE",94,0)
 ;;HL*1.6*138 end
"RTN","HLOSITE",95,0)
OLDPURGE() ;returns the retention time in days for unsent messages
"RTN","HLOSITE",96,0)
 N TIME
"RTN","HLOSITE",97,0)
 S TIME=$P($G(^HLD(779.1,1,0)),"^",12)
"RTN","HLOSITE",98,0)
 Q $S(TIME:TIME,1:45)
"RTN","HLOSRVR")
0^3^B82216599^B95024776
"RTN","HLOSRVR",1,0)
HLOSRVR ;ALB/CJM - Server for receiving messages - 10/4/94 1pm ;06/25/2012
"RTN","HLOSRVR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,134,137,138,139,143,147,157,158**;Oct 13, 1995;Build 14
"RTN","HLOSRVR",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR",4,0)
 ;
"RTN","HLOSRVR",5,0)
GETWORK(WORK) ;
"RTN","HLOSRVR",6,0)
 ;GET WORK function for a single server or a Taskman multi-server
"RTN","HLOSRVR",7,0)
 N LINK
"RTN","HLOSRVR",8,0)
 I '$$CHKSTOP^HLOPROC,$G(WORK("LINK"))]"",$$GETLINK^HLOTLNK(WORK("LINK"),.LINK),+LINK("SERVER") S WORK("PORT")=LINK("PORT") Q 1
"RTN","HLOSRVR",9,0)
 Q 0
"RTN","HLOSRVR",10,0)
 ;
"RTN","HLOSRVR",11,0)
DOWORKS(WORK) ;
"RTN","HLOSRVR",12,0)
 ;DO WORK rtn for a single server (non-concurrent)
"RTN","HLOSRVR",13,0)
 N $ETRAP,$ESTACK
"RTN","HLOSRVR",14,0)
 S $ETRAP="G ERROR^HLOSRVR3"
"RTN","HLOSRVR",15,0)
 D SERVER(WORK("LINK"))
"RTN","HLOSRVR",16,0)
 Q
"RTN","HLOSRVR",17,0)
DOWORKM(WORK) ;
"RTN","HLOSRVR",18,0)
 ;DO WORK rtn for a Taskman multi-server (Cache systems only)
"RTN","HLOSRVR",19,0)
 D LISTEN^%ZISTCPS(WORK("PORT"),"SERVER^HLOSRVR("""_WORK("LINK")_""")")
"RTN","HLOSRVR",20,0)
 Q
"RTN","HLOSRVR",21,0)
 ;
"RTN","HLOSRVR",22,0)
VMS2(LINKNAME) ;called from a VMS TCP Service once a connection request has been received.  This entry point should be used only if an additional VMS TCPIP Services are being created for HLO.
"RTN","HLOSRVR",23,0)
 ;Input:
"RTN","HLOSRVR",24,0)
 ;   LINKNAME - only pass it in if an additional service is being created on a different port
"RTN","HLOSRVR",25,0)
 Q:'$L(LINKNAME)
"RTN","HLOSRVR",26,0)
 D VMS
"RTN","HLOSRVR",27,0)
 Q
"RTN","HLOSRVR",28,0)
 ;
"RTN","HLOSRVR",29,0)
VMS ;Called from VMS TCP Service once a connection request has been received. This entry point should be used only by the standard HLO service that runs on the standard HLO port.
"RTN","HLOSRVR",30,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",31,0)
 D
"RTN","HLOSRVR",32,0)
 .Q:$L($G(LINKNAME))
"RTN","HLOSRVR",33,0)
 .;
"RTN","HLOSRVR",34,0)
 .N PROC,NODE
"RTN","HLOSRVR",35,0)
 .S PROC=$O(^HLD(779.3,"B","VMS TCP LISTENER",0))
"RTN","HLOSRVR",36,0)
 .I PROC S LINKNAME=$P($G(^HLD(779.3,PROC,0)),"^",14) Q:$L(LINKNAME)
"RTN","HLOSRVR",37,0)
 .S NODE=$G(^HLD(779.1,1,0)) I $P(NODE,"^",10) S LINKNAME=$P($G(^HLCS(870,$P(NODE,"^",10),0)),"^") Q:$L(LINKNAME) 
"RTN","HLOSRVR",38,0)
 .S LINKNAME="HLO DEFAULT LISTENER"
"RTN","HLOSRVR",39,0)
 ;
"RTN","HLOSRVR",40,0)
 D SERVER(LINKNAME,"SYS$NET")
"RTN","HLOSRVR",41,0)
 Q
"RTN","HLOSRVR",42,0)
LINUX1 ;The listener entry point on Linux systems.  The HL LOGICAL LINK should
"RTN","HLOSRVR",43,0)
 ;be specified in the xinetd configuration file as the variable
"RTN","HLOSRVR",44,0)
 ;HLOLINK or otherwise in the HLO SYSTEM PARAMETERS file 
"RTN","HLOSRVR",45,0)
 ;
"RTN","HLOSRVR",46,0)
 N LINKNAME,NODE
"RTN","HLOSRVR",47,0)
 S LINKNAME=$System.Util.GetEnviron("HLOLINK")
"RTN","HLOSRVR",48,0)
 I '$L(LINKNAME) S NODE=$G(^HLD(779.1,1,0)) I $P(NODE,"^",10) S LINKNAME=$P($G(^HLCS(870,$P(NODE,"^",10),0)),"^")
"RTN","HLOSRVR",49,0)
 S:'$L(LINKNAME) LINKNAME="HLO DEFAULT LISTENER"
"RTN","HLOSRVR",50,0)
 D LINUX(LINKNAME)
"RTN","HLOSRVR",51,0)
 Q
"RTN","HLOSRVR",52,0)
 ;
"RTN","HLOSRVR",53,0)
LINUX(LINKNAME) ;Listener for Linux systems running under Xinetd.
"RTN","HLOSRVR",54,0)
 ;Input:
"RTN","HLOSRVR",55,0)
 ;  LINKNAME - name of the HL LOGICAL LINK for the listener
"RTN","HLOSRVR",56,0)
 ;
"RTN","HLOSRVR",57,0)
 Q:'$L($G(LINKNAME))
"RTN","HLOSRVR",58,0)
 Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",59,0)
 ;
"RTN","HLOSRVR",60,0)
 D $ZU(68,15,1) ;need error on disconnect
"RTN","HLOSRVR",61,0)
 D SERVER(LINKNAME,$PRINCIPAL)
"RTN","HLOSRVR",62,0)
 Q
"RTN","HLOSRVR",63,0)
 ;
"RTN","HLOSRVR",64,0)
SERVER(LINKNAME,LOGICAL) ; LINKNAME identifies the logical link, which describes the communication channel to be used
"RTN","HLOSRVR",65,0)
 N $ETRAP,$ESTACK S $ETRAP="G ERROR^HLOSRVR3"
"RTN","HLOSRVR",66,0)
 N HLCSTATE,INQUE
"RTN","HLOSRVR",67,0)
 S INQUE=0
"RTN","HLOSRVR",68,0)
 ;
"RTN","HLOSRVR",69,0)
ZB1 ;
"RTN","HLOSRVR",70,0)
 ;
"RTN","HLOSRVR",71,0)
 Q:'$$CONNECT(.HLCSTATE,LINKNAME,.LOGICAL)
"RTN","HLOSRVR",72,0)
 ;
"RTN","HLOSRVR",73,0)
 K LINKNAME
"RTN","HLOSRVR",74,0)
 F  Q:'HLCSTATE("CONNECTED")  D  Q:$$CHKSTOP^HLOPROC
"RTN","HLOSRVR",75,0)
 .N HLMSTATE,SENT
"RTN","HLOSRVR",76,0)
 .;read msg and parse the hdr
"RTN","HLOSRVR",77,0)
 .;HLMSTATE("MSA",1) is set with type of ack to return
"RTN","HLOSRVR",78,0)
 .;
"RTN","HLOSRVR",79,0)
 .I $$READMSG^HLOSRVR1(.HLCSTATE,.HLMSTATE) D
"RTN","HLOSRVR",80,0)
 ..I (HLMSTATE("MSA",1)]"") S SENT=$$WRITEACK(.HLCSTATE,.HLMSTATE) D:HLMSTATE("IEN") SAVEACK(.HLMSTATE,SENT)
"RTN","HLOSRVR",81,0)
 ..;
"RTN","HLOSRVR",82,0)
 ..I HLMSTATE("ID")'="" L -HLO("MSGID",HLMSTATE("ID"))
"RTN","HLOSRVR",83,0)
 ..;
"RTN","HLOSRVR",84,0)
 ..D:HLMSTATE("IEN") UPDATE(.HLMSTATE,.HLCSTATE)
"RTN","HLOSRVR",85,0)
 ..D:HLCSTATE("COUNTS")>4 SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",86,0)
 ..I $G(HLMSTATE("ACK TO IEN")),$L($G(HLMSTATE("ACK TO","SEQUENCE QUEUE"))) D ADVANCE^HLOQUE(HLMSTATE("ACK TO","SEQUENCE QUEUE"),+HLMSTATE("ACK TO IEN"))
"RTN","HLOSRVR",87,0)
 .E  D
"RTN","HLOSRVR",88,0)
 ..I $G(HLMSTATE("ID"))'="" L -HLO("MSGID",HLMSTATE("ID"))
"RTN","HLOSRVR",89,0)
 ..D INQUE() H:HLCSTATE("CONNECTED") 1
"RTN","HLOSRVR",90,0)
 ;
"RTN","HLOSRVR",91,0)
END D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR",92,0)
 D INQUE()
"RTN","HLOSRVR",93,0)
 D SAVECNTS^HLOSTAT(.HLCSTATE)
"RTN","HLOSRVR",94,0)
 Q
"RTN","HLOSRVR",95,0)
 ;
"RTN","HLOSRVR",96,0)
CONNECT(HLCSTATE,LINKNAME,LOGICAL) ;
"RTN","HLOSRVR",97,0)
 ;sets up HLCSTATE() and opens a server connection
"RTN","HLOSRVR",98,0)
 ;
"RTN","HLOSRVR",99,0)
 N LINK,NODE
"RTN","HLOSRVR",100,0)
 S HLCSTATE("CONNECTED")=0
"RTN","HLOSRVR",101,0)
 Q:'$$GETLINK^HLOTLNK(LINKNAME,.LINK) 0
"RTN","HLOSRVR",102,0)
ZB999 ; 
"RTN","HLOSRVR",103,0)
 Q:+LINK("SERVER")'=1 0
"RTN","HLOSRVR",104,0)
 S HLCSTATE("SERVER")=LINK("SERVER")
"RTN","HLOSRVR",105,0)
 M HLCSTATE("LINK")=LINK
"RTN","HLOSRVR",106,0)
 S HLCSTATE("READ TIMEOUT")=20
"RTN","HLOSRVR",107,0)
 S HLCSTATE("OPEN TIMEOUT")=30
"RTN","HLOSRVR",108,0)
 S HLCSTATE("READ")="" ;buffer for reads
"RTN","HLOSRVR",109,0)
 ;
"RTN","HLOSRVR",110,0)
 ;HLCSTATE("BUFFER",<seg>,<line>)  write buffer
"RTN","HLOSRVR",111,0)
 S HLCSTATE("BUFFER","BYTE COUNT")=0 ;count of bytes in buffer
"RTN","HLOSRVR",112,0)
 S HLCSTATE("BUFFER","SEGMENT COUNT")=0 ;count of segments in buffer
"RTN","HLOSRVR",113,0)
 ;
"RTN","HLOSRVR",114,0)
 S HLCSTATE("COUNTS")=0
"RTN","HLOSRVR",115,0)
 S HLCSTATE("MESSAGE STARTED")=0 ;start of message flag
"RTN","HLOSRVR",116,0)
 S HLCSTATE("MESSAGE ENDED")=0 ;end of message flag
"RTN","HLOSRVR",117,0)
 S NODE=^%ZOSF("OS")
"RTN","HLOSRVR",118,0)
 S HLCSTATE("SYSTEM","OS")=$S(NODE["DSM":"DSM",NODE["OpenM":"CACHE",NODE["G.TM":"G.TM",1:"")
"RTN","HLOSRVR",119,0)
 Q:HLCSTATE("SYSTEM","OS")="" 0
"RTN","HLOSRVR",120,0)
 D  ;get necessary system parameters
"RTN","HLOSRVR",121,0)
 .N SYS,SUB
"RTN","HLOSRVR",122,0)
 .D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOSRVR",123,0)
 .F SUB="MAXSTRING","DOMAIN","STATION","PROCESSING ID","NORMAL PURGE","ERROR PURGE" S HLCSTATE("SYSTEM",SUB)=SYS(SUB)
"RTN","HLOSRVR",124,0)
 .S HLCSTATE("SYSTEM","BUFFER")=SYS("HL7 BUFFER")
"RTN","HLOSRVR",125,0)
 I HLCSTATE("LINK","LLP")="TCP" D
"RTN","HLOSRVR",126,0)
 .D OPEN^HLOTCP(.HLCSTATE,.LOGICAL)
"RTN","HLOSRVR",127,0)
 E  ;no other LLP implemented
"RTN","HLOSRVR",128,0)
 ;
"RTN","HLOSRVR",129,0)
 Q HLCSTATE("CONNECTED")
"RTN","HLOSRVR",130,0)
 ;
"RTN","HLOSRVR",131,0)
INQUE(MSGIEN,PARMS) ;
"RTN","HLOSRVR",132,0)
 ;
"RTN","HLOSRVR",133,0)
 ;
"RTN","HLOSRVR",134,0)
 ;puts received messages on the incoming queue and sets the B x-ref
"RTN","HLOSRVR",135,0)
 I $G(MSGIEN) S INQUE=INQUE+1 M INQUE(MSGIEN)=PARMS
"RTN","HLOSRVR",136,0)
 ;
"RTN","HLOSRVR",137,0)
 ;
"RTN","HLOSRVR",138,0)
 I ('$G(MSGIEN))!(INQUE>20) S MSGIEN=0 D
"RTN","HLOSRVR",139,0)
 .F  S MSGIEN=$O(INQUE(MSGIEN)) Q:'MSGIEN  D
"RTN","HLOSRVR",140,0)
 ..S ^HLB("B",INQUE(MSGIEN,"MSGID"),MSGIEN)=""
"RTN","HLOSRVR",141,0)
 ..S ^HLA("B",INQUE(MSGIEN,"DT/TM"),INQUE(MSGIEN,"BODY"))=""
"RTN","HLOSRVR",142,0)
 ..D:INQUE(MSGIEN,"PASS")
"RTN","HLOSRVR",143,0)
 ...N PURGE,ORIG
"RTN","HLOSRVR",144,0)
 ...S PURGE=+$G(INQUE(MSGIEN,"PURGE"))
"RTN","HLOSRVR",145,0)
 ...S ORIG("IEN")=$G(INQUE(MSGIEN,"ORIG_IEN"))
"RTN","HLOSRVR",146,0)
 ...S:ORIG("IEN") ORIG("STATUS")=$G(INQUE(MSGIEN,"ORIG_STATUS")),ORIG("ACK BY")=INQUE(MSGIEN,"MSGID")
"RTN","HLOSRVR",147,0)
 ...D INQUE^HLOQUE(INQUE(MSGIEN,"FROM"),INQUE(MSGIEN,"QUEUE"),MSGIEN,INQUE(MSGIEN,"ACTION"),PURGE,.ORIG)
"RTN","HLOSRVR",148,0)
 .K INQUE S INQUE=0
"RTN","HLOSRVR",149,0)
 Q
"RTN","HLOSRVR",150,0)
 ;
"RTN","HLOSRVR",151,0)
SAVEACK(HLMSTATE,SENT) ;
"RTN","HLOSRVR",152,0)
 ;Input:
"RTN","HLOSRVR",153,0)
 ;  SENT - flag = 1 if transmission of ack succeeded, 0 otherwise
"RTN","HLOSRVR",154,0)
 ;
"RTN","HLOSRVR",155,0)
 N NODE,I,XX
"RTN","HLOSRVR",156,0)
 S $P(NODE,"^")=HLMSTATE("MSA","DT/TM OF MESSAGE")
"RTN","HLOSRVR",157,0)
 S $P(NODE,"^",2)=HLMSTATE("MSA","MESSAGE CONTROL ID")
"RTN","HLOSRVR",158,0)
 S $P(NODE,"^",3)="MSA"
"RTN","HLOSRVR",159,0)
 F I=1:1:3 S NODE=NODE_"|"_$G(HLMSTATE("MSA",I))
"RTN","HLOSRVR",160,0)
 S ^HLB(HLMSTATE("IEN"),4)=NODE
"RTN","HLOSRVR",161,0)
 S:SENT $P(^HLB(HLMSTATE("IEN"),0),"^",$S($E(HLMSTATE("MSA",1))="A":18,1:17))=1
"RTN","HLOSRVR",162,0)
 Q
"RTN","HLOSRVR",163,0)
 ;
"RTN","HLOSRVR",164,0)
UPDATE(HLMSTATE,HLCSTATE) ;
"RTN","HLOSRVR",165,0)
 ;Updates status and purge date when appropriate
"RTN","HLOSRVR",166,0)
 ;Also, sets the "B" xrefs, files 777,778, and places message on the incoming queue
"RTN","HLOSRVR",167,0)
 ;
"RTN","HLOSRVR",168,0)
 N PARMS
"RTN","HLOSRVR",169,0)
 S PARMS("PASS")=0
"RTN","HLOSRVR",170,0)
 I HLMSTATE("STATUS","ACTION")]"",HLMSTATE("STATUS")'="ER" D
"RTN","HLOSRVR",171,0)
 .N IEN
"RTN","HLOSRVR",172,0)
 .S IEN=HLMSTATE("IEN")
"RTN","HLOSRVR",173,0)
 .S PARMS("PASS")=1,$P(^HLB(IEN,0),"^",6)=HLMSTATE("STATUS","QUEUE"),$P(^HLB(IEN,0),"^",10)=$P(HLMSTATE("STATUS","ACTION"),"^"),$P(^HLB(IEN,0),"^",11)=$P(HLMSTATE("STATUS","ACTION"),"^",2)
"RTN","HLOSRVR",174,0)
 D:'PARMS("PASS")  ;if not passing to the app, set the purge date
"RTN","HLOSRVR",175,0)
 .I HLMSTATE("STATUS")="" S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",176,0)
 .D SETPURGE^HLOF778A(HLMSTATE("IEN"),HLMSTATE("STATUS"),$G(HLMSTATE("ACK TO IEN")),$G(HLMSTATE("ACK TO","STATUS")))
"RTN","HLOSRVR",177,0)
 ;
"RTN","HLOSRVR",178,0)
 ;if not waiting for an application ack, set the status now even if passing to the app - but don't set the purge until the infiler passes the message
"RTN","HLOSRVR",179,0)
 I HLMSTATE("STATUS")="",($G(HLMSTATE("ACK TO IEN"))!HLMSTATE("HDR","APP ACK TYPE")'="AL") S HLMSTATE("STATUS")="SU"
"RTN","HLOSRVR",180,0)
 I HLMSTATE("STATUS")'="" S $P(^HLB(HLMSTATE("IEN"),0),"^",20)=HLMSTATE("STATUS") S:$G(HLMSTATE("MSA",3))]"" $P(^HLB(HLMSTATE("IEN"),0),"^",21)=HLMSTATE("MSA",3) D:HLMSTATE("STATUS")'="SU"
"RTN","HLOSRVR",181,0)
 .N APP
"RTN","HLOSRVR",182,0)
 .S APP=HLMSTATE("HDR","RECEIVING APPLICATION") S:APP="" APP="UNKNOWN" S ^HLB("ERRORS",APP,HLMSTATE("DT/TM"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR",183,0)
 .D COUNT^HLOESTAT("IN",$G(HLMSTATE("HDR","RECEIVING APPLICATION")),$G(HLMSTATE("HDR","SENDING APPLICATION")),$S(HLMSTATE("BATCH"):"BATCH",1:$G(HLMSTATE("HDR","MESSAGE TYPE"))),$G(HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR",184,0)
 ;
"RTN","HLOSRVR",185,0)
 ;set the necessary parms for passing the msg to the app via the infiler
"RTN","HLOSRVR",186,0)
 D:PARMS("PASS")
"RTN","HLOSRVR",187,0)
 .N I,FROM
"RTN","HLOSRVR",188,0)
 .S FROM=HLMSTATE("HDR","SENDING FACILITY",1)
"RTN","HLOSRVR",189,0)
 .I HLMSTATE("HDR","SENDING FACILITY",2)]"" S FROM=FROM_"~"_HLMSTATE("HDR","SENDING FACILITY",2)_"~"_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",190,0)
 .I FROM="" S FROM="UNKNOWN SENDING FACILITY"
"RTN","HLOSRVR",191,0)
 .S PARMS("FROM")=FROM,PARMS("QUEUE")=HLMSTATE("STATUS","QUEUE"),PARMS("ACTION")=HLMSTATE("STATUS","ACTION")
"RTN","HLOSRVR",192,0)
 .I HLMSTATE("STATUS")'="" S PARMS("PURGE")=1
"RTN","HLOSRVR",193,0)
 .;The infiler should set the purge date at the same time as the initial message, and update the status and 'ack by' fields
"RTN","HLOSRVR",194,0)
 .S:$G(HLMSTATE("ACK TO IEN")) PARMS("ORIG_IEN")=HLMSTATE("ACK TO IEN"),PARMS("ORIG_STATUS")=$G(HLMSTATE("ACK TO","STATUS"))
"RTN","HLOSRVR",195,0)
 ;
"RTN","HLOSRVR",196,0)
 S PARMS("BODY")=HLMSTATE("BODY")
"RTN","HLOSRVR",197,0)
 S PARMS("DT/TM")=HLMSTATE("DT/TM")
"RTN","HLOSRVR",198,0)
 S PARMS("MSGID")=HLMSTATE("ID")
"RTN","HLOSRVR",199,0)
 ;
"RTN","HLOSRVR",200,0)
 D INQUE(HLMSTATE("IEN"),.PARMS)
"RTN","HLOSRVR",201,0)
 Q
"RTN","HLOSRVR",202,0)
 ;
"RTN","HLOSRVR",203,0)
WRITEACK(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR",204,0)
 ;Sends an accept ack
"RTN","HLOSRVR",205,0)
 ;
"RTN","HLOSRVR",206,0)
 ;Input:
"RTN","HLOSRVR",207,0)
 ;  HLCSTATE (pass by reference) defines the communication channel
"RTN","HLOSRVR",208,0)
 ;  HLMSTATE (pass by reference) the message being acked
"RTN","HLOSRVR",209,0)
 ;     ("MSA",1) - value for MSA-1
"RTN","HLOSRVR",210,0)
 ;     ("MSA",2) - value for MSA-2
"RTN","HLOSRVR",211,0)
 ;     ("MSA",3) - value for MSA-3
"RTN","HLOSRVR",212,0)
 ;     ("HDR") - parsed values for the message being ack'd
"RTN","HLOSRVR",213,0)
 ;Output:
"RTN","HLOSRVR",214,0)
 ;  Function returns 1 if successful, 0 otherwise
"RTN","HLOSRVR",215,0)
 ;  HLMSTATE("MSA","MESSAGE CONTROL ID") - the msg id of the ack
"RTN","HLOSRVR",216,0)
 ;  HLMSTATE(,"MSA","DT/TM OF MESSAGE") - from the ack header
"RTN","HLOSRVR",217,0)
 ; 
"RTN","HLOSRVR",218,0)
 N HDR,SUB,FS,CS,MSA,ACKID,TIME
"RTN","HLOSRVR",219,0)
 ;Hard-code the delimiters, the standard requires that the receiving system accept the delimiters listed in the header
"RTN","HLOSRVR",220,0)
 S FS="|"
"RTN","HLOSRVR",221,0)
 S CS="^"
"RTN","HLOSRVR",222,0)
 S TIME=$$NOW^XLFDT
"RTN","HLOSRVR",223,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=TIME
"RTN","HLOSRVR",224,0)
 S ACKID=HLCSTATE("SYSTEM","STATION")_" "_$$NEWIEN^HLOF778A("OUT")
"RTN","HLOSRVR",225,0)
 S HLMSTATE("MSA","MESSAGE CONTROL ID")=ACKID
"RTN","HLOSRVR",226,0)
 ;
"RTN","HLOSRVR",227,0)
 S HDR(1)="MSH"_FS_"^~\&"_FS_HLMSTATE("HDR","RECEIVING APPLICATION")_FS_HLCSTATE("SYSTEM","STATION")_CS_HLCSTATE("SYSTEM","DOMAIN")_CS_"DNS"_FS
"RTN","HLOSRVR",228,0)
 S HDR(1)=HDR(1)_HLMSTATE("HDR","SENDING APPLICATION")_FS_HLMSTATE("HDR","SENDING FACILITY",1)_CS_HLMSTATE("HDR","SENDING FACILITY",2)_CS_HLMSTATE("HDR","SENDING FACILITY",3)
"RTN","HLOSRVR",229,0)
 ;
"RTN","HLOSRVR",230,0)
 S HDR(2)=FS_$$HLDATE^HLFNC(TIME,"TS")_FS_FS_"ACK"_FS_ACKID_FS_HLMSTATE("HDR","PROCESSING ID")_FS_"2.4"_FS_FS_FS_"NE"_FS_"NE"
"RTN","HLOSRVR",231,0)
 ;
"RTN","HLOSRVR",232,0)
 S MSA(1)="MSA"_FS
"RTN","HLOSRVR",233,0)
 F SUB=1:1:3 S MSA(1)=MSA(1)_HLMSTATE("MSA",SUB)_FS
"RTN","HLOSRVR",234,0)
 I $$WRITEHDR^HLOT(.HLCSTATE,.HDR),$$WRITESEG^HLOT(.HLCSTATE,.MSA),$$ENDMSG^HLOT(.HLCSTATE) S HLCSTATE("COUNTS","ACKS")=$G(HLCSTATE("COUNTS","ACKS"))+1 Q 1
"RTN","HLOSRVR",235,0)
 S HLMSTATE("MSA","DT/TM OF MESSAGE")=""
"RTN","HLOSRVR",236,0)
 Q 0
"RTN","HLOSRVR1")
0^16^B68927877^B90167265
"RTN","HLOSRVR1",1,0)
HLOSRVR1 ;IRMFO-ALB/CJM/OAK/PIJ - Reading messages, sending acks;03/24/2004  14:43 ;03/08/2012
"RTN","HLOSRVR1",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,131,133,134,137,138,139,143,146,147,152,158**;Oct 13, 1995;Build 14
"RTN","HLOSRVR1",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR1",4,0)
 ;
"RTN","HLOSRVR1",5,0)
READMSG(HLCSTATE,HLMSTATE) ;
"RTN","HLOSRVR1",6,0)
 ;Reads a message.  The header is parsed. Does these checks:
"RTN","HLOSRVR1",7,0)
 ; 1) Duplicate?
"RTN","HLOSRVR1",8,0)
 ; 2) Wrong Receiving Facility?
"RTN","HLOSRVR1",9,0)
 ; 3) Can the Receiving App accept this message, based on the message type & event?
"RTN","HLOSRVR1",10,0)
 ; 4) Processing ID must match the receiving system
"RTN","HLOSRVR1",11,0)
 ; 5) Must have an ID
"RTN","HLOSRVR1",12,0)
 ; 6) Header must be BHS or MSH
"RTN","HLOSRVR1",13,0)
 ;
"RTN","HLOSRVR1",14,0)
 ;Output:
"RTN","HLOSRVR1",15,0)
 ;  Function returns 1 if the message was read fully, 0 otherwise
"RTN","HLOSRVR1",16,0)
 ;  HLMSTATE (pass by reference) the message.  It will include the fields for the return ack in HLMSTATE("MSA")
"RTN","HLOSRVR1",17,0)
 ;
"RTN","HLOSRVR1",18,0)
 N ACK,SEG,STORE,I
"RTN","HLOSRVR1",19,0)
 ;
"RTN","HLOSRVR1",20,0)
 S STORE=1
"RTN","HLOSRVR1",21,0)
 Q:'$$READHDR^HLOT(.HLCSTATE,.SEG) 0
"RTN","HLOSRVR1",22,0)
 D SPLITHDR(.SEG)
"RTN","HLOSRVR1",23,0)
 ;
"RTN","HLOSRVR1",24,0)
 ;parse the header, stop if unsuccessful because the server cannot know what to do next
"RTN","HLOSRVR1",25,0)
 I '$$PARSEHDR^HLOPRS(.SEG) D  Q 0
"RTN","HLOSRVR1",26,0)
ZB29 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",27,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",28,0)
 ;
"RTN","HLOSRVR1",29,0)
 S I=$S(SEG("SEGMENT TYPE")="MSH":$G(SEG("MESSAGE CONTROL ID")),1:$G(SEG("BATCH CONTROL ID")))
"RTN","HLOSRVR1",30,0)
 I I'="" L +HLO("MSGID",I):5 I '$T D  Q 0
"RTN","HLOSRVR1",31,0)
 .S HLCSTATE("MESSAGE ENDED")=0
"RTN","HLOSRVR1",32,0)
 .D CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",33,0)
 ;
"RTN","HLOSRVR1",34,0)
 D NEWMSG^HLOSRVR2(.HLCSTATE,.HLMSTATE,.SEG)
"RTN","HLOSRVR1",35,0)
 I HLMSTATE("ID")="" D
"RTN","HLOSRVR1",36,0)
 .S STORE=0
"RTN","HLOSRVR1",37,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="AL" S HLMSTATE("MSA",1)="CE",HLMSTATE("MSA",3)="CONTROL ID MISSING"
"RTN","HLOSRVR1",38,0)
 I STORE,$$DUP(.HLMSTATE) D
"RTN","HLOSRVR1",39,0)
ZB30 .S STORE=0
"RTN","HLOSRVR1",40,0)
 ;
"RTN","HLOSRVR1",41,0)
 ;if the message is not to be stored, just read it and discard the segments
"RTN","HLOSRVR1",42,0)
 I 'STORE D
"RTN","HLOSRVR1",43,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)
"RTN","HLOSRVR1",44,0)
 ;
"RTN","HLOSRVR1",45,0)
 E  D
"RTN","HLOSRVR1",46,0)
 .N FS,NEWMSGID
"RTN","HLOSRVR1",47,0)
 .S NEWMSGID=""
"RTN","HLOSRVR1",48,0)
 .S FS=HLMSTATE("HDR","FIELD SEPARATOR")
"RTN","HLOSRVR1",49,0)
 .F  Q:'$$READSEG^HLOT(.HLCSTATE,.SEG)  D
"RTN","HLOSRVR1",50,0)
 ..N MSA,SEGTYPE,OLDMSGID,CODE,IEN,TEXT
"RTN","HLOSRVR1",51,0)
 ..S SEGTYPE=$E($E(SEG(1),1,3)_$E($G(SEG(2)),1,2),1,3)
"RTN","HLOSRVR1",52,0)
 ..I SEGTYPE="MSA" D
"RTN","HLOSRVR1",53,0)
 ...S MSA=SEG(1)_$G(SEG(2))_$G(SEG(3))
"RTN","HLOSRVR1",54,0)
 ...S OLDMSGID=$P(MSA,FS,3),CODE=$P(MSA,FS,2)
"RTN","HLOSRVR1",55,0)
 ...S TEXT=$$ESCAPE^HLOPBLD(.HLMSTATE,$P(MSA,FS,4))
"RTN","HLOSRVR1",56,0)
 ...I $E(CODE,1)'="A" S SEGTYPE="" Q
"RTN","HLOSRVR1",57,0)
 ...S IEN=$$ACKTOIEN^HLOMSG1("",OLDMSGID)
"RTN","HLOSRVR1",58,0)
 ..I 'HLMSTATE("BATCH") D
"RTN","HLOSRVR1",59,0)
 ...D:SEGTYPE="MSA"
"RTN","HLOSRVR1",60,0)
 ....S HLMSTATE("ACK TO")=OLDMSGID
"RTN","HLOSRVR1",61,0)
 ....S HLMSTATE("ACK TO","ACK BY")=HLMSTATE("ID")
"RTN","HLOSRVR1",62,0)
 ....S HLMSTATE("ACK TO","STATUS")=$S(CODE="AA":"SU",1:"ER")
"RTN","HLOSRVR1",63,0)
 ....I $G(IEN) D
"RTN","HLOSRVR1",64,0)
 .....S HLMSTATE("ACK TO IEN")=IEN
"RTN","HLOSRVR1",65,0)
 .....S HLMSTATE("ACK TO","SEQUENCE QUEUE")=$P($G(^HLB(+IEN,5)),"^")
"RTN","HLOSRVR1",66,0)
 ....S HLMSTATE("ACK TO","ERROR TEXT")=TEXT
"RTN","HLOSRVR1",67,0)
 ...D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",68,0)
 ..E  D  ;batch
"RTN","HLOSRVR1",69,0)
 ...I SEGTYPE="MSH" D
"RTN","HLOSRVR1",70,0)
 ....D SPLITHDR(.SEG)
"RTN","HLOSRVR1",71,0)
 ....S NEWMSGID=$P(SEG(2),FS,5)
"RTN","HLOSRVR1",72,0)
 ....D ADDMSG2^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",73,0)
 ...E  D  ;not MSH
"RTN","HLOSRVR1",74,0)
 ....D:SEGTYPE="MSA"
"RTN","HLOSRVR1",75,0)
 .....N SUBIEN S SUBIEN=HLMSTATE("BATCH","CURRENT MESSAGE")
"RTN","HLOSRVR1",76,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN)=OLDMSGID
"RTN","HLOSRVR1",77,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"ACK BY")=NEWMSGID
"RTN","HLOSRVR1",78,0)
 .....S HLMSTATE("BATCH","ACK TO",SUBIEN,"STATUS")=$S(CODE="AA":"SU",1:"ER")
"RTN","HLOSRVR1",79,0)
 .....S:$D(IEN) HLMSTATE("BATCH","ACK TO",SUBIEN,"IEN")=IEN
"RTN","HLOSRVR1",80,0)
 ....D ADDSEG^HLOMSG(.HLMSTATE,.SEG)
"RTN","HLOSRVR1",81,0)
 .I HLMSTATE("UNSTORED LINES"),HLCSTATE("MESSAGE ENDED"),$$SAVEMSG^HLOF778(.HLMSTATE)
"RTN","HLOSRVR1",82,0)
 ;
"RTN","HLOSRVR1",83,0)
 I STORE,'HLCSTATE("MESSAGE ENDED") D
"RTN","HLOSRVR1",84,0)
 .;reading failed, don't store
"RTN","HLOSRVR1",85,0)
 .D:HLMSTATE("IEN") DEL778(HLMSTATE("IEN")) D:HLMSTATE("BODY") DEL777(HLMSTATE("BODY"))
"RTN","HLOSRVR1",86,0)
 .S HLMSTATE("IEN")="",HLMSTATE("BODY")=""
"RTN","HLOSRVR1",87,0)
 E  D:STORE
"RTN","HLOSRVR1",88,0)
 .D CHECKMSG(.HLMSTATE)
"RTN","HLOSRVR1",89,0)
 .D ADDAC(.HLMSTATE) ;so future duplicates are detected
"RTN","HLOSRVR1",90,0)
 .D COUNT^HLOSTAT(.HLCSTATE,HLMSTATE("HDR","RECEIVING APPLICATION"),HLMSTATE("HDR","SENDING APPLICATION"),$S(HLMSTATE("BATCH"):"BATCH",1:HLMSTATE("HDR","MESSAGE TYPE")_"~"_HLMSTATE("HDR","EVENT")))
"RTN","HLOSRVR1",91,0)
 ;
"RTN","HLOSRVR1",92,0)
 D:'HLCSTATE("MESSAGE ENDED") CLOSE^HLOT(.HLCSTATE)
"RTN","HLOSRVR1",93,0)
 Q HLCSTATE("MESSAGE ENDED")
"RTN","HLOSRVR1",94,0)
 ;
"RTN","HLOSRVR1",95,0)
ADDAC(HLMSTATE) ;adds the AC xref for duplicates detection
"RTN","HLOSRVR1",96,0)
 ;
"RTN","HLOSRVR1",97,0)
 N FROM
"RTN","HLOSRVR1",98,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",99,0)
 S ^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),HLMSTATE("IEN"))=""
"RTN","HLOSRVR1",100,0)
 Q
"RTN","HLOSRVR1",101,0)
 ;
"RTN","HLOSRVR1",102,0)
DUP(HLMSTATE) ;
"RTN","HLOSRVR1",103,0)
 ;Returns 1 if the message is a duplicate and its ack (if requested) is found, 0 otherwise
"RTN","HLOSRVR1",104,0)
 ;Input:
"RTN","HLOSRVR1",105,0)
 ; HLMSTATE (pass by reference) the message being read
"RTN","HLOSRVR1",106,0)
 ;Output:
"RTN","HLOSRVR1",107,0)
 ;  Function returns 1 if the message is a duplicate, 0 otherwise
"RTN","HLOSRVR1",108,0)
 ;  HLMSTATE (pass by reference) IF the message is a duplicate:
"RTN","HLOSRVR1",109,0)
 ;     returns the prior MSA segment in HLMSTATE("MSA")
"RTN","HLOSRVR1",110,0)
 ;
"RTN","HLOSRVR1",111,0)
 N IEN,FROM,DUP
"RTN","HLOSRVR1",112,0)
 S (IEN,DUP)=0
"RTN","HLOSRVR1",113,0)
 ;
"RTN","HLOSRVR1",114,0)
 ;no way to determine!  Bad header will be rejected
"RTN","HLOSRVR1",115,0)
 Q:(HLMSTATE("ID")="") 0
"RTN","HLOSRVR1",116,0)
 ;
"RTN","HLOSRVR1",117,0)
 S FROM=$S(HLMSTATE("HDR","SENDING FACILITY",2)]"":HLMSTATE("HDR","SENDING FACILITY",2),1:HLMSTATE("HDR","SENDING FACILITY",1))
"RTN","HLOSRVR1",118,0)
 F  S IEN=$O(^HLB("AC",FROM_HLMSTATE("HDR","SENDING APPLICATION")_HLMSTATE("ID"),IEN)) Q:'IEN  D  Q:DUP
"RTN","HLOSRVR1",119,0)
 .I HLMSTATE("HDR","ACCEPT ACK TYPE")="NE" S DUP=1 Q
"RTN","HLOSRVR1",120,0)
 .;need the MSA to return
"RTN","HLOSRVR1",121,0)
 .D  Q
"RTN","HLOSRVR1",122,0)
 ..N NODE
"RTN","HLOSRVR1",123,0)
 ..S NODE=$P($G(^HLB(IEN,4)),"^",3,10)
"RTN","HLOSRVR1",124,0)
 ..S HLMSTATE("MSA",1)=$P(NODE,"|",2)
"RTN","HLOSRVR1",125,0)
 ..Q:$L(HLMSTATE("MSA",1))'=2
"RTN","HLOSRVR1",126,0)
 ..S HLMSTATE("MSA",2)=$P(NODE,"|",3)
"RTN","HLOSRVR1",127,0)
 ..S HLMSTATE("MSA",3)=$P(NODE,"|",4,10)
"RTN","HLOSRVR1",128,0)
 ..S DUP=1
"RTN","HLOSRVR1",129,0)
 ;
"RTN","HLOSRVR1",130,0)
 Q DUP
"RTN","HLOSRVR1",131,0)
 ;
"RTN","HLOSRVR1",132,0)
CHECKMSG(HLMSTATE) ;
"RTN","HLOSRVR1",133,0)
 ;Checks the header & MSA segment, sets HLMSTATE("STATUS","ACTION") if the message needs to be passed, determines if completion status should be set
"RTN","HLOSRVR1",134,0)
 ;Input:
"RTN","HLOSRVR1",135,0)
 ;  HLMSTATE("HDR") - the parsed header segment
"RTN","HLOSRVR1",136,0)
 ;Output:
"RTN","HLOSRVR1",137,0)
 ;  HLMSTATE("STATUS")="ER" if an error is detected
"RTN","HLOSRVR1",138,0)
 ;  HLMSTATE("STATUS","QUEUE") queue to put the message on
"RTN","HLOSRVR1",139,0)
 ;  HLMSTATE("STATUS","ACTION")  <tag^rtn> that is the processing routine for the receiving application
"RTN","HLOSRVR1",140,0)
 ;  HLMSTATE("MSA") - MSA(1)=accept code to be returned, MSA(3)= error txt
"RTN","HLOSRVR1",141,0)
 ;
"RTN","HLOSRVR1",142,0)
 N WANTACK,PASS,ACTION,QUEUE,ERROR
"RTN","HLOSRVR1",143,0)
 M HDR=HLMSTATE("HDR")
"RTN","HLOSRVR1",144,0)
 S ERROR=0
"RTN","HLOSRVR1",145,0)
 I HDR("ACCEPT ACK TYPE")="NE",'HLMSTATE("ORIGINAL MODE") D
"RTN","HLOSRVR1",146,0)
 .S WANTACK=0
"RTN","HLOSRVR1",147,0)
 E  D
"RTN","HLOSRVR1",148,0)
 .S WANTACK=1
"RTN","HLOSRVR1",149,0)
 I HLMSTATE("ORIGINAL MODE") S HLMSTATE("MSA",1)="AE",HLMSTATE("MSA",3)="THIS INTERFACE DOES NOT IMPLEMENT ORIGINAL MODE APPLICATION ACKOWLEDGMENTS",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",150,0)
 I $G(HLMSTATE("ACK TO"))="" D  Q:ERROR
"RTN","HLOSRVR1",151,0)
 .;
"RTN","HLOSRVR1",152,0)
 .I '$$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S ERROR=1 S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("MSA",3)="RECEIVING APPLICATION NOT DEFINED",HLMSTATE("STATUS")="ER" Q
"RTN","HLOSRVR1",153,0)
 .S HLMSTATE("STATUS","ACTION")=$G(ACTION),HLMSTATE("STATUS","QUEUE")=$G(QUEUE)
"RTN","HLOSRVR1",154,0)
 E  D  Q:ERROR  ;this is an app ack
"RTN","HLOSRVR1",155,0)
 .;does the original message exist?
"RTN","HLOSRVR1",156,0)
 .N NODE
"RTN","HLOSRVR1",157,0)
 .S:+$G(HLMSTATE("ACK TO IEN")) NODE=$G(^HLB(+HLMSTATE("ACK TO IEN"),0))
"RTN","HLOSRVR1",158,0)
 .I $G(NODE)="" S ERROR=1,HLMSTATE("STATUS")="ER",HLMSTATE("ACK TO IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE TO APPLICATION ACKNOWLEDGMENT NOT FOUND" Q
"RTN","HLOSRVR1",159,0)
 .I $P(NODE,"^",7)'="",$P(NODE,"^",7)'=HLMSTATE("ID") S ERROR=1,HLMSTATE("STATUS")="ER",HLMSTATE("ACK TO IEN")="" S:WANTACK HLMSTATE("MSA",1)="CE" S HLMSTATE("MSA",3)="INITIAL MESSAGE WAS ALREADY ACKED" Q
"RTN","HLOSRVR1",160,0)
 .;
"RTN","HLOSRVR1",161,0)
 .S HLMSTATE("STATUS","QUEUE")=$S($P(NODE,"^",6)]"":$P(NODE,"^",6),1:"DEFAULT")
"RTN","HLOSRVR1",162,0)
 .I ($P(NODE,"^",11)]"") S HLMSTATE("STATUS","ACTION")=$P(NODE,"^",10,11) Q
"RTN","HLOSRVR1",163,0)
 .;processing routine for the app ack wasn't found with the original message, look in the HLO Application Registry
"RTN","HLOSRVR1",164,0)
 .I HLMSTATE("HDR","MESSAGE TYPE")="ACK",HLMSTATE("HDR","EVENT")="" S HDR("EVENT")=$$GETEVENT^HLOCLNT2(+HLMSTATE("ACK TO IEN"))
"RTN","HLOSRVR1",165,0)
 .;
"RTN","HLOSRVR1",166,0)
 .I $$ACTION^HLOAPP(.HDR,.ACTION,.QUEUE) S HLMSTATE("STATUS","ACTION")=$G(ACTION) S:HLMSTATE("STATUS","QUEUE")="DEFAULT" HLMSTATE("STATUS","QUEUE")=QUEUE
"RTN","HLOSRVR1",167,0)
 ;
"RTN","HLOSRVR1",168,0)
 I HDR("PROCESSING ID")'=HLCSTATE("SYSTEM","PROCESSING ID") S:WANTACK HLMSTATE("MSA",1)="CR" S HLMSTATE("STATUS")="ER",HLMSTATE("MSA",3)="SYSTEM PROCESSING ID="_HLCSTATE("SYSTEM","PROCESSING ID") Q
"RTN","HLOSRVR1",169,0)
 ;
"RTN","HLOSRVR1",170,0)
 ;wrong receiving facility?  This is hard to check if the sender is not VistA, because the HL7 standard permits different coding systems to be used. This check is only for DNS or station number.
"RTN","HLOSRVR1",171,0)
 S PASS=0
"RTN","HLOSRVR1",172,0)
 D
"RTN","HLOSRVR1",173,0)
 .;if its an ack to an existing message, don't check the receiving facility
"RTN","HLOSRVR1",174,0)
 .I $G(HLMSTATE("ACK TO"))]"" S PASS=1 Q
"RTN","HLOSRVR1",175,0)
 .I HDR("RECEIVING FACILITY",1)=HLCSTATE("SYSTEM","STATION") S PASS=1 Q
"RTN","HLOSRVR1",176,0)
 .I HDR("RECEIVING FACILITY",3)'="DNS" S PASS=1 Q
"RTN","HLOSRVR1",177,0)
 .I HDR("RECEIVING FACILITY",2)="" S PASS=1 Q
"RTN","HLOSRVR1",178,0)
 .I $P(HDR("RECEIVING FACILITY",2),":")[HLCSTATE("SYSTEM","DOMAIN") S PASS=1 Q
"RTN","HLOSRVR1",179,0)
 .I HLCSTATE("SYSTEM","DOMAIN")[$P(HDR("RECEIVING FACILITY",2),":") S PASS=1 Q
"RTN","HLOSRVR1",180,0)
 I 'PASS S HLMSTATE("STATUS")="ER",HLMSTATE("MSA",3)="RECEIVING FACILITY IS "_HLCSTATE("SYSTEM","DOMAIN") S:WANTACK HLMSTATE("MSA",1)="CE"
"RTN","HLOSRVR1",181,0)
 I PASS,WANTACK S HLMSTATE("MSA",1)="CA"
"RTN","HLOSRVR1",182,0)
 Q
"RTN","HLOSRVR1",183,0)
 ;
"RTN","HLOSRVR1",184,0)
DEL777(IEN777) ;delete a record from file 777 where the read did not complete
"RTN","HLOSRVR1",185,0)
 ;
"RTN","HLOSRVR1",186,0)
 K ^HLA(IEN777,0)
"RTN","HLOSRVR1",187,0)
 Q
"RTN","HLOSRVR1",188,0)
DEL778(IEN778) ;delete a record from file 778 where the read did not complete
"RTN","HLOSRVR1",189,0)
 ;
"RTN","HLOSRVR1",190,0)
 K ^HLB(IEN778,0)
"RTN","HLOSRVR1",191,0)
 Q
"RTN","HLOSRVR1",192,0)
 ;
"RTN","HLOSRVR1",193,0)
SPLITHDR(HDR) ;
"RTN","HLOSRVR1",194,0)
 ;splits hdr segment into two lines, first being just components 1-6
"RTN","HLOSRVR1",195,0)
 ;
"RTN","HLOSRVR1",196,0)
 N TEMP,FS
"RTN","HLOSRVR1",197,0)
 D SQUISH(.HDR)
"RTN","HLOSRVR1",198,0)
 S FS=$E($G(HDR(1)),4)
"RTN","HLOSRVR1",199,0)
 S TEMP(1)=$P($G(HDR(1)),FS,1,6)
"RTN","HLOSRVR1",200,0)
 S TEMP(2)=""
"RTN","HLOSRVR1",201,0)
 I $L(TEMP(1))<$L($G(HDR(1))) S TEMP(2)=FS_$P($G(HDR(1)),FS,7,20)
"RTN","HLOSRVR1",202,0)
 S HDR(2)=TEMP(2)_$G(HDR(2))
"RTN","HLOSRVR1",203,0)
 S HDR(1)=TEMP(1)
"RTN","HLOSRVR1",204,0)
 Q
"RTN","HLOSRVR1",205,0)
 ;
"RTN","HLOSRVR1",206,0)
SQUISH(SEG) ;
"RTN","HLOSRVR1",207,0)
 ;reformat the segment array into full lines
"RTN","HLOSRVR1",208,0)
 ;
"RTN","HLOSRVR1",209,0)
 ;nothing to do if less than 2 lines
"RTN","HLOSRVR1",210,0)
 Q:'$O(SEG(1))
"RTN","HLOSRVR1",211,0)
 ;
"RTN","HLOSRVR1",212,0)
 N A,I,J,K,MAX,COUNT,LEN
"RTN","HLOSRVR1",213,0)
 S MAX=$S($G(HLCSTATE("SYSTEM","MAXSTRING"))>256:HLCSTATE("SYSTEM","MAXSTRING"),1:256)
"RTN","HLOSRVR1",214,0)
 S (COUNT,I)=0,J=1
"RTN","HLOSRVR1",215,0)
 F  S I=$O(SEG(I)) Q:'I  D
"RTN","HLOSRVR1",216,0)
 .S LEN=$L(SEG(I))
"RTN","HLOSRVR1",217,0)
 .F K=1:1:LEN D
"RTN","HLOSRVR1",218,0)
 ..S A(J)=$G(A(J))_$E(SEG(I),K)
"RTN","HLOSRVR1",219,0)
 ..S COUNT=COUNT+1
"RTN","HLOSRVR1",220,0)
 ..I (COUNT>(MAX-1)) S COUNT=0,J=J+1
"RTN","HLOSRVR1",221,0)
 K SEG
"RTN","HLOSRVR1",222,0)
 M SEG=A
"RTN","HLOSRVR1",223,0)
 Q
"RTN","HLOSRVR2")
0^17^B5343067^B5350765
"RTN","HLOSRVR2",1,0)
HLOSRVR2 ;ALB/CJM-HL7 - HLO Server ;02/29/2012
"RTN","HLOSRVR2",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**131,137,138,146,158**;Oct 13, 1995;Build 14
"RTN","HLOSRVR2",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOSRVR2",4,0)
 ;
"RTN","HLOSRVR2",5,0)
NEWMSG(HLCSTATE,HLMSTATE,HDR) ;
"RTN","HLOSRVR2",6,0)
 ;initialize the HLMSTATE array after reading the header
"RTN","HLOSRVR2",7,0)
 ;Inputs:
"RTN","HLOSRVR2",8,0)
 ;  HLCSTATE (pass by reference)
"RTN","HLOSRVR2",9,0)
 ;  HDR (pass by reference) parsed header
"RTN","HLOSRVR2",10,0)
 ;Output:
"RTN","HLOSRVR2",11,0)
 ;  HLMSTATE (pass by reference)
"RTN","HLOSRVR2",12,0)
 ;
"RTN","HLOSRVR2",13,0)
 K HLMSTATE
"RTN","HLOSRVR2",14,0)
 S HLMSTATE("IEN")=""
"RTN","HLOSRVR2",15,0)
 S HLMSTATE("BODY")=""
"RTN","HLOSRVR2",16,0)
 S HLMSTATE("DIRECTION")="IN"
"RTN","HLOSRVR2",17,0)
 S HLMSTATE("CURRENT SEGMENT")=0 ;no segments in cache
"RTN","HLOSRVR2",18,0)
 S HLMSTATE("UNSTORED LINES")=1 ;just the header in cache so far
"RTN","HLOSRVR2",19,0)
 S HLMSTATE("LINE COUNT")=0 ;no lines within message stored to disk
"RTN","HLOSRVR2",20,0)
 I HDR("SEGMENT TYPE")="BHS" D
"RTN","HLOSRVR2",21,0)
 .S HLMSTATE("BATCH")=1
"RTN","HLOSRVR2",22,0)
 .S HLMSTATE("ID")=HDR("BATCH CONTROL ID")
"RTN","HLOSRVR2",23,0)
 .S HLMSTATE("BATCH","CURRENT MESSAGE")=0 ;no messages in batch
"RTN","HLOSRVR2",24,0)
 .S HLMSTATE("UNSTORED MSH")=0
"RTN","HLOSRVR2",25,0)
 E  D
"RTN","HLOSRVR2",26,0)
 .S HLMSTATE("BATCH")=0
"RTN","HLOSRVR2",27,0)
 .S HLMSTATE("ID")=HDR("MESSAGE CONTROL ID")
"RTN","HLOSRVR2",28,0)
 M HLMSTATE("HDR")=HDR
"RTN","HLOSRVR2",29,0)
 M HLMSTATE("SYSTEM")=HLCSTATE("SYSTEM")
"RTN","HLOSRVR2",30,0)
 S HLMSTATE("STATUS")=""
"RTN","HLOSRVR2",31,0)
 S HLMSTATE("STATUS","QUEUE")=""
"RTN","HLOSRVR2",32,0)
 S HLMSTATE("STATUS","ACTION")=""
"RTN","HLOSRVR2",33,0)
 S HLMSTATE("STATUS","LINK NAME")=HLCSTATE("LINK","NAME")
"RTN","HLOSRVR2",34,0)
 S HLMSTATE("STATUS","PORT")=$P(HDR("SENDING FACILITY",2),":",2)
"RTN","HLOSRVR2",35,0)
 ;
"RTN","HLOSRVR2",36,0)
 ;if this is a batch, and it references another batch, assume it is a batch of app acks
"RTN","HLOSRVR2",37,0)
 ;** START 138 CJM
"RTN","HLOSRVR2",38,0)
 ;I HLMSTATE("BATCH"),HLMSTATE("ID")]"" D
"RTN","HLOSRVR2",39,0)
 I HLMSTATE("BATCH"),HLMSTATE("HDR","REFERENCE BATCH CONTROL ID")]"" D
"RTN","HLOSRVR2",40,0)
 .N IEN
"RTN","HLOSRVR2",41,0)
 .;S HLMSTATE("ACK TO")=HLMSTATE("ID")
"RTN","HLOSRVR2",42,0)
 .S HLMSTATE("ACK TO")=HLMSTATE("HDR","REFERENCE BATCH CONTROL ID")
"RTN","HLOSRVR2",43,0)
 .S HLMSTATE("ACK TO","STATUS")="SU"
"RTN","HLOSRVR2",44,0)
 .;S IEN=$O(^HLB("B",HLMSTATE("ID"),0))
"RTN","HLOSRVR2",45,0)
 .S IEN=$O(^HLB("B",HLMSTATE("HDR","REFERENCE BATCH CONTROL ID"),0))
"RTN","HLOSRVR2",46,0)
 .;** END 138 CJM
"RTN","HLOSRVR2",47,0)
 .I IEN S HLMSTATE("ACK TO IEN")=IEN_"^"
"RTN","HLOSRVR2",48,0)
 E  S HLMSTATE("ACK TO")=""
"RTN","HLOSRVR2",49,0)
 I 'HLMSTATE("BATCH"),HDR("ACCEPT ACK TYPE")="",HDR("APP ACK TYPE")="" D
"RTN","HLOSRVR2",50,0)
 .S HLMSTATE("ORIGINAL MODE")=1
"RTN","HLOSRVR2",51,0)
 E  D
"RTN","HLOSRVR2",52,0)
 .S HLMSTATE("ORIGINAL MODE")=0
"RTN","HLOSRVR2",53,0)
 N I F I=1,3 S HLMSTATE("MSA",I)=""
"RTN","HLOSRVR2",54,0)
 S HLMSTATE("MSA",2)=HLMSTATE("ID")
"RTN","HLOSRVR2",55,0)
 Q
"RTN","HLOUSR")
0^18^B121713479^B121166141
"RTN","HLOUSR",1,0)
HLOUSR ;ALB/CJM/OAK/PIJ/RBN -ListManager Screen for viewing system status;12 JUN 1997 10:00 am ;02/28/2012
"RTN","HLOUSR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,134,137,138,139,146,147,153,158**;Oct 13, 1995;Build 14
"RTN","HLOUSR",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR",4,0)
 ;
"RTN","HLOUSR",5,0)
EN ;
"RTN","HLOUSR",6,0)
 ;
"RTN","HLOUSR",7,0)
 N HLSCREEN,TESTOPEN,HLRFRSH,HLPARMS
"RTN","HLOUSR",8,0)
 D WAIT^DICD
"RTN","HLOUSR",9,0)
 D EN^VALM("HLO SYSTEM MONITOR")
"RTN","HLOUSR",10,0)
 Q
"RTN","HLOUSR",11,0)
 ;
"RTN","HLOUSR",12,0)
BRIEF ;
"RTN","HLOUSR",13,0)
 N COUNT,LINK,QUE,FROM,TIME,STATUS,TEMP,DIR,TODAY,LIST,LNKMSG,OS
"RTN","HLOUSR",14,0)
 S HLRFRSH="BRIEF^HLOUSR"
"RTN","HLOUSR",15,0)
 S (HLSCREEN,VALMSG)="Brief System Status"
"RTN","HLOUSR",16,0)
 S VALMCNT=16
"RTN","HLOUSR",17,0)
 ;K @VALMAR
"RTN","HLOUSR",18,0)
 S OS=$$OS^%ZOSV
"RTN","HLOUSR",19,0)
 ;
"RTN","HLOUSR",20,0)
 D CLEAN^VALM10
"RTN","HLOUSR",21,0)
 S VALMBG=1
"RTN","HLOUSR",22,0)
 S VALMBCK="R"
"RTN","HLOUSR",23,0)
 S VALMDDF("COL 1")="COL1^1^80^"
"RTN","HLOUSR",24,0)
 K VALMDDF("COL 2"),VALMDDF("COL 3"),VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",25,0)
 D CHGCAP^VALM("COL 1"," Brief Operational Overview")
"RTN","HLOUSR",26,0)
 S @VALMAR@(1,0)="SYSTEM STATUS:             "_$S($$CHKSTOP^HLOPROC:"STOPPED",1:"RUNNING")
"RTN","HLOUSR",27,0)
 S @VALMAR@(2,0)="PROCESS MANAGER:           "_$S($$RUNNING:"RUNNING",1:"STOPPED")
"RTN","HLOUSR",28,0)
 ;
"RTN","HLOUSR",29,0)
 ;
"RTN","HLOUSR",30,0)
 I $$CHKSTOP^HLOPROC,OS'["VMS" S TESTOPEN("LISTENER")=""
"RTN","HLOUSR",31,0)
 S TIME=$P($G(TESTOPEN("LISTENER")),"^",2)
"RTN","HLOUSR",32,0)
 I TIME,$$FMDIFF^XLFDT($$NOW^XLFDT,TIME,2)<100 D
"RTN","HLOUSR",33,0)
 .S STATUS=+TESTOPEN("LISTENER")
"RTN","HLOUSR",34,0)
 E  D
"RTN","HLOUSR",35,0)
 .;** P147 START CJM
"RTN","HLOUSR",36,0)
 .;is the Kernel listener running under the HLO process manager?
"RTN","HLOUSR",37,0)
 .S STATUS=$$KLISTEN
"RTN","HLOUSR",38,0)
 .;
"RTN","HLOUSR",39,0)
 .;if the Kernel listner is NOT running, might check the listener via the OPEN command.  With loadbalancing, the IP address of the listener link sometimes fails, so also try 'loopback'.
"RTN","HLOUSR",40,0)
 .I 'STATUS,(OS["VMS")!('$$CHKSTOP^HLOPROC) D
"RTN","HLOUSR",41,0)
 ..N IP,LINK
"RTN","HLOUSR",42,0)
 ..S LINK=$P($G(^HLD(779.1,1,0)),"^",10)
"RTN","HLOUSR",43,0)
 ..I LINK,$$GET^HLOTLNK(LINK,.LINK) D
"RTN","HLOUSR",44,0)
 ...F IP="127.0.0.1","0.0.0.0",LINK("IP") D  Q:STATUS
"RTN","HLOUSR",45,0)
 ....N POP,IO,IOF,IOST
"RTN","HLOUSR",46,0)
 ....D CALL^%ZISTCP(IP,LINK("PORT"),5)
"RTN","HLOUSR",47,0)
 ....S STATUS='POP
"RTN","HLOUSR",48,0)
 ....C:STATUS IO
"RTN","HLOUSR",49,0)
 .;
"RTN","HLOUSR",50,0)
 .S:(('STATUS)&('$$CHKSTOP^HLOPROC)) LNKMSG=$S(OS["VMS":" Please start the HLO VMS TCPIP SERVICE",1:"Please start the HLO Listener")
"RTN","HLOUSR",51,0)
 .;
"RTN","HLOUSR",52,0)
 .;** P147 END CJM
"RTN","HLOUSR",53,0)
 .;
"RTN","HLOUSR",54,0)
 .D:'STATUS CNTRL^VALM10(3,38,85,IOINHI,IOINORM)
"RTN","HLOUSR",55,0)
 .S TESTOPEN("LISTENER")=STATUS_"^"_$$NOW^XLFDT
"RTN","HLOUSR",56,0)
 ;
"RTN","HLOUSR",57,0)
 S @VALMAR@(3,0)="STANDARD LISTENER:         "_$S(STATUS:"RUNNING",1:"STOPPED   ")_$G(LNKMSG)
"RTN","HLOUSR",58,0)
 ;** P139 end **
"RTN","HLOUSR",59,0)
 ;
"RTN","HLOUSR",60,0)
 S @VALMAR@(4,0)="TASKMAN:                   "_$S($$TM^%ZTLOAD:"RUNNING",1:"STOPPED")
"RTN","HLOUSR",61,0)
 ;
"RTN","HLOUSR",62,0)
 S (LIST,LINK)=""
"RTN","HLOUSR",63,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D  I $L(LIST)>60 S LIST=LIST_",..." Q
"RTN","HLOUSR",64,0)
 .N TIME,QUE,LINKARY
"RTN","HLOUSR",65,0)
 .I $$GETLINK^HLOTLNK($P(LINK,":"),.LINKARY)
"RTN","HLOUSR",66,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOUSR",67,0)
 .I '$G(LINKARY("SHUTDOWN")),TIME="" Q
"RTN","HLOUSR",68,0)
 .I '$G(LINKARY("SHUTDOWN")),($$HDIFF^XLFDT($H,TIME,2)<300) Q
"RTN","HLOUSR",69,0)
 .;;***patch HL*1.6*138 start
"RTN","HLOUSR",70,0)
 .S LIST=LIST_$S($L(LIST):", ",1:"")_LINK
"RTN","HLOUSR",71,0)
 .;;.S LIST=LIST_$S($L(LIST):", ",1:"")_$P(LINK,":")
"RTN","HLOUSR",72,0)
 .;; ***patch HL*1.6*138 end
"RTN","HLOUSR",73,0)
 S @VALMAR@(5,0)="DOWN LINKS: "_LIST
"RTN","HLOUSR",74,0)
 S @VALMAR@(6,0)="CLIENT LINK PROCESSES:     "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","OUTGOING CLIENT LINK"))
"RTN","HLOUSR",75,0)
 S @VALMAR@(7,0)="IN-FILER PROCESSES:        "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","INCOMING QUEUES"))
"RTN","HLOUSR",76,0)
 ; ***patch HL*1.6*146 START - RBN ***
"RTN","HLOUSR",77,0)
 ;S COUNT=0,LINK=""
"RTN","HLOUSR",78,0)
 ;F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOUSR",79,0)
 ;.S QUE=""
"RTN","HLOUSR",80,0)
 ;.F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOUSR",81,0)
 ;..S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE))
"RTN","HLOUSR",82,0)
 ;..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",83,0)
 N CNTARRAY
"RTN","HLOUSR",84,0)
 S COUNT=$$OUT^HLOQUE(.CNTARRAY)
"RTN","HLOUSR",85,0)
 ; ***patch HL*1.6*146 END - RBN ***
"RTN","HLOUSR",86,0)
 S @VALMAR@(8,0)="MESSAGES PENDING ON OUT QUEUES:    "_$$RJ(+COUNT,7)_"     ON SEQUENCE QUEUES:  "_$$RJ(+$G(^HLC("QUEUECOUNT","SEQUENCE")),7)
"RTN","HLOUSR",87,0)
 S TEMP="STOPPED OUTGOING QUEUES: "
"RTN","HLOUSR",88,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",89,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","OUT",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",90,0)
 S @VALMAR@(9,0)=TEMP
"RTN","HLOUSR",91,0)
 ; ***patch HL*1.6*146 START - RBN ***
"RTN","HLOUSR",92,0)
 ;S COUNT=0,QUE=""
"RTN","HLOUSR",93,0)
 ;F  S QUE=$O(^HLC("QUEUECOUNT","IN",QUE)) Q:QUE=""  D
"RTN","HLOUSR",94,0)
 ;.S FROM=""
"RTN","HLOUSR",95,0)
 ;.F  S FROM=$O(^HLC("QUEUECOUNT","IN",QUE,FROM)) Q:FROM=""  D
"RTN","HLOUSR",96,0)
 ;..S TEMP=$G(^HLC("QUEUECOUNT","IN",QUE,FROM))
"RTN","HLOUSR",97,0)
 ;..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",98,0)
 S COUNT=0
"RTN","HLOUSR",99,0)
 K CNTARRAY
"RTN","HLOUSR",100,0)
 S COUNT=$$IN^HLOQUE(.CNTARRAY)
"RTN","HLOUSR",101,0)
 ; ***patch HL*1.6*146 END - RBN ***
"RTN","HLOUSR",102,0)
 S @VALMAR@(10,0)="MESSAGES PENDING ON APPLICATIONS: "_$$RJ(+COUNT,7)
"RTN","HLOUSR",103,0)
 S TEMP="STOPPED INCOMING QUEUES: "
"RTN","HLOUSR",104,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",105,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","IN",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",106,0)
 S @VALMAR@(11,0)=TEMP
"RTN","HLOUSR",107,0)
 S @VALMAR@(12,0)="FILE 777 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^",2))
"RTN","HLOUSR",108,0)
 S @VALMAR@(13,0)="FILE 778 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^",2))
"RTN","HLOUSR",109,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOUSR",110,0)
 S @VALMAR@(14,0)="MESSAGES SENT TODAY:           "_$$RJ($$ADD("OUT"),10)
"RTN","HLOUSR",111,0)
 S @VALMAR@(15,0)="MESSAGES RECEIVED TODAY:       "_$$RJ($$ADD("IN"),10)
"RTN","HLOUSR",112,0)
 S @VALMAR@(16,0)="MESSAGE ERRORS TODAY:          "_$$RJ($$ADD("EOUT")+$$ADD("EIN"),10)
"RTN","HLOUSR",113,0)
 Q
"RTN","HLOUSR",114,0)
 ;
"RTN","HLOUSR",115,0)
ADD(DIR) ;
"RTN","HLOUSR",116,0)
 N RAP,SAP,TIME,TOTAL,TYPE
"RTN","HLOUSR",117,0)
 S TOTAL=0
"RTN","HLOUSR",118,0)
 S TIME=TODAY-.0001
"RTN","HLOUSR",119,0)
 F  S TIME=$O(^HLSTATS(DIR,"HOURLY",TIME)) Q:'TIME  Q:((TIME\1)>TODAY)  D
"RTN","HLOUSR",120,0)
 .S SAP=""
"RTN","HLOUSR",121,0)
 .F  S SAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOUSR",122,0)
 ..Q:SAP="ACCEPT ACK"
"RTN","HLOUSR",123,0)
 ..S RAP=""
"RTN","HLOUSR",124,0)
 ..F  S RAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOUSR",125,0)
 ...S TYPE=""
"RTN","HLOUSR",126,0)
 ...F  S TYPE=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOUSR",127,0)
 ....S TOTAL=TOTAL+$G(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE))
"RTN","HLOUSR",128,0)
 Q TOTAL
"RTN","HLOUSR",129,0)
 ;
"RTN","HLOUSR",130,0)
HELP ;
"RTN","HLOUSR",131,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSR",132,0)
 Q
"RTN","HLOUSR",133,0)
 ;
"RTN","HLOUSR",134,0)
EXIT ;
"RTN","HLOUSR",135,0)
 D CLEAN^VALM10
"RTN","HLOUSR",136,0)
 D CLEAR^VALM1
"RTN","HLOUSR",137,0)
 Q
"RTN","HLOUSR",138,0)
 ;
"RTN","HLOUSR",139,0)
EXPND ;
"RTN","HLOUSR",140,0)
 Q
"RTN","HLOUSR",141,0)
 ;
"RTN","HLOUSR",142,0)
PROCS ;
"RTN","HLOUSR",143,0)
 S HLRFRSH="PROCS^HLOUSR"
"RTN","HLOUSR",144,0)
 ;K @VALMAR
"RTN","HLOUSR",145,0)
 D CLEAN^VALM10
"RTN","HLOUSR",146,0)
 S VALMCNT=0
"RTN","HLOUSR",147,0)
 S VALMBCK="R"
"RTN","HLOUSR",148,0)
 S VALMDDF("COL 1")="COL 1^1^34^"
"RTN","HLOUSR",149,0)
 S VALMDDF("COL 2")="COL 2^35^10^MIN^H"
"RTN","HLOUSR",150,0)
 S VALMDDF("COL 3")="COL 3^47^10^MAX^H"
"RTN","HLOUSR",151,0)
 S VALMDDF("COL 4")="COL 4^59^10^#RUNNING^H"
"RTN","HLOUSR",152,0)
 S VALMDDF("COL 5")="COL 5^71^10^#QUEUED^IOBON"
"RTN","HLOUSR",153,0)
 D CHGCAP^VALM("COL 1"," Process Type")
"RTN","HLOUSR",154,0)
 N IEN
"RTN","HLOUSR",155,0)
 S IEN=0
"RTN","HLOUSR",156,0)
 F  S IEN=$O(^HLD(779.3,"C",1,IEN)) Q:'IEN  D
"RTN","HLOUSR",157,0)
 .N PROC
"RTN","HLOUSR",158,0)
 .Q:'$$GETPROC^HLOPROC1(IEN,.PROC)
"RTN","HLOUSR",159,0)
 .Q:PROC("NAME")="VMS TCP LISTENER"
"RTN","HLOUSR",160,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",161,0)
 .S @VALMAR@(VALMCNT,0)=$$LJ(PROC("NAME"),30)_$$RJ(PROC("MINIMUM"),6)_$$RJ(PROC("MAXIMUM"),12)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC("NAME"))),14)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC("NAME"))),12)
"RTN","HLOUSR",162,0)
 S VALMCNT=VALMCNT+1,@VALMAR@(VALMCNT,0)=""
"RTN","HLOUSR",163,0)
 S IEN=""
"RTN","HLOUSR",164,0)
 F  S IEN=$O(^HLTMP("HL7 RUNNING PROCESSES",IEN)) Q:IEN=""  D
"RTN","HLOUSR",165,0)
 .N NODE
"RTN","HLOUSR",166,0)
 .S NODE=$G(^HLTMP("HL7 RUNNING PROCESSES",IEN))
"RTN","HLOUSR",167,0)
 .Q:NODE=""
"RTN","HLOUSR",168,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",169,0)
 .S @VALMAR@(VALMCNT,0)="$J: "_$$LJ(IEN,9)_" ->"_$$CJ($P(NODE,"^",3),28)_"<- started at "_$$HTE^XLFDT($P(NODE,"^"))
"RTN","HLOUSR",170,0)
 Q
"RTN","HLOUSR",171,0)
 ;
"RTN","HLOUSR",172,0)
INQUEUE ;
"RTN","HLOUSR",173,0)
 N FROM
"RTN","HLOUSR",174,0)
 D CLEAN^VALM10
"RTN","HLOUSR",175,0)
 ;K @VALMAR
"RTN","HLOUSR",176,0)
 S HLRFRSH="INQUEUE^HLOUSR"
"RTN","HLOUSR",177,0)
 S (HLSCREEN,VALMSG)="Incoming Queues ('!' = stopped queues)"
"RTN","HLOUSR",178,0)
 S VALMCNT=0
"RTN","HLOUSR",179,0)
 S VALMBCK="R"
"RTN","HLOUSR",180,0)
 S VALMDDF("COL 1")="COL 1^1^40^ From^H"
"RTN","HLOUSR",181,0)
 S VALMDDF("COL 2")="COL 2^45^20^Queue^H"
"RTN","HLOUSR",182,0)
 S VALMDDF("COL 3")="COL 3^70^10^Count^H"
"RTN","HLOUSR",183,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",184,0)
 D CHGCAP^VALM("COL 1"," From")
"RTN","HLOUSR",185,0)
 S FROM=""
"RTN","HLOUSR",186,0)
 F  S FROM=$O(^HLC("QUEUECOUNT","IN",FROM)) Q:FROM=""  D
"RTN","HLOUSR",187,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR",188,0)
 .S SHOW=$$LJ(FROM,40)_"  "
"RTN","HLOUSR",189,0)
 .S QUE=""
"RTN","HLOUSR",190,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","IN",FROM,QUE)) Q:QUE=""  D
"RTN","HLOUSR",191,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","IN",FROM,QUE))
"RTN","HLOUSR",192,0)
 ..Q:COUNT<0
"RTN","HLOUSR",193,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR",194,0)
 ..S @VALMAR@(VALMCNT,0)=SHOW_$$LJ($S($$STOPPED^HLOQUE("IN",QUE):"!",1:"")_QUE,21)_" "_$$RJ(COUNT,10)
"RTN","HLOUSR",195,0)
 ..S SHOW=$$LJ("",40)_"  "
"RTN","HLOUSR",196,0)
 Q
"RTN","HLOUSR",197,0)
VIEWLINK ;
"RTN","HLOUSR",198,0)
 N C,QUIT,LINK,LINKARY,TEMP
"RTN","HLOUSR",199,0)
 S (QUIT,C,LINK)=""
"RTN","HLOUSR",200,0)
 S VALMBCK="R"
"RTN","HLOUSR",201,0)
 ;
"RTN","HLOUSR",202,0)
 ;currently HL7 (Optimized) only does TCP
"RTN","HLOUSR",203,0)
 S LINK=$$ASKLINK
"RTN","HLOUSR",204,0)
 Q:LINK=""
"RTN","HLOUSR",205,0)
 Q:'$$GETLINK^HLOTLNK(LINK,.LINKARY)
"RTN","HLOUSR",206,0)
 S LINK=LINK_":"_LINKARY("PORT")
"RTN","HLOUSR",207,0)
 W !,"Hit any key to stop...",!
"RTN","HLOUSR",208,0)
 F  D  Q:QUIT
"RTN","HLOUSR",209,0)
 .N COUNT,QUE
"RTN","HLOUSR",210,0)
 .S (COUNT,QUE)=""
"RTN","HLOUSR",211,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE)) S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",212,0)
 .W $C(13),"                             ",$C(13),"MESSAGES PENDING TRANSMISSION: ",IOBON,$$RJ(+COUNT,10),IOBOFF
"RTN","HLOUSR",213,0)
 .R *C:1 I $T S QUIT=1
"RTN","HLOUSR",214,0)
 Q
"RTN","HLOUSR",215,0)
 ;
"RTN","HLOUSR",216,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR",217,0)
 Q $$CJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",218,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR",219,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",220,0)
RJ(STRING,LEN) ;
"RTN","HLOUSR",221,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",222,0)
 ;
"RTN","HLOUSR",223,0)
RUNNING() ;Process Manager running?
"RTN","HLOUSR",224,0)
 N RUNNING
"RTN","HLOUSR",225,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOUSR",226,0)
 S RUNNING='$T
"RTN","HLOUSR",227,0)
 I 'RUNNING L -^HLTMP("PROCESS MANAGER")
"RTN","HLOUSR",228,0)
 Q RUNNING
"RTN","HLOUSR",229,0)
 ;
"RTN","HLOUSR",230,0)
TESTLINK ;
"RTN","HLOUSR",231,0)
 N LINKNAME,OK,PORT,LINK
"RTN","HLOUSR",232,0)
 S VALMBCK="R"
"RTN","HLOUSR",233,0)
 S LINKNAME=$$ASKLINK
"RTN","HLOUSR",234,0)
 Q:LINKNAME=""
"RTN","HLOUSR",235,0)
 ;**P138 START
"RTN","HLOUSR",236,0)
 S PORT=$$ASKPORT^HLOUSRA(LINKNAME)
"RTN","HLOUSR",237,0)
 Q:'PORT
"RTN","HLOUSR",238,0)
 S LINK=LINKNAME_":"_PORT
"RTN","HLOUSR",239,0)
 ;S OK=$$IFOPEN^HLOUSR1(LINKNAME)
"RTN","HLOUSR",240,0)
 W !,"Testing...." ;P158
"RTN","HLOUSR",241,0)
 S OK=$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOUSR",242,0)
 ;** P138 END
"RTN","HLOUSR",243,0)
 I OK W !,LINK_" IS operational..."
"RTN","HLOUSR",244,0)
 E  W !,LINK_" is NOT operational..."
"RTN","HLOUSR",245,0)
 W !,"Hit any key to continue..."
"RTN","HLOUSR",246,0)
 R *C:DTIME
"RTN","HLOUSR",247,0)
 Q
"RTN","HLOUSR",248,0)
 ;
"RTN","HLOUSR",249,0)
ASKLINK() ;
"RTN","HLOUSR",250,0)
 N DIC,TCP,X,Y,DTOUT,DUOUT
"RTN","HLOUSR",251,0)
 S DIC=870
"RTN","HLOUSR",252,0)
 S DIC(0)="AEMNQ"
"RTN","HLOUSR",253,0)
 S TCP=$O(^HLCS(869.1,"B","TCP",0))
"RTN","HLOUSR",254,0)
 S DIC("A")="Select a TCP link:"
"RTN","HLOUSR",255,0)
 S DIC("S")="I $P(^(0),U,3)=TCP"
"RTN","HLOUSR",256,0)
 D FULL^VALM1
"RTN","HLOUSR",257,0)
 D ^DIC
"RTN","HLOUSR",258,0)
 I +Y'=-1,'$D(DTOUT),'$D(DUOUT) Q $P(Y,"^",2)
"RTN","HLOUSR",259,0)
 Q ""
"RTN","HLOUSR",260,0)
 ;
"RTN","HLOUSR",261,0)
STOP ;
"RTN","HLOUSR",262,0)
 I '$$ASKYESNO^HLOUSR2("Are you SURE that you want to stop sending and receiving messages","NO") S VALMBCK="" Q
"RTN","HLOUSR",263,0)
 ;
"RTN","HLOUSR",264,0)
 D STOPHL7^HLOPROC1
"RTN","HLOUSR",265,0)
 S VALMBCK="R",VALMSG="HL7 (Optimized) has been stopped...."
"RTN","HLOUSR",266,0)
 H 5
"RTN","HLOUSR",267,0)
 D @HLRFRSH
"RTN","HLOUSR",268,0)
 ;D:HLSCREEN="Brief System Status" BRIEF^HLOUSR
"RTN","HLOUSR",269,0)
 ;D:HLSCREEN="Running Processes" PROCS^HLOUSR
"RTN","HLOUSR",270,0)
 Q
"RTN","HLOUSR",271,0)
 ;
"RTN","HLOUSR",272,0)
UPDMODE ;realtime
"RTN","HLOUSR",273,0)
 Q:'$L(HLRFRSH)
"RTN","HLOUSR",274,0)
 N TOP,BOTTOM,DX,DY,IOTM,IOBM,LINE,OLD,OLDCNT
"RTN","HLOUSR",275,0)
 S OLDCNT=VALMCNT
"RTN","HLOUSR",276,0)
 W !!!!!,IOINHI,"Hit any key to escape realtime display mode...",IOINORM
"RTN","HLOUSR",277,0)
 S IOTM=20,IOBM=23 W @IOSTBM
"RTN","HLOUSR",278,0)
 S TOP=VALMBG
"RTN","HLOUSR",279,0)
 S BOTTOM=TOP+20
"RTN","HLOUSR",280,0)
 F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",281,0)
 .I LINE>VALMCNT S @VALMAR@(LINE,0)=$$LJ(" ",80) Q
"RTN","HLOUSR",282,0)
 .S @VALMAR@(LINE,0)=$$LJ($G(@VALMAR@(LINE,0)),80)
"RTN","HLOUSR",283,0)
 F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",284,0)
 .S OLD(LINE)=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR",285,0)
 F LINE=17:1:BOTTOM D
"RTN","HLOUSR",286,0)
 .S DX=50,DY=22 X IOXY W !
"RTN","HLOUSR",287,0)
 .D WRITE^VALM10(LINE)
"RTN","HLOUSR",288,0)
 D  F  R *C:4 Q:$T  D
"RTN","HLOUSR",289,0)
 .D @HLRFRSH
"RTN","HLOUSR",290,0)
 .;**START PATCH 138**
"RTN","HLOUSR",291,0)
 .S OLDCNT=VALMCNT
"RTN","HLOUSR",292,0)
 .;**END PATCH 138**
"RTN","HLOUSR",293,0)
 .F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",294,0)
 ..I LINE>VALMCNT S @VALMAR@(LINE,0)=$$LJ(" ",80) Q
"RTN","HLOUSR",295,0)
 ..S @VALMAR@(LINE,0)=$$LJ($G(@VALMAR@(LINE,0)),80)
"RTN","HLOUSR",296,0)
 .S VALMCNT=BOTTOM
"RTN","HLOUSR",297,0)
 .F LINE=TOP:1:BOTTOM IF OLD(LINE)'=$G(@VALMAR@(LINE,0)) D
"RTN","HLOUSR",298,0)
 ..S OLD(LINE)=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR",299,0)
 ..S DX=50,DY=22 X IOXY W !
"RTN","HLOUSR",300,0)
 ..D WRITE^VALM10(LINE)
"RTN","HLOUSR",301,0)
 ;**START PATCH 138**
"RTN","HLOUSR",302,0)
 S VALMCNT=OLDCNT
"RTN","HLOUSR",303,0)
 I VALMCNT<VALMBG S VALMBG=VALMCNT
"RTN","HLOUSR",304,0)
 ;**END PATCH 138**
"RTN","HLOUSR",305,0)
 S VALMBCK="R"
"RTN","HLOUSR",306,0)
 Q
"RTN","HLOUSR",307,0)
 ;
"RTN","HLOUSR",308,0)
EDITSITE ;
"RTN","HLOUSR",309,0)
 ;edit HLO System Parameters
"RTN","HLOUSR",310,0)
 N DR,DA,DIE
"RTN","HLOUSR",311,0)
 S DA=$O(^HLD(779.1,0))
"RTN","HLOUSR",312,0)
 Q:'DA
"RTN","HLOUSR",313,0)
 S DIE="^HLD(779.1,"
"RTN","HLOUSR",314,0)
 S DR="[HLO EDIT SYSTEM PARAMETERS]"
"RTN","HLOUSR",315,0)
 D ^DIE
"RTN","HLOUSR",316,0)
 Q
"RTN","HLOUSR",317,0)
 ;
"RTN","HLOUSR",318,0)
LOGALL ;
"RTN","HLOUSR",319,0)
 N ON,CHANGE,DATA
"RTN","HLOUSR",320,0)
 ;Will turn on/off logging of all errors
"RTN","HLOUSR",321,0)
 S ON=$G(^HLTMP("LOG ALL ERRORS"))
"RTN","HLOUSR",322,0)
 W !!,"Logging of all HLO errors is turned ",$S(ON:"ON",1:"OFF"),"."
"RTN","HLOUSR",323,0)
 W !!,"Logging of all HLO errors, including READ and WRITE errors, should be turned",!,"on only for short periods for troubleshooting purposes.",!
"RTN","HLOUSR",324,0)
 S CHANGE=$$ASKYESNO^HLOUSR2("Do you want logging of all HLO errors turned "_$S(ON:"OFF",1:"ON"),$S(ON:"YES",1:"NO"))
"RTN","HLOUSR",325,0)
 Q:'CHANGE
"RTN","HLOUSR",326,0)
 S ON='ON
"RTN","HLOUSR",327,0)
 S ^HLTMP("LOG ALL ERRORS")=ON
"RTN","HLOUSR",328,0)
 W !,"Logging of all HLO errors is turned ",$S(ON:"ON",1:"OFF"),"."
"RTN","HLOUSR",329,0)
 Q
"RTN","HLOUSR",330,0)
 ;
"RTN","HLOUSR",331,0)
KLISTEN() ;
"RTN","HLOUSR",332,0)
 ;checks if the Kernel multi-listener is running
"RTN","HLOUSR",333,0)
 N DOLLARJ,FOUND
"RTN","HLOUSR",334,0)
 S DOLLARJ=""
"RTN","HLOUSR",335,0)
 S FOUND=0
"RTN","HLOUSR",336,0)
 F  S DOLLARJ=$O(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)) Q:DOLLARJ=""  I $P($G(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)),"^",3)["TASKMAN MULTI-LISTENER" S FOUND=1 Q
"RTN","HLOUSR",337,0)
 Q FOUND
"RTN","HLOUSR3")
0^19^B69134170^B69258883
"RTN","HLOUSR3",1,0)
HLOUSR3 ;ALB/CJM/RBN -ListManager Screen for viewing messages(continued);12 JUN 1997 10:00 am ;03/26/2012
"RTN","HLOUSR3",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,134,138,139,147,158**;Oct 13, 1995;Build 14
"RTN","HLOUSR3",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR3",4,0)
 ;
"RTN","HLOUSR3",5,0)
 ;
"RTN","HLOUSR3",6,0)
EN ; Main entry point.
"RTN","HLOUSR3",7,0)
 N HLPARMS
"RTN","HLOUSR3",8,0)
 D FULL^VALM1
"RTN","HLOUSR3",9,0)
 I '$$ASK(.HLPARMS) S VALMBCK="R" Q
"RTN","HLOUSR3",10,0)
 D WAIT^DICD
"RTN","HLOUSR3",11,0)
 D EN^VALM("HLO MESSAGE SEARCH")
"RTN","HLOUSR3",12,0)
 Q
"RTN","HLOUSR3",13,0)
SEARCH ; Find a message.
"RTN","HLOUSR3",14,0)
 N I,APP,START,END,DIR,MSG,EVENT,TIME
"RTN","HLOUSR3",15,0)
 D EXIT
"RTN","HLOUSR3",16,0)
 S I=""
"RTN","HLOUSR3",17,0)
 F  S I=$O(HLPARMS(I)) Q:I=""  S @I=HLPARMS(I)
"RTN","HLOUSR3",18,0)
 K HLPARMS
"RTN","HLOUSR3",19,0)
 S (VALMCNT,I)=0
"RTN","HLOUSR3",20,0)
 S TIME=START
"RTN","HLOUSR3",21,0)
 F  S TIME=$O(^HLB("SEARCH",DIR,TIME)) Q:'TIME  Q:TIME>END  Q:VALMCNT>MAX  D
"RTN","HLOUSR3",22,0)
 .N SAPP S SAPP=""
"RTN","HLOUSR3",23,0)
 .S:APP'="" SAPP=$O(^HLB("SEARCH",DIR,TIME,APP),-1)
"RTN","HLOUSR3",24,0)
 .F  S SAPP=$O(^HLB("SEARCH",DIR,TIME,SAPP)) Q:SAPP=""  Q:$E(SAPP,1,$L(APP))]APP  Q:VALMCNT>MAX  D:$E(SAPP,1,$L(APP))=APP
"RTN","HLOUSR3",25,0)
 ..N SMSG S SMSG=""
"RTN","HLOUSR3",26,0)
 ..S:MSG'="" SMSG=$O(^HLB("SEARCH",DIR,TIME,SAPP,MSG),-1)
"RTN","HLOUSR3",27,0)
 ..F  S SMSG=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG)) Q:SMSG=""  Q:$E(SMSG,1,$L(MSG))]MSG  Q:VALMCNT>MAX  D:$E(SMSG,1,$L(MSG))=MSG
"RTN","HLOUSR3",28,0)
 ...N SEVENT S SEVENT=""
"RTN","HLOUSR3",29,0)
 ...S:EVENT'="" SEVENT=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,EVENT),-1)
"RTN","HLOUSR3",30,0)
 ...F  S SEVENT=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,SEVENT)) Q:SEVENT=""  Q:$E(SEVENT,1,$L(EVENT))]EVENT  Q:VALMCNT>MAX  D:$E(SEVENT,1,$L(EVENT))=EVENT
"RTN","HLOUSR3",31,0)
 ....N IEN
"RTN","HLOUSR3",32,0)
 ....S IEN=""
"RTN","HLOUSR3",33,0)
 ....F  S IEN=$O(^HLB("SEARCH",DIR,TIME,SAPP,SMSG,SEVENT,IEN)) Q:IEN=""  Q:VALMCNT>MAX  D ADDTO(DIR,TIME,SAPP,SMSG,SEVENT,IEN)
"RTN","HLOUSR3",34,0)
 ;
"RTN","HLOUSR3",35,0)
 ;
"RTN","HLOUSR3",36,0)
END ; Return to List Manager.
"RTN","HLOUSR3",37,0)
 S VALMBCK="R"
"RTN","HLOUSR3",38,0)
 ;
"RTN","HLOUSR3",39,0)
 Q
"RTN","HLOUSR3",40,0)
ADDTO(DIR,TIME,APP,MSG,EVENT,IEN) ; Add message to queue.
"RTN","HLOUSR3",41,0)
 N HDR,FS,LOC,MSGID
"RTN","HLOUSR3",42,0)
 S MSGID=$S($P(IEN,"^",2):$P($G(^HLB(+IEN,3,$P(IEN,"^",2),0)),"^",2),1:$P($G(^HLB(IEN,0)),"^",1))
"RTN","HLOUSR3",43,0)
 S HDR=$G(^HLB(+IEN,1))
"RTN","HLOUSR3",44,0)
 S FS=$E(HDR,4)
"RTN","HLOUSR3",45,0)
 I FS'="" D
"RTN","HLOUSR3",46,0)
 .I DIR="IN" S LOC=$P(HDR,FS,4)
"RTN","HLOUSR3",47,0)
 .I DIR'="IN" S LOC=$P(HDR,FS,6)
"RTN","HLOUSR3",48,0)
 E  S LOC=""
"RTN","HLOUSR3",49,0)
 S @VALMAR@($$I,0)=$$LJ(MSGID,25)_$$LJ(APP,30)_" "_MSG_"~"_EVENT
"RTN","HLOUSR3",50,0)
 D CNTRL^VALM10(VALMCNT,1,25,IOINHI,IOINORM)
"RTN","HLOUSR3",51,0)
 S @VALMAR@($$I,0)="     "_$$LJ($$FMTE^XLFDT(TIME,2),20)_$$LJ(LOC,60)
"RTN","HLOUSR3",52,0)
 S @VALMAR@($$I,0)=""
"RTN","HLOUSR3",53,0)
 Q
"RTN","HLOUSR3",54,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR3",55,0)
 Q $$LJ^XLFSTR(STRING,LEN)
"RTN","HLOUSR3",56,0)
 ;
"RTN","HLOUSR3",57,0)
I() ;
"RTN","HLOUSR3",58,0)
 S VALMCNT=VALMCNT+1
"RTN","HLOUSR3",59,0)
 Q VALMCNT
"RTN","HLOUSR3",60,0)
 ;
"RTN","HLOUSR3",61,0)
ASK(PARMS) ; Ask for parameter values.
"RTN","HLOUSR3",62,0)
 N SUB
"RTN","HLOUSR3",63,0)
 F SUB="START","END","EVENT","APP","MSG","DIR" S PARMS(SUB)=""
"RTN","HLOUSR3",64,0)
 S PARMS("START")=$$ASKBEGIN^HLOUSR2()
"RTN","HLOUSR3",65,0)
 Q:'PARMS("START") 0
"RTN","HLOUSR3",66,0)
 S PARMS("END")=$$ASKEND^HLOUSR2(PARMS("START"))
"RTN","HLOUSR3",67,0)
 Q:'PARMS("END") 0
"RTN","HLOUSR3",68,0)
 S PARMS("APP")=$$ASKAPP()
"RTN","HLOUSR3",69,0)
 Q:PARMS("APP")=-1 0
"RTN","HLOUSR3",70,0)
 S PARMS("MSG")=$$ASKMSG()
"RTN","HLOUSR3",71,0)
 Q:PARMS("MSG")=-1 0
"RTN","HLOUSR3",72,0)
 S PARMS("EVENT")=$$ASKEVENT()
"RTN","HLOUSR3",73,0)
 Q:PARMS("EVENT")=-1 0
"RTN","HLOUSR3",74,0)
 S PARMS("DIR")=$$ASKDIR()
"RTN","HLOUSR3",75,0)
 Q:PARMS("DIR")=-1 0
"RTN","HLOUSR3",76,0)
 ;** P139 START CJM
"RTN","HLOUSR3",77,0)
 S PARMS("DIR")=$S(PARMS("DIR")="I":"IN",PARMS("DIR")="i":"IN",1:"OUT")
"RTN","HLOUSR3",78,0)
 ;** P139 END CJM
"RTN","HLOUSR3",79,0)
 S PARMS("MAX")=$$ASKMAX()
"RTN","HLOUSR3",80,0)
 Q:'(PARMS("MAX")>-1) 0
"RTN","HLOUSR3",81,0)
 Q 1
"RTN","HLOUSR3",82,0)
 ;
"RTN","HLOUSR3",83,0)
ASKMAX() ; Ask for the maximum number of messages.
"RTN","HLOUSR3",84,0)
 N DIR
"RTN","HLOUSR3",85,0)
 S DIR(0)="N^1:30000:0"
"RTN","HLOUSR3",86,0)
 S DIR("A")="Maximum List Size"
"RTN","HLOUSR3",87,0)
 S DIR("B")=1000
"RTN","HLOUSR3",88,0)
 S DIR("?",1)="In case a large number of messages meet your search criteria, what are the"
"RTN","HLOUSR3",89,0)
 S DIR("?")="maximum number of messages to display? (30,000 maximum)"
"RTN","HLOUSR3",90,0)
 D ^DIR
"RTN","HLOUSR3",91,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",92,0)
 Q 3*(X-1)
"RTN","HLOUSR3",93,0)
ASKAPP() ; Ask for application name.
"RTN","HLOUSR3",94,0)
 N DIR
"RTN","HLOUSR3",95,0)
 S DIR(0)="FO^0:60"
"RTN","HLOUSR3",96,0)
 S DIR("A")="Application"
"RTN","HLOUSR3",97,0)
 S DIR("?",1)="Enter the name of the application, or '^' to exit."
"RTN","HLOUSR3",98,0)
 S DIR("?")="You can enter just the first part of the name."
"RTN","HLOUSR3",99,0)
 D ^DIR
"RTN","HLOUSR3",100,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",101,0)
 Q X
"RTN","HLOUSR3",102,0)
ASKMSG() ;
"RTN","HLOUSR3",103,0)
 N DIR
"RTN","HLOUSR3",104,0)
 S DIR(0)="FO^0:3"
"RTN","HLOUSR3",105,0)
 S DIR("A")="HL7 Message Type"
"RTN","HLOUSR3",106,0)
 S DIR("?",1)="Enter the 3 character message type (e.g. MFN, ADT), or '^' to exit."
"RTN","HLOUSR3",107,0)
 S DIR("?")="You can enter just the first character or two."
"RTN","HLOUSR3",108,0)
 D ^DIR
"RTN","HLOUSR3",109,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",110,0)
 Q X
"RTN","HLOUSR3",111,0)
ASKEVENT() ; Ask for event.
"RTN","HLOUSR3",112,0)
 N DIR
"RTN","HLOUSR3",113,0)
 S DIR(0)="FO^0:3"
"RTN","HLOUSR3",114,0)
 S DIR("A")="HL7 Event"
"RTN","HLOUSR3",115,0)
 S DIR("?",1)="Enter the 3 character event type, or '^' to exit."
"RTN","HLOUSR3",116,0)
 S DIR("?")="You can enter just the first character or two."
"RTN","HLOUSR3",117,0)
 D ^DIR
"RTN","HLOUSR3",118,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",119,0)
 Q X
"RTN","HLOUSR3",120,0)
ASKDIR() ; Ask message direction
"RTN","HLOUSR3",121,0)
 N DIR
"RTN","HLOUSR3",122,0)
 S DIR(0)="S^I:INCOMING;O:OUTGOING"
"RTN","HLOUSR3",123,0)
 S DIR("A")="Incoming or Outgoing"
"RTN","HLOUSR3",124,0)
 S DIR("?",1)="Are you searching for an incoming message or an outgoing message?"
"RTN","HLOUSR3",125,0)
 S DIR("?")="You can enter '^' to exit"
"RTN","HLOUSR3",126,0)
 D ^DIR
"RTN","HLOUSR3",127,0)
 Q:$D(DTOUT)!$D(DUOUT) -1
"RTN","HLOUSR3",128,0)
 Q X
"RTN","HLOUSR3",129,0)
HDR ; Set the List Manager header
"RTN","HLOUSR3",130,0)
 S VALMHDR(1)="MsgID                    Application                    MsgType"
"RTN","HLOUSR3",131,0)
 Q
"RTN","HLOUSR3",132,0)
HLP ;
"RTN","HLOUSR3",133,0)
 Q
"RTN","HLOUSR3",134,0)
EXIT ; Clean up and exit back to List Manager
"RTN","HLOUSR3",135,0)
 D CLEAN^VALM10
"RTN","HLOUSR3",136,0)
 D CLEAR^VALM1
"RTN","HLOUSR3",137,0)
 S VALMBCK="R"
"RTN","HLOUSR3",138,0)
 Q
"RTN","HLOUSR3",139,0)
 ;
"RTN","HLOUSR3",140,0)
SETPURGE ; Set a message up for purging.
"RTN","HLOUSR3",141,0)
 N MSG,DIR
"RTN","HLOUSR3",142,0)
 S VALMBCK="R"
"RTN","HLOUSR3",143,0)
 Q:'$G(MSGIEN)
"RTN","HLOUSR3",144,0)
 Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR3",145,0)
 I MSG("STATUS")="",'MSG("STATUS","PURGE") W !,"Can not set purge yet!" D PAUSE^VALM1 Q
"RTN","HLOUSR3",146,0)
 S DIR(0)="D^"_DT_":"_$$FMADD^XLFDT(DT,+45)_":E"
"RTN","HLOUSR3",147,0)
 S DIR("A")="When should the message be purged?"
"RTN","HLOUSR3",148,0)
 D ^DIR
"RTN","HLOUSR3",149,0)
 D:Y SETPURGE^HLOUSR7(+MSGIEN,Y),DISPLAY^HLOUSR1
"RTN","HLOUSR3",150,0)
 Q
"RTN","HLOUSR3",151,0)
SCREEN() ;  Screen for message purge status.
"RTN","HLOUSR3",152,0)
 N TRUE
"RTN","HLOUSR3",153,0)
 S TRUE=1
"RTN","HLOUSR3",154,0)
 I $P($G(X),"^",3)="SET PURGE" D  Q TRUE
"RTN","HLOUSR3",155,0)
 .N MSG
"RTN","HLOUSR3",156,0)
 .I '$G(MSGIEN) S TRUE=0 Q
"RTN","HLOUSR3",157,0)
 .I '$$GETMSG^HLOMSG(+MSGIEN,.MSG) S TRUE=0 Q
"RTN","HLOUSR3",158,0)
 .I MSG("STATUS")="",'MSG("STATUS","PURGE") S TRUE=0
"RTN","HLOUSR3",159,0)
 S:'TRUE VALMBCK="R"
"RTN","HLOUSR3",160,0)
 Q TRUE
"RTN","HLOUSR3",161,0)
 ;;**Start Patch HL*1.6.138 **
"RTN","HLOUSR3",162,0)
 ;;The following three subroutines have been added for HL*1.6*138 - RBN
"RTN","HLOUSR3",163,0)
 ;;
"RTN","HLOUSR3",164,0)
RESEND ; If outbound message has been sent, resends it.
"RTN","HLOUSR3",165,0)
 N CONF
"RTN","HLOUSR3",166,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR3",167,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR3",168,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOUSR3",169,0)
 ;Q:$$VERIFY^HLOQUE1()=-1
"RTN","HLOUSR3",170,0)
 N MSG,DIR,ERROR,FLG,OLDIEN,SYS
"RTN","HLOUSR3",171,0)
 S OLDIEN=MSGIEN
"RTN","HLOUSR3",172,0)
 I $G(OPT1DIS) D  K OPT1DIS Q
"RTN","HLOUSR3",173,0)
 . W !,"Sorry that option is not available for this message." D PAUSE^VALM1 Q
"RTN","HLOUSR3",174,0)
 S VALMBCK="R"
"RTN","HLOUSR3",175,0)
 Q:'$G(MSGIEN)
"RTN","HLOUSR3",176,0)
 Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR3",177,0)
 I MSG("DIRECTION")'="OUT" W !,"Message is not an outbound message" D PAUSE^VALM1 Q
"RTN","HLOUSR3",178,0)
 I MSG("STATUS")="",'MSG("DT/TM") W !,"Message has not been sent!" D PAUSE^VALM1 Q
"RTN","HLOUSR3",179,0)
 Q:'$$ASKYESNO^HLOUSR2("Are you SURE you want to resend MsgID: "_MSG("ID"),"NO")
"RTN","HLOUSR3",180,0)
 S MSGIEN=$$RESEND^HLOAPI3(+MSGIEN,.ERROR)
"RTN","HLOUSR3",181,0)
 I $G(ERROR) W ERROR D PAUSE^VALM1 Q
"RTN","HLOUSR3",182,0)
 W !,"The message has been copied to MsgID ",MSGIEN," which will be displayed next"
"RTN","HLOUSR3",183,0)
 I $$ASKYESNO^HLOUSR2("Do you want the original message purged?","NO") D
"RTN","HLOUSR3",184,0)
 . D SYSPARMS^HLOSITE(.SYS)
"RTN","HLOUSR3",185,0)
 . S HLOPURDT=$$FMADD^XLFDT($$NOW^XLFDT,SYS("ERROR PURGE"))
"RTN","HLOUSR3",186,0)
 . S FLG=$$SETPURGE^HLOUSR7(OLDIEN,HLOPURDT)
"RTN","HLOUSR3",187,0)
 S FLG=$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR3",188,0)
 D DISPLAY^HLOUSR1
"RTN","HLOUSR3",189,0)
 Q
"RTN","HLOUSR3",190,0)
 ;
"RTN","HLOUSR3",191,0)
REPROC ; If inbound message has been processed, reprocesses it.
"RTN","HLOUSR3",192,0)
 N CONF
"RTN","HLOUSR3",193,0)
 D FULL^VALM1
"RTN","HLOUSR3",194,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR3",195,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR3",196,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOUSR3",197,0)
 ;Q:$$VERIFY^HLOQUE1()=-1
"RTN","HLOUSR3",198,0)
 N MSG,DIR,ERROR,SYSPARM
"RTN","HLOUSR3",199,0)
 I $G(OPT2DIS) D  K OPT2DIS Q
"RTN","HLOUSR3",200,0)
 . W !,"Sorry that option is not available for this message." D PAUSE^VALM1 Q
"RTN","HLOUSR3",201,0)
 S VALMBCK="R"
"RTN","HLOUSR3",202,0)
 Q:'$G(MSGIEN)
"RTN","HLOUSR3",203,0)
 Q:'$$GETMSG^HLOMSG(+MSGIEN,.MSG)
"RTN","HLOUSR3",204,0)
 I MSG("DIRECTION")'="IN" W !,"Message is not an inbound message" D PAUSE^VALM1 Q
"RTN","HLOUSR3",205,0)
 I MSG("STATUS")="",'MSG("STATUS","APP HANDOFF") W !,"Message has not been processed" D PAUSE^VALM1 Q
"RTN","HLOUSR3",206,0)
 Q:'$$ASKYESNO^HLOUSR2("Are you SURE you want to reprocess MsgID: "_MSG("ID"),"NO")
"RTN","HLOUSR3",207,0)
 I '$$PROCNOW^HLOAPI3(+MSGIEN,"",.ERROR) W ERROR D PAUSE^VALM1 Q
"RTN","HLOUSR3",208,0)
 W !,"Done!  The message has been reprocessed by the application."
"RTN","HLOUSR3",209,0)
 S DIR(0)="D^"_DT_":"_$$FMADD^XLFDT(DT,+45)_":E"
"RTN","HLOUSR3",210,0)
 I '$$ASKYESNO^HLOUSR2("Do you want to purge the message?","NO") D
"RTN","HLOUSR3",211,0)
 . D SYSPARMS^HLOSITE(.SYSPARM)
"RTN","HLOUSR3",212,0)
 . S HLOPURDT=$$FMADD^XLFDT($$NOW^XLFDT,SYSPARM("ERROR PURGE"))
"RTN","HLOUSR3",213,0)
 . S FLG=$$SETPURGE^HLOUSR7(MSGIEN,HLOPURDT)
"RTN","HLOUSR3",214,0)
 Q
"RTN","HLOUSR3",215,0)
 ;
"RTN","HLOUSR3",216,0)
MSGPREP ; Enable or disable menu options
"RTN","HLOUSR3",217,0)
 N MSG,FDA,ERR
"RTN","HLOUSR3",218,0)
 D GETMSG^HLOMSG(MSGIEN,.MSG)
"RTN","HLOUSR3",219,0)
 I 'MSG("DT/TM") D            ; Message has not been sent/processed
"RTN","HLOUSR3",220,0)
 .  S (OPT1DIS,OPT2DIS)=1
"RTN","HLOUSR3",221,0)
 I MSG("DIRECTION")="OUT" D   ; Msg outbound and sent ; disable MP
"RTN","HLOUSR3",222,0)
 .  S OPT2DIS=1
"RTN","HLOUSR3",223,0)
 I MSG("DIRECTION")="IN" D    ; Msg inbound and sent ; disable MR
"RTN","HLOUSR3",224,0)
 .  S OPT1DIS=1
"RTN","HLOUSR3",225,0)
 S VALMBCK="R"
"RTN","HLOUSR3",226,0)
 Q
"RTN","HLOUSR3",227,0)
 ;;**End Patch HL*1.6*138 **
"RTN","HLOUSR3",228,0)
 ;
"RTN","HLOUSR7")
0^21^B25426797^B22703242
"RTN","HLOUSR7",1,0)
HLOUSR7 ;OIFO-ALB/CJM - Deleting HLO queues ;03/26/2012
"RTN","HLOUSR7",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**147,153,158**;Oct 13, 1995;Build 14
"RTN","HLOUSR7",3,0)
 ;Per VHA Directive 2004-038, this routine should not be modified.
"RTN","HLOUSR7",4,0)
 ;
"RTN","HLOUSR7",5,0)
 ;
"RTN","HLOUSR7",6,0)
SPURGE ; Entry point from ListManager for deleting sequential queues.
"RTN","HLOUSR7",7,0)
 N CONF,LINK,QUE,PORT,WHEN,COUNT,IEN
"RTN","HLOUSR7",8,0)
 S VALMBCK="R"
"RTN","HLOUSR7",9,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR7",10,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR7",11,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOUSR7",12,0)
 S QUE=$$GETQ^HLOUSR4()
"RTN","HLOUSR7",13,0)
 Q:QUE=""
"RTN","HLOUSR7",14,0)
 I '$D(^HLB("QUEUE","SEQUENCE",QUE)) W !,"There are no messages on that queue!" D PAUSE^VALM1 Q
"RTN","HLOUSR7",15,0)
 W !!,"Deleting a queue in error will result in lost messages!"
"RTN","HLOUSR7",16,0)
 Q:'$$ASKYESNO^HLOUSR2("Are you SURE you want to delete that queue","NO")
"RTN","HLOUSR7",17,0)
 W !!,"After removing the messages from the sequence queue they will deleted"
"RTN","HLOUSR7",18,0)
 W !,"When do you want to schedule the messages to be purged?"
"RTN","HLOUSR7",19,0)
 S WHEN=$$ASKWHEN($$FMADD^XLFDT($$NOW^XLFDT,7),"Date/Time to schedule purge:")
"RTN","HLOUSR7",20,0)
 Q:'WHEN
"RTN","HLOUSR7",21,0)
 S (IEN,COUNT)=0
"RTN","HLOUSR7",22,0)
 F  S IEN=$O(^HLB("QUEUE","SEQUENCE",QUE,IEN)) Q:'IEN  S COUNT=COUNT+1 Q:COUNT>100
"RTN","HLOUSR7",23,0)
 I COUNT>100,$$ASKTASK() D
"RTN","HLOUSR7",24,0)
 .S ZTRTN="SEQPURGE^HLOUSR7"
"RTN","HLOUSR7",25,0)
 .S ZTDESC="HLO QUEUE PURGE"
"RTN","HLOUSR7",26,0)
 .S ZTDTH=$H
"RTN","HLOUSR7",27,0)
 .S ZTIO=""
"RTN","HLOUSR7",28,0)
 .S ZTSAVE("QUE")=QUE,ZTSAVE("WHEN")=""
"RTN","HLOUSR7",29,0)
 .D ^%ZTLOAD
"RTN","HLOUSR7",30,0)
 .I '$G(ZTSK) W !!,?5,"UNABLE TO SCHEDULE PURGE JOB",!
"RTN","HLOUSR7",31,0)
 .I $G(ZTSK) W !!,?5,"Purge job is scheduled, task #"_ZTSK
"RTN","HLOUSR7",32,0)
 .D PAUSE^VALM1
"RTN","HLOUSR7",33,0)
 E  D
"RTN","HLOUSR7",34,0)
 .D SEQPURGE
"RTN","HLOUSR7",35,0)
 .I $L(HLRFRSH) D @HLRFRSH
"RTN","HLOUSR7",36,0)
 Q
"RTN","HLOUSR7",37,0)
 ;
"RTN","HLOUSR7",38,0)
OPURGE ; Entry point from ListManager for deleting outgoing queues.
"RTN","HLOUSR7",39,0)
 N CONF,LINK,QUE,PORT,WHEN,COUNT,IEN
"RTN","HLOUSR7",40,0)
 S VALMBCK="R"
"RTN","HLOUSR7",41,0)
 D OWNSKEY^XUSRB(.CONF,"HLOMGR",DUZ)
"RTN","HLOUSR7",42,0)
 I CONF(0)'=1 D  Q
"RTN","HLOUSR7",43,0)
 . W !,"**** You are not authorized to use this option ****" D PAUSE^VALM1 Q
"RTN","HLOUSR7",44,0)
 S LINK=$$ASKLINK^HLOUSR
"RTN","HLOUSR7",45,0)
 Q:LINK=""
"RTN","HLOUSR7",46,0)
 W !
"RTN","HLOUSR7",47,0)
 S PORT=$$ASKPORT^HLOTRACE(LINK)
"RTN","HLOUSR7",48,0)
 I 'PORT W !,"There are no outgoing messages for that destination!" Q
"RTN","HLOUSR7",49,0)
 S LINK=LINK_":"_PORT
"RTN","HLOUSR7",50,0)
 W !
"RTN","HLOUSR7",51,0)
 S QUE=$$ASKQUE^HLOTRACE(LINK)
"RTN","HLOUSR7",52,0)
 I QUE=""  W !,"There are no outgoing messages for that destination!" Q
"RTN","HLOUSR7",53,0)
 W !!,"Deleting a queue in error will result in lost messages!"
"RTN","HLOUSR7",54,0)
 Q:'$$ASKYESNO^HLOUSR2("Are you SURE you want to delete that queue","NO")
"RTN","HLOUSR7",55,0)
 W !!,"After removing the messages from the outgoing queue they will deleted"
"RTN","HLOUSR7",56,0)
 W !,"When do you want to schedule the messages to be purged?"
"RTN","HLOUSR7",57,0)
 S WHEN=$$ASKWHEN($$FMADD^XLFDT($$NOW^XLFDT,7),"Date/Time to schedule purge:")
"RTN","HLOUSR7",58,0)
 Q:'WHEN
"RTN","HLOUSR7",59,0)
 S (IEN,COUNT)=0
"RTN","HLOUSR7",60,0)
 F  S IEN=$O(^HLB("QUEUE","OUT",LINK,QUE,IEN)) Q:'IEN  S COUNT=COUNT+1 Q:COUNT>100
"RTN","HLOUSR7",61,0)
 I COUNT>100,$$ASKTASK() D
"RTN","HLOUSR7",62,0)
 .S ZTRTN="OUTPURGE^HLOUSR7"
"RTN","HLOUSR7",63,0)
 .S ZTDESC="HLO QUEUE PURGE"
"RTN","HLOUSR7",64,0)
 .S ZTDTH=$H
"RTN","HLOUSR7",65,0)
 .S ZTIO=""
"RTN","HLOUSR7",66,0)
 .S ZTSAVE("LINK")="",ZTSAVE("QUE")=QUE,ZTSAVE("WHEN")=""
"RTN","HLOUSR7",67,0)
 .D ^%ZTLOAD
"RTN","HLOUSR7",68,0)
 .I '$G(ZTSK) W !!,?5,"UNABLE TO SCHEDULE PURGE JOB",!
"RTN","HLOUSR7",69,0)
 .I $G(ZTSK) W !!,?5,"Purge job is scheduled, task #"_ZTSK
"RTN","HLOUSR7",70,0)
 .D PAUSE^VALM1
"RTN","HLOUSR7",71,0)
 E  D
"RTN","HLOUSR7",72,0)
 .D OUTPURGE
"RTN","HLOUSR7",73,0)
 .D OUTQUE^HLOUSR6
"RTN","HLOUSR7",74,0)
 Q
"RTN","HLOUSR7",75,0)
 ;
"RTN","HLOUSR7",76,0)
ASKTASK() ;
"RTN","HLOUSR7",77,0)
 W !!,"There are a lot of messages pending on that queue!"
"RTN","HLOUSR7",78,0)
 Q $$ASKYESNO^HLOUSR2("Would you like to delete the queue in the background via a separate task","YES")
"RTN","HLOUSR7",79,0)
 ;
"RTN","HLOUSR7",80,0)
  ;
"RTN","HLOUSR7",81,0)
ASKWHEN(DEFAULT,PROMPT)       ;
"RTN","HLOUSR7",82,0)
 ;Description: Asks the user to enter a dt/tm.
"RTN","HLOUSR7",83,0)
 ;Input: DEFAULT - the suggested default dt/time (optional, defaults to NOW)
"RTN","HLOUSR7",84,0)
 ;PROMPT - optional prompt
"RTN","HLOUSR7",85,0)
 ;Output: Returns the date as the function value, or 0 if the user does not select a date
"RTN","HLOUSR7",86,0)
 ;
"RTN","HLOUSR7",87,0)
 ;
"RTN","HLOUSR7",88,0)
 N %DT
"RTN","HLOUSR7",89,0)
 S %DT="AEST"
"RTN","HLOUSR7",90,0)
 S:$L($G(PROMPT)) %DT("A")=PROMPT
"RTN","HLOUSR7",91,0)
 S %DT("B")=$$FMTE^XLFDT($S($L($G(DEFAULT)):DEFAULT,1:"NOW"))
"RTN","HLOUSR7",92,0)
 S %DT(0)="NOW"
"RTN","HLOUSR7",93,0)
 Q:$D(DTOUT) 0
"RTN","HLOUSR7",94,0)
 D ^%DT
"RTN","HLOUSR7",95,0)
 I Y=-1 Q 0
"RTN","HLOUSR7",96,0)
 Q Y
"RTN","HLOUSR7",97,0)
OUTPURGE ;Purge outgoing queue
"RTN","HLOUSR7",98,0)
 N MSG,CNT
"RTN","HLOUSR7",99,0)
 N MSG
"RTN","HLOUSR7",100,0)
 S (CNT,MSG)=0
"RTN","HLOUSR7",101,0)
 I '$D(ZTQUEUED) W !,"Removing messages....",!
"RTN","HLOUSR7",102,0)
 F  S MSG=$O(^HLB("QUEUE","OUT",LINK,QUE,MSG)) Q:'MSG  D
"RTN","HLOUSR7",103,0)
 .S CNT=CNT+1
"RTN","HLOUSR7",104,0)
 .I '(CNT#100),'$D(ZTQUEUED) W "."
"RTN","HLOUSR7",105,0)
 .I '(CNT#70000),'$D(ZTQUEUED) W "!"
"RTN","HLOUSR7",106,0)
 .D DEQUE^HLOQUE(LINK,QUE,"OUT",MSG)
"RTN","HLOUSR7",107,0)
 .I $$SETPURGE(MSG,WHEN) S $P(^HLB(MSG,0),"^",21)="MESSAGE GENERATED IN ERROR AND NOT TRANSMITTED"
"RTN","HLOUSR7",108,0)
 Q
"RTN","HLOUSR7",109,0)
 ;
"RTN","HLOUSR7",110,0)
SEQPURGE ;Purge sequence queue
"RTN","HLOUSR7",111,0)
 N MSG,CNT
"RTN","HLOUSR7",112,0)
 S (CNT,MSG)=0
"RTN","HLOUSR7",113,0)
 I '$D(ZTQUEUED) W !,"Removing messages....",!
"RTN","HLOUSR7",114,0)
 F  S MSG=$O(^HLB("QUEUE","SEQUENCE",QUE,MSG)) Q:'MSG  D
"RTN","HLOUSR7",115,0)
 .S CNT=CNT+1
"RTN","HLOUSR7",116,0)
 .I '(CNT#100),'$D(ZTQUEUED) W "."
"RTN","HLOUSR7",117,0)
 .I '(CNT#70000),'$D(ZTQUEUED) W "!"
"RTN","HLOUSR7",118,0)
 .K ^HLB("QUEUE","SEQUENCE",QUE,MSG)
"RTN","HLOUSR7",119,0)
 .I $$SETPURGE(MSG,WHEN) S $P(^HLB(MSG,0),"^",21)="MESSAGE GENERATED IN ERROR AND NOT TRANSMITTED"
"RTN","HLOUSR7",120,0)
 I $$INC^HLOSITE($NA(^HLC("QUEUECOUNT","SEQUENCE")),-$G(^HLC("QUEUECOUNT","SEQUENCE",QUE)))
"RTN","HLOUSR7",121,0)
 S ^HLC("QUEUECOUNT","SEQUENCE",QUE)=0
"RTN","HLOUSR7",122,0)
 S ^HLB("QUEUE","SEQUENCE",QUE)=""
"RTN","HLOUSR7",123,0)
 Q
"RTN","HLOUSR7",124,0)
 ;
"RTN","HLOUSR7",125,0)
SETPURGE(MSGIEN,TIME) ;  Set message up for purging.
"RTN","HLOUSR7",126,0)
 ;Resets the purge date/time.
"RTN","HLOUSR7",127,0)
 ;Input:
"RTN","HLOUSR7",128,0)
 ;   MSGIEN (required) ien of the message, file #778
"RTN","HLOUSR7",129,0)
 ;   TIME (optional) dt/time to set the purge time to, defaults to NOW
"RTN","HLOUSR7",130,0)
 ;Output:
"RTN","HLOUSR7",131,0)
 ;   Function returns 1 on success, 0 on failure
"RTN","HLOUSR7",132,0)
 ;   
"RTN","HLOUSR7",133,0)
 N NODE,OLDTIME,HLDIR
"RTN","HLOUSR7",134,0)
 Q:'$G(MSGIEN) 0
"RTN","HLOUSR7",135,0)
 S NODE=$G(^HLB(MSGIEN,0))
"RTN","HLOUSR7",136,0)
 Q:NODE="" 0
"RTN","HLOUSR7",137,0)
 S OLDTIME=$P(NODE,"^",9)
"RTN","HLOUSR7",138,0)
 S:'$G(TIME) TIME=$$NOW^XLFDT
"RTN","HLOUSR7",139,0)
 S HLDIR=$S($E($P(NODE,"^",4))="I":"IN",1:"OUT")
"RTN","HLOUSR7",140,0)
 K:OLDTIME ^HLB("AD",HLDIR,OLDTIME,MSGIEN)
"RTN","HLOUSR7",141,0)
 S $P(^HLB(MSGIEN,0),"^",9)=TIME
"RTN","HLOUSR7",142,0)
 S ^HLB("AD",HLDIR,TIME,MSGIEN)=""
"RTN","HLOUSR7",143,0)
 Q 1
"RTN","HLUCM001")
0^23^B50315331^B49070779
"RTN","HLUCM001",1,0)
HLUCM001 ;CIOFO-O/LJA - HL7/Capacity Mgt API (continued) ;05/01/2012
"RTN","HLUCM001",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**79,88,103,158**;Oct 13, 1995;Build 14
"RTN","HLUCM001",3,0)
 ;
"RTN","HLUCM001",4,0)
ADDTMP ; Accumulate totals into ^TMP(TOTALS,$J,...)
"RTN","HLUCM001",5,0)
 ; FAC,ORIGETM,ORIGSTM,TYPEHR,TYPEIO,TYPELR -- req
"RTN","HLUCM001",6,0)
 ;
"RTN","HLUCM001",7,0)
 N CHAR,ERRFLAG,FAC,SEC,START,TOTCURR,TYPEHR,TYPEIO,TYPELR
"RTN","HLUCM001",8,0)
 ;
"RTN","HLUCM001",9,0)
 S CHAR=$G(DATA("CHAR")),SEC=$G(DATA("DIFF")),FAC=$G(DATA("FAC"))
"RTN","HLUCM001",10,0)
 S TYPEHR=$G(DATA("HR")),TYPEIO=$G(DATA("IO")),TYPELR=$G(DATA("LR"))
"RTN","HLUCM001",11,0)
 ;
"RTN","HLUCM001",12,0)
 S START=$$HR($G(DATA("START")))
"RTN","HLUCM001",13,0)
 ;I START<ORIGSTM S START=ORIGSTM
"RTN","HLUCM001",14,0)
 ;I START>ORIGETM S START=ORIGETM
"RTN","HLUCM001",15,0)
 ;
"RTN","HLUCM001",16,0)
 ; Back door way to total by day only. (Dropping HR).
"RTN","HLUCM001",17,0)
 I $D(^TMP($J,"HLUCMDT")) S START=START\1
"RTN","HLUCM001",18,0)
 ;
"RTN","HLUCM001",19,0)
 ; Is delta time greater than 30 minutes?
"RTN","HLUCM001",20,0)
 S ERRFLAG=0
"RTN","HLUCM001",21,0)
 I SEC>1799 D
"RTN","HLUCM001",22,0)
 .  S X=TOTALS N TOTALS S TOTALS=X_"ERRTIME",ERRFLAG=1
"RTN","HLUCM001",23,0)
 .  D ERRMOVE^HLUCM009(+IEN772) ; Move into ^TMP($J,"HLUCMSTORE","ERR")
"RTN","HLUCM001",24,0)
 ; Store under TOTALS_ERRTIME
"RTN","HLUCM001",25,0)
 ;
"RTN","HLUCM001",26,0)
 ; Maybe, this IEN772 has already been ERRd by ERRMOVE^HLUCM009?
"RTN","HLUCM001",27,0)
 I $D(^TMP($J,"HLUCMSTORE","ERR","X",+IEN772)) D  QUIT  ;->
"RTN","HLUCM001",28,0)
 .  D ERRMOVE^HLUCM009(+IEN772) ; Just to be sure
"RTN","HLUCM001",29,0)
 ;
"RTN","HLUCM001",30,0)
 ; Should this entry even be counted?
"RTN","HLUCM001",31,0)
 I (HLAPI="CMF"!(HLAPI="CM2F"))&(TYPELR'="R") QUIT  ;->
"RTN","HLUCM001",32,0)
 ;
"RTN","HLUCM001",33,0)
 ; Accumulating and totaling here...
"RTN","HLUCM001",34,0)
 I TYPELR="R" D ACCUMFAC^HLUCM090
"RTN","HLUCM001",35,0)
 D ACCUMHR
"RTN","HLUCM001",36,0)
 D ACCUMSP
"RTN","HLUCM001",37,0)
 D ACCUMPR
"RTN","HLUCM001",38,0)
 D TOTALING
"RTN","HLUCM001",39,0)
 ;
"RTN","HLUCM001",40,0)
 Q
"RTN","HLUCM001",41,0)
 ;
"RTN","HLUCM001",42,0)
TOTALING ; Grand totals
"RTN","HLUCM001",43,0)
 S TOTCURR=$G(^TMP(TOTALS,$J))
"RTN","HLUCM001",44,0)
 S $P(TOTCURR,U)=$P(TOTCURR,U)+DATA("CHAR")
"RTN","HLUCM001",45,0)
 I $G(HLUCMADD)'="DON'T ADD.  COLLECT3~HLUCM003" D
"RTN","HLUCM001",46,0)
 .  S $P(TOTCURR,U,2)=$P(TOTCURR,U,2)+1
"RTN","HLUCM001",47,0)
 S $P(TOTCURR,U,3)=$P(TOTCURR,U,3)+DATA("DIFF")
"RTN","HLUCM001",48,0)
 S $P(TOTCURR,U,4)=$P(TOTCURR,U,4)+1
"RTN","HLUCM001",49,0)
 S ^TMP(TOTALS,$J)=TOTCURR
"RTN","HLUCM001",50,0)
 Q
"RTN","HLUCM001",51,0)
 ;
"RTN","HLUCM001",52,0)
ACCUMHR ; Hour totaling
"RTN","HLUCM001",53,0)
 ; DATA(),FAC,START,TYPEHR -- req
"RTN","HLUCM001",54,0)
 ;
"RTN","HLUCM001",55,0)
 I HLAPI="CM"!(HLAPI="CM2") D ACCUMLAT^HLUCM009("HR","TM",TYPEHR,START,DATA("PCKG"),DATA("PROT"))
"RTN","HLUCM001",56,0)
 I HLAPI="CMF"!(HLAPI="CM2F") D ACCUMLAT^HLUCM009("HR","TM",TYPEHR,FAC,START,DATA("PCKG"),DATA("PROT"))
"RTN","HLUCM001",57,0)
 ;
"RTN","HLUCM001",58,0)
 ; Total level CATEGORY
"RTN","HLUCM001",59,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,"HR"))
"RTN","HLUCM001",60,0)
 D INCR
"RTN","HLUCM001",61,0)
 S ^TMP(TOTALS,$J,"HR")=TOTCURR
"RTN","HLUCM001",62,0)
 ;
"RTN","HLUCM001",63,0)
 QUIT
"RTN","HLUCM001",64,0)
 ;
"RTN","HLUCM001",65,0)
ACCUMSP ; Namespace totaling
"RTN","HLUCM001",66,0)
 ; DATA(),FAC,TYPEIO,TYPELR -- req
"RTN","HLUCM001",67,0)
 ;
"RTN","HLUCM001",68,0)
 I HLAPI="CM"!(HLAPI="CM2") D
"RTN","HLUCM001",69,0)
 .  D ACCUMLAT^HLUCM009("NMSP","IO",TYPEIO,DATA("PCKG"),START,DATA("PROT"))
"RTN","HLUCM001",70,0)
 .  D ACCUMLAT^HLUCM009("NMSP","LR",TYPELR,DATA("PCKG"),START,DATA("PROT"))
"RTN","HLUCM001",71,0)
 I HLAPI="CMF"!(HLAPI="CM2F") D
"RTN","HLUCM001",72,0)
 .  D ACCUMLAT^HLUCM009("NMSP","IO",TYPEIO,FAC,DATA("PCKG"),START,DATA("PROT"))
"RTN","HLUCM001",73,0)
 .  D ACCUMLAT^HLUCM009("NMSP","LR",TYPELR,FAC,DATA("PCKG"),START,DATA("PROT"))
"RTN","HLUCM001",74,0)
 ;
"RTN","HLUCM001",75,0)
 ; Total level CATEGORY
"RTN","HLUCM001",76,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,"NMSP"))
"RTN","HLUCM001",77,0)
 D INCR
"RTN","HLUCM001",78,0)
 S ^TMP(TOTALS,$J,"NMSP")=TOTCURR
"RTN","HLUCM001",79,0)
 ;
"RTN","HLUCM001",80,0)
 QUIT
"RTN","HLUCM001",81,0)
 ;
"RTN","HLUCM001",82,0)
ACCUMPR ; Protocol totaling...
"RTN","HLUCM001",83,0)
 ; DATA(),FAC,START -- req
"RTN","HLUCM001",84,0)
 ;
"RTN","HLUCM001",85,0)
 I HLAPI="CM"!(HLAPI="CM2") D ACCUMLAT^HLUCM009("PROT","PR","P",DATA("PROT"),DATA("PCKG"),START)
"RTN","HLUCM001",86,0)
 I HLAPI="CMF"!(HLAPI="CM2F") D ACCUMLAT^HLUCM009("PROT","PR","P",FAC,DATA("PROT"),DATA("PCKG"),START)
"RTN","HLUCM001",87,0)
 ;
"RTN","HLUCM001",88,0)
 ; Total level CATEGORY
"RTN","HLUCM001",89,0)
 S TOTCURR=$G(^TMP(TOTALS,$J,"PROT"))
"RTN","HLUCM001",90,0)
 D INCR
"RTN","HLUCM001",91,0)
 S ^TMP(TOTALS,$J,"PROT")=TOTCURR
"RTN","HLUCM001",92,0)
 ;
"RTN","HLUCM001",93,0)
 QUIT
"RTN","HLUCM001",94,0)
 ;
"RTN","HLUCM001",95,0)
INCR ; Increment totals in TOTCURR...
"RTN","HLUCM001",96,0)
 ; CHAR,SEC -- req
"RTN","HLUCM001",97,0)
 S $P(TOTCURR,U)=$P(TOTCURR,U)+CHAR ; Number characters
"RTN","HLUCM001",98,0)
 I $G(HLUCMADD)'="DON'T ADD.  COLLECT3~HLUCM003" D
"RTN","HLUCM001",99,0)
 .  S $P(TOTCURR,U,2)=$P(TOTCURR,U,2)+1
"RTN","HLUCM001",100,0)
 S $P(TOTCURR,U,3)=$P(TOTCURR,U,3)+SEC ; Processing seconds
"RTN","HLUCM001",101,0)
 S $P(TOTCURR,U,4)=$P(TOTCURR,U,4)+1
"RTN","HLUCM001",102,0)
 QUIT
"RTN","HLUCM001",103,0)
 ;
"RTN","HLUCM001",104,0)
HR(FMDT) ; Return FM DATE and HOUR only...
"RTN","HLUCM001",105,0)
 N HR
"RTN","HLUCM001",106,0)
 S FMDT=$G(FMDT)
"RTN","HLUCM001",107,0)
 I FMDT'?7N&(FMDT'?7N1"."1.N) QUIT "" ;->
"RTN","HLUCM001",108,0)
 S:FMDT'["." FMDT=FMDT_"."
"RTN","HLUCM001",109,0)
 S FMDT=$E(FMDT_"00",1,10) ; .00 thru .23 now...
"RTN","HLUCM001",110,0)
 S HR=+$P(FMDT,".",2)+1
"RTN","HLUCM001",111,0)
 S:HR<10 HR=0_HR S:HR>24 HR=24
"RTN","HLUCM001",112,0)
 QUIT (FMDT\1)_"."_HR
"RTN","HLUCM001",113,0)
 ;
"RTN","HLUCM001",114,0)
OKPAR101(PAR) ; PAR=IEN101...
"RTN","HLUCM001",115,0)
 N RET,VAL
"RTN","HLUCM001",116,0)
 ;
"RTN","HLUCM001",117,0)
 I PAR=1!(PAR=2) QUIT PAR ;->
"RTN","HLUCM001",118,0)
 I PAR="0^9999999" QUIT PAR ;->
"RTN","HLUCM001",119,0)
 ;
"RTN","HLUCM001",120,0)
 ; Passed as 0^IEN or 0^PROTOCOL NAME...
"RTN","HLUCM001",121,0)
 S VAL=$P(PAR,U,2)
"RTN","HLUCM001",122,0)
 ;
"RTN","HLUCM001",123,0)
 ; Was IEN passed?
"RTN","HLUCM001",124,0)
 I VAL=+VAL D  QUIT RET ;->
"RTN","HLUCM001",125,0)
 .  S RET=""
"RTN","HLUCM001",126,0)
 .  I $D(^ORD(101,+VAL,0)) S RET=PAR
"RTN","HLUCM001",127,0)
 .  I '$D(^ORD(101,+VAL,0)) QUIT  ;-> Leaving RET=""
"RTN","HLUCM001",128,0)
 ;
"RTN","HLUCM001",129,0)
 ; Name was passed... (Can be up to 63 characters long...)
"RTN","HLUCM001",130,0)
 ; Find IEN for name...
"RTN","HLUCM001",131,0)
 S VAL=$$FIND101(PAR)
"RTN","HLUCM001",132,0)
 ;
"RTN","HLUCM001",133,0)
 ; If VAL=IEN, reset IEN101 to 0^IEN format...
"RTN","HLUCM001",134,0)
 I VAL>0 QUIT "0^"_+VAL  ;->
"RTN","HLUCM001",135,0)
 ;
"RTN","HLUCM001",136,0)
 QUIT ""
"RTN","HLUCM001",137,0)
 ;
"RTN","HLUCM001",138,0)
TYPELR(IEN772,FACNM) ; Is this Local or Remote or Unknown?
"RTN","HLUCM001",139,0)
 ; SITENM -- req
"RTN","HLUCM001",140,0)
 N D772,I773,IEN,IEN870,IO,MIEN,NM,TXT,TYPE,X
"RTN","HLUCM001",141,0)
 ;
"RTN","HLUCM001",142,0)
 ; If SITENM=FACNM, then it isn't remote...
"RTN","HLUCM001",143,0)
 I $G(SITENM)]"",$G(FACNM)]"",SITENM=FACNM QUIT "L" ;->
"RTN","HLUCM001",144,0)
 ;
"RTN","HLUCM001",145,0)
 S D772=$G(^HL(772,+IEN772,0))
"RTN","HLUCM001",146,0)
 ;
"RTN","HLUCM001",147,0)
 ; Mailman check...
"RTN","HLUCM001",148,0)
 S MIEN=$P(D772,U,5) ; get Mailman IEN...
"RTN","HLUCM001",149,0)
 I MIEN S X=$$MAILTYPE^HLUCM009(MIEN) QUIT:X="R" $$SLR(IEN772,"R") ;-> Mailman, and remote...
"RTN","HLUCM001",150,0)
 ;
"RTN","HLUCM001",151,0)
 ; Additional mail check...
"RTN","HLUCM001",152,0)
 I $$MAIL870^HLUCM090(IEN772)="R" QUIT $$SLR(IEN772,"R") ;->
"RTN","HLUCM001",153,0)
 ;
"RTN","HLUCM001",154,0)
 ; Institution check...
"RTN","HLUCM001",155,0)
 I $$INST870^HLUCM090(+IEN772,+$P($$SITE^VASITE,U,3))="R" QUIT $$SLR(IEN772,"R") ;->
"RTN","HLUCM001",156,0)
 ;
"RTN","HLUCM001",157,0)
 ; MSH segment in 773 check...
"RTN","HLUCM001",158,0)
 S TYPE="L",I773=0
"RTN","HLUCM001",159,0)
 F  S I773=$O(^HLMA("B",IEN772,I773)) Q:'I773!(TYPE'="L")  D
"RTN","HLUCM001",160,0)
 .  N DIV,P4,P6
"RTN","HLUCM001",161,0)
 .  S TXT="",MIEN=0
"RTN","HLUCM001",162,0)
 .  F  S MIEN=$O(^HLMA(+I773,"MSH",MIEN)) Q:MIEN'>0  D
"RTN","HLUCM001",163,0)
 .  .  S TXT=TXT_$G(^HLMA(+I773,"MSH",+MIEN,0))
"RTN","HLUCM001",164,0)
 .  QUIT:TXT']""  ;->
"RTN","HLUCM001",165,0)
 .  S X=$$SITESMSH^HLUCM009(TXT),P4=$P(X,U),P6=$P(X,U,2)
"RTN","HLUCM001",166,0)
 .  S:P4'=P6 TYPE="R"
"RTN","HLUCM001",167,0)
 ;
"RTN","HLUCM001",168,0)
 ; Was anything found?
"RTN","HLUCM001",169,0)
 QUIT:TYPE'="L" $$SLR(IEN772,TYPE) ;->
"RTN","HLUCM001",170,0)
 ;
"RTN","HLUCM001",171,0)
 ; Logical links check...
"RTN","HLUCM001",172,0)
 S IEN870=$$IEN870^HLUCM009(+IEN772) I IEN870 D
"RTN","HLUCM001",173,0)
 .  N DATA,MGIEN
"RTN","HLUCM001",174,0)
 .  S DATA=$G(^HLCS(870,+IEN870,0))
"RTN","HLUCM001",175,0)
 .  QUIT:$P(DATA,U,3)'=1  ;-> Not MAIL...
"RTN","HLUCM001",176,0)
 .  S MGIEN=$P($G(^HLCS(870,+IEN870,100)),U) QUIT:MGIEN'>0  ;->
"RTN","HLUCM001",177,0)
 .  ; If a MAIL type link and there is an associated mail group,
"RTN","HLUCM001",178,0)
 .  ; it is almost always REMOTE.  Enough so, that "R" will be assumed.
"RTN","HLUCM001",179,0)
 .  ; QUIT:$O(^XMB(3.8,+MGIEN,6,0))'>0  ;-> No remote groups
"RTN","HLUCM001",180,0)
 .  S TYPE="R"
"RTN","HLUCM001",181,0)
 .  ; Rare to hit this point.
"RTN","HLUCM001",182,0)
 ;
"RTN","HLUCM001",183,0)
 QUIT $$SLR(IEN772,TYPE)
"RTN","HLUCM001",184,0)
 ;
"RTN","HLUCM001",185,0)
SLR(IEN772,LR) ; Store the L/R type for use for FACILITY sorting
"RTN","HLUCM001",186,0)
 N FAC,HLDATA,PARENT,TYPE,X
"RTN","HLUCM001",187,0)
 Q LR
"RTN","HLUCM001",188,0)
 ;
"RTN","HLUCM001",189,0)
PREPARE() ; Called by $$CM & $$CM2 and other APIs...
"RTN","HLUCM001",190,0)
 ;
"RTN","HLUCM001",191,0)
 S ORIGSTM=$G(START),ORIGETM=$G(END)
"RTN","HLUCM001",192,0)
 S SITENM=$P($$SITE^VASITE,U,2)
"RTN","HLUCM001",193,0)
 ;
"RTN","HLUCM001",194,0)
 ; Summarize by DAY instead of hour?
"RTN","HLUCM001",195,0)
 I ORIGSTM?7N,ORIGETM']"" D
"RTN","HLUCM001",196,0)
 .  S ^TMP($J,"HLUCMDT")=""
"RTN","HLUCM001",197,0)
 .  S ORIGETM=ORIGSTM_".24"
"RTN","HLUCM001",198,0)
 ;
"RTN","HLUCM001",199,0)
 D ZEROUP
"RTN","HLUCM001",200,0)
 ;
"RTN","HLUCM001",201,0)
 ; Miscellaneous KILLs...
"RTN","HLUCM001",202,0)
 D KILLS^HLUCM009("START")
"RTN","HLUCM001",203,0)
 ;
"RTN","HLUCM001",204,0)
 ; Build namespace xref
"RTN","HLUCM001",205,0)
 D NMSPXRF^HLUCM009
"RTN","HLUCM001",206,0)
 ;
"RTN","HLUCM001",207,0)
 ; This is where results are returned to caller...
"RTN","HLUCM001",208,0)
 KILL ERRINFO
"RTN","HLUCM001",209,0)
 ;
"RTN","HLUCM001",210,0)
 ; Perform all setup chores.  If errors found, they will be placed
"RTN","HLUCM001",211,0)
 ; in ERRINFO(ERROR-REASON)="" array
"RTN","HLUCM001",212,0)
 QUIT:$$SETUP^HLUCM009 "" ;-> Some errors occurred...
"RTN","HLUCM001",213,0)
 ;
"RTN","HLUCM001",214,0)
 Q 1
"RTN","HLUCM001",215,0)
 ;
"RTN","HLUCM001",216,0)
ZEROUP ; If didn't add 0^...
"RTN","HLUCM001",217,0)
 I $G(IEN101)]"",IEN101'?1N,IEN101'?1"0^".E S IEN101="0^"_IEN101
"RTN","HLUCM001",218,0)
 I $G(PNMSP)]"",PNMSP'?1N,PNMSP'?1"0^".E S PNMSP="0^"_PNMSP
"RTN","HLUCM001",219,0)
 Q
"RTN","HLUCM001",220,0)
 ;
"RTN","HLUCM001",221,0)
FIND101(VAL) ; No checking for upp/lowercase.  Must be passed right!
"RTN","HLUCM001",222,0)
 ; VAL = Protocol name...
"RTN","HLUCM001",223,0)
 N FIEN,IEN,LNM,PNM
"RTN","HLUCM001",224,0)
 ;
"RTN","HLUCM001",225,0)
 S VAL=$P(VAL,"0^",2)
"RTN","HLUCM001",226,0)
 ;
"RTN","HLUCM001",227,0)
 ; Passed as IEN?
"RTN","HLUCM001",228,0)
 I VAL=+VAL,$D(^ORD(101,+VAL,0)) QUIT +VAL ;->
"RTN","HLUCM001",229,0)
 ;
"RTN","HLUCM001",230,0)
 ; Passed as NAME?
"RTN","HLUCM001",231,0)
 S FIEN=0
"RTN","HLUCM001",232,0)
 S LNM=$E(VAL,1,$S($L(VAL)>30:29,1:$L(VAL)-1))
"RTN","HLUCM001",233,0)
 F  S LNM=$O(^ORD(101,"B",LNM)) Q:LNM]VAL!(LNM']"")!(FIEN)  D
"RTN","HLUCM001",234,0)
 .  S IEN=0
"RTN","HLUCM001",235,0)
 .  F  S IEN=$O(^ORD(101,"B",LNM,IEN)) Q:IEN'>0!(FIEN)  D
"RTN","HLUCM001",236,0)
 .  .  QUIT:$P($G(^ORD(101,+IEN,0)),U)'=VAL  ;->
"RTN","HLUCM001",237,0)
 .  .  S FIEN=+IEN
"RTN","HLUCM001",238,0)
 QUIT $S(FIEN:FIEN,1:"")
"RTN","HLUCM001",239,0)
 ;
"RTN","HLUCM001",240,0)
REFPROT(PROT) ; If passed by reference, is PROT in array? 0=Don't count, 2=Count
"RTN","HLUCM001",241,0)
 ; PROTYPE -- req
"RTN","HLUCM001",242,0)
 N X
"RTN","HLUCM001",243,0)
 I PROTYPE'=1 QUIT 1 ;-> Not passed by reference...
"RTN","HLUCM001",244,0)
 S X=$P(PROT,"~") I X]"" I $D(IEN101(X)) QUIT 1 ;-> found by name in array
"RTN","HLUCM001",245,0)
 S X=$P(PROT,"~",2) I X]"" I $D(IEN101(+X)) QUIT 1 ;-> found by IEN in array
"RTN","HLUCM001",246,0)
 QUIT ""
"RTN","HLUCM001",247,0)
 ;
"RTN","HLUCM001",248,0)
REFPCKG(PCKG) ; If passed by reference, is PCKG in array? 0=Don't count,1=OK to count
"RTN","HLUCM001",249,0)
 ; NMSPTYPE -- req
"RTN","HLUCM001",250,0)
 I NMSPTYPE'=1 QUIT 1 ;-> Not passed by reference...
"RTN","HLUCM001",251,0)
 I PCKG]"" I $D(PNMSP(PCKG)) QUIT 1 ;-> found in array
"RTN","HLUCM001",252,0)
 QUIT ""
"RTN","HLUCM001",253,0)
 ;
"RTN","HLUCM001",254,0)
EOR ; HLUCM001 - HL7/Capacity Mgt API (continued) ;2/27/01 10:15
"VER")
8.0^22.0
"^DD",778,778,0)
FIELD^^.22^32
"^DD",778,778,0,"DDA")
N
"^DD",778,778,0,"DT")
3120323
"^DD",778,778,0,"IX","AC",778,.01)

"^DD",778,778,0,"IX","AD",778,.09)

"^DD",778,778,0,"IX","AE",778.03,.02)

"^DD",778,778,0,"IX","B",778,.01)

"^DD",778,778,0,"IX","C",778,.02)

"^DD",778,778,0,"NM","HLO MESSAGES")

"^DD",778,778,0,"VRPK")
HL
"^DD",778,778,.01,0)
MESSAGE ID^RF^^0;1^K:$L(X)>20!($L(X)<3) X
"^DD",778,778,.01,1,0)
^.1
"^DD",778,778,.01,1,1,0)
778^B
"^DD",778,778,.01,1,1,1)
S ^HLB("B",$E(X,1,30),DA)=""
"^DD",778,778,.01,1,1,2)
K ^HLB("B",$E(X,1,30),DA)
"^DD",778,778,.01,1,2,0)
778^AC^MUMPS
"^DD",778,778,.01,1,2,1)
Q
"^DD",778,778,.01,1,2,2)
Q
"^DD",778,778,.01,1,2,"%D",0)
^.101^3^3^3041116^^
"^DD",778,778,.01,1,2,"%D",1,0)
This x-ref is maintained by the HL7 package.  It is used to detect if an
"^DD",778,778,.01,1,2,"%D",2,0)
incoming message is a duplicate.  The format is:
"^DD",778,778,.01,1,2,"%D",3,0)
^HLB("AC"sending facility>_<sending application>_<msg id>,ien)=0
"^DD",778,778,.01,1,2,"DT")
3040812
"^DD",778,778,.01,3)
Answer must be 3-20 characters in length
"^DD",778,778,.01,"DT")
3050504
"^DD",778,778,.02,0)
MESSAGE BODY^RP777'^HLA(^0;2^Q
"^DD",778,778,.02,1,0)
^.1
"^DD",778,778,.02,1,1,0)
778^C^MUMPS
"^DD",778,778,.02,1,1,1)
S ^HLB("C",X,DA)=""
"^DD",778,778,.02,1,1,2)
K ^HLB("C",X,DA)
"^DD",778,778,.02,1,1,"%D",0)
^.101^2^2^3050317^^
"^DD",778,778,.02,1,1,"%D",1,0)
Used to find all the messages that point to the same entry in file 777. Only
"^DD",778,778,.02,1,1,"%D",2,0)
set for outgoing messages.
"^DD",778,778,.02,1,1,"DT")
3040815
"^DD",778,778,.02,3)
Which record in file #777 contains the body of the message?
"^DD",778,778,.02,"DT")
3050317
"^DD",778,778,.03,0)
APPLICATION ACKNOWLEDGMENT TO^F^^0;3^K:$L(X)>30!($L(X)<3) X
"^DD",778,778,.03,3)
Enter the Message Control ID of the message to which this one is an acknowledgment.
"^DD",778,778,.03,21,0)
^^2^2^3050317^^
"^DD",778,778,.03,21,1,0)
This is the Message Control ID of the original message to which this message
"^DD",778,778,.03,21,2,0)
is an application acknowledgment.
"^DD",778,778,.03,"DT")
3050317
"^DD",778,778,.04,0)
DIRECTION^RS^I:INCOMING;O:OUTGOING;^0;4^Q
"^DD",778,778,.04,3)
Is the message INCOMING or OUTGOING?
"^DD",778,778,.04,"DT")
3041116
"^DD",778,778,.05,0)
LINK^RF^^0;5^K:$L(X)>10!($L(X)<3) X
"^DD",778,778,.05,3)
Enter the name of the logical link over which the message is being transmitted.
"^DD",778,778,.05,"DT")
3041116
"^DD",778,778,.06,0)
QUEUE^F^^0;6^K:$L(X)>20!($L(X)<3) X
"^DD",778,778,.06,3)
Is the queue on which this message was placed.
"^DD",778,778,.06,"DT")
3040729
"^DD",778,778,.07,0)
APPLICATION ACKNOWLEDGMENT BY^F^^0;7^K:$L(X)>30!($L(X)<3) X
"^DD",778,778,.07,3)
If this message has received an application response then enter the responses Message Control ID.
"^DD",778,778,.07,"DT")
3040930
"^DD",778,778,.08,0)
REMOTE PORT^NJ5,0^^0;8^K:+X'=X!(X>65535)!(X<1)!(X?.E1"."1.N) X
"^DD",778,778,.08,3)
Enter the remote port indicated in the Facility field of the message header.
"^DD",778,778,.08,21,0)
^^4^4^3050504^^
"^DD",778,778,.08,21,1,0)
This is the remote port # that may be found in the message header. For outgoing
"^DD",778,778,.08,21,2,0)
messages, it is in the Receiving Facility field, for incoming messages it is
"^DD",778,778,.08,21,3,0)
in tthe Sending Facility. For application acknowledgments, the port provided in
"^DD",778,778,.08,21,4,0)
the original message is used to return the acknowledgment. 
"^DD",778,778,.08,"DT")
3050504
"^DD",778,778,.09,0)
SCHEDULED PURGE DATE/TIME^D^^0;9^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",778,778,.09,1,0)
^.1
"^DD",778,778,.09,1,1,0)
778^AD^MUMPS
"^DD",778,778,.09,1,1,1)
Q
"^DD",778,778,.09,1,1,2)
Q
"^DD",778,778,.09,1,1,3)
DO NOT DELETE!
"^DD",778,778,.09,1,1,"%D",0)
^.101^4^4^3040828^^
"^DD",778,778,.09,1,1,"%D",1,0)
This cross-reference will be used to control the purging process.  It will
"^DD",778,778,.09,1,1,"%D",2,0)
be maintained within the HL7 package and will not be set via Fileman.
"^DD",778,778,.09,1,1,"%D",3,0)
The format is:
"^DD",778,778,.09,1,1,"%D",4,0)
^HLB("AD",<"IN" or "OUT">,<dt/tm for purging>,<message ien>)="
"^DD",778,778,.09,1,1,"DT")
3040819
"^DD",778,778,.09,3)
When can this message be purged?
"^DD",778,778,.09,"DT")
3040819
"^DD",778,778,.1,0)
APPLICATION ACK RSPNS TAG^F^^0;10^K:$L(X)>8!($L(X)<1) X
"^DD",778,778,.1,3)
Answer must be 1-8 characters in length.
"^DD",778,778,.1,21,0)
^^4^4^3040727^
"^DD",778,778,.1,21,1,0)
The sending application routine to execute when the application ack is received.
"^DD",778,778,.1,21,2,0)

"^DD",778,778,.1,21,3,0)
This is part one of a two-part field which is the entry point.  The second part
"^DD",778,778,.1,21,4,0)
names the routine.  
"^DD",778,778,.1,"DT")
3040727
"^DD",778,778,.11,0)
APPLICATION ACK RSPNS RTN^F^^0;11^K:$L(X)>8!($L(X)<1) X
"^DD",778,778,.11,3)
Enter the application routine that should be executed when an applicaton ack is returned.
"^DD",778,778,.11,21,0)
^^11^11^3070314^^
"^DD",778,778,.11,21,1,0)
Answer must be 1-8 characters in length. 
"^DD",778,778,.11,21,2,0)
The sending application routine to execute when
"^DD",778,778,.11,21,3,0)
the application ack is received.  
"^DD",778,778,.11,21,4,0)
 
"^DD",778,778,.11,21,5,0)
This is part two of a two-part field which is
"^DD",778,778,.11,21,6,0)
the routine name.  The first part names the
"^DD",778,778,.11,21,7,0)
entry point.  
"^DD",778,778,.11,21,8,0)

"^DD",778,778,.11,21,9,0)
For an returned application ack, this field documents
"^DD",778,778,.11,21,10,0)
the routine that was executed to process the application ack.
"^DD",778,778,.11,21,11,0)

"^DD",778,778,.11,"DT")
3070314
"^DD",778,778,.12,0)
ACCEPT ACK RSPNS TAG^F^^0;12^K:$L(X)>8!($L(X)<1) X
"^DD",778,778,.12,3)
Answer must be 1-8 characters in length.
"^DD",778,778,.12,21,0)
^.001^7^7^3041116^^^
"^DD",778,778,.12,21,1,0)
The sending application's routine to execute when the transmission of the
"^DD",778,778,.12,21,2,0)
message fails, i.e., the message cannot be sent or no acceptack is received.  
"^DD",778,778,.12,21,3,0)
 
"^DD",778,778,.12,21,4,0)
This is part one of a two-part field, naming the entry point of the routine to
"^DD",778,778,.12,21,5,0)
be called.  The second part names the routine.  
"^DD",778,778,.12,21,6,0)
  
"^DD",778,778,.12,21,7,0)
  
"^DD",778,778,.12,"DT")
3041116
"^DD",778,778,.13,0)
ACCEPT ACK RESPNS RTN^F^^0;13^K:$L(X)>8!($L(X)<1) X
"^DD",778,778,.13,3)
Answer must be 1-8 characters in length.
"^DD",778,778,.13,21,0)
^.001^6^6^3041116^^^^
"^DD",778,778,.13,21,1,0)
The sending application routine to execute whe the commit ack is received.     
"^DD",778,778,.13,21,2,0)
 
"^DD",778,778,.13,21,3,0)
This is part two of a two-part field, consisting of the routine name. The first
"^DD",778,778,.13,21,4,0)
part names the entry point with the M routine.
"^DD",778,778,.13,21,5,0)
  
"^DD",778,778,.13,21,6,0)
  
"^DD",778,778,.13,"DT")
3041116
"^DD",778,778,.14,0)
TRANSMISSION FAILURE RSPNS TAG^F^^0;14^K:$L(X)>8!($L(X)<1) X
"^DD",778,778,.14,3)
Answer must be 1-8 characters in length.
"^DD",778,778,.14,21,0)
^^8^8^3040727^
"^DD",778,778,.14,21,1,0)
The sending application's routine to execute
"^DD",778,778,.14,21,2,0)
when the transmission of the message fails,
"^DD",778,778,.14,21,3,0)
i.e., the message can not be sent or no commit
"^DD",778,778,.14,21,4,0)
ack is received.  
"^DD",778,778,.14,21,5,0)
 
"^DD",778,778,.14,21,6,0)
This is part one of a two-part field which is
"^DD",778,778,.14,21,7,0)
the entry point.  The second part names the
"^DD",778,778,.14,21,8,0)
routine.  
"^DD",778,778,.14,"DT")
3040727
"^DD",778,778,.15,0)
TRANSMISSION FAILURE RSPNS RTN^F^^0;15^K:$L(X)>8!($L(X)<1) X
"^DD",778,778,.15,3)
Answer must be 1-8 characters in length.
"^DD",778,778,.15,21,0)
^^8^8^3040727^
"^DD",778,778,.15,21,1,0)
The sending application's routine to execute
"^DD",778,778,.15,21,2,0)
when the transmission of the message fails,
"^DD",778,778,.15,21,3,0)
i.e., the message can not be sent or no commit
"^DD",778,778,.15,21,4,0)
ack is received.  
"^DD",778,778,.15,21,5,0)
 
"^DD",778,778,.15,21,6,0)
This is part two of a two-part field which is
"^DD",778,778,.15,21,7,0)
the routine's name.  The first part names the
"^DD",778,778,.15,21,8,0)
entry point.  
"^DD",778,778,.15,"DT")
3040727
"^DD",778,778,.16,0)
TRANSMISSION DATE/TIME^D^^0;16^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",778,778,.16,3)

"^DD",778,778,.16,21,0)
^^1^1^3040728^
"^DD",778,778,.16,21,1,0)
This is the date and time that the message was either received or sent.
"^DD",778,778,.16,"DT")
3040728
"^DD",778,778,.17,0)
ACCEPT ACK'D^S^1:YES;^0;17^Q
"^DD",778,778,.17,3)
Enter 1 if an accept ack was sent or received.
"^DD",778,778,.17,"DT")
3040823
"^DD",778,778,.18,0)
APPLICATION ACK'D^S^1:YES;^0;18^Q
"^DD",778,778,.18,21,0)
^.001^3^3^3041116^^^
"^DD",778,778,.18,21,1,0)
For incoming messages, this flag indicates that an application ack was
"^DD",778,778,.18,21,2,0)
returned.  For outgoing messages, this field indicates that the application
"^DD",778,778,.18,21,3,0)
ack was sent.
"^DD",778,778,.18,"DT")
3041116
"^DD",778,778,.19,0)
APPLICATION HANDOFF^S^1:YES;^0;19^Q
"^DD",778,778,.19,21,0)
^^4^4^3040728^
"^DD",778,778,.19,21,1,0)
This flag indicates that this message was handed to the application.  That
"^DD",778,778,.19,21,2,0)
may be for initial processing, or it may be in response to one of the other
"^DD",778,778,.19,21,3,0)
conditions that an application may register its need to respond, such
"^DD",778,778,.19,21,4,0)
as a failure of the remote system to accept the message.
"^DD",778,778,.19,"DT")
3040728
"^DD",778,778,.2,0)
COMPLETION STATUS^S^SU:SUCCESSFUL;TF:(obsolete) transmission failure;SE:(obsolete) system error;AE:(obsolete) application error;ER:ERROR;^0;20^Q
"^DD",778,778,.2,3)
Enter the code that indicates the final status of the message.
"^DD",778,778,.2,21,0)
^.001^3^3^3040820^^^^
"^DD",778,778,.2,21,1,0)
This field indicates the final status of the message.
"^DD",778,778,.2,21,2,0)
Any code but SU (SUCCESSFUL) indicates that an error occurred.
"^DD",778,778,.2,21,3,0)
No value indicates that the message has not completed.
"^DD",778,778,.2,"DT")
3080514
"^DD",778,778,.21,0)
ERROR TEXT^F^^0;21^K:$L(X)>30!($L(X)<1) X
"^DD",778,778,.21,3)
Answer must be 1-30 characters in length.
"^DD",778,778,.21,21,0)
^.001^3^3^3071102^^^^
"^DD",778,778,.21,21,1,0)
The HL7 package may use this field to document errors that prevent transmission.
"^DD",778,778,.21,21,2,0)
Errors determined by the remote system are contained in the MSA segment of the 
"^DD",778,778,.21,21,3,0)
response message.
"^DD",778,778,.21,"DT")
3040928
"^DD",778,778,.22,0)
APP-SPECIFIED RETENTION^NJ3,0^^0;22^K:+X'=X!(X>999)!(X<1)!(X?.E1"."1.N) X
"^DD",778,778,.22,.1)
APPLICATION SPECIFIED MINIMUM RETENTION TIME
"^DD",778,778,.22,3)
How many days should the message be retained after it is processed?  Enter 1 to 999.
"^DD",778,778,.22,21,0)
^^10^10^3120521^^^^
"^DD",778,778,.22,21,1,0)
This field indicates the minimum retention time in days specified by the
"^DD",778,778,.22,21,2,0)
application for the message before it is purged. When the purge is actually
"^DD",778,778,.22,21,3,0)
scheduled the site parameter will override the retention time specified in
"^DD",778,778,.22,21,4,0)
this field if the site parameter specifies a longer retention time.
"^DD",778,778,.22,21,5,0)

"^DD",778,778,.22,21,6,0)

"^DD",778,778,.22,21,7,0)

"^DD",778,778,.22,21,8,0)

"^DD",778,778,.22,21,9,0)

"^DD",778,778,.22,21,10,0)

"^DD",778,778,.22,"DT")
3120521
"^DD",778,778,1,0)
HDR SEGMENT,COMPONENTS 1-6^RF^^1;E1,250^K:$L(X)>250!($L(X)<8) X
"^DD",778,778,1,3)
The first 6 components of the message header segment.
"^DD",778,778,1,"DT")
3040729
"^DD",778,778,2,0)
HDR SEGMENT,COMPONENTS 7-END^RF^^2;E1,250^K:$L(X)>250!($L(X)<15) X
"^DD",778,778,2,3)
Enter the header segment begining with component 7
"^DD",778,778,2,"DT")
3041116
"^DD",778,778,3,0)
MSH SEGMENTS FOR BATCH^778.03A^^3;0
"^DD",778,778,4.01,0)
DATE/TIME OF ACCEPT ACK^D^^4;1^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",778,778,4.01,3)
Enter the date and time of the ack.
"^DD",778,778,4.01,21,0)
^^1^1^3040928^^
"^DD",778,778,4.01,21,1,0)
This field will be used to record the accept ack.
"^DD",778,778,4.01,"DT")
3040928
"^DD",778,778,4.02,0)
ACCEPT ACK MESSAGE ID^F^^4;2^K:$L(X)>30!($L(X)<1) X
"^DD",778,778,4.02,3)
Answer must be 1-30 characters in length.
"^DD",778,778,4.02,"DT")
3040928
"^DD",778,778,4.03,0)
ACCEPT ACK MSA SEGMENT^F^^4;3^K:$L(X)>210!($L(X)<3) X
"^DD",778,778,4.03,3)
Answer must be 3-210 characters in length.
"^DD",778,778,4.03,"DT")
3040928
"^DD",778,778,5,0)
TRANMISSION ATTEMPTS^NJ8,0^^TRIES;1^K:+X'=X!(X>99999999)!(X<0)!(X?.E1"."1.N) X
"^DD",778,778,5,3)
How many times has HLO tried to transmit this message?
"^DD",778,778,5,21,0)
^^3^3^3070314^
"^DD",778,778,5,21,1,0)
For outgoing messages, this field is a counter of how many times HLO
"^DD",778,778,5,21,2,0)
attempted to send this message.
"^DD",778,778,5,21,3,0)

"^DD",778,778,5,"DT")
3070314
"^DD",778,778,5.01,0)
SEQUENCE QUEUE^F^^5;1^K:$L(X)>30!($L(X)<3) X
"^DD",778,778,5.01,3)
Enter the name of the sequence queue to place the message on, 3-30 characters.
"^DD",778,778,5.01,21,0)
^^10^10^3070625^
"^DD",778,778,5.01,21,1,0)
Applications may have difficulty insuring that messages are received by
"^DD",778,778,5.01,21,2,0)
the remote application in the same order that the sending application 
"^DD",778,778,5.01,21,3,0)
generates the messages.  If an application determines that maintaining
"^DD",778,778,5.01,21,4,0)
the order of its messages is necessary, one method it may use it to specify
"^DD",778,778,5.01,21,5,0)
that 1) Application acknowledgemnts are needed  and 2) that the messages
"^DD",778,778,5.01,21,6,0)
should be placed on a sequence queue.   Messages that are placed on a
"^DD",778,778,5.01,21,7,0)
particular sequence queue are not moved to the outgoing queue for transmission 
"^DD",778,778,5.01,21,8,0)
until the application acknolwedgment for the preceding message is received.
"^DD",778,778,5.01,21,9,0)
This guarantees the order of delivery.
"^DD",778,778,5.01,21,10,0)

"^DD",778,778,5.01,"DT")
3070730
"^DD",778,778,5.02,0)
MOVED TO OUT QUEUE^S^1:YES;^5;2^Q
"^DD",778,778,5.02,3)
Enter YES if the message has been moved from a sequence queue to an outgoing queue.
"^DD",778,778,5.02,"DT")
3070625
"^DD",778,778,5.03,0)
SEQUENCING EXCEPTION RAISED^S^1:YES;^5;3^Q
"^DD",778,778,5.03,3)
Enter YES if the application ack is delayed, preventing the quence queue from moving.
"^DD",778,778,5.03,"DT")
3070625
"^DD",778,778.03,0)
MSH SEGMENTS FOR BATCH SUB-FIELD^^2^7
"^DD",778,778.03,0,"DT")
3070710
"^DD",778,778.03,0,"IX","B",778.03,.01)

"^DD",778,778.03,0,"NM","MSH SEGMENTS FOR BATCH")

"^DD",778,778.03,0,"UP")
778
"^DD",778,778.03,.01,0)
MESSAGE IN BATCH^NJ5,0^^0;1^K:+X'=X!(X>99999)!(X<1)!(X?.E1"."1N.N) X
"^DD",778,778.03,.01,1,0)
^.1
"^DD",778,778.03,.01,1,1,0)
778.03^B
"^DD",778,778.03,.01,1,1,1)
S ^HLB(DA(1),3,"B",$E(X,1,30),DA)=""
"^DD",778,778.03,.01,1,1,2)
K ^HLB(DA(1),3,"B",$E(X,1,30),DA)
"^DD",778,778.03,.01,3)
Enter a number to sequence each message within the batch, starting with 1,2,3,...etc.
"^DD",778,778.03,.01,"DT")
3040726
"^DD",778,778.03,.02,0)
MESSAGE ID^RF^^0;2^K:$L(X)>30!($L(X)<1) X
"^DD",778,778.03,.02,1,0)
^.1
"^DD",778,778.03,.02,1,1,0)
778^AE^MUMPS
"^DD",778,778.03,.02,1,1,1)
Q
"^DD",778,778.03,.02,1,1,2)
Q
"^DD",778,778.03,.02,1,1,"%D",0)
^.101^5^5^3041006^^
"^DD",778,778.03,.02,1,1,"%D",1,0)
This cross-reference is maintained outside of Fileman. It is for finding
"^DD",778,778.03,.02,1,1,"%D",2,0)
individual messages within a batch using the individual Message Control ID.
"^DD",778,778.03,.02,1,1,"%D",3,0)
Its format is:
"^DD",778,778.03,.02,1,1,"%D",4,0)

"^DD",778,778.03,.02,1,1,"%D",5,0)
"AE",<Message Control ID>,<ien, file 778>^<subien>)=""
"^DD",778,778.03,.02,1,1,"DT")
3041006
"^DD",778,778.03,.02,3)
Answer must be 1-30 characters in length.
"^DD",778,778.03,.02,"DT")
3041006
"^DD",778,778.03,.03,0)
APPLICATION ACKNOWLEDGMENT TO^F^^0;3^K:$L(X)>30!($L(X)<3) X
"^DD",778,778.03,.03,3)
Enter the Message Control ID of the message to which this one is a response.
"^DD",778,778.03,.03,21,0)
^^1^1^3040928^
"^DD",778,778.03,.03,21,1,0)
This field is completed only if this message is an application acknowledgment.
"^DD",778,778.03,.03,"DT")
3040928
"^DD",778,778.03,.04,0)
APPLICATION ACKNOWLEDGMENT BY^F^^0;4^K:$L(X)>30!($L(X)<3) X
"^DD",778,778.03,.04,3)
 Enter the Message Control ID of the application response.
"^DD",778,778.03,.04,"DT")
3040929
"^DD",778,778.03,.05,0)
COMPLETION STATUS^S^SU:SUCCESS;AE:(obsolete) application error;ER:ERROR;^0;5^Q
"^DD",778,778.03,.05,3)
Enter only if an application acknowledgment is received. SU is for successfully completed messages, ER if an error is returned.
"^DD",778,778.03,.05,"DT")
3070710
"^DD",778,778.03,1,0)
MSH SEGMENT, COMPONENTS 1-6^RF^^1;E1,250^K:$L(X)>250!($L(X)<8) X
"^DD",778,778.03,1,3)
Answer must be 8-250 characters in length.
"^DD",778,778.03,1,"DT")
3040729
"^DD",778,778.03,2,0)
MSH SEGMENT, COMPONENTS 7-END^F^^2;E1,250^K:$L(X)>250!($L(X)<15) X
"^DD",778,778.03,2,3)
Answer must be 15-250 characters in length.
"^DD",778,778.03,2,"DT")
3040729
"^DD",779.1,779.1,0)
FIELD^^.13^13
"^DD",779.1,779.1,0,"DDA")
N
"^DD",779.1,779.1,0,"DT")
3120323
"^DD",779.1,779.1,0,"IX","B",779.1,.01)

"^DD",779.1,779.1,0,"NM","HLO SYSTEM PARAMETERS")

"^DD",779.1,779.1,0,"VRPK")
HL
"^DD",779.1,779.1,.01,0)
DOMAIN NAME^RF^^0;1^K:$L(X)>64!($L(X)<3)!'(X'?1P.E) X
"^DD",779.1,779.1,.01,1,0)
^.1
"^DD",779.1,779.1,.01,1,1,0)
779.1^B
"^DD",779.1,779.1,.01,1,1,1)
S ^HLD(779.1,"B",$E(X,1,60),DA)=""
"^DD",779.1,779.1,.01,1,1,2)
K ^HLD(779.1,"B",$E(X,1,60),DA)
"^DD",779.1,779.1,.01,3)
The domain name for this system.  It will be used to populate component 2 of the Sending Facility field of the HL7 message header.
"^DD",779.1,779.1,.01,21,0)
^^2^2^3040805^
"^DD",779.1,779.1,.01,21,1,0)
The domain name for this system.  It will be used to populate component 2
"^DD",779.1,779.1,.01,21,2,0)
of the Sending Facility field of the HL7 message headers.
"^DD",779.1,779.1,.01,"DT")
3040805
"^DD",779.1,779.1,.02,0)
STATION NUMBER^F^^0;2^K:$L(X)>7!($L(X)<3) X
"^DD",779.1,779.1,.02,3)
Enter the station number with suffix that this system belongs under.  It will be used in component 1 of the Sending Facility field of the HL7 message header.
"^DD",779.1,779.1,.02,"DT")
3040805
"^DD",779.1,779.1,.03,0)
PRODUCTION ID^RS^P:production;T:training;^0;3^Q
"^DD",779.1,779.1,.03,3)
ENTER P if this is a production system, T otherwise.
"^DD",779.1,779.1,.03,"DT")
3040805
"^DD",779.1,779.1,.04,0)
MAXIMUM STRING LENGTH^NJ5,0^^0;4^K:+X'=X!(X>99999)!(X<1)!(X?.E1"."1N.N) X
"^DD",779.1,779.1,.04,3)
This is the maximum length for strings built by HLO when local applications create new messages to send.
"^DD",779.1,779.1,.04,21,0)
^^4^4^3050706^
"^DD",779.1,779.1,.04,21,1,0)
This parameter determines the maximum length for strings that HLO will create
"^DD",779.1,779.1,.04,21,2,0)
when messages are being built.  It doesn't apply to servers, as the size of
"^DD",779.1,779.1,.04,21,3,0)
input buffer used by TCP/IP determines the maximum string length created by a
"^DD",779.1,779.1,.04,21,4,0)
single read.
"^DD",779.1,779.1,.04,"DT")
3050706
"^DD",779.1,779.1,.05,0)
BUFFER SIZE FOR HL7 (BYTES)^NJ5,0^^0;5^K:+X'=X!(X>20000)!(X<10000)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.05,3)
This parameter represents the size of the buffer used by HLO for its background processes.  It defaults to 15000 bytes, but may be set from 10,000 bytes to 20,000 bytes.
"^DD",779.1,779.1,.05,"DT")
3050805
"^DD",779.1,779.1,.06,0)
BUFFER SIZE FOR USER (BYTES)^NJ5,0^^0;6^K:+X'=X!(X>10000)!(X<512)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.06,3)
This parameter is the size of the buffer used by HLO in the context of an online user.  It defaults to 5000, but may be reset to between 512 and 10000 bytes.
"^DD",779.1,779.1,.06,"DT")
3050805
"^DD",779.1,779.1,.07,0)
NORMAL MSG RETENTION (DAYS)^NJ2,0^^0;7^K:+X'=X!(X>99)!(X<1)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.07,3)
How many days should successful messages be kept before being purged? Enter a whole number, 1 to 99.
"^DD",779.1,779.1,.07,21,0)
^^7^7^3120323^^^^
"^DD",779.1,779.1,.07,21,1,0)
This field controls how many days successful messages are retained after
"^DD",779.1,779.1,.07,21,2,0)
being fully processed before they are purged. 
"^DD",779.1,779.1,.07,21,3,0)

"^DD",779.1,779.1,.07,21,4,0)
The application may specify a longer time to retain its messages, which would
"^DD",779.1,779.1,.07,21,5,0)
override the time specified here.
"^DD",779.1,779.1,.07,21,6,0)

"^DD",779.1,779.1,.07,21,7,0)

"^DD",779.1,779.1,.07,"DT")
3120326
"^DD",779.1,779.1,.08,0)
BAD MESSAGE RETENTION (DAYS)^NJ2,0^^0;8^K:+X'=X!(X>99)!(X<5)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.08,3)
How many days should message with errors remain on your system?  Enter 5 to 99. The default is 7.
"^DD",779.1,779.1,.08,21,0)
^^5^5^3120323^^
"^DD",779.1,779.1,.08,21,1,0)
This field controls the purging of HL7 messages that do not complete
"^DD",779.1,779.1,.08,21,2,0)
successfully.  The period should be reasonably long to allow
"^DD",779.1,779.1,.08,21,3,0)
investigation, but because of the high daily volume of
"^DD",779.1,779.1,.08,21,4,0)
messages purging must occur as quickly as practical.
"^DD",779.1,779.1,.08,21,5,0)

"^DD",779.1,779.1,.08,"DT")
3120323
"^DD",779.1,779.1,.09,0)
HLO ON/OFF SWITCH^S^0:OFF;1:ON;^0;9^Q
"^DD",779.1,779.1,.09,3)
Set to 0 to turn off messaging and all HL7 processes.
"^DD",779.1,779.1,.09,"DT")
3050503
"^DD",779.1,779.1,.1,0)
HLO STANDARD LISTENER^*P870'^HLCS(870,^0;10^S DIC("S")="I ($P($G(^HLCS(870,Y,400)),""^"",3)=""M"")!($P($G(^HLCS(870,Y,400)),""^"",3)=""S"")" D ^DIC K DIC S DIC=$G(DIE),X=+Y K:Y<0 X
"^DD",779.1,779.1,.1,3)
Select an entry from the HL Logical Link file that is the listener that remote applications will normally connect to.
"^DD",779.1,779.1,.1,12)
This screen allows only server entries to be selected.
"^DD",779.1,779.1,.1,12.1)
S DIC("S")="I ($P($G(^HLCS(870,Y,400)),""^"",3)=""M"")!($P($G(^HLCS(870,Y,400)),""^"",3)=""S"")"
"^DD",779.1,779.1,.1,"DT")
3050601
"^DD",779.1,779.1,.11,0)
HLO RECOUNT ON/OFF FLAG^S^0:OFF;1:ON;^0;11^Q
"^DD",779.1,779.1,.11,3)
Set to 1 to disallow update of queues when a recount is being performed.
"^DD",779.1,779.1,.11,"DT")
3071025
"^DD",779.1,779.1,.12,0)
UNSENT MSG RETENTION (DAYS)^NJ3,0^^0;12^K:+X'=X!(X>999)!(X<1)!(X?.E1"."1.N) X
"^DD",779.1,779.1,.12,3)
How many days should an unsent message be kept before it is purged? (default value is 45 days)
"^DD",779.1,779.1,.12,"DT")
3080723
"^DD",779.1,779.1,.13,0)
BOX-VOLUME PAIR^P14.7'^%ZIS(14.7,^0;13^Q
"^DD",779.1,779.1,.13,3)
Enter the BOX-VOLUME pair that HLO processes should run on.
"^DD",779.1,779.1,.13,21,0)
^^13^13^3100324^
"^DD",779.1,779.1,.13,21,1,0)
The BOX-VOLUME PAIR parameter allows a site to specify which CPU and volume
"^DD",779.1,779.1,.13,21,2,0)
set the HLO processes should run on.  This parameter only controls procesess
"^DD",779.1,779.1,.13,21,3,0)
started by the HLO Process Manager by calling the Taskmanager APIs.
"^DD",779.1,779.1,.13,21,4,0)

"^DD",779.1,779.1,.13,21,5,0)
This parameter is optional.
"^DD",779.1,779.1,.13,21,6,0)

"^DD",779.1,779.1,.13,21,7,0)
For VMS sites, this parameter generally does NOT control what node to run
"^DD",779.1,779.1,.13,21,8,0)
the listener on, because VMS sites should use VMS TCPIP Services for their
"^DD",779.1,779.1,.13,21,9,0)
listener.
"^DD",779.1,779.1,.13,21,10,0)

"^DD",779.1,779.1,.13,21,11,0)
For Cache/NT sites using a load balancer, this parameter can be used to
"^DD",779.1,779.1,.13,21,12,0)
specify what node to run the listener on. 
"^DD",779.1,779.1,.13,21,13,0)

"^DD",779.1,779.1,.13,"DT")
3100324
"^DD",779.2,779.2,0)
FIELD^^.13^15
"^DD",779.2,779.2,0,"DDA")
N
"^DD",779.2,779.2,0,"DT")
3120323
"^DD",779.2,779.2,0,"IX","B",779.2,.01)

"^DD",779.2,779.2,0,"NM","HLO APPLICATION REGISTRY")

"^DD",779.2,779.2,0,"VRPK")
HL
"^DD",779.2,779.2,.01,0)
APPLICATION NAME^RF^^0;1^K:$L(X)>60!($L(X)<3)!'(X'?1P.E) X
"^DD",779.2,779.2,.01,.1)

"^DD",779.2,779.2,.01,1,0)
^.1
"^DD",779.2,779.2,.01,1,1,0)
779.2^B
"^DD",779.2,779.2,.01,1,1,1)
S ^HLD(779.2,"B",$E(X,1,60),DA)=""
"^DD",779.2,779.2,.01,1,1,2)
K ^HLD(779.2,"B",$E(X,1,60),DA)
"^DD",779.2,779.2,.01,3)
Answer must be 3-60 characters in length. It must be unique and should be name-spaced.
"^DD",779.2,779.2,.01,"DT")
3081110
"^DD",779.2,779.2,.02,0)
RESPONSE LINK (OPTIONAL)^FX^^0;2^K:'$$CHKLINK^HLOTLNK(X) X
"^DD",779.2,779.2,.02,3)
If the return link cannot be identified via the Sending Facility (i.e., sent via an IE), what link should the application ack be sent through?
"^DD",779.2,779.2,.02,21,0)
^^5^5^3041116^^
"^DD",779.2,779.2,.02,21,1,0)
This field applies only if: 1) The receiving application is expected to 
"^DD",779.2,779.2,.02,21,2,0)
return application acknowledgments.  2) The initial message is  received 
"^DD",779.2,779.2,.02,21,3,0)
indirectly through the IE, and the  receiving application in turn does 
"^DD",779.2,779.2,.02,21,4,0)
not want to send the application acknowledgment directly back to the 
"^DD",779.2,779.2,.02,21,5,0)
sending facility identified in the message header.  
"^DD",779.2,779.2,.02,"DT")
3041116
"^DD",779.2,779.2,.03,0)
DEFAULT PRIVATE IN-QUEUE^F^^0;3^K:$L(X)>20!($L(X)<3) X
"^DD",779.2,779.2,.03,3)
You may create an optional default private in-queue by entering a unique name up to 20 characters in length. Queues specified for specific message types take precedence.
"^DD",779.2,779.2,.03,"DT")
3050317
"^DD",779.2,779.2,.04,0)
BATCH ACTION TAG^F^^0;4^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.2,.04,3)
If the application utilizes batch messages, the action to perform upon receipt of the message should be entered in the BATCH ACTION TAG and BATCH ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.2,.04,"DT")
3040814
"^DD",779.2,779.2,.05,0)
BATCH ACTION ROUTINE^F^^0;5^K:$L(X)>8!($L(X)<3) X
"^DD",779.2,779.2,.05,3)
If the application utilizes batch messages, the action to perform upon receipt of the message should be entered in the BATCH ACTION TAG and BATCH ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.2,.05,"DT")
3040814
"^DD",779.2,779.2,.06,0)
DEFAULT ACTION TAG^F^^0;6^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.2,.06,3)
You can enter the action to perform upon  receipt of a message where no other action applies by entering the DEFAULT ACTION TAG and DEFAULT ACTION ROUTINE fields as <tag>^<routine>. 
"^DD",779.2,779.2,.06,"DT")
3040815
"^DD",779.2,779.2,.07,0)
DEFAULT ACTION ROUTINE^F^^0;7^K:$L(X)>8!($L(X)<3) X
"^DD",779.2,779.2,.07,3)
You can enter the action to perform upon receipt of a message where no other action applies by entering the DEFAULT ACTION TAG and DEFAULT ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.2,.07,"DT")
3040814
"^DD",779.2,779.2,.08,0)
BATCH PRIVATE IN-QUEUE^F^^0;8^K:$L(X)>20!($L(X)<3) X
"^DD",779.2,779.2,.08,3)
You may establish a private queue for your batch messages by entering a unique name (name-spaced) up to 20 characters long.
"^DD",779.2,779.2,.08,"DT")
3050317
"^DD",779.2,779.2,.09,0)
APPLICATION SPECIFIC LISTENER^*P870'X^HLCS(870,^0;9^S DIC("S")="I $P($G(^HLCS(870,Y,400)),""^"",3)'="""",""SM""[$P(^HLCS(870,Y,400),""^"",3)" D ^DIC K DIC S DIC=$G(DIE),X=+Y K:Y<0 X
"^DD",779.2,779.2,.09,3)
If your application requires its own listener (HIGHLY DISCOURAGED), enter it here.
"^DD",779.2,779.2,.09,12)
The link entered must be a listener.
"^DD",779.2,779.2,.09,12.1)
S DIC("S")="I $P($G(^HLCS(870,Y,400)),""^"",3)'="""",""SM""[$P(^HLCS(870,Y,400),""^"",3)"
"^DD",779.2,779.2,.09,21,0)
^^6^6^3050503^
"^DD",779.2,779.2,.09,21,1,0)
Applications are highly discouraged from establishing their own listeners.  The
"^DD",779.2,779.2,.09,21,2,0)
use of the multi-listeners provide concurrent processing of many connections
"^DD",779.2,779.2,.09,21,3,0)
over the same port, so a dedicated listener will not provide an application
"^DD",779.2,779.2,.09,21,4,0)
with a performance boost, while it will cause the site additional work to
"^DD",779.2,779.2,.09,21,5,0)
maintain. So before establishing a dedicated listener, the application
"^DD",779.2,779.2,.09,21,6,0)
developer should verify the need.
"^DD",779.2,779.2,.09,"DT")
3061120
"^DD",779.2,779.2,.1,0)
SEQUENCE EXCEPTION TAG^F^^0;10^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.2,.1,3)
What is the tag to invoke the sequencing exception routine at?
"^DD",779.2,779.2,.1,"DT")
3070705
"^DD",779.2,779.2,.11,0)
SEQUENCE EXCEPTION ROUTINE^F^^0;11^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.2,.11,3)
What routine should be invoked when a sequencing exception is encountered?
"^DD",779.2,779.2,.11,"DT")
3070705
"^DD",779.2,779.2,.12,0)
SEQUENCING TIMEOUT^NJ4,0^^0;12^K:+X'=X!(X>9999)!(X<5)!(X?.E1"."1.N) X
"^DD",779.2,779.2,.12,3)
Enter how long to wait for an applicaiton ack used in sequencing before rasing an exception.  Enter between 5 (minutes) and 9999 (minutes). 
"^DD",779.2,779.2,.12,"DT")
3070726
"^DD",779.2,779.2,.13,0)
MINIMUM RETENTION TIME^NJ3,0^^0;13^K:+X'=X!(X>999)!(X<1)!(X?.E1"."1.N) X
"^DD",779.2,779.2,.13,3)
How many days should the application's messages be retained after they are processed?  Enter a whole number, 1 to 999.
"^DD",779.2,779.2,.13,4)
D EN^DDIOL("The retention time may be specified for a specific message type."),EN^DDIOL("If so, it will override the retention time specified here.")
"^DD",779.2,779.2,.13,21,0)
^^13^13^3120326^^^^
"^DD",779.2,779.2,.13,21,1,0)
This field may be used by the application to set the minimum number of days
"^DD",779.2,779.2,.13,21,2,0)
that its messages should be retained after being processed. 
"^DD",779.2,779.2,.13,21,3,0)

"^DD",779.2,779.2,.13,21,4,0)
This value applies to the application's messages as a whole, but may be
"^DD",779.2,779.2,.13,21,5,0)
overridden if the application specifies a value for specific message types.
"^DD",779.2,779.2,.13,21,6,0)

"^DD",779.2,779.2,.13,21,7,0)
The site parameter, if set to a longer time, will override the application
"^DD",779.2,779.2,.13,21,8,0)
parameter, whereas a shorter value will be ignored.
"^DD",779.2,779.2,.13,21,9,0)

"^DD",779.2,779.2,.13,21,10,0)

"^DD",779.2,779.2,.13,21,11,0)

"^DD",779.2,779.2,.13,21,12,0)

"^DD",779.2,779.2,.13,21,13,0)

"^DD",779.2,779.2,.13,"DT")
3120326
"^DD",779.2,779.2,1,0)
MESSAGE TYPE ACTIONS^779.21I^^1;0
"^DD",779.2,779.2,1,21,0)
^^2^2^3070103^^
"^DD",779.2,779.2,1,21,1,0)

"^DD",779.2,779.2,1,21,2,0)

"^DD",779.2,779.2,2,0)
Package File Link^RP9.4'^DIC(9.4,^2;1^Q
"^DD",779.2,779.2,2,3)
Enter the package responsible for these messages.
"^DD",779.2,779.2,2,21,0)
^^3^3^3050919^^
"^DD",779.2,779.2,2,21,1,0)
This field holds a pointer to the Package File for the Package 
"^DD",779.2,779.2,2,21,2,0)
responsible for these messages.
"^DD",779.2,779.2,2,21,3,0)

"^DD",779.2,779.2,2,"DT")
3050919
"^DD",779.2,779.21,0)
MESSAGE TYPE ACTIONS SUB-FIELD^^.08^8
"^DD",779.2,779.21,0,"DT")
3120323
"^DD",779.2,779.21,0,"ID",.02)
W "   ",$P(^(0),U,2)
"^DD",779.2,779.21,0,"ID",.06)
W "   ",$P(^(0),U,6)
"^DD",779.2,779.21,0,"IX","B",779.21,.01)

"^DD",779.2,779.21,0,"NM","MESSAGE TYPE ACTIONS")

"^DD",779.2,779.21,0,"UP")
779.2
"^DD",779.2,779.21,.01,0)
HL7 MESSAGE TYPE^MF^^0;1^K:$L(X)>3!($L(X)<3) X
"^DD",779.2,779.21,.01,1,0)
^.1
"^DD",779.2,779.21,.01,1,1,0)
779.21^B
"^DD",779.2,779.21,.01,1,1,1)
S ^HLD(779.2,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",779.2,779.21,.01,1,1,2)
K ^HLD(779.2,DA(1),1,"B",$E(X,1,30),DA)
"^DD",779.2,779.21,.01,3)
Enter the 3 character HL7 Message Type.
"^DD",779.2,779.21,.01,21,0)
^^3^3^3040814^
"^DD",779.2,779.21,.01,21,1,0)
An application should use this multiple to define the action that the receiving
"^DD",779.2,779.21,.01,21,2,0)
application needs to perform upon receipt of a specific type of HL7 message,
"^DD",779.2,779.21,.01,21,3,0)
identified by the HL7 MESSAGE TYPE and HL7 EVENT fields.
"^DD",779.2,779.21,.01,"DT")
3111202
"^DD",779.2,779.21,.02,0)
HL7 EVENT^RF^^0;2^K:$L(X)>3!($L(X)<3) X
"^DD",779.2,779.21,.02,3)
Enter the 3 character HL7 event type.
"^DD",779.2,779.21,.02,"DT")
3111202
"^DD",779.2,779.21,.03,0)
PRIVATE IN-QUEUE^F^^0;3^K:$L(X)>20!($L(X)<3) X
"^DD",779.2,779.21,.03,3)
You may create a private in-queue for message of this type by entering a unique name up to 20 characters long.
"^DD",779.2,779.21,.03,"DT")
3050919
"^DD",779.2,779.21,.04,0)
ACTION TAG^F^^0;4^K:$L(X)>8!($L(X)<1) X
"^DD",779.2,779.21,.04,3)
You must enter the action to perform upon receipt of this type by entering the ACTION TAG and ACTION ROUTINE fields as <tag>^<routine>. The tag is optional. 
"^DD",779.2,779.21,.04,"DT")
3040815
"^DD",779.2,779.21,.05,0)
ACTION ROUTINE^RF^^0;5^K:$L(X)>8!($L(X)<3) X
"^DD",779.2,779.21,.05,3)
You must enter the action to perform upon receipt of this type by entering the ACTION TAG and ACTION ROUTINE fields as <tag>^<routine>.
"^DD",779.2,779.21,.05,"DT")
3050919
"^DD",779.2,779.21,.06,0)
HL7 VERSION^F^^0;6^K:$L(X)>20!($L(X)<1) X
"^DD",779.2,779.21,.06,3)
Leave blank UNLESS this action applies only to a specific version of the message!  Enter the version exactly as it will appear in the message header.
"^DD",779.2,779.21,.06,"DT")
3111202
"^DD",779.2,779.21,.07,0)
INACTIVE^S^1:INACTIVE;^0;7^Q
"^DD",779.2,779.21,.07,3)
Enter '1' to stop the application from generating messages of this type.
"^DD",779.2,779.21,.07,21,0)
^^4^4^3060621^
"^DD",779.2,779.21,.07,21,1,0)
This flag is made available to the application, but it is up to the application
"^DD",779.2,779.21,.07,21,2,0)
to honor it.   In otherwords, its up to the application to check the flag and
"^DD",779.2,779.21,.07,21,3,0)
decide whether or not to generate messages of this type.
"^DD",779.2,779.21,.07,21,4,0)

"^DD",779.2,779.21,.07,"DT")
3060621
"^DD",779.2,779.21,.08,0)
MINIMUM RETENTION TIME^NJ3,0^^0;8^K:+X'=X!(X>999)!(X<1)!(X?.E1"."1.N) X
"^DD",779.2,779.21,.08,3)
Enter the number of days to retain messages of this type after they are processed.  Enter a whole number, 1 to 999.
"^DD",779.2,779.21,.08,4)
D EN^DDIOL("The retention time specified here will override the value specified for the"),EN^DDIOL("overall application.")
"^DD",779.2,779.21,.08,21,0)
^^5^5^3120323^^^
"^DD",779.2,779.21,.08,21,1,0)
This field may be set by the application to specify how many days
"^DD",779.2,779.21,.08,21,2,0)
this type of message should be retained before purging.
"^DD",779.2,779.21,.08,21,3,0)

"^DD",779.2,779.21,.08,21,4,0)

"^DD",779.2,779.21,.08,21,5,0)

"^DD",779.2,779.21,.08,"DT")
3120326
"^DD",870,870,24,0)
DO NOT PING^S^0:NO;1:YES;^0;24^Q
"^DD",870,870,24,3)
Enter YES to prevent this link from being PINGED. The default is NO.
"^DD",870,870,24,21,0)
^^2^2^3120712^
"^DD",870,870,24,21,1,0)
This field, if set to YES, will prevent the link from being PINGED.
"^DD",870,870,24,21,2,0)

"^DD",870,870,24,"DT")
3120712
"^DIC",778,778,0)
HLO MESSAGES^778
"^DIC",778,778,0,"GL")
^HLB(
"^DIC",778,778,"%",0)
^1.005^^0
"^DIC",778,778,"%D",0)
^1.001^3^3^3071102^^^^
"^DIC",778,778,"%D",1,0)
Used to record each message as it is sent or received.  The content of the
"^DIC",778,778,"%D",2,0)
message is stored in a file #777, as it might be sent to multiple locations
"^DIC",778,778,"%D",3,0)
and applications.
"^DIC",778,"B","HLO MESSAGES",778)

"^DIC",779.1,779.1,0)
HLO SYSTEM PARAMETERS^779.1
"^DIC",779.1,779.1,0,"GL")
^HLD(779.1,
"^DIC",779.1,779.1,"%",0)
^1.005^^0
"^DIC",779.1,779.1,"%D",0)
^1.001^2^2^3050801^^^^
"^DIC",779.1,779.1,"%D",1,0)
This file contains parameters used by the HLO (HL7 Optimized)
"^DIC",779.1,779.1,"%D",2,0)
that are specific to the system the software is installed on.
"^DIC",779.1,"B","HLO SYSTEM PARAMETERS",779.1)

"^DIC",779.2,779.2,0)
HLO APPLICATION REGISTRY^779.2
"^DIC",779.2,779.2,0,"GL")
^HLD(779.2,
"^DIC",779.2,779.2,"%",0)
^1.005^^0
"^DIC",779.2,779.2,"%D",0)
^^12^12^3050801^^^^
"^DIC",779.2,779.2,"%D",1,0)
This file is used to register sending and receiving applications for HL7
"^DIC",779.2,779.2,"%D",2,0)
messaging. For receiving applications, the process of registration consists of
"^DIC",779.2,779.2,"%D",3,0)
registering what messages the application is prepared to receive.
"^DIC",779.2,779.2,"%D",4,0)

"^DIC",779.2,779.2,"%D",5,0)
For both sending and receiving applications, it is necessary to specify
"^DIC",779.2,779.2,"%D",6,0)
what package the application belongs to.  For sending applications, that is
"^DIC",779.2,779.2,"%D",7,0)
the only field that applies, other than the name of the sending application.
"^DIC",779.2,779.2,"%D",8,0)

"^DIC",779.2,779.2,"%D",9,0)
An application can be either a sender or a receiver of messages, or both. In 
"^DIC",779.2,779.2,"%D",10,0)
order for an application to receive messages, it must specify an action 
"^DIC",779.2,779.2,"%D",11,0)
(M tag^routine) for each type of message that it is capable of receiving, or a
"^DIC",779.2,779.2,"%D",12,0)
default action that applies when no messsage-specific action is defined.
"^DIC",779.2,"B","HLO APPLICATION REGISTRY",779.2)

"BLD",1629,6)
^126
**END**
**END**
