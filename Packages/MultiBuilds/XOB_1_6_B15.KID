KIDS Distribution saved on May 08, 2009@15:13:08
Version 1.6: Foundations, VistALink and VistALink Security
**KIDS**:XOBU 1.6^XOBV 1.6^XOBS 1.6^

**INSTALL NAME**
XOBU 1.6
"BLD",4062,0)
XOBU 1.6^FOUNDATIONS^0^3090508^y
"BLD",4062,1,0)
^^5^5^3071113^
"BLD",4062,1,1,0)
This build contains common files, libraries, etc. used by all the XOB* 
"BLD",4062,1,2,0)
packages.
"BLD",4062,1,3,0)
 
"BLD",4062,1,4,0)
It also contains options, protocols and list templates used to manage 
"BLD",4062,1,5,0)
Foundations site parameters and operations.
"BLD",4062,4,0)
^9.64PA^18.01^1
"BLD",4062,4,18.01,0)
18.01
"BLD",4062,4,18.01,222)
y^y^f^^^^n
"BLD",4062,4,"B",18.01,18.01)

"BLD",4062,6.3)
15
"BLD",4062,"ABNS",0)
^9.66A^^
"BLD",4062,"ABPKG")
n^n
"BLD",4062,"INI")
EN^XOBUPRE
"BLD",4062,"INID")
n^n^n
"BLD",4062,"INIT")
EN^XOBUPOST
"BLD",4062,"KRN",0)
^9.67PA^8989.52^19
"BLD",4062,"KRN",.4,0)
.4
"BLD",4062,"KRN",.401,0)
.401
"BLD",4062,"KRN",.402,0)
.402
"BLD",4062,"KRN",.402,"NM",0)
^9.68A^1^1
"BLD",4062,"KRN",.402,"NM",1,0)
XOBU SITE PARAMETERS    FILE #18.01^18.01^0
"BLD",4062,"KRN",.402,"NM","B","XOBU SITE PARAMETERS    FILE #18.01",1)

"BLD",4062,"KRN",.403,0)
.403
"BLD",4062,"KRN",.5,0)
.5
"BLD",4062,"KRN",.84,0)
.84
"BLD",4062,"KRN",.84,"NM",0)
^9.68A^^
"BLD",4062,"KRN",3.6,0)
3.6
"BLD",4062,"KRN",3.8,0)
3.8
"BLD",4062,"KRN",9.2,0)
9.2
"BLD",4062,"KRN",9.8,0)
9.8
"BLD",4062,"KRN",9.8,"NM",0)
^9.68A^6^5
"BLD",4062,"KRN",9.8,"NM",1,0)
XOBUM^^0^B36328580
"BLD",4062,"KRN",9.8,"NM",2,0)
XOBUM1^^0^B26724948
"BLD",4062,"KRN",9.8,"NM",3,0)
XOBUZAP^^0^B66617883
"BLD",4062,"KRN",9.8,"NM",4,0)
XOBUZAP1^^0^B2296758
"BLD",4062,"KRN",9.8,"NM",6,0)
XOBUZAP0^^0^B5948951
"BLD",4062,"KRN",9.8,"NM","B","XOBUM",1)

"BLD",4062,"KRN",9.8,"NM","B","XOBUM1",2)

"BLD",4062,"KRN",9.8,"NM","B","XOBUZAP",3)

"BLD",4062,"KRN",9.8,"NM","B","XOBUZAP0",6)

"BLD",4062,"KRN",9.8,"NM","B","XOBUZAP1",4)

"BLD",4062,"KRN",19,0)
19
"BLD",4062,"KRN",19,"NM",0)
^9.68A^2^2
"BLD",4062,"KRN",19,"NM",1,0)
XOBU SITE SETUP MENU^^0
"BLD",4062,"KRN",19,"NM",2,0)
XUSITEMGR^^2
"BLD",4062,"KRN",19,"NM","B","XOBU SITE SETUP MENU",1)

"BLD",4062,"KRN",19,"NM","B","XUSITEMGR",2)

"BLD",4062,"KRN",19.1,0)
19.1
"BLD",4062,"KRN",101,0)
101
"BLD",4062,"KRN",101,"NM",0)
^9.68A^17^10
"BLD",4062,"KRN",101,"NM",1,0)
XOBU FOUNDATIONS MAIN MENU^^0
"BLD",4062,"KRN",101,"NM",2,0)
XOBU FOUNDATIONS MAIN REFRESH^^0
"BLD",4062,"KRN",101,"NM",3,0)
XOBU FOUNDATIONS SYSTEM STATUS^^0
"BLD",4062,"KRN",101,"NM",4,0)
XOBU SITE PARAMETERS^^0
"BLD",4062,"KRN",101,"NM",12,0)
XOBU TERMINATE A JOB^^0
"BLD",4062,"KRN",101,"NM",13,0)
XOBU TERMINATE ALL JOBS^^0
"BLD",4062,"KRN",101,"NM",14,0)
XOBU TERMINATE JOBS REFRESH^^0
"BLD",4062,"KRN",101,"NM",15,0)
XOBU TERMINATE JOBS UTILITY MENU^^0
"BLD",4062,"KRN",101,"NM",16,0)
XOBU TERMINATE CONNECTION MANAGER^^0
"BLD",4062,"KRN",101,"NM",17,0)
XOBU TERMINATE SYSTEM STATUS^^0
"BLD",4062,"KRN",101,"NM","B","XOBU FOUNDATIONS MAIN MENU",1)

"BLD",4062,"KRN",101,"NM","B","XOBU FOUNDATIONS MAIN REFRESH",2)

"BLD",4062,"KRN",101,"NM","B","XOBU FOUNDATIONS SYSTEM STATUS",3)

"BLD",4062,"KRN",101,"NM","B","XOBU SITE PARAMETERS",4)

"BLD",4062,"KRN",101,"NM","B","XOBU TERMINATE A JOB",12)

"BLD",4062,"KRN",101,"NM","B","XOBU TERMINATE ALL JOBS",13)

"BLD",4062,"KRN",101,"NM","B","XOBU TERMINATE CONNECTION MANAGER",16)

"BLD",4062,"KRN",101,"NM","B","XOBU TERMINATE JOBS REFRESH",14)

"BLD",4062,"KRN",101,"NM","B","XOBU TERMINATE JOBS UTILITY MENU",15)

"BLD",4062,"KRN",101,"NM","B","XOBU TERMINATE SYSTEM STATUS",17)

"BLD",4062,"KRN",409.61,0)
409.61
"BLD",4062,"KRN",409.61,"NM",0)
^9.68A^2^2
"BLD",4062,"KRN",409.61,"NM",1,0)
XOBU FOUNDATIONS MAIN^^0
"BLD",4062,"KRN",409.61,"NM",2,0)
XOBU TERMINATE JOBS UTILITY^^0
"BLD",4062,"KRN",409.61,"NM","B","XOBU FOUNDATIONS MAIN",1)

"BLD",4062,"KRN",409.61,"NM","B","XOBU TERMINATE JOBS UTILITY",2)

"BLD",4062,"KRN",771,0)
771
"BLD",4062,"KRN",870,0)
870
"BLD",4062,"KRN",8989.51,0)
8989.51
"BLD",4062,"KRN",8989.52,0)
8989.52
"BLD",4062,"KRN",8994,0)
8994
"BLD",4062,"KRN","B",.4,.4)

"BLD",4062,"KRN","B",.401,.401)

"BLD",4062,"KRN","B",.402,.402)

"BLD",4062,"KRN","B",.403,.403)

"BLD",4062,"KRN","B",.5,.5)

"BLD",4062,"KRN","B",.84,.84)

"BLD",4062,"KRN","B",3.6,3.6)

"BLD",4062,"KRN","B",3.8,3.8)

"BLD",4062,"KRN","B",9.2,9.2)

"BLD",4062,"KRN","B",9.8,9.8)

"BLD",4062,"KRN","B",19,19)

"BLD",4062,"KRN","B",19.1,19.1)

"BLD",4062,"KRN","B",101,101)

"BLD",4062,"KRN","B",409.61,409.61)

"BLD",4062,"KRN","B",771,771)

"BLD",4062,"KRN","B",870,870)

"BLD",4062,"KRN","B",8989.51,8989.51)

"BLD",4062,"KRN","B",8989.52,8989.52)

"BLD",4062,"KRN","B",8994,8994)

"BLD",4062,"PRE")
XOBUENV
"BLD",4062,"QUES",0)
^9.62^^
"BLD",4062,"REQB",0)
^9.611^^
"FIA",18.01)
FOUNDATIONS SITE PARAMETERS
"FIA",18.01,0)
^XOB(18.01,
"FIA",18.01,0,0)
18.01P
"FIA",18.01,0,1)
y^y^f^^^^n
"FIA",18.01,0,10)

"FIA",18.01,0,11)

"FIA",18.01,0,"RLRO")

"FIA",18.01,0,"VR")
1.6^XOBU
"FIA",18.01,18.01)
0
"FIA",18.01,18.012)
0
"INI")
EN^XOBUPRE
"INIT")
EN^XOBUPOST
"KRN",.402,2166,-1)
0^1
"KRN",.402,2166,0)
XOBU SITE PARAMETERS^3050708.0813^@^18.01^^@^3090205
"KRN",.402,2166,"%D",0)
^^4^4^3030407^
"KRN",.402,2166,"%D",1,0)
This template is used to edit the Foundations and VistALink site 
"KRN",.402,2166,"%D",2,0)
parameters.
"KRN",.402,2166,"%D",3,0)
 
"KRN",.402,2166,"%D",4,0)
The XOBU SITE PARAMETERS protocol executes this template.
"KRN",.402,2166,"DR",1,18.01)
W !!,"Overall Parameters: ";W !,"   <none at this time>";W !!,"VistALink Parameters: ";.02;.03;.04//604800;.05//3600;21//10;IF $$GETOS^XOBVTCP()["DSM" SET Y="";100;
"KRN",.402,2166,"DR",2,18.012)
.01;.02;
"KRN",19,96,-1)
2^2
"KRN",19,96,0)
XUSITEMGR^Operations Management^^M^1039^^^^^^y^^n^^
"KRN",19,96,10,0)
^19.01IP^40^39
"KRN",19,96,10,40,0)
12438
"KRN",19,96,10,40,"^")
XOBU SITE SETUP MENU
"KRN",19,96,"U")
OPERATIONS MANAGEMENT
"KRN",19,12438,-1)
0^1
"KRN",19,12438,0)
XOBU SITE SETUP MENU^Foundations Management^^A^^^^^^^^FOUNDATIONS^^1
"KRN",19,12438,1,0)
^^7^7^3030409^
"KRN",19,12438,1,1,0)
This option invokes the Foundations Management ListManager template 
"KRN",19,12438,1,2,0)
XOBU FOUNDATIONS MAIN.  This ListManager application is the main
"KRN",19,12438,1,3,0)
Foundations Management menu which provides configuration and management
"KRN",19,12438,1,4,0)
for VistALink Listeners.
"KRN",19,12438,1,5,0)
 
"KRN",19,12438,1,6,0)
The Foundations Management submenu is located on the Operations
"KRN",19,12438,1,7,0)
Management menu.
"KRN",19,12438,20)
DO EN^XOBUM
"KRN",19,12438,99)
59242,48154
"KRN",19,12438,99.1)
59336,42464
"KRN",19,12438,"U")
FOUNDATIONS MANAGEMENT
"KRN",101,4971,-1)
0^4
"KRN",101,4971,0)
XOBU SITE PARAMETERS^Site Parameters^^A^^^^^^^^FOUNDATIONS
"KRN",101,4971,1,0)
^^3^3^3030410^
"KRN",101,4971,1,1,0)
This action protocol will add/edit an entry in the VISTALINK SITE
"KRN",101,4971,1,2,0)
PARAMETERS file (#18.01) by invoking the XOBU SITE PARAMETERS input
"KRN",101,4971,1,3,0)
template.
"KRN",101,4971,20)
DO PARMS^XOBUM
"KRN",101,4971,99)
59263,43463
"KRN",101,4974,-1)
0^2
"KRN",101,4974,0)
XOBU FOUNDATIONS MAIN REFRESH^Refresh^^A^^^^^^^^FOUNDATIONS
"KRN",101,4974,1,0)
^^3^3^3030410^
"KRN",101,4974,1,1,0)
This action protocol will refresh and redisplay the current Foundations
"KRN",101,4974,1,2,0)
Management screen.  This is useful when checking the current status of
"KRN",101,4974,1,3,0)
a VistALink Listener.
"KRN",101,4974,20)
DO REFRESH^XOBUM
"KRN",101,4974,99)
59263,43463
"KRN",101,4975,-1)
0^3
"KRN",101,4975,0)
XOBU FOUNDATIONS SYSTEM STATUS^System Status^^A^^^^^^^^FOUNDATIONS
"KRN",101,4975,1,0)
^^1^1^3030410^
"KRN",101,4975,1,1,0)
This action protocol will display the M operating system status.
"KRN",101,4975,20)
DO SS^XOBUM
"KRN",101,4975,99)
59263,43463
"KRN",101,5016,-1)
0^1
"KRN",101,5016,0)
XOBU FOUNDATIONS MAIN MENU^Foundations Manager Menu^^M^^^^^^^^FOUNDATIONS
"KRN",101,5016,1,0)
^101.06^3^3^3080403^^
"KRN",101,5016,1,1,0)
This menu contains all the action protocols for the Foundations
"KRN",101,5016,1,2,0)
Management menu [XOBV SITE SETUP MENU] which is used to configure and
"KRN",101,5016,1,3,0)
manage VistALink Listeners.
"KRN",101,5016,4)
40^4
"KRN",101,5016,10,0)
^101.01PA^10^10
"KRN",101,5016,10,1,0)
4971^SP^11^
"KRN",101,5016,10,1,"^")
XOBU SITE PARAMETERS
"KRN",101,5016,10,5,0)
4974^RE^14^
"KRN",101,5016,10,5,"^")
XOBU FOUNDATIONS MAIN REFRESH
"KRN",101,5016,10,7,0)
5017^CM^15^
"KRN",101,5016,10,7,"^")
XOBU TERMINATE CONNECTION MANAGER
"KRN",101,5016,24)
I 1 X:$D(^ORD(101,+$P(^ORD(101,DA(1),10,DA,0),"^",1),24)) ^(24)
"KRN",101,5016,26)
D SHOW^VALM
"KRN",101,5016,28)
Select Action:
"KRN",101,5016,99)
61088,59694
"KRN",101,5017,-1)
0^16
"KRN",101,5017,0)
XOBU TERMINATE CONNECTION MANAGER^Connection Manager^^A^^^^^^^^FOUNDATIONS
"KRN",101,5017,15)
SET VALMBCK="R"
"KRN",101,5017,20)
DO VLEN^XOBUZAP1
"KRN",101,5017,99)
61088,45489
"KRN",101,5018,-1)
0^13
"KRN",101,5018,0)
XOBU TERMINATE ALL JOBS^Terminate All^^A^^^^^^^^FOUNDATIONS
"KRN",101,5018,1,0)
^^1^1^3080402^
"KRN",101,5018,1,1,0)
Allows user to terminated all the Cache jobs in the list.
"KRN",101,5018,20)
DO TERMALL^XOBUZAP
"KRN",101,5018,24)
IF $$CACHE^XOBUZAP()
"KRN",101,5018,99)
61088,45616
"KRN",101,5019,-1)
0^12
"KRN",101,5019,0)
XOBU TERMINATE A JOB^Terminate PID^^A^^^^^^^^FOUNDATIONS
"KRN",101,5019,1,0)
^^1^1^3080402^
"KRN",101,5019,1,1,0)
Allows user to terminated one Cache job from the list.
"KRN",101,5019,20)
DO TERMPID^XOBUZAP
"KRN",101,5019,24)
IF $$CACHE^XOBUZAP()
"KRN",101,5019,99)
61088,45725
"KRN",101,5020,-1)
0^17
"KRN",101,5020,0)
XOBU TERMINATE SYSTEM STATUS^System Status^^A^^^^^^^^FOUNDATIONS
"KRN",101,5020,1,0)
^^1^1^3080402^
"KRN",101,5020,1,1,0)
This action protocol will display the M operating system status.
"KRN",101,5020,20)
DO SS^XOBUZAP
"KRN",101,5020,99)
61088,45844
"KRN",101,5021,-1)
0^14
"KRN",101,5021,0)
XOBU TERMINATE JOBS REFRESH^Refresh^^A^^^^^^^^FOUNDATIONS
"KRN",101,5021,1,0)
^^3^3^3080402^
"KRN",101,5021,1,1,0)
Allows user to refresh the list to remove jobs that have been terminated
"KRN",101,5021,1,2,0)
using other actions and to build list from the most current Cache job
"KRN",101,5021,1,3,0)
list.
"KRN",101,5021,20)
DO REFRESH^XOBUZAP
"KRN",101,5021,99)
61088,45905
"KRN",101,5022,-1)
0^15
"KRN",101,5022,0)
XOBU TERMINATE JOBS UTILITY MENU^Terminate Jobs Utility^^M^^^^^^^^FOUNDATIONS
"KRN",101,5022,1,0)
^^35^35^3080402^
"KRN",101,5022,1,1,0)
This general purpose tool helps sites terminate Cache jobs in a specified
"KRN",101,5022,1,2,0)
state and routine.
"KRN",101,5022,1,3,0)
 
"KRN",101,5022,1,4,0)
The immediate use for the utility is help sites terminate socket 
"KRN",101,5022,1,5,0)
connections for VistALink and Broker. It would be used during VistALink
"KRN",101,5022,1,6,0)
and Broker upgrades to safely terminate connection jobs in a 'READ' state.
"KRN",101,5022,1,7,0)
 
"KRN",101,5022,1,8,0)
It is up to these applications to supply the necessary option that 
"KRN",101,5022,1,9,0)
accesses this utility. They must specific the job selection criteria to
"KRN",101,5022,1,10,0)
the utility before the utility can display the jobs that meet the
"KRN",101,5022,1,11,0)
criteria.
"KRN",101,5022,1,12,0)
 
"KRN",101,5022,1,13,0)
For example, for VistALink the code that executes the utility is the
"KRN",101,5022,1,14,0)
following:
"KRN",101,5022,1,15,0)
 
"KRN",101,5022,1,16,0)
VL ; -- entry point for VistALink socket job cleanup
"KRN",101,5022,1,17,0)
 NEW XOBSEL
"KRN",101,5022,1,18,0)
 DO VLSEL(.XOBSEL)
"KRN",101,5022,1,19,0)
 DO EN^XOBUZAP(.XOBSEL)
"KRN",101,5022,1,20,0)
 QUIT
"KRN",101,5022,1,21,0)
 ;
"KRN",101,5022,1,22,0)
VLSEL(XOBSEL) ; -- setup VistALink connection socket job selection
"KRN",101,5022,1,23,0)
              ;    criteria
"KRN",101,5022,1,24,0)
 ; -- routine name the job should be executing
"KRN",101,5022,1,25,0)
 SET XOBSEL("ROUTINE")="XOBVSKT"
"KRN",101,5022,1,26,0)
 ; -- state the routine should be in
"KRN",101,5022,1,27,0)
 ;    A list of valid jobs sates can be found at STATE^XOBUZAP / 5 = READ
"KRN",101,5022,1,28,0)
 SET XOBSEL("STATE")=5
"KRN",101,5022,1,29,0)
 ; -- optional title to be used by ListManager
"KRN",101,5022,1,30,0)
 SET XOBSEL("TITLE")="VL/J2M Connection Terminator"
"KRN",101,5022,1,31,0)
 QUIT
"KRN",101,5022,1,32,0)
 ;
"KRN",101,5022,1,33,0)
 
"KRN",101,5022,1,34,0)
Cluster Note: The utility must be run in the namespace on each box in a
"KRN",101,5022,1,35,0)
cluster.
"KRN",101,5022,4)
40^4
"KRN",101,5022,10,0)
^101.01PA^4^4
"KRN",101,5022,10,1,0)
5018^TA^1^
"KRN",101,5022,10,1,"^")
XOBU TERMINATE ALL JOBS
"KRN",101,5022,10,2,0)
5019^TP^2^
"KRN",101,5022,10,2,"^")
XOBU TERMINATE A JOB
"KRN",101,5022,10,3,0)
5020^SS^4^
"KRN",101,5022,10,3,"^")
XOBU TERMINATE SYSTEM STATUS
"KRN",101,5022,10,4,0)
5021^RE^3^
"KRN",101,5022,10,4,"^")
XOBU TERMINATE JOBS REFRESH
"KRN",101,5022,24)
I 1 X:$D(^ORD(101,+$P(^ORD(101,DA(1),10,DA,0),"^",1),24)) ^(24)
"KRN",101,5022,26)
DO SHOW^VALM
"KRN",101,5022,28)
Select Action:
"KRN",101,5022,99)
61088,48691
"KRN",409.61,656,-1)
0^1
"KRN",409.61,656,0)
XOBU FOUNDATIONS MAIN^1^^80^8^17^0^1^Listener^XOBU FOUNDATIONS MAIN MENU^Foundations Manager :: Main^1^^1
"KRN",409.61,656,1)
^VALM HIDDEN ACTIONS
"KRN",409.61,656,"ARRAY")
 ^TMP("XOB LISTENERS",$J)
"KRN",409.61,656,"COL",0)
^409.621^6^6
"KRN",409.61,656,"COL",1,0)
ID^3^2^ID
"KRN",409.61,656,"COL",2,0)
BOX^7^15^Box-Volume
"KRN",409.61,656,"COL",3,0)
PORT^25^5^Port
"KRN",409.61,656,"COL",4,0)
STATUS^32^10^Status
"KRN",409.61,656,"COL",5,0)
CONFIG^65^14^Configuration
"KRN",409.61,656,"COL",6,0)
DATE^45^18^Status Date/Time
"KRN",409.61,656,"COL","B","BOX",2)

"KRN",409.61,656,"COL","B","CONFIG",5)

"KRN",409.61,656,"COL","B","DATE",6)

"KRN",409.61,656,"COL","B","ID",1)

"KRN",409.61,656,"COL","B","PORT",3)

"KRN",409.61,656,"COL","B","STATUS",4)

"KRN",409.61,656,"FNL")
DO EXIT^XOBUM
"KRN",409.61,656,"HDR")
DO HDR^XOBUM
"KRN",409.61,656,"HLP")
DO HELP^XOBUM
"KRN",409.61,656,"INIT")
DO INIT^XOBUM
"KRN",409.61,659,-1)
0^2
"KRN",409.61,659,0)
XOBU TERMINATE JOBS UTILITY^1^^80^8^20^0^1^Job Entry^XOBU TERMINATE JOBS UTILITY MENU^Terminate Jobs Utility (TJU)^1^^1
"KRN",409.61,659,1)
^VALM HIDDEN ACTIONS
"KRN",409.61,659,"ARRAY")
 ^TMP("XOB TERMINATE JOBS",$J)
"KRN",409.61,659,"COL",0)
^409.621^4^4
"KRN",409.61,659,"COL",1,0)
ENTRY^2^5^Entry
"KRN",409.61,659,"COL",2,0)
PID^8^12^PID
"KRN",409.61,659,"COL",3,0)
COMMENT^55^25^Comment^H
"KRN",409.61,659,"COL",4,0)
DEVICE^20^34^Device:Client IP
"KRN",409.61,659,"COL","B","COMMENT",3)

"KRN",409.61,659,"COL","B","DEVICE",4)

"KRN",409.61,659,"COL","B","ENTRY",1)

"KRN",409.61,659,"COL","B","PID",2)

"KRN",409.61,659,"FNL")
DO EXIT^XOBUZAP
"KRN",409.61,659,"HDR")
DO HDR^XOBUZAP
"KRN",409.61,659,"HLP")
DO HELP^XOBUZAP
"KRN",409.61,659,"INIT")
DO INIT^XOBUZAP
"MBREQ")
0
"ORD",7,.402)
.402;7;;;EDEOUT^DIFROMSO(.402,DA,"",XPDA);FPRE^DIFROMSI(.402,"",XPDA);EPRE^DIFROMSI(.402,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.402,DA,"",XPDA);DEL^DIFROMSK(.402,"",%)
"ORD",7,.402,0)
INPUT TEMPLATE
"ORD",15,101)
101;15;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"ORD",15,101,0)
PROTOCOL
"ORD",17,409.61)
409.61;17;1;;;;;;;LMDEL^XPDIA1
"ORD",17,409.61,0)
LIST TEMPLATE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",555,-1)
1^1
"PKG",555,0)
FOUNDATIONS^XOBU
"PKG",555,1,0)
^9.41A^5^5^3030919^^
"PKG",555,1,1,0)
Contains common files, libraries, etc. used by all the XOB*
"PKG",555,1,2,0)
packages.  
"PKG",555,1,3,0)
 
"PKG",555,1,4,0)
Also, contains options, protocols and list templates used to
"PKG",555,1,5,0)
manage Foundations site parameters and operations.
"PKG",555,20,0)
^9.402P^^
"PKG",555,22,0)
^9.49I^1^1
"PKG",555,22,1,0)
1.6^3090508
"PKG",555,22,1,1,0)
^^5^5^3090508
"PKG",555,22,1,1,1,0)
This build contains common files, libraries, etc. used by all the XOB* 
"PKG",555,22,1,1,2,0)
packages.
"PKG",555,22,1,1,3,0)
 
"PKG",555,22,1,1,4,0)
It also contains options, protocols and list templates used to manage 
"PKG",555,22,1,1,5,0)
Foundations site parameters and operations.
"PKG",555,"VERSION")
1.6
"PRE")
XOBUENV
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
8
"RTN","XOBUENV")
0^^B95255801
"RTN","XOBUENV",1,0)
XOBUENV ;; ld/alb - VistaLink Environment Check ; 11/15/2007  08:44
"RTN","XOBUENV",2,0)
 ;;1.6;Foundations;;May 08, 2009;Build 15
"RTN","XOBUENV",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBUENV",4,0)
 ;
"RTN","XOBUENV",5,0)
EN ;- entry point
"RTN","XOBUENV",6,0)
 ;
"RTN","XOBUENV",7,0)
 ;- programmer variables check
"RTN","XOBUENV",8,0)
 DO PROG IF $GET(XPDABORT) GOTO ENQ
"RTN","XOBUENV",9,0)
 ;
"RTN","XOBUENV",10,0)
 ;- operating system check
"RTN","XOBUENV",11,0)
 DO OSCHK IF $GET(XPDABORT) GOTO ENQ
"RTN","XOBUENV",12,0)
 ;
"RTN","XOBUENV",13,0)
 ;- check for presence of obsolete SYSTEM file (#18)
"RTN","XOBUENV",14,0)
 DO FILE18
"RTN","XOBUENV",15,0)
 ;
"RTN","XOBUENV",16,0)
 ;- load check
"RTN","XOBUENV",17,0)
 S XPDENV=$G(XPDENV),XPDABORT=$G(XPDABORT)
"RTN","XOBUENV",18,0)
 ;
"RTN","XOBUENV",19,0)
 IF 'XPDENV,'XPDABORT WRITE !!?1,">>> VistALink environment check completed for KIDS Load a Distribution option.",!
"RTN","XOBUENV",20,0)
 ;
"RTN","XOBUENV",21,0)
 ;- install check
"RTN","XOBUENV",22,0)
 I XPDENV=1 D
"RTN","XOBUENV",23,0)
 . ;- check that listeners were stopped before package installation continues
"RTN","XOBUENV",24,0)
 . S:$$STPLSTNR()<1 XPDABORT=2
"RTN","XOBUENV",25,0)
 . I 'XPDABORT WRITE !!?1,">>> VistALink environment check completed for KIDS Install Package option.",!
"RTN","XOBUENV",26,0)
 ;
"RTN","XOBUENV",27,0)
 ;IF XPDENV=1,'XPDABORT WRITE !!?1,">>> VistALink environment check completed for KIDS Install Package option.",!
"RTN","XOBUENV",28,0)
 ;
"RTN","XOBUENV",29,0)
ENQ QUIT
"RTN","XOBUENV",30,0)
 ;
"RTN","XOBUENV",31,0)
PROG ;- check environment for programmer variables
"RTN","XOBUENV",32,0)
 ;
"RTN","XOBUENV",33,0)
 WRITE !?1,">>> Performing environment check...",!
"RTN","XOBUENV",34,0)
 IF +$GET(DUZ)'>0!($GET(DUZ(0))'="@") DO
"RTN","XOBUENV",35,0)
 . SET XPDABORT=1
"RTN","XOBUENV",36,0)
 . WRITE !,"     Programmer environment variables have not been correctly defined.",!
"RTN","XOBUENV",37,0)
 QUIT
"RTN","XOBUENV",38,0)
 ;
"RTN","XOBUENV",39,0)
OSCHK ;- check environment for operating system (DSM or OpenM)
"RTN","XOBUENV",40,0)
 ;
"RTN","XOBUENV",41,0)
 NEW XOBOS
"RTN","XOBUENV",42,0)
 SET XOBOS=$PIECE($GET(^%ZOSF("OS")),"^")
"RTN","XOBUENV",43,0)
 IF XOBOS'["DSM"&(XOBOS'["OpenM")&(XOBOS'["GT.M") DO
"RTN","XOBUENV",44,0)
 . SET XPDABORT=1
"RTN","XOBUENV",45,0)
 . DO PRNTXT("OSMSG")
"RTN","XOBUENV",46,0)
 QUIT
"RTN","XOBUENV",47,0)
 ;
"RTN","XOBUENV",48,0)
STPLSTNR() ;- ask if all listeners are stopped prior to installing package
"RTN","XOBUENV",49,0)
 ;
"RTN","XOBUENV",50,0)
 NEW XOB0,XOBA,XOBARR,XOBB,XOBHLP,XOBHARR
"RTN","XOBUENV",51,0)
 ;
"RTN","XOBUENV",52,0)
 ;- set DIR variables
"RTN","XOBUENV",53,0)
 SET XOB0="YAO"
"RTN","XOBUENV",54,0)
 SET XOBA=" Have all VistALink listeners been stopped? "
"RTN","XOBUENV",55,0)
 SET XOBB="NO"
"RTN","XOBUENV",56,0)
 S XOBHLP=" transport globals."
"RTN","XOBUENV",57,0)
 ;
"RTN","XOBUENV",58,0)
 ;- set DIR("A",#) array
"RTN","XOBUENV",59,0)
 D SETARRAY("DIRARR","XOBARR")
"RTN","XOBUENV",60,0)
 ;
"RTN","XOBUENV",61,0)
 ;- set DIR("?",#) array
"RTN","XOBUENV",62,0)
 D SETARRAY("DIRHARR","XOBHARR")
"RTN","XOBUENV",63,0)
 QUIT $$ANSWER(XOB0,XOBA,XOBB,.XOBARR,XOBHLP,.XOBHARR)
"RTN","XOBUENV",64,0)
 ;
"RTN","XOBUENV",65,0)
SETARRAY(LINETAG,XOBARRY) ;-
"RTN","XOBUENV",66,0)
 Q:$G(LINETAG)=""!($G(XOBARRY))=""
"RTN","XOBUENV",67,0)
 NEW I,LINE
"RTN","XOBUENV",68,0)
 FOR I=1:1 SET LINE=$PIECE($TEXT(@LINETAG+I),";;",2) QUIT:LINE="$END"  S @XOBARRY@(I)=LINE
"RTN","XOBUENV",69,0)
 QUIT
"RTN","XOBUENV",70,0)
 ;
"RTN","XOBUENV",71,0)
FILE18 ;- check for obsolete Kernel file #18 which is in VistALink's numberspace
"RTN","XOBUENV",72,0)
 ;
"RTN","XOBUENV",73,0)
 NEW I,LINE,XOBABORT,XOBASK
"RTN","XOBUENV",74,0)
 ;
"RTN","XOBUENV",75,0)
 ;- file #18 not found
"RTN","XOBUENV",76,0)
 IF '$$FILECHK() GOTO FILE18Q
"RTN","XOBUENV",77,0)
 ;
"RTN","XOBUENV",78,0)
 ;- file found; display user msg
"RTN","XOBUENV",79,0)
 DO PRNTXT("INTRO")
"RTN","XOBUENV",80,0)
 ;
"RTN","XOBUENV",81,0)
 ;- if load, ask if they want file deletion instructions
"RTN","XOBUENV",82,0)
 IF 'XPDENV DO  GOTO FILE18Q
"RTN","XOBUENV",83,0)
 . DO:$$ASKINSTR()>0 TOP,PRNTXT("INSTR1"),PAUSE,PRNTXT("INSTR2"),PAUSE
"RTN","XOBUENV",84,0)
 ;
"RTN","XOBUENV",85,0)
 ;- if install, ask if user wants to abort install
"RTN","XOBUENV",86,0)
 ;- if yes, ask if they want file deletion instructions
"RTN","XOBUENV",87,0)
 SET XOBABORT=$$ASKINSTL()
"RTN","XOBUENV",88,0)
 IF XOBABORT DO  QUIT
"RTN","XOBUENV",89,0)
 . IF XOBABORT=1 DO:$$ASKINSTR()>0 TOP,PRNTXT("INSTR1"),PAUSE,PRNTXT("INSTR2"),PAUSE
"RTN","XOBUENV",90,0)
 . SET XPDABORT=2
"RTN","XOBUENV",91,0)
 ;
"RTN","XOBUENV",92,0)
 ;- if user wants to continue install, ask again to be sure
"RTN","XOBUENV",93,0)
 IF XOBABORT=0 DO
"RTN","XOBUENV",94,0)
 . SET XOBASK=$$REASK()
"RTN","XOBUENV",95,0)
 . IF XOBASK<1 DO
"RTN","XOBUENV",96,0)
 .. IF XOBASK=0 DO:$$ASKINSTR()>0 TOP,PRNTXT("INSTR1"),PAUSE,PRNTXT("INSTR2"),PAUSE
"RTN","XOBUENV",97,0)
 .. SET XPDABORT=2
"RTN","XOBUENV",98,0)
FILE18Q QUIT
"RTN","XOBUENV",99,0)
 ;
"RTN","XOBUENV",100,0)
ASKINSTL() ;- ask if user wants to abort install
"RTN","XOBUENV",101,0)
 ;
"RTN","XOBUENV",102,0)
 NEW XOB0,XOBA,XOBARR,XOBB
"RTN","XOBUENV",103,0)
 SET XOB0="YAO"
"RTN","XOBUENV",104,0)
 SET XOBA=" Do you want to abort the installation now? "
"RTN","XOBUENV",105,0)
 SET XOBB="YES"
"RTN","XOBUENV",106,0)
 SET XOBARR(1)="     NOTE:"
"RTN","XOBUENV",107,0)
 SET XOBARR(2)="       If you choose to abort the installation, please do a global listing"
"RTN","XOBUENV",108,0)
 SET XOBARR(3)="       of file ^DIC(18, and ^DD(18, after deleting the file to ensure that"
"RTN","XOBUENV",109,0)
 SET XOBARR(4)="       the SYSTEM file (#18) is completely deleted from your system before"
"RTN","XOBUENV",110,0)
 SET XOBARR(5)="       reinstalling the VistALink package.  If you need additional help"
"RTN","XOBUENV",111,0)
 SET XOBARR(6)="       deleting the file, please contact National VistA Support (NVS)."
"RTN","XOBUENV",112,0)
 SET XOBARR(7)=" "
"RTN","XOBUENV",113,0)
 QUIT $$ANSWER(XOB0,XOBA,XOBB,.XOBARR)
"RTN","XOBUENV",114,0)
 ;
"RTN","XOBUENV",115,0)
REASK() ;- ask user again if they want to continue with install (pre-init will
"RTN","XOBUENV",116,0)
 ;         delete file #18)
"RTN","XOBUENV",117,0)
 ;
"RTN","XOBUENV",118,0)
 NEW XOB0,XOBA,XOBARR,XOBB
"RTN","XOBUENV",119,0)
 SET XOB0="YAO"
"RTN","XOBUENV",120,0)
 SET XOBA=" Are you sure you want to continue? "
"RTN","XOBUENV",121,0)
 SET XOBB="NO"
"RTN","XOBUENV",122,0)
 SET XOBARR(1)=" "
"RTN","XOBUENV",123,0)
 SET XOBARR(2)="     NOTE:"
"RTN","XOBUENV",124,0)
 SET XOBARR(3)="       Continuing with the installation will delete the SYSTEM file (#18)"
"RTN","XOBUENV",125,0)
 SET XOBARR(4)="       using the FileMan Data Dictionary Deletion call (EN^DIU2)."
"RTN","XOBUENV",126,0)
 SET XOBARR(5)=" "
"RTN","XOBUENV",127,0)
 QUIT $$ANSWER(XOB0,XOBA,XOBB,.XOBARR)
"RTN","XOBUENV",128,0)
 ;
"RTN","XOBUENV",129,0)
ASKINSTR() ;- ask if user wants file deletion instructions
"RTN","XOBUENV",130,0)
 ;
"RTN","XOBUENV",131,0)
 NEW XOB0,XOBA,XOBARR,XOBB
"RTN","XOBUENV",132,0)
 SET XOB0="YAO"
"RTN","XOBUENV",133,0)
 SET XOBA=" Would you like instructions on how to delete SYSTEM file (#18)? "
"RTN","XOBUENV",134,0)
 SET XOBB="YES"
"RTN","XOBUENV",135,0)
 SET XOBARR(1)=" "
"RTN","XOBUENV",136,0)
 QUIT $$ANSWER(XOB0,XOBA,XOBB,.XOBARR)
"RTN","XOBUENV",137,0)
 ;
"RTN","XOBUENV",138,0)
ANSWER(XOB0,XOBA,XOBB,XOBARR,XOBHLP,XOBHARR) ;wrap FileMan DIR call
"RTN","XOBUENV",139,0)
 ;
"RTN","XOBUENV",140,0)
 ;  Input:
"RTN","XOBUENV",141,0)
 ;    XOB0    - DIR(0) string
"RTN","XOBUENV",142,0)
 ;    XOBA    - DIR("A") string
"RTN","XOBUENV",143,0)
 ;    XOBB    - DIR("B") string
"RTN","XOBUENV",144,0)
 ;    XOBARR  - DIR("A",#) string
"RTN","XOBUENV",145,0)
 ;    XOBHLP  - DIR("?") string
"RTN","XOBUENV",146,0)
 ;    XOBHARR - DIR("?",#) string
"RTN","XOBUENV",147,0)
 ;
"RTN","XOBUENV",148,0)
 ;  Output:
"RTN","XOBUENV",149,0)
 ;   Function Value - Internal value returned from ^DIR (0 for No, 1 for
"RTN","XOBUENV",150,0)
 ;                    YES) or -1 if user up-arrows or the read times out.
"RTN","XOBUENV",151,0)
 ;
"RTN","XOBUENV",152,0)
 NEW DIR,DIRUT,X,Y  ; ^DIR variables
"RTN","XOBUENV",153,0)
 ;
"RTN","XOBUENV",154,0)
 SET DIR(0)=XOB0
"RTN","XOBUENV",155,0)
 SET DIR("A")=$GET(XOBA)
"RTN","XOBUENV",156,0)
 IF $DATA(XOBARR)>1 MERGE DIR("A")=XOBARR
"RTN","XOBUENV",157,0)
 IF $GET(XOBB)'="" SET DIR("B")=XOBB
"RTN","XOBUENV",158,0)
 IF $G(XOBHLP)'="" S DIR("?")=XOBHLP
"RTN","XOBUENV",159,0)
 I $D(XOBHARR)>1 M DIR("?")=XOBHARR
"RTN","XOBUENV",160,0)
 DO ^DIR KILL DIR
"RTN","XOBUENV",161,0)
 QUIT $SELECT($DATA(DIRUT):-1,1:$PIECE(Y,U))
"RTN","XOBUENV",162,0)
 ;
"RTN","XOBUENV",163,0)
FILECHK() ;- check for file 18
"RTN","XOBUENV",164,0)
 ;
"RTN","XOBUENV",165,0)
 NEW XOBA,XOBFIL
"RTN","XOBUENV",166,0)
 SET XOBA=0
"RTN","XOBUENV",167,0)
 DO FILE^DID(18,"","NAME","XOBFIL")
"RTN","XOBUENV",168,0)
 IF $GET(XOBFIL("NAME"))="SYSTEM",($$VFILE^DILFD(18)) SET XOBA=1
"RTN","XOBUENV",169,0)
 IF $DATA(^DIC(18))!$DATA(^DD(18)) SET XOBA=1
"RTN","XOBUENV",170,0)
 QUIT XOBA
"RTN","XOBUENV",171,0)
 ;
"RTN","XOBUENV",172,0)
PRNTXT(TEXT) ;- display user text
"RTN","XOBUENV",173,0)
 ;
"RTN","XOBUENV",174,0)
 QUIT:$GET(TEXT)=""
"RTN","XOBUENV",175,0)
 NEW I,LINE
"RTN","XOBUENV",176,0)
 FOR I=1:1 SET LINE=$PIECE($TEXT(@TEXT+I),";;",2) QUIT:LINE="$END"  WRITE !,LINE
"RTN","XOBUENV",177,0)
 QUIT
"RTN","XOBUENV",178,0)
 ;
"RTN","XOBUENV",179,0)
TOP ;- top of screen
"RTN","XOBUENV",180,0)
 ;
"RTN","XOBUENV",181,0)
 QUIT:$EXTRACT(IOST,1,2)'="C-"
"RTN","XOBUENV",182,0)
 IF $Y>1 WRITE @IOF
"RTN","XOBUENV",183,0)
 QUIT
"RTN","XOBUENV",184,0)
 ;
"RTN","XOBUENV",185,0)
PAUSE ;- enhance readability of text
"RTN","XOBUENV",186,0)
 ;
"RTN","XOBUENV",187,0)
 QUIT:$EXTRACT(IOST,1,2)'="C-"
"RTN","XOBUENV",188,0)
 WRITE ! SET DIR(0)="E",DIR("A")="Press return to continue" DO ^DIR KILL DIR WRITE !
"RTN","XOBUENV",189,0)
 QUIT
"RTN","XOBUENV",190,0)
 ;
"RTN","XOBUENV",191,0)
INTRO ;- display message to user explaining file #18
"RTN","XOBUENV",192,0)
 ;; >>>>>>>>>> ATTENTION: File SYSTEM (#18) was found on your system. <<<<<<<<<<
"RTN","XOBUENV",193,0)
 ;;     
"RTN","XOBUENV",194,0)
 ;;     SYSTEM file #18 was the precursor to the KERNEL SYSTEMS PARAMETER
"RTN","XOBUENV",195,0)
 ;;     file and is obsolete.  The SYSTEM file uses the same numberspace
"RTN","XOBUENV",196,0)
 ;;     that VistALink is assigned and must be deleted before VistALink
"RTN","XOBUENV",197,0)
 ;;     can be installed.  You may wish to manually backup and manually
"RTN","XOBUENV",198,0)
 ;;     delete file #18.
"RTN","XOBUENV",199,0)
 ;;     
"RTN","XOBUENV",200,0)
 ;;     If you do not manually delete file #18 and it is still on your system
"RTN","XOBUENV",201,0)
 ;;     during the installation phase, you will be prompted with a series of
"RTN","XOBUENV",202,0)
 ;;     questions.  The questions will allow you to abort the installation or
"RTN","XOBUENV",203,0)
 ;;     allow the installation to safely delete the SYSTEM file for you.
"RTN","XOBUENV",204,0)
 ;;     
"RTN","XOBUENV",205,0)
 ;;$END
"RTN","XOBUENV",206,0)
 ;
"RTN","XOBUENV",207,0)
INSTR1 ;- user instructions to delete file #18
"RTN","XOBUENV",208,0)
 ;;
"RTN","XOBUENV",209,0)
 ;;
"RTN","XOBUENV",210,0)
 ;;     ********      How to delete the SYSTEM file (#18)     ********
"RTN","XOBUENV",211,0)
 ;;
"RTN","XOBUENV",212,0)
 ;;
"RTN","XOBUENV",213,0)
 ;;     1)  From the programmer prompt, go to the FileMan main menu
"RTN","XOBUENV",214,0)
 ;;
"RTN","XOBUENV",215,0)
 ;;     2)  Choose option 6, UTILITY FUNCTIONS
"RTN","XOBUENV",216,0)
 ;;
"RTN","XOBUENV",217,0)
 ;;     3)  Choose option 6, EDIT FILE
"RTN","XOBUENV",218,0)
 ;;
"RTN","XOBUENV",219,0)
 ;;     4)  MODIFY WHAT FILE: // 18  SYSTEM
"RTN","XOBUENV",220,0)
 ;;
"RTN","XOBUENV",221,0)
 ;;     5)  Do you want to use the screen-mode version? YES// YES
"RTN","XOBUENV",222,0)
 ;;         (recommend using screen-mode because you can exit out without
"RTN","XOBUENV",223,0)
 ;;         saving your changes if necessary)
"RTN","XOBUENV",224,0)
 ;;
"RTN","XOBUENV",225,0)
 ;;     6)  At the FILE NAME: prompt (which should have the name SYSTEM
"RTN","XOBUENV",226,0)
 ;;         in it), type @
"RTN","XOBUENV",227,0)
 ;;$END
"RTN","XOBUENV",228,0)
 ;
"RTN","XOBUENV",229,0)
INSTR2 ;- user instructions to delete file #18 (continued)
"RTN","XOBUENV",230,0)
 ;;
"RTN","XOBUENV",231,0)
 ;;
"RTN","XOBUENV",232,0)
 ;;     7)  It will then ask the following questions:
"RTN","XOBUENV",233,0)
 ;;           DO YOU WANT JUST TO DELETE THE FILE CONTENTS,
"RTN","XOBUENV",234,0)
 ;;                    & KEEP THE FILE DEFINITION? No// No   (No)
"RTN","XOBUENV",235,0)
 ;;              IS IT OK TO DELETE THE '^DIC(18)' GLOBAL? Yes// Yes   (Yes)
"RTN","XOBUENV",236,0)
 ;;                  SURE YOU WANT TO DELETE THE ENTIRE FILE? No// Yes  (Yes)
"RTN","XOBUENV",237,0)
 ;;           Deleting the DATA DICTIONARY...
"RTN","XOBUENV",238,0)
 ;;           Deleting the INPUT TEMPLATES....
"RTN","XOBUENV",239,0)
 ;;           Deleting the PRINT TEMPLATES...
"RTN","XOBUENV",240,0)
 ;;           Deleting the SORT TEMPLATES...
"RTN","XOBUENV",241,0)
 ;;           Deleting the FORMS...
"RTN","XOBUENV",242,0)
 ;;
"RTN","XOBUENV",243,0)
 ;;     8)  The last step is a global listing to check that file #18 and its DD
"RTN","XOBUENV",244,0)
 ;;         have been deleted.  Here's an example:
"RTN","XOBUENV",245,0)
 ;;           cor> D ^%G
"RTN","XOBUENV",246,0)
 ;;           Global ^DIC(18,
"RTN","XOBUENV",247,0)
 ;;           DIC(18,
"RTN","XOBUENV",248,0)
 ;;           Global ^DD(18,
"RTN","XOBUENV",249,0)
 ;;           DD(18,
"RTN","XOBUENV",250,0)
 ;;           Global ^
"RTN","XOBUENV",251,0)
 ;;$END
"RTN","XOBUENV",252,0)
 ;
"RTN","XOBUENV",253,0)
OSMSG ;- message to user if operating system is not Cache or DSM
"RTN","XOBUENV",254,0)
 ;;
"RTN","XOBUENV",255,0)
 ;;     VistALink has been tested on Cache and DSM. It has not been tested
"RTN","XOBUENV",256,0)
 ;;     or programmed to be compatible yet on other M implementations, 
"RTN","XOBUENV",257,0)
 ;;     therefore installation will abort.
"RTN","XOBUENV",258,0)
 ;;     
"RTN","XOBUENV",259,0)
 ;;$END
"RTN","XOBUENV",260,0)
 ;
"RTN","XOBUENV",261,0)
DIRARR ;- DIR array text
"RTN","XOBUENV",262,0)
 ;; 
"RTN","XOBUENV",263,0)
 ;; All running VistALink listeners should be stopped before proceeding with
"RTN","XOBUENV",264,0)
 ;; this installation. Enter ? for help on stopping VistALink listeners.
"RTN","XOBUENV",265,0)
 ;; 
"RTN","XOBUENV",266,0)
 ;;$END
"RTN","XOBUENV",267,0)
 ;
"RTN","XOBUENV",268,0)
DIRHARR ;-DIR help array text
"RTN","XOBUENV",269,0)
 ;; If VistALink listeners were started using the Foundations Management menu
"RTN","XOBUENV",270,0)
 ;; [XOBU SITE SETUP MENU], stop listeners using the STP Stop Listener action
"RTN","XOBUENV",271,0)
 ;; within the menu.
"RTN","XOBUENV",272,0)
 ;; 
"RTN","XOBUENV",273,0)
 ;; If VistALink listeners were started using TCPIP Services within the VMS
"RTN","XOBUENV",274,0)
 ;; operating system, use the TCPIP utility within VMS or contact your site
"RTN","XOBUENV",275,0)
 ;; manager to stop the listeners.
"RTN","XOBUENV",276,0)
 ;; 
"RTN","XOBUENV",277,0)
 ;; Answering 'NO' to this question will abort the installation but leave the
"RTN","XOBUENV",278,0)
 ;;$END
"RTN","XOBUENV",279,0)
 ;
"RTN","XOBUM")
0^1^B36328580
"RTN","XOBUM",1,0)
XOBUM ;; ld,mjk/alb - Foundations Manager ; 07/27/2002  13:00
"RTN","XOBUM",2,0)
 ;;1.6;Foundations;;May 08, 2009;Build 15
"RTN","XOBUM",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBUM",4,0)
 ;
"RTN","XOBUM",5,0)
EN ; -- main entry point for XOBU FOUNDATIONS MAIN ListMan Template
"RTN","XOBUM",6,0)
 ; Option: XOBU SITE SETUP MENU on Operations Management menu [XUSITEMGR]
"RTN","XOBUM",7,0)
 ;
"RTN","XOBUM",8,0)
 DO EN^VALM("XOBU FOUNDATIONS MAIN")
"RTN","XOBUM",9,0)
 QUIT
"RTN","XOBUM",10,0)
 ;
"RTN","XOBUM",11,0)
HDR ; -- header code
"RTN","XOBUM",12,0)
 NEW Y,X
"RTN","XOBUM",13,0)
 SET Y=$GET(^XOB(18.01,1,0))
"RTN","XOBUM",14,0)
 SET VALMHDR(1)="                    <<<      VistALink Parameters     >>>"
"RTN","XOBUM",15,0)
 SET VALMHDR(2)=""
"RTN","XOBUM",16,0)
 SET X="    "
"RTN","XOBUM",17,0)
 SET X=X_"VistALink Version: "_$PIECE($TEXT(XOBUM+1),";",3)
"RTN","XOBUM",18,0)
 SET X=X_"    "
"RTN","XOBUM",19,0)
 SET X=X_"Heartbeat Rate: "_$PIECE(Y,U,2)
"RTN","XOBUM",20,0)
 SET X=X_"    "
"RTN","XOBUM",21,0)
 SET X=X_"Latency Delta: "_$PIECE(Y,U,3)
"RTN","XOBUM",22,0)
 SET VALMHDR(3)=X
"RTN","XOBUM",23,0)
 SET VALMHDR(4)=""
"RTN","XOBUM",24,0)
 SET VALMHDR(5)="                    <<< VistALink Listener Status Log >>>"
"RTN","XOBUM",25,0)
 QUIT
"RTN","XOBUM",26,0)
 ;
"RTN","XOBUM",27,0)
INIT ; -- init variables and list array
"RTN","XOBUM",28,0)
 DO CLEAR
"RTN","XOBUM",29,0)
 QUIT
"RTN","XOBUM",30,0)
 ;
"RTN","XOBUM",31,0)
BUILD ; -- init variables and list array
"RTN","XOBUM",32,0)
 NEW I,XOBI,XOB0,X,XOBDATA,XOBOS,XOBROOT,XOBTXT
"RTN","XOBUM",33,0)
 DO KILL
"RTN","XOBUM",34,0)
 ;
"RTN","XOBUM",35,0)
 SET VALMCNT=0
"RTN","XOBUM",36,0)
 SET XOBROOT=$NAME(XOBDATA("DILIST","ID"))
"RTN","XOBUM",37,0)
 DO LIST^DIC(18.04,"",".01;.02;.03;.04;.05;.06","","","","","","","",$NAME(XOBDATA))
"RTN","XOBUM",38,0)
 SET XOBI=0
"RTN","XOBUM",39,0)
 FOR  SET XOBI=$ORDER(@XOBROOT@(XOBI)) QUIT:'XOBI  DO
"RTN","XOBUM",40,0)
 . SET VALMCNT=VALMCNT+1
"RTN","XOBUM",41,0)
 . SET X=""
"RTN","XOBUM",42,0)
 . SET X=$$SETFLD^VALM1(VALMCNT,X,"ID")
"RTN","XOBUM",43,0)
 . SET X=$$SETFLD^VALM1($GET(@XOBROOT@(XOBI,.01)),X,"BOX")
"RTN","XOBUM",44,0)
 . SET X=$$SETFLD^VALM1($GET(@XOBROOT@(XOBI,.02)),X,"PORT")
"RTN","XOBUM",45,0)
 . SET X=$$SETFLD^VALM1($GET(@XOBROOT@(XOBI,.03)),X,"STATUS")
"RTN","XOBUM",46,0)
 . SET X=$$SETFLD^VALM1($GET(@XOBROOT@(XOBI,.05)),X,"DATE")
"RTN","XOBUM",47,0)
 . SET X=$$SETFLD^VALM1($GET(@XOBROOT@(XOBI,.06)),X,"CONFIG")
"RTN","XOBUM",48,0)
 . DO SET^VALM10(VALMCNT,X,VALMCNT)
"RTN","XOBUM",49,0)
 . SET ^TMP("XOB LISTENERS","IDX",$JOB,VALMCNT)=VALMCNT_"^"_+$GET(XOBDATA("DILIST",2,XOBI))
"RTN","XOBUM",50,0)
 ;
"RTN","XOBUM",51,0)
 QUIT:VALMCNT
"RTN","XOBUM",52,0)
 ;
"RTN","XOBUM",53,0)
 ;-- supported Kernel API to get OS version
"RTN","XOBUM",54,0)
 SET XOBOS=$$VERSION^%ZOSV(1)
"RTN","XOBUM",55,0)
 QUIT:XOBOS'["VMS"&(XOBOS'["DSM")
"RTN","XOBUM",56,0)
 SET XOBOS=$SELECT(XOBOS["VMS":"VMS",1:"DSM")
"RTN","XOBUM",57,0)
 ;
"RTN","XOBUM",58,0)
 ;-- display text for VistaLink TCPIP enabled (Cache/VMS or DSM)
"RTN","XOBUM",59,0)
 FOR I=1:1 SET XOBTXT=$PIECE($TEXT(@XOBOS+I),";;",2) QUIT:XOBTXT="$END$"  DO
"RTN","XOBUM",60,0)
 . SET VALMCNT=VALMCNT+1
"RTN","XOBUM",61,0)
 . DO SET^VALM10(VALMCNT,$$SETSTR^VALM1(XOBTXT,"",12,65))
"RTN","XOBUM",62,0)
 QUIT
"RTN","XOBUM",63,0)
 ;
"RTN","XOBUM",64,0)
HELP ; -- help code
"RTN","XOBUM",65,0)
 SET X="?" DO DISP^XQORM1 WRITE !!
"RTN","XOBUM",66,0)
 QUIT
"RTN","XOBUM",67,0)
 ;
"RTN","XOBUM",68,0)
EXIT ; -- exit code
"RTN","XOBUM",69,0)
 DO KILL
"RTN","XOBUM",70,0)
 QUIT
"RTN","XOBUM",71,0)
 ;
"RTN","XOBUM",72,0)
KILL ; -- kill off list location
"RTN","XOBUM",73,0)
 KILL ^TMP("XOB LISTENERS",$JOB)
"RTN","XOBUM",74,0)
 QUIT
"RTN","XOBUM",75,0)
 ;
"RTN","XOBUM",76,0)
EXPND ; -- expand code
"RTN","XOBUM",77,0)
 QUIT
"RTN","XOBUM",78,0)
 ;
"RTN","XOBUM",79,0)
START ; -- start a listener
"RTN","XOBUM",80,0)
 ; -- Protocol: XOBV LISTENER START
"RTN","XOBUM",81,0)
 NEW XOBOK
"RTN","XOBUM",82,0)
 DO FULL^VALM1
"RTN","XOBUM",83,0)
 IF $$START^XOBUM1() DO
"RTN","XOBUM",84,0)
 . SET VALMSG="Refresh to see 'RUNNING' status"
"RTN","XOBUM",85,0)
 ELSE  DO
"RTN","XOBUM",86,0)
 . DO PAUSE^VALM1
"RTN","XOBUM",87,0)
 DO REFRESH
"RTN","XOBUM",88,0)
 QUIT
"RTN","XOBUM",89,0)
 ;
"RTN","XOBUM",90,0)
BOX ; -- start this BOX-VOl default configuration
"RTN","XOBUM",91,0)
 ; -- Protocol: XOBV LISTENER BOX-VOL
"RTN","XOBUM",92,0)
 IF $$BOX^XOBUM1() SET VALMSG="Refresh to see 'RUNNING' status"
"RTN","XOBUM",93,0)
 DO REFRESH
"RTN","XOBUM",94,0)
 QUIT
"RTN","XOBUM",95,0)
 ;
"RTN","XOBUM",96,0)
STOP ; -- stop a listener
"RTN","XOBUM",97,0)
 ; -- Protocol: XOBV LISTENER STOP
"RTN","XOBUM",98,0)
 NEW Y,X,DATA,ENTRY,LOGDA,XOBOK
"RTN","XOBUM",99,0)
 DO FULL^VALM1
"RTN","XOBUM",100,0)
 DO EN^VALM2(XQORNOD(0),"S")
"RTN","XOBUM",101,0)
 SET ENTRY=+$ORDER(VALMY(""))
"RTN","XOBUM",102,0)
 IF 'ENTRY GOTO STOPQ
"RTN","XOBUM",103,0)
 ;
"RTN","XOBUM",104,0)
 SET DATA=$GET(^TMP("XOB LISTENERS","IDX",$JOB,ENTRY))
"RTN","XOBUM",105,0)
 DO SELECT^VALM10(+DATA,1)
"RTN","XOBUM",106,0)
 ;
"RTN","XOBUM",107,0)
 SET LOGDA=+$PIECE(DATA,U,2)
"RTN","XOBUM",108,0)
 SET XOBOK=$$STOP^XOBUM1(LOGDA)
"RTN","XOBUM",109,0)
 IF XOBOK SET VALMSG=">>> Listener may take up to 60 seconds to stop <<<"
"RTN","XOBUM",110,0)
 IF 'XOBOK DO ERROR(XOBOK)
"RTN","XOBUM",111,0)
 DO SELECT^VALM10(+DATA,0)
"RTN","XOBUM",112,0)
 ;
"RTN","XOBUM",113,0)
STOPQ ;
"RTN","XOBUM",114,0)
 DO REFRESH
"RTN","XOBUM",115,0)
 QUIT
"RTN","XOBUM",116,0)
 ;
"RTN","XOBUM",117,0)
PARMS ; -- maintain site parameters
"RTN","XOBUM",118,0)
 ; -- Protocol: XOBU SITE PARAMETERS
"RTN","XOBUM",119,0)
 NEW XOBOK
"RTN","XOBUM",120,0)
 DO FULL^VALM1
"RTN","XOBUM",121,0)
 SET XOBOK=$$PARMS^XOBUM1()
"RTN","XOBUM",122,0)
 IF 'XOBOK DO ERROR(XOBOK)
"RTN","XOBUM",123,0)
 ;
"RTN","XOBUM",124,0)
 ; -- Add users to VISTALINK PERSON file (#18.09)
"RTN","XOBUM",125,0)
 ; SET XOBOK=$$ADDPERS^XOBUM1()
"RTN","XOBUM",126,0)
 ; IF 'XOBOK DO ERROR(XOBOK)
"RTN","XOBUM",127,0)
 ;
"RTN","XOBUM",128,0)
 DO HDR
"RTN","XOBUM",129,0)
 DO REFRESH
"RTN","XOBUM",130,0)
 QUIT
"RTN","XOBUM",131,0)
 ;
"RTN","XOBUM",132,0)
CFG ; -- maintain listener configurations
"RTN","XOBUM",133,0)
 ; -- Protocol: XOBV LISTENER CONFIG
"RTN","XOBUM",134,0)
 NEW XOBOK
"RTN","XOBUM",135,0)
 DO FULL^VALM1
"RTN","XOBUM",136,0)
 SET XOBOK=$$CFG^XOBUM1()
"RTN","XOBUM",137,0)
 IF 'XOBOK DO ERROR(XOBOK)
"RTN","XOBUM",138,0)
 DO REFRESH
"RTN","XOBUM",139,0)
 QUIT
"RTN","XOBUM",140,0)
 ;
"RTN","XOBUM",141,0)
CP ; -- add connector proxy
"RTN","XOBUM",142,0)
 ; -- Protocol: XOBV LISTENER CONNECTOR PROXY
"RTN","XOBUM",143,0)
 NEW XOBOK
"RTN","XOBUM",144,0)
 DO FULL^VALM1
"RTN","XOBUM",145,0)
 SET XOBOK=$$CP^XOBUM1()
"RTN","XOBUM",146,0)
 IF 'XOBOK DO ERROR(XOBOK)
"RTN","XOBUM",147,0)
 DO REFRESH
"RTN","XOBUM",148,0)
 QUIT
"RTN","XOBUM",149,0)
 ;
"RTN","XOBUM",150,0)
CLEAR ; -- clean up log entries of non-listeners
"RTN","XOBUM",151,0)
 ; -- Protocol: XOBV LISTENER LOG CLEAR
"RTN","XOBUM",152,0)
 DO WAIT^DICD WRITE !
"RTN","XOBUM",153,0)
 DO CLEARLOG^XOBVTCP
"RTN","XOBUM",154,0)
 DO REFRESH
"RTN","XOBUM",155,0)
 QUIT
"RTN","XOBUM",156,0)
 ;
"RTN","XOBUM",157,0)
REFRESH ; -- refresh display
"RTN","XOBUM",158,0)
 ; -- Protocol: XOBU FOUNDATIONS MAIN REFRESH
"RTN","XOBUM",159,0)
 DO BUILD
"RTN","XOBUM",160,0)
 SET VALMBCK="R"
"RTN","XOBUM",161,0)
 QUIT
"RTN","XOBUM",162,0)
 ;
"RTN","XOBUM",163,0)
SS ; -- display M os system status
"RTN","XOBUM",164,0)
 ; -- Protocol: XOBU FOUNDATIONS SYSTEM STATUS
"RTN","XOBUM",165,0)
 DO FULL^VALM1
"RTN","XOBUM",166,0)
 IF $DATA(^%ZOSF("SS")) DO
"RTN","XOBUM",167,0)
 . XECUTE ^%ZOSF("SS")
"RTN","XOBUM",168,0)
 ELSE  DO
"RTN","XOBUM",169,0)
 . WRITE !,"Error: ^%ZOSF(""SS"") node is not defined."
"RTN","XOBUM",170,0)
 DO PAUSE^VALM1
"RTN","XOBUM",171,0)
 DO REFRESH
"RTN","XOBUM",172,0)
 QUIT
"RTN","XOBUM",173,0)
 ;
"RTN","XOBUM",174,0)
ERROR(XOBOK) ;
"RTN","XOBUM",175,0)
 WRITE !,$PIECE(XOBOK,U,2)
"RTN","XOBUM",176,0)
 DO PAUSE^VALM1
"RTN","XOBUM",177,0)
 QUIT
"RTN","XOBUM",178,0)
 ;
"RTN","XOBUM",179,0)
NOYET ; -- not yet available
"RTN","XOBUM",180,0)
 WRITE !!,"Action is under construction.",!
"RTN","XOBUM",181,0)
 DO PAUSE^VALM1
"RTN","XOBUM",182,0)
 SET VALMBCK="R"
"RTN","XOBUM",183,0)
 QUIT
"RTN","XOBUM",184,0)
 ;
"RTN","XOBUM",185,0)
VMS ; -- text for Cache/VMS TCPIP listener
"RTN","XOBUM",186,0)
 ;;
"RTN","XOBUM",187,0)
 ;;If this screen shows no running listener(s), it is likely that
"RTN","XOBUM",188,0)
 ;;the VistALink listener(s) for this system are managed by the
"RTN","XOBUM",189,0)
 ;;TCP/IP utility at the VMS system level and are already running.
"RTN","XOBUM",190,0)
 ;;
"RTN","XOBUM",191,0)
 ;;The following TCP/IP command will show the status of all
"RTN","XOBUM",192,0)
 ;;listener services with names starting with vlink:
"RTN","XOBUM",193,0)
 ;;      $ tcpip show service vlink*
"RTN","XOBUM",194,0)
 ;;Please contact IRM site staff for additional information
"RTN","XOBUM",195,0)
 ;;regarding the VistALink listener(s) such as port number(s).
"RTN","XOBUM",196,0)
 ;;$END$
"RTN","XOBUM",197,0)
DSM ; -- text for VMS/DSM TCPIP disclaimer
"RTN","XOBUM",198,0)
 ;;
"RTN","XOBUM",199,0)
 ;;This Foundations Manager screen cannot be used to manage
"RTN","XOBUM",200,0)
 ;;VistALink listeners under DSM.
"RTN","XOBUM",201,0)
 ;;
"RTN","XOBUM",202,0)
 ;;For DSM, use the VMS TCP/IP utility to manage VistALink
"RTN","XOBUM",203,0)
 ;;listeners. For example, the following TCP/IP command will
"RTN","XOBUM",204,0)
 ;;show the status of all listener services with names
"RTN","XOBUM",205,0)
 ;;starting with vlink:
"RTN","XOBUM",206,0)
 ;;
"RTN","XOBUM",207,0)
 ;;      $ tcpip show service vlink*
"RTN","XOBUM",208,0)
 ;;$END$
"RTN","XOBUM1")
0^2^B26724948
"RTN","XOBUM1",1,0)
XOBUM1 ;; ld,mjk/alb - Foundations Manager ; 07/27/2002  13:00
"RTN","XOBUM1",2,0)
 ;;1.6;Foundations;;May 08, 2009;Build 15
"RTN","XOBUM1",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBUM1",4,0)
 ;
"RTN","XOBUM1",5,0)
START(XOBPORT) ;-- Entry point to start a single VistALink Listener
"RTN","XOBUM1",6,0)
 ;
"RTN","XOBUM1",7,0)
 ;  This procedure will start the VistALink Listener on a specific port.  The port number is optional
"RTN","XOBUM1",8,0)
 ;  and will be validated if passed to this procedure.  If the port is not passed, the user will be
"RTN","XOBUM1",9,0)
 ;  prompted for a port number.
"RTN","XOBUM1",10,0)
 ;
"RTN","XOBUM1",11,0)
 ;   Input:
"RTN","XOBUM1",12,0)
 ;     XOBPORT  - Port number for the Listener (optional)
"RTN","XOBUM1",13,0)
 ;
"RTN","XOBUM1",14,0)
 ;  Output:
"RTN","XOBUM1",15,0)
 ;     None
"RTN","XOBUM1",16,0)
 ;
"RTN","XOBUM1",17,0)
 NEW XOBTASK,Y,XOBOK
"RTN","XOBUM1",18,0)
 ;
"RTN","XOBUM1",19,0)
 ;-- Reset I/O variables
"RTN","XOBUM1",20,0)
 SET U="^" DO HOME^%ZIS
"RTN","XOBUM1",21,0)
 ;
"RTN","XOBUM1",22,0)
 DO
"RTN","XOBUM1",23,0)
 . ;
"RTN","XOBUM1",24,0)
 . ;-- Check operating system
"RTN","XOBUM1",25,0)
 . IF '$$CHKOS() SET XOBOK=0 QUIT
"RTN","XOBUM1",26,0)
 . ;
"RTN","XOBUM1",27,0)
 . ;-- Validate/prompt for port
"RTN","XOBUM1",28,0)
 . IF '$$VALID($GET(XOBPORT)) SET XOBPORT=$$GETPORT("start")
"RTN","XOBUM1",29,0)
 . IF 'XOBPORT SET XOBOK=0 QUIT
"RTN","XOBUM1",30,0)
 . ;
"RTN","XOBUM1",31,0)
 . ;-- Wait msg to user
"RTN","XOBUM1",32,0)
 . DO WAIT^DICD WRITE !
"RTN","XOBUM1",33,0)
 . ;
"RTN","XOBUM1",34,0)
 . ;-- Check if Listener is running on port
"RTN","XOBUM1",35,0)
 . IF '$$LOCK^XOBVTCP(XOBPORT) DO  QUIT
"RTN","XOBUM1",36,0)
 . . DO EN^DDIOL("VistALink Listener on port "_XOBPORT_" appears to be running already.")
"RTN","XOBUM1",37,0)
 . . SET XOBOK=0
"RTN","XOBUM1",38,0)
 . ;
"RTN","XOBUM1",39,0)
 . ;-- Lock was successful; unlock and queue the listener to startup
"RTN","XOBUM1",40,0)
 . DO UNLOCK^XOBVTCP(XOBPORT)
"RTN","XOBUM1",41,0)
 . DO UPDATE^XOBVTCP(XOBPORT,1)
"RTN","XOBUM1",42,0)
 . SET XOBOK=$$START^XOBVTCP(XOBPORT)
"RTN","XOBUM1",43,0)
 . IF 'XOBOK DO
"RTN","XOBUM1",44,0)
 . . DO UPDATE^XOBVTCP(XOBPORT,5)
"RTN","XOBUM1",45,0)
 . . DO EN^DDIOL("Unable to start VistALink Listener on port "_XOBPORT_".")
"RTN","XOBUM1",46,0)
 ;
"RTN","XOBUM1",47,0)
 QUIT XOBOK
"RTN","XOBUM1",48,0)
 ;
"RTN","XOBUM1",49,0)
 ;
"RTN","XOBUM1",50,0)
CHKOS() ;-- Check operating system
"RTN","XOBUM1",51,0)
 ;
"RTN","XOBUM1",52,0)
 ;  This function will determine which operating system is being used.
"RTN","XOBUM1",53,0)
 ;
"RTN","XOBUM1",54,0)
 ;   Input:
"RTN","XOBUM1",55,0)
 ;     None
"RTN","XOBUM1",56,0)
 ;
"RTN","XOBUM1",57,0)
 ;  Output:
"RTN","XOBUM1",58,0)
 ;     Function value - returns 1 on success, 0 on failure
"RTN","XOBUM1",59,0)
 ;
"RTN","XOBUM1",60,0)
 NEW OPERSYS,RESULT
"RTN","XOBUM1",61,0)
 ;
"RTN","XOBUM1",62,0)
 SET RESULT=0
"RTN","XOBUM1",63,0)
 ;
"RTN","XOBUM1",64,0)
 ;-- Get operating system
"RTN","XOBUM1",65,0)
 SET OPERSYS=$$GETOS^XOBVTCP()
"RTN","XOBUM1",66,0)
 ;
"RTN","XOBUM1",67,0)
 DO
"RTN","XOBUM1",68,0)
 . IF OPERSYS="OpenM-NT" DO  QUIT
"RTN","XOBUM1",69,0)
 .. DO EN^DDIOL("Starting VistALink Listener...")
"RTN","XOBUM1",70,0)
 .. SET RESULT=1
"RTN","XOBUM1",71,0)
 . ;
"RTN","XOBUM1",72,0)
 . IF OPERSYS["DSM" DO EN^DDIOL("Use the TCPIP utility in VMS to enable the VistALink Listener.") QUIT
"RTN","XOBUM1",73,0)
 . ;
"RTN","XOBUM1",74,0)
 . ;-- All other operating systems
"RTN","XOBUM1",75,0)
 . DO EN^DDIOL("Starting the VistALink Listener is not yet supported for "_OPERSYS_".") QUIT
"RTN","XOBUM1",76,0)
 . ;
"RTN","XOBUM1",77,0)
 QUIT RESULT
"RTN","XOBUM1",78,0)
 ;
"RTN","XOBUM1",79,0)
 ;
"RTN","XOBUM1",80,0)
VALID(XOBPORT) ;-- Validate port
"RTN","XOBUM1",81,0)
 ;
"RTN","XOBUM1",82,0)
 ;  This function will validate a port number passed in.
"RTN","XOBUM1",83,0)
 ;  
"RTN","XOBUM1",84,0)
 ;   Input:
"RTN","XOBUM1",85,0)
 ;     XOBPORT  - Port number for the Listener (Optional)
"RTN","XOBUM1",86,0)
 ;
"RTN","XOBUM1",87,0)
 ;  Output:
"RTN","XOBUM1",88,0)
 ;     Function value - returns 1 if valid, 0 otherwise
"RTN","XOBUM1",89,0)
 ;
"RTN","XOBUM1",90,0)
 NEW RESULT
"RTN","XOBUM1",91,0)
 ;
"RTN","XOBUM1",92,0)
 SET XOBPORT=+$GET(XOBPORT)
"RTN","XOBUM1",93,0)
 SET RESULT=0
"RTN","XOBUM1",94,0)
 ;
"RTN","XOBUM1",95,0)
 ;-- Check if port is not defined or invalid
"RTN","XOBUM1",96,0)
 DO  ; Drops out of block on failure
"RTN","XOBUM1",97,0)
 . QUIT:XOBPORT=0
"RTN","XOBUM1",98,0)
 . QUIT:(XOBPORT?.AP)
"RTN","XOBUM1",99,0)
 . QUIT:XOBPORT<5000!(XOBPORT>65535)
"RTN","XOBUM1",100,0)
 . SET RESULT=1
"RTN","XOBUM1",101,0)
 QUIT RESULT
"RTN","XOBUM1",102,0)
 ;
"RTN","XOBUM1",103,0)
 ;
"RTN","XOBUM1",104,0)
GETPORT(XOBST) ;-- Prompt user for port number
"RTN","XOBUM1",105,0)
 ;
"RTN","XOBUM1",106,0)
 ;  This function will prompt the user for a valid port number.
"RTN","XOBUM1",107,0)
 ;  
"RTN","XOBUM1",108,0)
 ;   Input:
"RTN","XOBUM1",109,0)
 ;     XOBST - start = start Listener
"RTN","XOBUM1",110,0)
 ;             stop  = stop Listener
"RTN","XOBUM1",111,0)
 ;
"RTN","XOBUM1",112,0)
 ;  Output:
"RTN","XOBUM1",113,0)
 ;     Function value - returns port # or zero
"RTN","XOBUM1",114,0)
 ;
"RTN","XOBUM1",115,0)
 NEW DIR,DIRUT,PORT
"RTN","XOBUM1",116,0)
 SET XOBST=$GET(XOBST)
"RTN","XOBUM1",117,0)
 ;
"RTN","XOBUM1",118,0)
 SET DIR(0)="NA^5000:65535"
"RTN","XOBUM1",119,0)
 SET DIR("A")="Enter Port: "
"RTN","XOBUM1",120,0)
 SET DIR("B")=8000  ; Default port is 8000
"RTN","XOBUM1",121,0)
 SET DIR("?")="Choose a numeric port to "_XOBST_" the VistALink Listener on in the range of 5000-65535."
"RTN","XOBUM1",122,0)
 DO ^DIR KILL DIR
"RTN","XOBUM1",123,0)
 IF $DATA(DIRUT) DO
"RTN","XOBUM1",124,0)
 . DO EN^DDIOL("Port not specified.  VistALink Listener not "_$SELECT(XOBST="start":"started",1:"stopped")_".")
"RTN","XOBUM1",125,0)
 . SET PORT=0
"RTN","XOBUM1",126,0)
 ELSE  SET PORT=+$GET(Y)
"RTN","XOBUM1",127,0)
 ;
"RTN","XOBUM1",128,0)
 QUIT PORT
"RTN","XOBUM1",129,0)
 ;
"RTN","XOBUM1",130,0)
 ;
"RTN","XOBUM1",131,0)
BOX() ; -- start this BOX-VOl default configuration
"RTN","XOBUM1",132,0)
 NEW XOBOX
"RTN","XOBUM1",133,0)
 IF $$CHKOS^XOBUM1() DO
"RTN","XOBUM1",134,0)
 . SET XOBOK=1
"RTN","XOBUM1",135,0)
 . DO WAIT^DICD WRITE !
"RTN","XOBUM1",136,0)
 . DO STARTCFG^XOBVTCP($$GETCFG^XOBVTCP())
"RTN","XOBUM1",137,0)
 ELSE  DO
"RTN","XOBUM1",138,0)
 . SET XOBOK=0
"RTN","XOBUM1",139,0)
 QUIT XOBOK
"RTN","XOBUM1",140,0)
 ;
"RTN","XOBUM1",141,0)
 ;
"RTN","XOBUM1",142,0)
STOP(LOGDA) ; -- stop a listener
"RTN","XOBUM1",143,0)
 NEW Y,X,LOG0,XOBBOX,XOBPORT,XONCFG,XOBSTAT,XOBOK,XOBCFG
"RTN","XOBUM1",144,0)
 SET XOBOK=0
"RTN","XOBUM1",145,0)
 ;
"RTN","XOBUM1",146,0)
 SET LOG0=$GET(^XOB(18.04,LOGDA,0))
"RTN","XOBUM1",147,0)
 SET XOBBOX=$PIECE(LOG0,U)
"RTN","XOBUM1",148,0)
 SET XOBPORT=$PIECE(LOG0,U,2)
"RTN","XOBUM1",149,0)
 SET XOBSTAT=$PIECE(LOG0,U,3)
"RTN","XOBUM1",150,0)
 SET XOBCFG=$PIECE(LOG0,U,6)
"RTN","XOBUM1",151,0)
 ; 
"RTN","XOBUM1",152,0)
 ; -- must be valid entry with a running status
"RTN","XOBUM1",153,0)
 IF XOBPORT,XOBSTAT=2 DO
"RTN","XOBUM1",154,0)
 . DO UPDLOG^XOBVTCP(LOGDA,XOBPORT,3,XOBCFG)
"RTN","XOBUM1",155,0)
 . SET XOBOK=1
"RTN","XOBUM1",156,0)
 ELSE  DO
"RTN","XOBUM1",157,0)
 . SET XOBOK=0_U_"Listener is not running!"
"RTN","XOBUM1",158,0)
 ;
"RTN","XOBUM1",159,0)
 QUIT XOBOK
"RTN","XOBUM1",160,0)
 ;
"RTN","XOBUM1",161,0)
PARMS() ; -- maintain site parameters
"RTN","XOBUM1",162,0)
 NEW DIC,X,Y,DR,DA,DIE,XOBOK
"RTN","XOBUM1",163,0)
 SET XOBOK=0
"RTN","XOBUM1",164,0)
 ;
"RTN","XOBUM1",165,0)
 IF $GET(^XOB(18.01,1,0))["" DO
"RTN","XOBUM1",166,0)
 . SET DA=1,DR="[XOBU SITE PARAMETERS]",DIE="^XOB(18.01," DO ^DIE
"RTN","XOBUM1",167,0)
 . SET XOBOK=1
"RTN","XOBUM1",168,0)
 ELSE  DO
"RTN","XOBUM1",169,0)
 . SET XOBOK=0_U_"Error: Site parameter file not initialized."
"RTN","XOBUM1",170,0)
 ;
"RTN","XOBUM1",171,0)
 QUIT XOBOK
"RTN","XOBUM1",172,0)
 ;
"RTN","XOBUM1",173,0)
CFG() ; -- listener configuration edit
"RTN","XOBUM1",174,0)
 NEW DIC,X,Y,DR,DA,DIE,XOBDONE,XOBOK
"RTN","XOBUM1",175,0)
 SET XOBOK=0
"RTN","XOBUM1",176,0)
 ;
"RTN","XOBUM1",177,0)
 SET XOBDONE=0
"RTN","XOBUM1",178,0)
 ;
"RTN","XOBUM1",179,0)
 FOR   DO  QUIT:XOBDONE
"RTN","XOBUM1",180,0)
 . WRITE !
"RTN","XOBUM1",181,0)
 . SET DIC="^XOB(18.03,",DIC(0)="AEMLQ" DO ^DIC
"RTN","XOBUM1",182,0)
 . IF Y<1 SET XOBDONE=1 QUIT
"RTN","XOBUM1",183,0)
 . SET DA=+Y,DR="[XOBV LISTENER CONFIG EDIT]",DIE="^XOB(18.03," DO ^DIE
"RTN","XOBUM1",184,0)
 SET XOBOK=1
"RTN","XOBUM1",185,0)
 ;
"RTN","XOBUM1",186,0)
 QUIT XOBOK
"RTN","XOBUM1",187,0)
 ;
"RTN","XOBUM1",188,0)
CP() ; -- add a connector proxy
"RTN","XOBUM1",189,0)
 NEW XOBOK
"RTN","XOBUM1",190,0)
 SET XOBOK=0
"RTN","XOBUM1",191,0)
 DO CONT^XUSAP
"RTN","XOBUM1",192,0)
 SET XOBOK=1
"RTN","XOBUM1",193,0)
 QUIT XOBOK
"RTN","XOBUM1",194,0)
 ;
"RTN","XOBUPOST")
0^^B715309
"RTN","XOBUPOST",1,0)
XOBUPOST ;; ld,mjk/alb - Foundations Post-Init ; 07/27/2002  13:00
"RTN","XOBUPOST",2,0)
 ;;1.6;Foundations;;May 08, 2009;Build 15
"RTN","XOBUPOST",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBUPOST",4,0)
 QUIT
"RTN","XOBUPOST",5,0)
 ;
"RTN","XOBUPOST",6,0)
EN ; -- add post-init code here
"RTN","XOBUPOST",7,0)
 DO PARMS
"RTN","XOBUPOST",8,0)
 QUIT
"RTN","XOBUPOST",9,0)
 ;
"RTN","XOBUPOST",10,0)
 ;
"RTN","XOBUPOST",11,0)
PARMS ; -- add parameter entry
"RTN","XOBUPOST",12,0)
 NEW DIC,X,Y,DIE,DA,DR,XOBBOX,XOBDA,XOBMULI,XOBNEW
"RTN","XOBUPOST",13,0)
 ;
"RTN","XOBUPOST",14,0)
 ; -- box-pair name, no ien
"RTN","XOBUPOST",15,0)
 SET XOBBOX=$PIECE($$GETENV(),U,4)
"RTN","XOBUPOST",16,0)
 ;
"RTN","XOBUPOST",17,0)
 ; -- Top-Level Parameters --
"RTN","XOBUPOST",18,0)
 SET DIC="^XOB(18.01,",DIC(0)="LX",X=$$DOMAIN() DO ^DIC
"RTN","XOBUPOST",19,0)
 ;
"RTN","XOBUPOST",20,0)
 QUIT
"RTN","XOBUPOST",21,0)
 ;
"RTN","XOBUPOST",22,0)
 ;
"RTN","XOBUPOST",23,0)
DOMAIN() ; -- get account's domain entry
"RTN","XOBUPOST",24,0)
 ;
"RTN","XOBUPOST",25,0)
 QUIT $$KSP^XUPARAM("WHERE")
"RTN","XOBUPOST",26,0)
 ;
"RTN","XOBUPOST",27,0)
 ;
"RTN","XOBUPOST",28,0)
GETENV() ; -- get environment variable
"RTN","XOBUPOST",29,0)
 ;-- Get environment of current system i.e. Y=UCI^VOL/DIR^NODE^BOX LOOKUP
"RTN","XOBUPOST",30,0)
 NEW Y
"RTN","XOBUPOST",31,0)
 DO GETENV^%ZOSV
"RTN","XOBUPOST",32,0)
 QUIT Y
"RTN","XOBUPOST",33,0)
 ;
"RTN","XOBUPRE")
0^^B3331902
"RTN","XOBUPRE",1,0)
XOBUPRE ;; mjk,ld/alb - Foundations Pre-Init ; 07/27/2002  13:00
"RTN","XOBUPRE",2,0)
 ;;1.6;Foundations;;May 08, 2009;Build 15
"RTN","XOBUPRE",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBUPRE",4,0)
 QUIT
"RTN","XOBUPRE",5,0)
 ;
"RTN","XOBUPRE",6,0)
EN ; -- pre-init code
"RTN","XOBUPRE",7,0)
 ;
"RTN","XOBUPRE",8,0)
 ; -- change package file name entry from XOBS VISTALINK SECURITY to VISTALINK SECURITY
"RTN","XOBUPRE",9,0)
 DO PKGCHG
"RTN","XOBUPRE",10,0)
 ;
"RTN","XOBUPRE",11,0)
 ; -- delete obsolete SYSTEM file (18) if it exists
"RTN","XOBUPRE",12,0)
 DO DEL(18,"SYSTEM")
"RTN","XOBUPRE",13,0)
 ;
"RTN","XOBUPRE",14,0)
 ; -- delete VISTALINK PERSON file (18.09) if it exists (interim file used in early developers' previews)
"RTN","XOBUPRE",15,0)
 DO DEL(18.09,"VISTALINK PERSON")
"RTN","XOBUPRE",16,0)
 ;
"RTN","XOBUPRE",17,0)
 IF $$CHK() QUIT
"RTN","XOBUPRE",18,0)
 ;
"RTN","XOBUPRE",19,0)
 ; -- delete FOUNDATIONS SITE PARAMETERS file (18.01)
"RTN","XOBUPRE",20,0)
 DO DEL(18.01,"FOUNDATIONS SITE PARAMETERS")
"RTN","XOBUPRE",21,0)
 ;
"RTN","XOBUPRE",22,0)
 ; -- delete FOUNDATIONS SECURITY PROVIDER file (18.02)
"RTN","XOBUPRE",23,0)
 DO DEL(18.02,"FOUNDATIONS SECURITY PROVIDER")
"RTN","XOBUPRE",24,0)
 ;
"RTN","XOBUPRE",25,0)
 QUIT
"RTN","XOBUPRE",26,0)
 ;
"RTN","XOBUPRE",27,0)
PKGCHG ; -- change package file name
"RTN","XOBUPRE",28,0)
 ;
"RTN","XOBUPRE",29,0)
 ; -- change package file name entry to VISTALINK SECURITY
"RTN","XOBUPRE",30,0)
 ;   (should only affect VistALink v1.0 test sites)
"RTN","XOBUPRE",31,0)
 NEW DA,DIC,DIE,DR,X,Y
"RTN","XOBUPRE",32,0)
 SET DIC="^DIC(9.4,",DIC(0)="X",X="XOBS VISTALINK SECURITY" DO ^DIC
"RTN","XOBUPRE",33,0)
 IF +Y>0 SET DIE=DIC,DA=+Y,DR=".01///VISTALINK SECURITY" DO ^DIE
"RTN","XOBUPRE",34,0)
 ;
"RTN","XOBUPRE",35,0)
 ; -- change package PREFIX for entry FOUNDATIONS
"RTN","XOBUPRE",36,0)
 ;   (should only affect VistALink v1.0 test sites)
"RTN","XOBUPRE",37,0)
 NEW DA,DIC,DIE,DR,X,Y
"RTN","XOBUPRE",38,0)
 SET DIC="^DIC(9.4,",DIC(0)="X",X="FOUNDATIONS",DIC("S")="IF $P(^(0),U,2)=""XOB""" DO ^DIC
"RTN","XOBUPRE",39,0)
 IF +Y>0 SET DIE=DIC,DA=+Y,DR="1///XOBU" DO ^DIE
"RTN","XOBUPRE",40,0)
 ;
"RTN","XOBUPRE",41,0)
 QUIT
"RTN","XOBUPRE",42,0)
 ;
"RTN","XOBUPRE",43,0)
CHK() ; -- is newer version present
"RTN","XOBUPRE",44,0)
 NEW XOBRES
"RTN","XOBUPRE",45,0)
 ;
"RTN","XOBUPRE",46,0)
 ; -- check if new configuration file is present
"RTN","XOBUPRE",47,0)
 DO FILE^DID(18.03,"","NAME","XOBRES")
"RTN","XOBUPRE",48,0)
 ;
"RTN","XOBUPRE",49,0)
 ; -- if config file present than newer version installed
"RTN","XOBUPRE",50,0)
 QUIT $GET(XOBRES("NAME"))="VISTALINK LISTENER CONFIGURATION"
"RTN","XOBUPRE",51,0)
 ;
"RTN","XOBUPRE",52,0)
DEL(XOBFILE,XOBNAME) ; -- delete file
"RTN","XOBUPRE",53,0)
 NEW DIU,XOBRES
"RTN","XOBUPRE",54,0)
 ;
"RTN","XOBUPRE",55,0)
 DO FILE^DID(XOBFILE,"","NAME","XOBRES")
"RTN","XOBUPRE",56,0)
 ;
"RTN","XOBUPRE",57,0)
 ; -- if file present then delete
"RTN","XOBUPRE",58,0)
 IF $GET(XOBRES("NAME"))=XOBNAME DO
"RTN","XOBUPRE",59,0)
 . ; -- delete file and data
"RTN","XOBUPRE",60,0)
 . SET DIU=XOBFILE,DIU(0)="TD" DO EN^DIU2
"RTN","XOBUPRE",61,0)
 ;
"RTN","XOBUPRE",62,0)
 QUIT
"RTN","XOBUPRE",63,0)
 ;
"RTN","XOBUZAP")
0^3^B66617883
"RTN","XOBUZAP",1,0)
XOBUZAP ;; mjk/alb - Terminate Jobs Utility ; 08/4/2005  13:00
"RTN","XOBUZAP",2,0)
 ;;1.6;Foundations;;May 08, 2009;Build 15
"RTN","XOBUZAP",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBUZAP",4,0)
 QUIT
"RTN","XOBUZAP",5,0)
 ;
"RTN","XOBUZAP",6,0)
 ; ----------------------- Main Entry Points -----------------------
"RTN","XOBUZAP",7,0)
 ;
"RTN","XOBUZAP",8,0)
EN(XOBSEL) ; -- Interactive and main entry point for XOBU TERMINATE JOBS tool
"RTN","XOBUZAP",9,0)
 ;
"RTN","XOBUZAP",10,0)
 ; Input: XOBSEL array that specifies selection criteria
"RTN","XOBUZAP",11,0)
 ;           XOBSEL("ROUTINE")=<routine name>
"RTN","XOBUZAP",12,0)
 ;           XOBSEL("STATE")=<job state#> (see STATE tag for list of states)
"RTN","XOBUZAP",13,0)
 ;           XOBSEL("TITLE")=optional title text to be used by ListManager (upper right of LM screen)
"RTN","XOBUZAP",14,0)
 ;           XOBSEL("VISTA INFO REF")=optional reference to array or global containing "CLIENT IP" and "DUZ" nodes
"RTN","XOBUZAP",15,0)
 ;           
"RTN","XOBUZAP",16,0)
 ; -- verify job selection critera
"RTN","XOBUZAP",17,0)
 IF '$$VERSEL(.XOBSEL) DO  GOTO ENQ
"RTN","XOBUZAP",18,0)
 . WRITE !,"Job selection criteria not specified correctly or is missing!"
"RTN","XOBUZAP",19,0)
 ;
"RTN","XOBUZAP",20,0)
 ; -- start 'Terminate Jobs Utility'
"RTN","XOBUZAP",21,0)
 DO EN^VALM("XOBU TERMINATE JOBS UTILITY")
"RTN","XOBUZAP",22,0)
ENQ ;
"RTN","XOBUZAP",23,0)
 QUIT
"RTN","XOBUZAP",24,0)
 ;
"RTN","XOBUZAP",25,0)
ZAP(XOBSEL) ; -- Non-interactive entry point for XOBU TERMINATE JOBS tool
"RTN","XOBUZAP",26,0)
 ;                  API terminates all jobs that job selection criteria
"RTN","XOBUZAP",27,0)
 ;                  
"RTN","XOBUZAP",28,0)
 ;  Input: XOBSEL array that specifies selection criteria (See above EN tag for information)
"RTN","XOBUZAP",29,0)
 ;
"RTN","XOBUZAP",30,0)
 ; Return: Count of how many jobs terminated OR
"RTN","XOBUZAP",31,0)
 ;         -1 if MUMPS implementation is not Cache
"RTN","XOBUZAP",32,0)
 ;         -2 if XOBSEL arrary is not passed in or is invalid.
"RTN","XOBUZAP",33,0)
 ;            
"RTN","XOBUZAP",34,0)
 NEW XOBJOBS,XOBPID,XOBCNS,XOBCNT
"RTN","XOBUZAP",35,0)
 ; -- check if this is a Cache implementation
"RTN","XOBUZAP",36,0)
 IF '$$CACHE() SET XOBCNT=-1 GOTO ZAPQ
"RTN","XOBUZAP",37,0)
 ;
"RTN","XOBUZAP",38,0)
 ; -- verify job selection critera
"RTN","XOBUZAP",39,0)
 IF '$$VERSEL(.XOBSEL) SET XOBCNT=-2 GOTO ZAPQ
"RTN","XOBUZAP",40,0)
 ;
"RTN","XOBUZAP",41,0)
 DO GETJOBS(.XOBJOBS)
"RTN","XOBUZAP",42,0)
 SET XOBCNS=$$CURNS()
"RTN","XOBUZAP",43,0)
 SET XOBCNT=0
"RTN","XOBUZAP",44,0)
 SET XOBPID=""
"RTN","XOBUZAP",45,0)
 FOR  SET XOBPID=$ORDER(XOBJOBS(XOBPID)) QUIT:XOBPID=""  DO
"RTN","XOBUZAP",46,0)
 . IF $$CHECK(.XOBSEL,XOBPID,XOBCNS) DO
"RTN","XOBUZAP",47,0)
 . . SET XOBRES=$$TERMJOB(XOBPID)
"RTN","XOBUZAP",48,0)
 . . IF XOBRES=1 SET XOBCNT=XOBCNT+1
"RTN","XOBUZAP",49,0)
ZAPQ ;
"RTN","XOBUZAP",50,0)
 QUIT XOBCNT
"RTN","XOBUZAP",51,0)
 ;
"RTN","XOBUZAP",52,0)
 ; ----------------------- Listman Related Code -----------------------
"RTN","XOBUZAP",53,0)
 ;
"RTN","XOBUZAP",54,0)
HDR ; -- header code
"RTN","XOBUZAP",55,0)
 SET VALMHDR(1)="    "_IOUON_"Job Selection Criteria"_IOUOFF_" (matches: "_+$GET(VALMCNT)_")"
"RTN","XOBUZAP",56,0)
 SET VALMHDR(2)="     Box-Volume Pair: "_IOINHI_$$BOXVOL()_IOINORM
"RTN","XOBUZAP",57,0)
 SET VALMHDR(3)="   Current Namespace: "_IOINHI_$$CURNS()_IOINORM
"RTN","XOBUZAP",58,0)
 SET VALMHDR(4)="             Routine: "_IOINHI_$GET(XOBSEL("ROUTINE"),"Unknown")_IOINORM
"RTN","XOBUZAP",59,0)
 SET VALMHDR(5)="           Job State: "_IOINHI_$PIECE($$GETSTATE^XOBUZAP0(+$GET(XOBSEL("STATE"),";;;Unknown")),";",4)_IOINORM
"RTN","XOBUZAP",60,0)
 QUIT
"RTN","XOBUZAP",61,0)
 ;
"RTN","XOBUZAP",62,0)
INIT ; -- init variables and list array
"RTN","XOBUZAP",63,0)
 IF $DATA(XOBSEL("TITLE")) SET VALM("TITLE")=XOBSEL("TITLE")
"RTN","XOBUZAP",64,0)
 DO BUILD
"RTN","XOBUZAP",65,0)
 SET VALMSG=$$CPMSG()
"RTN","XOBUZAP",66,0)
 QUIT
"RTN","XOBUZAP",67,0)
 ;
"RTN","XOBUZAP",68,0)
BUILD ; -- build list based on job selection criteria (XOBSEL)
"RTN","XOBUZAP",69,0)
 NEW XOBJOBS,XOBPID,XOBCNS
"RTN","XOBUZAP",70,0)
 DO KILL
"RTN","XOBUZAP",71,0)
 DO KILL^VALM10()
"RTN","XOBUZAP",72,0)
 IF '$$CACHE() DO  GOTO BUILDQ
"RTN","XOBUZAP",73,0)
 . DO SET^VALM10(1,"",1)
"RTN","XOBUZAP",74,0)
 . DO SET^VALM10(2,"",2)
"RTN","XOBUZAP",75,0)
 . DO SET^VALM10(3,"   'Terminate' actions not supported for the current M implementation ["_$$MUMPS()_"].",3)
"RTN","XOBUZAP",76,0)
 . SET VALMCNT=3
"RTN","XOBUZAP",77,0)
 SET XOBCNS=$$CURNS()
"RTN","XOBUZAP",78,0)
 DO GETJOBS(.XOBJOBS)
"RTN","XOBUZAP",79,0)
 SET VALMCNT=0
"RTN","XOBUZAP",80,0)
 SET XOBPID=""
"RTN","XOBUZAP",81,0)
 FOR  SET XOBPID=$ORDER(XOBJOBS(XOBPID)) QUIT:XOBPID=""  DO
"RTN","XOBUZAP",82,0)
 . IF $$CHECK(.XOBSEL,XOBPID,XOBCNS) DO
"RTN","XOBUZAP",83,0)
 . . NEW XOBJINFO
"RTN","XOBUZAP",84,0)
 . . DO JOBINFO(XOBPID,.XOBJINFO,.XOBSEL)
"RTN","XOBUZAP",85,0)
 . . SET VALMCNT=VALMCNT+1
"RTN","XOBUZAP",86,0)
 . . SET X=""
"RTN","XOBUZAP",87,0)
 . . SET X=$$SETFLD^VALM1($JUSTIFY(VALMCNT,4),X,"ENTRY")
"RTN","XOBUZAP",88,0)
 . . SET X=$$SETFLD^VALM1(XOBPID,X,"PID")
"RTN","XOBUZAP",89,0)
 . . SET X=$$SETFLD^VALM1($EXTRACT($GET(XOBJINFO("DEVICE"))_":"_$GET(XOBJINFO("CLIENT IP")),1,34),X,"DEVICE")
"RTN","XOBUZAP",90,0)
 . . SET X=$$SETFLD^VALM1($EXTRACT("User="_$SELECT($GET(XOBJINFO("CONNECTOR USER")):"*",1:"")_$GET(XOBJINFO("VISTA USER NAME")),1,30),X,"COMMENT")
"RTN","XOBUZAP",91,0)
 . . DO SET^VALM10(VALMCNT,X,VALMCNT)
"RTN","XOBUZAP",92,0)
 . . SET ^TMP("XOB TERMINATE JOBS","IDX",$JOB,VALMCNT,VALMCNT)=XOBPID
"RTN","XOBUZAP",93,0)
 ;
"RTN","XOBUZAP",94,0)
BUILDQ ;
"RTN","XOBUZAP",95,0)
 QUIT
"RTN","XOBUZAP",96,0)
 ;
"RTN","XOBUZAP",97,0)
KILL ; -- kill off list location
"RTN","XOBUZAP",98,0)
 KILL ^TMP("XOB TERMINATE JOBS",$JOB)
"RTN","XOBUZAP",99,0)
 KILL ^TMP("XOB TERMINATE JOBS","IDX",$JOB)
"RTN","XOBUZAP",100,0)
 QUIT
"RTN","XOBUZAP",101,0)
 ;
"RTN","XOBUZAP",102,0)
HELP ; -- help code
"RTN","XOBUZAP",103,0)
 SET X="?" DO DISP^XQORM1 WRITE !!
"RTN","XOBUZAP",104,0)
 QUIT
"RTN","XOBUZAP",105,0)
 ;
"RTN","XOBUZAP",106,0)
EXIT ; -- exit code
"RTN","XOBUZAP",107,0)
 QUIT
"RTN","XOBUZAP",108,0)
 ;
"RTN","XOBUZAP",109,0)
EXPND ; -- expand code
"RTN","XOBUZAP",110,0)
 QUIT
"RTN","XOBUZAP",111,0)
 ;
"RTN","XOBUZAP",112,0)
MSG ; -- set default message
"RTN","XOBUZAP",113,0)
 SET VALMSG="Use RE (Refresh) to display only alive jobs "
"RTN","XOBUZAP",114,0)
 QUIT
"RTN","XOBUZAP",115,0)
 ;
"RTN","XOBUZAP",116,0)
CPMSG() ; -- connection proxy user message
"RTN","XOBUZAP",117,0)
 QUIT "* Connector Proxy User"
"RTN","XOBUZAP",118,0)
 ;
"RTN","XOBUZAP",119,0)
REFRESH ; -- refresh display
"RTN","XOBUZAP",120,0)
 ; -- Protocol: XOBU TERMINATE JOBS REFRESH
"RTN","XOBUZAP",121,0)
 DO BUILD
"RTN","XOBUZAP",122,0)
 SET VALMSG=$$CPMSG()
"RTN","XOBUZAP",123,0)
 KILL VALMHDR
"RTN","XOBUZAP",124,0)
 SET VALMBCK="R"
"RTN","XOBUZAP",125,0)
 QUIT
"RTN","XOBUZAP",126,0)
 ;
"RTN","XOBUZAP",127,0)
SS ; -- display M os system status
"RTN","XOBUZAP",128,0)
 ; -- Protocol: XOBU TERMINATE SYSTEM STATUS
"RTN","XOBUZAP",129,0)
 DO FULL^VALM1
"RTN","XOBUZAP",130,0)
 IF $DATA(^%ZOSF("SS")) DO
"RTN","XOBUZAP",131,0)
 . XECUTE ^%ZOSF("SS")
"RTN","XOBUZAP",132,0)
 ELSE  DO
"RTN","XOBUZAP",133,0)
 . WRITE !,"Error: ^%ZOSF(""SS"") node is not defined."
"RTN","XOBUZAP",134,0)
 DO PAUSE^VALM1
"RTN","XOBUZAP",135,0)
 DO REFRESH
"RTN","XOBUZAP",136,0)
 QUIT
"RTN","XOBUZAP",137,0)
 ;
"RTN","XOBUZAP",138,0)
TERMALL ; -- terminate all pid/job
"RTN","XOBUZAP",139,0)
 ; -- Protocol: XOBU TERMINATE ALL JOBS
"RTN","XOBUZAP",140,0)
 IF '$$ASK() GOTO TERMALLQ
"RTN","XOBUZAP",141,0)
 NEW XOBI,XOBPID
"RTN","XOBUZAP",142,0)
 SET XOBI=""
"RTN","XOBUZAP",143,0)
 FOR  SET XOBI=$ORDER(^TMP("XOB TERMINATE JOBS","IDX",$JOB,XOBI)) QUIT:XOBI=""  DO
"RTN","XOBUZAP",144,0)
 . SET XOBPID=$GET(^TMP("XOB TERMINATE JOBS","IDX",$JOB,XOBI,XOBI))
"RTN","XOBUZAP",145,0)
 . DO TERMONE(XOBPID,XOBI)
"RTN","XOBUZAP",146,0)
 DO MSG
"RTN","XOBUZAP",147,0)
TERMALLQ ;
"RTN","XOBUZAP",148,0)
 SET VALMBCK=""
"RTN","XOBUZAP",149,0)
 QUIT
"RTN","XOBUZAP",150,0)
 ;
"RTN","XOBUZAP",151,0)
TERMPID ; -- terminate pid/job
"RTN","XOBUZAP",152,0)
 ; -- Protocol: XOBU TERMINATE A JOB 
"RTN","XOBUZAP",153,0)
 NEW XOBI,VALMY,XOBPID,XOBRES
"RTN","XOBUZAP",154,0)
 DO EN^VALM2(XQORNOD(0),"OS")
"RTN","XOBUZAP",155,0)
 SET XOBI=+$ORDER(VALMY(""))
"RTN","XOBUZAP",156,0)
 IF XOBI>0 DO
"RTN","XOBUZAP",157,0)
 . NEW XOBPID
"RTN","XOBUZAP",158,0)
 . SET XOBPID=$GET(^TMP("XOB TERMINATE JOBS","IDX",$JOB,XOBI,XOBI))
"RTN","XOBUZAP",159,0)
 . ; -- highlight entire line
"RTN","XOBUZAP",160,0)
 . DO SELECT^VALM10(XOBI,1)
"RTN","XOBUZAP",161,0)
 . IF XOBPID="<terminated>" DO  QUIT
"RTN","XOBUZAP",162,0)
 . . WRITE !,"Job has already been terminated!" DO PAUSE^VALM1
"RTN","XOBUZAP",163,0)
 . ;
"RTN","XOBUZAP",164,0)
 . IF $$ASK() DO
"RTN","XOBUZAP",165,0)
 . . DO TERMONE(XOBPID,XOBI),MSG
"RTN","XOBUZAP",166,0)
 . ELSE  DO
"RTN","XOBUZAP",167,0)
 . . ; -- unhighlight entire line
"RTN","XOBUZAP",168,0)
 . . DO SELECT^VALM10(XOBI,0)
"RTN","XOBUZAP",169,0)
 SET VALMBCK=""
"RTN","XOBUZAP",170,0)
 QUIT
"RTN","XOBUZAP",171,0)
 ;
"RTN","XOBUZAP",172,0)
TERMONE(XOBPID,XOBI) ; -- zap one pid and update display
"RTN","XOBUZAP",173,0)
 NEW XOBRES
"RTN","XOBUZAP",174,0)
 ; -- quit if already terminated
"RTN","XOBUZAP",175,0)
 IF XOBPID="<terminated>" QUIT
"RTN","XOBUZAP",176,0)
 ; -- make sure criteris is still met
"RTN","XOBUZAP",177,0)
 IF '$$CHECK(.XOBSEL,XOBPID,$$CURNS()) DO  QUIT
"RTN","XOBUZAP",178,0)
 . ; -- insert warning comment into display line
"RTN","XOBUZAP",179,0)
 . DO FLDTEXT^VALM10(XOBI,"COMMENT","Criteria not met!")
"RTN","XOBUZAP",180,0)
 . ; -- highlight entire line
"RTN","XOBUZAP",181,0)
 . DO SELECT^VALM10(XOBI,1)
"RTN","XOBUZAP",182,0)
 ; -- terminate job
"RTN","XOBUZAP",183,0)
 SET XOBRES=$$TERMJOB(XOBPID)
"RTN","XOBUZAP",184,0)
 ; -- insert comment into display line
"RTN","XOBUZAP",185,0)
 DO FLDTEXT^VALM10(XOBI,"COMMENT",$EXTRACT($$RESULT(XOBRES),1,25))
"RTN","XOBUZAP",186,0)
 ; -- highlight entire line
"RTN","XOBUZAP",187,0)
 DO SELECT^VALM10(XOBI,1)
"RTN","XOBUZAP",188,0)
 ; -- remove PID so it can't be terminated again
"RTN","XOBUZAP",189,0)
 SET ^TMP("XOB TERMINATE JOBS","IDX",$JOB,XOBI,XOBI)="<terminated>"
"RTN","XOBUZAP",190,0)
 QUIT
"RTN","XOBUZAP",191,0)
 ;
"RTN","XOBUZAP",192,0)
ASK(PROMPT) ; -- ask if user is sure
"RTN","XOBUZAP",193,0)
 NEW DIR,Y
"RTN","XOBUZAP",194,0)
 SET DIR("A")=$GET(PROMPT,"Are you sure")
"RTN","XOBUZAP",195,0)
 SET DIR("B")="NO",DIR(0)="Y"
"RTN","XOBUZAP",196,0)
 DO ^DIR
"RTN","XOBUZAP",197,0)
 QUIT +$GET(Y)
"RTN","XOBUZAP",198,0)
 ;
"RTN","XOBUZAP",199,0)
RESULT(RESULT) ; -- return result text
"RTN","XOBUZAP",200,0)
 ; -- Note: Code number conversions found in RESJOB routine in %SYS namespace
"RTN","XOBUZAP",201,0)
 IF RESULT=1 QUIT "Process terminated"
"RTN","XOBUZAP",202,0)
 IF RESULT=-1 QUIT "Process not responding"
"RTN","XOBUZAP",203,0)
 IF RESULT=-2 QUIT "Process died, not responding"
"RTN","XOBUZAP",204,0)
 IF RESULT=-3 QUIT "Process already died"
"RTN","XOBUZAP",205,0)
 QUIT RESULT_" --> unknown result type"
"RTN","XOBUZAP",206,0)
 ;
"RTN","XOBUZAP",207,0)
 ; ---------- Code used by Interactive and Non-Interactive Entry Points ----------
"RTN","XOBUZAP",208,0)
 ;
"RTN","XOBUZAP",209,0)
VERSEL(XOBSEL) ; -- every job selection criteria
"RTN","XOBUZAP",210,0)
 NEW XOBOK
"RTN","XOBUZAP",211,0)
 IF $GET(XOBSEL("ROUTINE"))=""!($GET(XOBSEL("STATE"))="") SET XOBOK=0 GOTO VERSELQ
"RTN","XOBUZAP",212,0)
 SET XOBOK=1
"RTN","XOBUZAP",213,0)
VERSELQ ;
"RTN","XOBUZAP",214,0)
 QUIT XOBOK
"RTN","XOBUZAP",215,0)
 ;
"RTN","XOBUZAP",216,0)
GETJOBS(XOBJOBS) ; -- build XOBJOBS()=pid information
"RTN","XOBUZAP",217,0)
 NEW XOBPID,XOBCNT
"RTN","XOBUZAP",218,0)
 SET XOBPID="",XOBCNT=0
"RTN","XOBUZAP",219,0)
 FOR  SET XOBPID=$ORDER(^$JOB(XOBPID)) QUIT:XOBPID=""  DO
"RTN","XOBUZAP",220,0)
 . SET XOBCNT=XOBCNT+1,XOBJOBS(XOBPID)=""
"RTN","XOBUZAP",221,0)
 QUIT
"RTN","XOBUZAP",222,0)
 ;
"RTN","XOBUZAP",223,0)
CHECK(XOBSEL,XOBPID,XOBNS) ; -- check job info against selection criteria
"RTN","XOBUZAP",224,0)
 ; -- use if 1) in correct namespace [XOBNS],
"RTN","XOBUZAP",225,0)
 ;           2) in correct routine [XOBSEL("ROUTINE")] and
"RTN","XOBUZAP",226,0)
 ;           3) in correct process state [XOBSEL("STATE")]
"RTN","XOBUZAP",227,0)
 NEW XOBJINFO
"RTN","XOBUZAP",228,0)
 DO JOBINFO(XOBPID,.XOBJINFO,.XOBSEL)
"RTN","XOBUZAP",229,0)
 IF XOBJINFO("NAMESPACE")=XOBNS,XOBJINFO("ROUTINE")=$GET(XOBSEL("ROUTINE")),XOBJINFO("STATE")=$GET(XOBSEL("STATE")) QUIT 1
"RTN","XOBUZAP",230,0)
 QUIT 0
"RTN","XOBUZAP",231,0)
 ;
"RTN","XOBUZAP",232,0)
JOBINFO(XOBPID,XOBJINFO,XOBSEL) ; -- get PID info
"RTN","XOBUZAP",233,0)
 ; -- In future (Cache v5+) use instance proprties of %SYSTEM.Process
"RTN","XOBUZAP",234,0)
 SET XOBJINFO("STATE")=+$ZUTIL(67,4,XOBPID)
"RTN","XOBUZAP",235,0)
 SET XOBJINFO("ROUTINE")=$ZUTIL(67,5,XOBPID)
"RTN","XOBUZAP",236,0)
 SET XOBJINFO("NAMESPACE")=$ZUTIL(67,6,XOBPID)
"RTN","XOBUZAP",237,0)
 SET XOBJINFO("DEVICE")=$ZUTIL(67,7,XOBPID)
"RTN","XOBUZAP",238,0)
 SET XOBJINFO("OS USERNAME")=$ZUTIL(67,11,XOBPID) ; currently not used
"RTN","XOBUZAP",239,0)
 ;
"RTN","XOBUZAP",240,0)
 ; -- get VistA Info is available
"RTN","XOBUZAP",241,0)
 IF $GET(XOBSEL("VISTA INFO REF"))]"" DO
"RTN","XOBUZAP",242,0)
 . NEW XOBY,XOBREF
"RTN","XOBUZAP",243,0)
 . SET XOBREF=$$GETREF^XOBUZAP0(XOBSEL("VISTA INFO REF"),XOBPID)
"RTN","XOBUZAP",244,0)
 . ;
"RTN","XOBUZAP",245,0)
 . SET XOBJINFO("VISTA DUZ")=+$$GETDUZ^XOBUZAP0(XOBREF)
"RTN","XOBUZAP",246,0)
 . SET XOBY=$PIECE($GET(^VA(200,XOBJINFO("VISTA DUZ"),0)),U)
"RTN","XOBUZAP",247,0)
 . SET XOBJINFO("VISTA USER NAME")=$SELECT(XOBY]"":XOBY,1:"<unknown>")
"RTN","XOBUZAP",248,0)
 . SET XOBJINFO("CONNECTOR USER")=$$CPCHK^XUSAP(XOBJINFO("VISTA DUZ"))
"RTN","XOBUZAP",249,0)
 . ;
"RTN","XOBUZAP",250,0)
 . SET XOBY=$$GETIP^XOBUZAP0(XOBREF)
"RTN","XOBUZAP",251,0)
 . SET XOBJINFO("CLIENT IP")=$SELECT(XOBY]"":XOBY,1:"<unknown>")
"RTN","XOBUZAP",252,0)
 QUIT
"RTN","XOBUZAP",253,0)
 ;
"RTN","XOBUZAP",254,0)
TERMJOB(XOBPID) ; -- terminate pid/job
"RTN","XOBUZAP",255,0)
 ; -- In future (Cache v5+) use instance method %SYSTEM.Process.Terminate()
"RTN","XOBUZAP",256,0)
 ;QUIT 1  ; -- used for testing
"RTN","XOBUZAP",257,0)
 QUIT $ZUTIL(4,XOBPID)
"RTN","XOBUZAP",258,0)
 ;
"RTN","XOBUZAP",259,0)
BOXVOL() ; -- cpu volume pair
"RTN","XOBUZAP",260,0)
 NEW Y DO GETENV^%ZOSV
"RTN","XOBUZAP",261,0)
 QUIT $P(Y,U,4)
"RTN","XOBUZAP",262,0)
 ;
"RTN","XOBUZAP",263,0)
CURNS() ; -- get current namespace
"RTN","XOBUZAP",264,0)
 QUIT $ZUTIL(5)
"RTN","XOBUZAP",265,0)
 ;
"RTN","XOBUZAP",266,0)
MUMPS() ; -- get MUMPS implementation
"RTN","XOBUZAP",267,0)
 QUIT $SELECT(^%ZOSF("OS")["OpenM":"OpenM",^("OS")["DSM":"DSM",^("OS")["UNIX":"UNIX",^("OS")["MSM":"MSM",1:"")
"RTN","XOBUZAP",268,0)
 ;
"RTN","XOBUZAP",269,0)
CACHE() ; -- is this a Cache implementation
"RTN","XOBUZAP",270,0)
 QUIT $$MUMPS()["OpenM"
"RTN","XOBUZAP",271,0)
 ;
"RTN","XOBUZAP0")
0^6^B5948951
"RTN","XOBUZAP0",1,0)
XOBUZAP0 ;; mjk/alb - Terminate Jobs Utility ; 08/4/2005  13:00
"RTN","XOBUZAP0",2,0)
 ;;1.6;Foundations;;May 08, 2009;Build 15
"RTN","XOBUZAP0",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBUZAP0",4,0)
 QUIT
"RTN","XOBUZAP0",5,0)
 ;
"RTN","XOBUZAP0",6,0)
 ; ------------------- ^XTMP Related Utilities -------------------------
"RTN","XOBUZAP0",7,0)
 ; 
"RTN","XOBUZAP0",8,0)
GETREF(SUB,XOBJOB) ; -- get ^XTMP reference of $JOB or passed in job #
"RTN","XOBUZAP0",9,0)
 QUIT $NAME(^XTMP(SUB_" "_$$BOXVOL^XOBUZAP()_" "_$GET(XOBJOB,$JOB)))
"RTN","XOBUZAP0",10,0)
 ;
"RTN","XOBUZAP0",11,0)
KILL(XOBREF) ; -- kill @ ref
"RTN","XOBUZAP0",12,0)
 KILL @XOBREF
"RTN","XOBUZAP0",13,0)
 QUIT
"RTN","XOBUZAP0",14,0)
 ; 
"RTN","XOBUZAP0",15,0)
SETVI(XOBREF,XOBDUZ,XOBIP,XOBDESC) ; -- Set VistA Info node
"RTN","XOBUZAP0",16,0)
 NEW XOBDT
"RTN","XOBUZAP0",17,0)
 SET XOBDT=$$DT^XLFDT()
"RTN","XOBUZAP0",18,0)
 SET @XOBREF@(0)=$$FMADD^XLFDT(XOBDT,7)_U_XOBDT_U_XOBDESC_" [$JOB ="_$JOB_"]"
"RTN","XOBUZAP0",19,0)
 SET @XOBREF@(1)=$GET(XOBDUZ)_U_$GET(XOBIP)
"RTN","XOBUZAP0",20,0)
 QUIT
"RTN","XOBUZAP0",21,0)
 ;
"RTN","XOBUZAP0",22,0)
GETDUZ(XOBREF) ; -- Get DUZ from VistA Info node
"RTN","XOBUZAP0",23,0)
 QUIT +$GET(@XOBREF@(1))
"RTN","XOBUZAP0",24,0)
 ;
"RTN","XOBUZAP0",25,0)
GETIP(XOBREF) ; -- Get Client IP from VistA Info node
"RTN","XOBUZAP0",26,0)
 QUIT $PIECE($GET(@XOBREF@(1)),U,2)
"RTN","XOBUZAP0",27,0)
 ;
"RTN","XOBUZAP0",28,0)
 ; --------------------------------------------------------------------
"RTN","XOBUZAP0",29,0)
 ; 
"RTN","XOBUZAP0",30,0)
GETSTATE(CODE) ; -- get state
"RTN","XOBUZAP0",31,0)
 QUIT $TEXT(STATE+CODE)
"RTN","XOBUZAP0",32,0)
 ;
"RTN","XOBUZAP0",33,0)
 ; Note: 'State' table below derived from Cache documentation on $ZUTIL(67,4) function.
"RTN","XOBUZAP0",34,0)
 ;       Codes 19-21 are present in Cache v5+ but not applicable to version 4.1.
"RTN","XOBUZAP0",35,0)
STATE ; -- get process STATE text
"RTN","XOBUZAP0",36,0)
 ;;1;LOCK :: Job is in the lock code.
"RTN","XOBUZAP0",37,0)
 ;;2;OPEN :: Job is opening a device.
"RTN","XOBUZAP0",38,0)
 ;;3;CLOS :: Job is closing a device.
"RTN","XOBUZAP0",39,0)
 ;;4;USE :: Job is in the USE command.
"RTN","XOBUZAP0",40,0)
 ;;5;READ :: Job is reading from a device.
"RTN","XOBUZAP0",41,0)
 ;;6;WRT :: Job is writing to a device.
"RTN","XOBUZAP0",42,0)
 ;;7;GGET :: Job is in gget.
"RTN","XOBUZAP0",43,0)
 ;;8;GSET :: Job is in gset.
"RTN","XOBUZAP0",44,0)
 ;;9;GKILL :: Job is in gkill.
"RTN","XOBUZAP0",45,0)
 ;;10;GORD :: Job is in gorder for $ORDER.
"RTN","XOBUZAP0",46,0)
 ;;11;GQRY :: Job is in gorder for $QUERY.
"RTN","XOBUZAP0",47,0)
 ;;12;GDEF :: Job is in gdefval.
"RTN","XOBUZAP0",48,0)
 ;;13;ZF :: Job is in a $ZF function call.
"RTN","XOBUZAP0",49,0)
 ;;14;HANG :: Job is in the HANG command.
"RTN","XOBUZAP0",50,0)
 ;;15;JOB :: Job is jobbing a job.
"RTN","XOBUZAP0",51,0)
 ;;16;EXAM :: Job is doing ^JOBEXAM.
"RTN","XOBUZAP0",52,0)
 ;;17;BRD :: Job is in $ZUTIL(9) or $ZUTIL(94), broadcasting a message.
"RTN","XOBUZAP0",53,0)
 ;;18;SUSP :: Job is suspended.
"RTN","XOBUZAP0",54,0)
 ;;19;INCR :: Job is in a $INCREMENT function call.
"RTN","XOBUZAP0",55,0)
 ;;20;BSET :: Job is setting a bit using the $BIT functions. 
"RTN","XOBUZAP0",56,0)
 ;;21;BGET :: Job is getting a bit using the $BIT functions.
"RTN","XOBUZAP1")
0^4^B2296758
"RTN","XOBUZAP1",1,0)
XOBUZAP1 ;; mjk/alb - VistALink Connection Manager ; 08/4/2005  13:00
"RTN","XOBUZAP1",2,0)
 ;;1.6;Foundations;;May 08, 2009;Build 15
"RTN","XOBUZAP1",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBUZAP1",4,0)
 QUIT
"RTN","XOBUZAP1",5,0)
 ;
"RTN","XOBUZAP1",6,0)
VLEN ; -- List Manager interactive entry point for VistALink connection socket
"RTN","XOBUZAP1",7,0)
 ;        job cleanup
"RTN","XOBUZAP1",8,0)
 NEW XOBSEL
"RTN","XOBUZAP1",9,0)
 DO VLSEL(.XOBSEL)
"RTN","XOBUZAP1",10,0)
 DO EN^XOBUZAP(.XOBSEL)
"RTN","XOBUZAP1",11,0)
 QUIT
"RTN","XOBUZAP1",12,0)
 ;
"RTN","XOBUZAP1",13,0)
VLQUICK ; -- Interactive that just zaps all for VistALink connection socket jobs
"RTN","XOBUZAP1",14,0)
 ;
"RTN","XOBUZAP1",15,0)
 IF $$ASK^XOBUZAP("Terminate all VistALink socket connection jobs") DO
"RTN","XOBUZAP1",16,0)
 . WRITE !,"Count of socket jobs terminated: ",$$VLZAP()
"RTN","XOBUZAP1",17,0)
 ELSE  DO
"RTN","XOBUZAP1",18,0)
 . WRITE !,"No jobs terminated."
"RTN","XOBUZAP1",19,0)
 QUIT
"RTN","XOBUZAP1",20,0)
 ;
"RTN","XOBUZAP1",21,0)
VLZAP() ; -- callable non-interactive for VistALink connection socket job cleanup
"RTN","XOBUZAP1",22,0)
 ;    o  BE CAREFUL because this call just does it!
"RTN","XOBUZAP1",23,0)
 ;    o  If in programmer's mode, it is recommended that the VLQUICK tag be used   
"RTN","XOBUZAP1",24,0)
 ;  Input: None
"RTN","XOBUZAP1",25,0)
 ; Return: Count of how many jobs terminated or
"RTN","XOBUZAP1",26,0)
 ;         -1 is XOBSEL arrary is not passed in or is invalid.
"RTN","XOBUZAP1",27,0)
 ;            
"RTN","XOBUZAP1",28,0)
 NEW XOBSEL
"RTN","XOBUZAP1",29,0)
 DO VLSEL(.XOBSEL)
"RTN","XOBUZAP1",30,0)
 QUIT $$ZAP^XOBUZAP(.XOBSEL)
"RTN","XOBUZAP1",31,0)
 ;
"RTN","XOBUZAP1",32,0)
VLSEL(XOBSEL) ; -- setup VistALink connection socket job selection criteria
"RTN","XOBUZAP1",33,0)
 ; -- routine name the job should be executing
"RTN","XOBUZAP1",34,0)
 SET XOBSEL("ROUTINE")="XOBVSKT"
"RTN","XOBUZAP1",35,0)
 ; -- state the routine should be in
"RTN","XOBUZAP1",36,0)
 SET XOBSEL("STATE")=5 ; READ state
"RTN","XOBUZAP1",37,0)
 ; -- optional title to be used by ListManager
"RTN","XOBUZAP1",38,0)
 SET XOBSEL("TITLE")="VL/J2M Connection Manager"
"RTN","XOBUZAP1",39,0)
 ; -- optional reference to VistA info for PIDs
"RTN","XOBUZAP1",40,0)
 SET XOBSEL("VISTA INFO REF")=$$GETSUB()
"RTN","XOBUZAP1",41,0)
 QUIT
"RTN","XOBUZAP1",42,0)
 ;
"RTN","XOBUZAP1",43,0)
GETSUB() ; -- get ^XTMP namespaced subscript beginning
"RTN","XOBUZAP1",44,0)
 QUIT "XOB VISTA INFO"
"RTN","XOBUZAP1",45,0)
 ;
"RTN","XOBUZAP1",46,0)
GETREF() ; -- get ^XTMP reference of $JOB for Connection Mgr
"RTN","XOBUZAP1",47,0)
 QUIT $$GETREF^XOBUZAP0($$GETSUB())
"RTN","XOBUZAP1",48,0)
 ;
"RTN","XOBUZAP1",49,0)
GETDESC() ; -- get description for 0th node of ^XTMP
"RTN","XOBUZAP1",50,0)
 QUIT "VistALink Connection Information"
"RTN","XOBUZAP1",51,0)
 ;
"SEC","^DIC",18.01,18.01,0,"AUDIT")
@
"SEC","^DIC",18.01,18.01,0,"DD")
@
"SEC","^DIC",18.01,18.01,0,"DEL")
@
"SEC","^DIC",18.01,18.01,0,"LAYGO")
@
"SEC","^DIC",18.01,18.01,0,"RD")
@
"SEC","^DIC",18.01,18.01,0,"WR")
@
"VER")
8.0^22.0
"^DD",18.01,18.01,0)
FIELD^^100^7
"^DD",18.01,18.01,0,"DDA")
N
"^DD",18.01,18.01,0,"DT")
3041110
"^DD",18.01,18.01,0,"IX","B",18.01,.01)

"^DD",18.01,18.01,0,"NM","FOUNDATIONS SITE PARAMETERS")

"^DD",18.01,18.01,0,"VRPK")
XOBU
"^DD",18.01,18.01,.01,0)
DOMAIN NAME^RP4.2'X^DIC(4.2,^0;1^S DINUM=1
"^DD",18.01,18.01,.01,1,0)
^.1
"^DD",18.01,18.01,.01,1,1,0)
18.01^B
"^DD",18.01,18.01,.01,1,1,1)
S ^XOB(18.01,"B",$E(X,1,30),DA)=""
"^DD",18.01,18.01,.01,1,1,2)
K ^XOB(18.01,"B",$E(X,1,30),DA)
"^DD",18.01,18.01,.01,3)
Enter the domain name associated with this application
"^DD",18.01,18.01,.01,21,0)
^^5^5^3030410^
"^DD",18.01,18.01,.01,21,1,0)
This is the domain name of this installation of the Foundations and
"^DD",18.01,18.01,.01,21,2,0)
VistALink application as it is known to the rest of the network.
"^DD",18.01,18.01,.01,21,3,0)
 
"^DD",18.01,18.01,.01,21,4,0)
This name applies to all CPUs or Volume sets which access this ^XOB
"^DD",18.01,18.01,.01,21,5,0)
global and the ^XWB global.
"^DD",18.01,18.01,.01,"DT")
3030410
"^DD",18.01,18.01,.02,0)
HEARTBEAT RATE^RNJ4,0^^0;2^K:+X'=X!(X>3600)!(X<180)!(X?.E1"."1.N) X
"^DD",18.01,18.01,.02,3)
Type the number of seconds between 180 and 3600
"^DD",18.01,18.01,.02,21,0)
^^11^11^3030430^
"^DD",18.01,18.01,.02,21,1,0)
This field indicates the rate (in seconds) the VistALink heartbeat message
"^DD",18.01,18.01,.02,21,2,0)
should be expected from a client. If there is no activity on the
"^DD",18.01,18.01,.02,21,3,0)
connection for this amount of time, the client will send a system
"^DD",18.01,18.01,.02,21,4,0)
heartbeat message.
"^DD",18.01,18.01,.02,21,5,0)
 
"^DD",18.01,18.01,.02,21,6,0)
The client, as part of the initial connection protocol, retrieves this 
"^DD",18.01,18.01,.02,21,7,0)
value. As a result, the client and the M server are always synchronized
"^DD",18.01,18.01,.02,21,8,0)
regarding the heartbeat rate.
"^DD",18.01,18.01,.02,21,9,0)
 
"^DD",18.01,18.01,.02,21,10,0)
 
"^DD",18.01,18.01,.02,21,11,0)
See also: LATENCY DELTA
"^DD",18.01,18.01,.02,"DT")
3030430
"^DD",18.01,18.01,.03,0)
LATENCY DELTA^NJ4,0^^0;3^K:+X'=X!(X>3600)!(X<180)!(X?.E1"."1.N) X
"^DD",18.01,18.01,.03,3)
Type the number of seconds between 180 and 3600
"^DD",18.01,18.01,.03,21,0)
^^10^10^3030410^
"^DD",18.01,18.01,.03,21,1,0)
This field indicates the number of seconds to add to the HEARTBEAT RATE 
"^DD",18.01,18.01,.03,21,2,0)
when calculating the initial timeout value for the VistALink Listener.
"^DD",18.01,18.01,.03,21,3,0)
 
"^DD",18.01,18.01,.03,21,4,0)
The client and the M server are synchronized regarding the HEARTBEAT 
"^DD",18.01,18.01,.03,21,5,0)
RATE. This latency parameter allows the site to fine tune the timeout
"^DD",18.01,18.01,.03,21,6,0)
value. The site can to take into account any network slowness or other
"^DD",18.01,18.01,.03,21,7,0)
factors that may delay the arrival of the system heartbeat message from
"^DD",18.01,18.01,.03,21,8,0)
the client.
"^DD",18.01,18.01,.03,21,9,0)
 
"^DD",18.01,18.01,.03,21,10,0)
See also: HEARTBEAT RATE
"^DD",18.01,18.01,.03,"DT")
3030410
"^DD",18.01,18.01,.04,0)
J2EE CONNECTION TIMEOUT^NJ6,0^^0;4^K:+X'=X!(X>604800)!(X<180)!(X?.E1"."1N.N) X
"^DD",18.01,18.01,.04,3)
Enter the number of seconds between 180 (3 minutes) and 604800 (1 week), inclusive.
"^DD",18.01,18.01,.04,21,0)
^^73^73^3060320^
"^DD",18.01,18.01,.04,21,1,0)
This field indicates the number of seconds that a VistaLink connection
"^DD",18.01,18.01,.04,21,2,0)
from J2EE to M should be allowed to remain connected but inactive, before
"^DD",18.01,18.01,.04,21,3,0)
M drops the connection.
"^DD",18.01,18.01,.04,21,4,0)
 
"^DD",18.01,18.01,.04,21,5,0)
It is recommended that this J2EE CONNECTION TIMEOUT
"^DD",18.01,18.01,.04,21,6,0)
parameter be set relatively high, for example 1 day (86400 seconds).
"^DD",18.01,18.01,.04,21,7,0)
 
"^DD",18.01,18.01,.04,21,8,0)
A high setting is recommended because all the major application
"^DD",18.01,18.01,.04,21,9,0)
server implementations have more robust mechanisms for controlling
"^DD",18.01,18.01,.04,21,10,0)
connection pools. The site should use the tools/mechanisms supplied
"^DD",18.01,18.01,.04,21,11,0)
by the application server implementation to control how the connection
"^DD",18.01,18.01,.04,21,12,0)
pool size grows and shrinks.
"^DD",18.01,18.01,.04,21,13,0)
 
"^DD",18.01,18.01,.04,21,14,0)
For a quick indicator of the level of control available, below is a
"^DD",18.01,18.01,.04,21,15,0)
brief summary of the connection pool properties in the J2EE
"^DD",18.01,18.01,.04,21,16,0)
deployment descriptors (DD) for J2EE Connector Architecture (J2CA)
"^DD",18.01,18.01,.04,21,17,0)
adaptors by the major application servers.
"^DD",18.01,18.01,.04,21,18,0)
 
"^DD",18.01,18.01,.04,21,19,0)
 
"^DD",18.01,18.01,.04,21,20,0)
BEA WebLogic:
"^DD",18.01,18.01,.04,21,21,0)
=============
"^DD",18.01,18.01,.04,21,22,0)
 
"^DD",18.01,18.01,.04,21,23,0)
DD  file: weblogic-ra.xml
"^DD",18.01,18.01,.04,21,24,0)
DTD file: weblogic810-ra.dtd
"^DD",18.01,18.01,.04,21,25,0)
 
"^DD",18.01,18.01,.04,21,26,0)
 <pool-params>
"^DD",18.01,18.01,.04,21,27,0)
    <initial-capacity>1</initial-capacity>
"^DD",18.01,18.01,.04,21,28,0)
    <max-capacity>5</max-capacity>
"^DD",18.01,18.01,.04,21,29,0)
    <capacity-increment>1</capacity-increment>
"^DD",18.01,18.01,.04,21,30,0)
    <shrinking-enabled>true</shrinking-enabled>
"^DD",18.01,18.01,.04,21,31,0)
    <connection-profiling-enabled>false</connection-profiling-enabled>
"^DD",18.01,18.01,.04,21,32,0)
    <shrink-frequency-seconds>900</shrink-frequency-seconds>
"^DD",18.01,18.01,.04,21,33,0)
    <inactive-connection-timeout-seconds>0
"^DD",18.01,18.01,.04,21,34,0)
         </inactive-connection-timeout-seconds>
"^DD",18.01,18.01,.04,21,35,0)
    <highest-num-waiters>2147483647</highest-num-waiters>
"^DD",18.01,18.01,.04,21,36,0)
    <highest-num-unavailable>0</highest-num-unavailable>
"^DD",18.01,18.01,.04,21,37,0)
    <connection-creation-retry-frequency-seconds>0
"^DD",18.01,18.01,.04,21,38,0)
         </connection-creation-retry-frequency-seconds>
"^DD",18.01,18.01,.04,21,39,0)
    <connection-reserve-timeout-seconds>10
"^DD",18.01,18.01,.04,21,40,0)
         </connection-reserve-timeout-seconds>
"^DD",18.01,18.01,.04,21,41,0)
    <test-frequency-seconds>0</test-frequency-seconds>
"^DD",18.01,18.01,.04,21,42,0)
    <match-connections-supported>true</match-connections-supported>
"^DD",18.01,18.01,.04,21,43,0)
  </pool-params>
"^DD",18.01,18.01,.04,21,44,0)
 
"^DD",18.01,18.01,.04,21,45,0)
 
"^DD",18.01,18.01,.04,21,46,0)
Oracle 9iAS:
"^DD",18.01,18.01,.04,21,47,0)
============
"^DD",18.01,18.01,.04,21,48,0)
 
"^DD",18.01,18.01,.04,21,49,0)
DD  file: oc4j-ra.xml
"^DD",18.01,18.01,.04,21,50,0)
DTD file: oc4j-connector-factories.dtd
"^DD",18.01,18.01,.04,21,51,0)
 
"^DD",18.01,18.01,.04,21,52,0)
 <connection-pooling>
"^DD",18.01,18.01,.04,21,53,0)
    <property name="waitTimeout" value="0" />
"^DD",18.01,18.01,.04,21,54,0)
    <property name="scheme" value="fixed" />
"^DD",18.01,18.01,.04,21,55,0)
    <property name="maxConnections" value="5" />
"^DD",18.01,18.01,.04,21,56,0)
    <property name="minConnections" value="1" />
"^DD",18.01,18.01,.04,21,57,0)
 </connection-pooling>
"^DD",18.01,18.01,.04,21,58,0)
 
"^DD",18.01,18.01,.04,21,59,0)
 
"^DD",18.01,18.01,.04,21,60,0)
JBoss:
"^DD",18.01,18.01,.04,21,61,0)
======
"^DD",18.01,18.01,.04,21,62,0)
 
"^DD",18.01,18.01,.04,21,63,0)
DD  file: jboss-xxx-ds.xml
"^DD",18.01,18.01,.04,21,64,0)
DTD file: ??
"^DD",18.01,18.01,.04,21,65,0)
 
"^DD",18.01,18.01,.04,21,66,0)
 <min-pool-size>1</min-pool-size>
"^DD",18.01,18.01,.04,21,67,0)
 <max-pool-size>5</max-pool-size>
"^DD",18.01,18.01,.04,21,68,0)
 <blocking-timeout-millis>5000</blocking-timeout-millis>
"^DD",18.01,18.01,.04,21,69,0)
 <idle-timeout-minutes>15</idle-timeout-minutes>
"^DD",18.01,18.01,.04,21,70,0)
 
"^DD",18.01,18.01,.04,21,71,0)
 
"^DD",18.01,18.01,.04,21,72,0)
For more information on each application server implementation, see
"^DD",18.01,18.01,.04,21,73,0)
documentation for each individual implementation.
"^DD",18.01,18.01,.04,"DT")
3041116
"^DD",18.01,18.01,.05,0)
J2EE REAUTHENTICATION TIMEOUT^NJ4,0^^0;5^K:+X'=X!(X>3600)!(X<180)!(X?.E1"."1N.N) X
"^DD",18.01,18.01,.05,3)
Number of seconds between 180 and 3600 (inclusive) before a reauthenticated connection is considered expired and must go through the reauthentication process again.
"^DD",18.01,18.01,.05,21,0)
^^34^34^3041118^
"^DD",18.01,18.01,.05,21,1,0)
Number of seconds a connection is considered reauthenicated after a 
"^DD",18.01,18.01,.05,21,2,0)
successful reauthentication has occurred.
"^DD",18.01,18.01,.05,21,3,0)
 
"^DD",18.01,18.01,.05,21,4,0)
Rules Enforced:
"^DD",18.01,18.01,.05,21,5,0)
===============
"^DD",18.01,18.01,.05,21,6,0)
- If a connection in the application server's pool is not
"^DD",18.01,18.01,.05,21,7,0)
  reused by the reauthenticated user before this timeout
"^DD",18.01,18.01,.05,21,8,0)
  limit is reached, the reauthentication is considered expired.
"^DD",18.01,18.01,.05,21,9,0)
 
"^DD",18.01,18.01,.05,21,10,0)
- If expiration does occur, the re-authentication process is
"^DD",18.01,18.01,.05,21,11,0)
  performed again.
"^DD",18.01,18.01,.05,21,12,0)
 
"^DD",18.01,18.01,.05,21,13,0)
- If expiration does not occur, the session is considered
"^DD",18.01,18.01,.05,21,14,0)
  reauthenticated for these number of seconds. (i.e. the time
"^DD",18.01,18.01,.05,21,15,0)
  out clock is reset)
"^DD",18.01,18.01,.05,21,16,0)
 
"^DD",18.01,18.01,.05,21,17,0)
- If a different user gains access to the connection, the
"^DD",18.01,18.01,.05,21,18,0)
  connection is immediately considered not reauthenticated and
"^DD",18.01,18.01,.05,21,19,0)
  the reauthentication process is performed.
"^DD",18.01,18.01,.05,21,20,0)
 
"^DD",18.01,18.01,.05,21,21,0)
Example of Reauthentication Expiration:
"^DD",18.01,18.01,.05,21,22,0)
=======================================
"^DD",18.01,18.01,.05,21,23,0)
 - User gains access and uses a connection from the pool at 4:00pm
"^DD",18.01,18.01,.05,21,24,0)
 - User signs off and goes home, along with most of the site staff
"^DD",18.01,18.01,.05,21,25,0)
 - After 4:00pm, user file maintenance is performed and 
"^DD",18.01,18.01,.05,21,26,0)
   the user's profile is changed. For example, the user's 
"^DD",18.01,18.01,.05,21,27,0)
   FILE MANAGER ACCESS CODE [DUZ(0)] is changed.  
"^DD",18.01,18.01,.05,21,28,0)
 - User signs back on the next morning at 8am
"^DD",18.01,18.01,.05,21,29,0)
 - Since there is very little activity from 4:00-8am, the connection
"^DD",18.01,18.01,.05,21,30,0)
   has not been re-used by another user and is still associated with 
"^DD",18.01,18.01,.05,21,31,0)
   4:00 user
"^DD",18.01,18.01,.05,21,32,0)
 - Since timeout has passed, reauthentication has expired
"^DD",18.01,18.01,.05,21,33,0)
 - Reauthentication process occurs for user
"^DD",18.01,18.01,.05,21,34,0)
 - Reauthentication process re-sets DUZ(0) appropriately to new value. 
"^DD",18.01,18.01,.05,"DT")
3041118
"^DD",18.01,18.01,21,0)
DEFAULT HTTP TIMEOUT^NJ3,0^^2;1^K:+X'=X!(X>300)!(X<2)!(X?.E1"."1.N) X
"^DD",18.01,18.01,21,3)
Default HTTP time-out between 1 and 300 seconds
"^DD",18.01,18.01,21,21,0)
^^10^10^3060320^
"^DD",18.01,18.01,21,21,1,0)
This field indicates the default HTTP time-out (in seconds) for call out
"^DD",18.01,18.01,21,21,2,0)
of the M to a J2EE application server using the M2J feature in VistALink.
"^DD",18.01,18.01,21,21,3,0)
 
"^DD",18.01,18.01,21,21,4,0)
This time-out value can be overridden by specifying a time-out for an
"^DD",18.01,18.01,21,21,5,0)
particular application server. This is accomplished by entering a time-out
"^DD",18.01,18.01,21,21,6,0)
value for DEFAULT HTTP TIMEOUT (#.1) field in the VISTALINK J2EE APP 
"^DD",18.01,18.01,21,21,7,0)
SERVERS (#18.08) file.
"^DD",18.01,18.01,21,21,8,0)
 
"^DD",18.01,18.01,21,21,9,0)
 
"^DD",18.01,18.01,21,21,10,0)
Note: This field is only used by the VistALink v2.0 codebase.
"^DD",18.01,18.01,21,"DT")
3050504
"^DD",18.01,18.01,100,0)
LISTENER CONFIGURATION^18.012P^^CONFIG;0
"^DD",18.01,18.01,100,21,0)
^^11^11^3030410^
"^DD",18.01,18.01,100,21,1,0)
This multiple field contains the VistALink Listener configurations for 
"^DD",18.01,18.01,100,21,2,0)
BOX-VOLUME entries in the DOMAIN NAME's scope.
"^DD",18.01,18.01,100,21,3,0)
 
"^DD",18.01,18.01,100,21,4,0)
Each configuration is used by the XOBV LISTENER STARTUP menu option. This
"^DD",18.01,18.01,100,21,5,0)
option is typically scheduled to run as part of the system startup after
"^DD",18.01,18.01,100,21,6,0)
the VistA system has been restarted. The option will start up VistALink
"^DD",18.01,18.01,100,21,7,0)
Listeners for the BOX-VOLUME where Task Manager is running.
"^DD",18.01,18.01,100,21,8,0)
 
"^DD",18.01,18.01,100,21,9,0)
Note: This only applies to Cache NT systems. VMS/DSM systems need to use 
"^DD",18.01,18.01,100,21,10,0)
the TCP/IP (UCX) utility to have Listeners automatically started
"^DD",18.01,18.01,100,21,11,0)
on reboot.
"^DD",18.01,18.012,0)
LISTENER CONFIGURATION SUB-FIELD^^.02^2
"^DD",18.01,18.012,0,"DT")
3030310
"^DD",18.01,18.012,0,"IX","B",18.012,.01)

"^DD",18.01,18.012,0,"NM","LISTENER CONFIGURATION")

"^DD",18.01,18.012,0,"UP")
18.01
"^DD",18.01,18.012,.01,0)
BOX-VOLUME PAIR^MRP14.7'^%ZIS(14.7,^0;1^Q
"^DD",18.01,18.012,.01,1,0)
^.1
"^DD",18.01,18.012,.01,1,1,0)
18.012^B
"^DD",18.01,18.012,.01,1,1,1)
S ^XOB(18.01,DA(1),"CONFIG","B",$E(X,1,30),DA)=""
"^DD",18.01,18.012,.01,1,1,2)
K ^XOB(18.01,DA(1),"CONFIG","B",$E(X,1,30),DA)
"^DD",18.01,18.012,.01,3)
Enter the BOX-VOLUME pair for this entry
"^DD",18.01,18.012,.01,21,0)
^^11^11^3030410^
"^DD",18.01,18.012,.01,21,1,0)
This field indicates the BOX-VOLUME pair for the entry.
"^DD",18.01,18.012,.01,21,2,0)
 
"^DD",18.01,18.012,.01,21,3,0)
The XOBV LISTENER STARTUP option uses this field to find the configuration
"^DD",18.01,18.012,.01,21,4,0)
that should be used to start up VistALink Listeners for the BOX-VOLUME 
"^DD",18.01,18.012,.01,21,5,0)
pair.
"^DD",18.01,18.012,.01,21,6,0)
 
"^DD",18.01,18.012,.01,21,7,0)
See also: DEFAULT CONFIGURATION
"^DD",18.01,18.012,.01,21,8,0)
 
"^DD",18.01,18.012,.01,21,9,0)
Note: This only applies to Cache NT systems. VMS/DSM systems need to use
"^DD",18.01,18.012,.01,21,10,0)
the TCP/IP (UCX) utility to have Listeners automatically started on 
"^DD",18.01,18.012,.01,21,11,0)
reboot.
"^DD",18.01,18.012,.01,"DT")
3030410
"^DD",18.01,18.012,.02,0)
DEFAULT CONFIGURATION^P18.03'^XOB(18.03,^0;2^Q
"^DD",18.01,18.012,.02,3)
Enter the default configuration name
"^DD",18.01,18.012,.02,21,0)
^^15^15^3030410^
"^DD",18.01,18.012,.02,21,1,0)
This field indicates the default startup Listener configuration for the 
"^DD",18.01,18.012,.02,21,2,0)
BOX-VOLUME PAIR entry.
"^DD",18.01,18.012,.02,21,3,0)
 
"^DD",18.01,18.012,.02,21,4,0)
The XOBV LISTENER STARTUP option uses this field to retrieve the correct 
"^DD",18.01,18.012,.02,21,5,0)
Listener configuration from the VISTALINK LISTENER CONFIGURATION file
"^DD",18.01,18.012,.02,21,6,0)
(#18.03).
"^DD",18.01,18.012,.02,21,7,0)
 
"^DD",18.01,18.012,.02,21,8,0)
The information in the configuration is then used to start up the
"^DD",18.01,18.012,.02,21,9,0)
indicated VistALink Listeners on the desired ports.
"^DD",18.01,18.012,.02,21,10,0)
 
"^DD",18.01,18.012,.02,21,11,0)
See also: BOX-VOLUME PAIR
"^DD",18.01,18.012,.02,21,12,0)
 
"^DD",18.01,18.012,.02,21,13,0)
Note: This only applies to Cache NT systems. VMS/DSM systems need to use
"^DD",18.01,18.012,.02,21,14,0)
the TCP/IP (UCX) utility to have Listeners automatically started on 
"^DD",18.01,18.012,.02,21,15,0)
reboot.
"^DD",18.01,18.012,.02,"DT")
3030410
"^DIC",18.01,18.01,0)
FOUNDATIONS SITE PARAMETERS^18.01
"^DIC",18.01,18.01,0,"GL")
^XOB(18.01,
"^DIC",18.01,18.01,"%",0)
^1.005^1^1
"^DIC",18.01,18.01,"%",1,0)
XOB
"^DIC",18.01,18.01,"%","B","XOB",1)

"^DIC",18.01,18.01,"%D",0)
^^5^5^3030410^^
"^DIC",18.01,18.01,"%D",1,0)
This file holds the site parameters for this installation of Foundations
"^DIC",18.01,18.01,"%D",2,0)
Management and VistALink.
"^DIC",18.01,18.01,"%D",3,0)
 
"^DIC",18.01,18.01,"%D",4,0)
It will have only one entry (DINUM=1) and the .01 field points to a
"^DIC",18.01,18.01,"%D",5,0)
DOMAIN that represents the name of the installation site.
"^DIC",18.01,"B","FOUNDATIONS SITE PARAMETERS",18.01)

**INSTALL NAME**
XOBV 1.6
"BLD",4063,0)
XOBV 1.6^VISTALINK^0^3090508^y
"BLD",4063,1,0)
^^35^35^3071113^
"BLD",4063,1,1,0)
This build contains TCP/IP transport functionality that enables
"BLD",4063,1,2,0)
synchronous communication from the following:
"BLD",4063,1,3,0)
   1) from non-M based systems to M-based VistA servers
"BLD",4063,1,4,0)
   2) from M VistA servers to non-M systems (typically Java/J2EE based
"BLD",4063,1,5,0)
      systems)
"BLD",4063,1,6,0)
 
"BLD",4063,1,7,0)
The communications are in the form of requests. For requests received by
"BLD",4063,1,8,0)
the M-based system, the VISTALINK package contains a Request Manager to
"BLD",4063,1,9,0)
manage these requests. Requests are forwarded to the appropriate Request
"BLD",4063,1,10,0)
Handler.
"BLD",4063,1,11,0)
 
"BLD",4063,1,12,0)
The VISTALINK package contains two native request handlers. One handles 
"BLD",4063,1,13,0)
system-type requests, like client heartbeats and close socket requests. 
"BLD",4063,1,14,0)
The other handler processes RPC requests.
"BLD",4063,1,15,0)
 
"BLD",4063,1,16,0)
Other packages can also supply handlers. For example, VISTALINK SECURITY
"BLD",4063,1,17,0)
(XOBS) supplies a handler that is used to process VistA security-related
"BLD",4063,1,18,0)
requests.
"BLD",4063,1,19,0)
 
"BLD",4063,1,20,0)
VISTALINK allows the following request formats:
"BLD",4063,1,21,0)
   1) XML and conform to a XML Schema 
"BLD",4063,1,22,0)
   2) a proprietary format (package must supply a proprietary parser)
"BLD",4063,1,23,0)
   3) both 1 and 2
"BLD",4063,1,24,0)
 
"BLD",4063,1,25,0)
VISTALINK also supplies a Java/J2EE component that allows developers of
"BLD",4063,1,26,0)
Java applications to make synchronous requests on the M server and for M
"BLD",4063,1,27,0)
applications to make synchronous requests of Java/J2EE application
"BLD",4063,1,28,0)
servers. The Java/J2EE side implements the J2EE Connector Architecture
"BLD",4063,1,29,0)
v1.0 framework (J2CA).
"BLD",4063,1,30,0)
 
"BLD",4063,1,31,0)
** NOTE: As of 7/2005, VISTALINK only supports Java to M communication.
"BLD",4063,1,32,0)
 
"BLD",4063,1,33,0)
Finally, VISTALINK contains a number of library calls available to 
"BLD",4063,1,34,0)
other packages for developing a request handler if needed. (Currently, 
"BLD",4063,1,35,0)
only VISTALINK SECURITY is allowed to use these calls.)
"BLD",4063,4,0)
^9.64PA^18.05^3
"BLD",4063,4,18.03,0)
18.03
"BLD",4063,4,18.03,222)
y^y^f^^^^n
"BLD",4063,4,18.04,0)
18.04
"BLD",4063,4,18.04,222)
y^y^f^^^^n
"BLD",4063,4,18.05,0)
18.05
"BLD",4063,4,18.05,222)
y^y^f^^n^^y^o^n
"BLD",4063,4,"B",18.03,18.03)

"BLD",4063,4,"B",18.04,18.04)

"BLD",4063,4,"B",18.05,18.05)

"BLD",4063,6.3)
15
"BLD",4063,"ABPKG")
n
"BLD",4063,"INI")
EN^XOBVPRE
"BLD",4063,"INID")
n^n^n
"BLD",4063,"INIT")
EN^XOBVPOST
"BLD",4063,"KRN",0)
^9.67PA^19^17
"BLD",4063,"KRN",.4,0)
.4
"BLD",4063,"KRN",.4,"NM",0)
^9.68A^^
"BLD",4063,"KRN",.401,0)
.401
"BLD",4063,"KRN",.402,0)
.402
"BLD",4063,"KRN",.402,"NM",0)
^9.68A^2^1
"BLD",4063,"KRN",.402,"NM",2,0)
XOBV LISTENER CONFIG EDIT    FILE #18.03^18.03^0
"BLD",4063,"KRN",.402,"NM","B","XOBV LISTENER CONFIG EDIT    FILE #18.03",2)

"BLD",4063,"KRN",.403,0)
.403
"BLD",4063,"KRN",.5,0)
.5
"BLD",4063,"KRN",.84,0)
.84
"BLD",4063,"KRN",.84,"NM",0)
^9.68A^15^15
"BLD",4063,"KRN",.84,"NM",1,0)
181001^^0
"BLD",4063,"KRN",.84,"NM",2,0)
181002^^0
"BLD",4063,"KRN",.84,"NM",3,0)
182001^^0
"BLD",4063,"KRN",.84,"NM",4,0)
182002^^0
"BLD",4063,"KRN",.84,"NM",5,0)
182003^^0
"BLD",4063,"KRN",.84,"NM",6,0)
182004^^0
"BLD",4063,"KRN",.84,"NM",7,0)
182005^^0
"BLD",4063,"KRN",.84,"NM",8,0)
182006^^0
"BLD",4063,"KRN",.84,"NM",9,0)
182007^^0
"BLD",4063,"KRN",.84,"NM",10,0)
182008^^0
"BLD",4063,"KRN",.84,"NM",11,0)
181003^^0
"BLD",4063,"KRN",.84,"NM",12,0)
181004^^0
"BLD",4063,"KRN",.84,"NM",13,0)
184001^^0
"BLD",4063,"KRN",.84,"NM",14,0)
182009^^0
"BLD",4063,"KRN",.84,"NM",15,0)
182010^^0
"BLD",4063,"KRN",.84,"NM","B",181001,1)

"BLD",4063,"KRN",.84,"NM","B",181002,2)

"BLD",4063,"KRN",.84,"NM","B",181003,11)

"BLD",4063,"KRN",.84,"NM","B",181004,12)

"BLD",4063,"KRN",.84,"NM","B",182001,3)

"BLD",4063,"KRN",.84,"NM","B",182002,4)

"BLD",4063,"KRN",.84,"NM","B",182003,5)

"BLD",4063,"KRN",.84,"NM","B",182004,6)

"BLD",4063,"KRN",.84,"NM","B",182005,7)

"BLD",4063,"KRN",.84,"NM","B",182006,8)

"BLD",4063,"KRN",.84,"NM","B",182007,9)

"BLD",4063,"KRN",.84,"NM","B",182008,10)

"BLD",4063,"KRN",.84,"NM","B",182009,14)

"BLD",4063,"KRN",.84,"NM","B",182010,15)

"BLD",4063,"KRN",.84,"NM","B",184001,13)

"BLD",4063,"KRN",3.6,0)
3.6
"BLD",4063,"KRN",3.6,"NM",0)
^9.68A^^
"BLD",4063,"KRN",3.8,0)
3.8
"BLD",4063,"KRN",3.8,"NM",0)
^9.68A^^
"BLD",4063,"KRN",9.2,0)
9.2
"BLD",4063,"KRN",9.2,"NM",0)
^9.68A^^
"BLD",4063,"KRN",9.8,0)
9.8
"BLD",4063,"KRN",9.8,"NM",0)
^9.68A^21^15
"BLD",4063,"KRN",9.8,"NM",3,0)
XOBVLIB^^0^B29603500
"BLD",4063,"KRN",9.8,"NM",4,0)
XOBVLL^^0^B20760795
"BLD",4063,"KRN",9.8,"NM",5,0)
XOBVLT^^0^B32764303
"BLD",4063,"KRN",9.8,"NM",9,0)
XOBVRH^^0^B12957948
"BLD",4063,"KRN",9.8,"NM",10,0)
XOBVRM^^0^B4502318
"BLD",4063,"KRN",9.8,"NM",11,0)
XOBVRMX^^0^B3008010
"BLD",4063,"KRN",9.8,"NM",12,0)
XOBVRPC^^0^B55791656
"BLD",4063,"KRN",9.8,"NM",13,0)
XOBVRPCI^^0^B31578368
"BLD",4063,"KRN",9.8,"NM",14,0)
XOBVRPCX^^0^B22239279
"BLD",4063,"KRN",9.8,"NM",15,0)
XOBVSKT^^0^B19091287
"BLD",4063,"KRN",9.8,"NM",16,0)
XOBVSYSI^^0^B53927220
"BLD",4063,"KRN",9.8,"NM",17,0)
XOBVTCP^^0^B48106146
"BLD",4063,"KRN",9.8,"NM",18,0)
XOBVTCPL^^0^B7619114
"BLD",4063,"KRN",9.8,"NM",20,0)
XOBVTLS^^0^B4033073
"BLD",4063,"KRN",9.8,"NM",21,0)
XOBVLJU^^1^
"BLD",4063,"KRN",9.8,"NM","B","XOBVLIB",3)

"BLD",4063,"KRN",9.8,"NM","B","XOBVLJU",21)

"BLD",4063,"KRN",9.8,"NM","B","XOBVLL",4)

"BLD",4063,"KRN",9.8,"NM","B","XOBVLT",5)

"BLD",4063,"KRN",9.8,"NM","B","XOBVRH",9)

"BLD",4063,"KRN",9.8,"NM","B","XOBVRM",10)

"BLD",4063,"KRN",9.8,"NM","B","XOBVRMX",11)

"BLD",4063,"KRN",9.8,"NM","B","XOBVRPC",12)

"BLD",4063,"KRN",9.8,"NM","B","XOBVRPCI",13)

"BLD",4063,"KRN",9.8,"NM","B","XOBVRPCX",14)

"BLD",4063,"KRN",9.8,"NM","B","XOBVSKT",15)

"BLD",4063,"KRN",9.8,"NM","B","XOBVSYSI",16)

"BLD",4063,"KRN",9.8,"NM","B","XOBVTCP",17)

"BLD",4063,"KRN",9.8,"NM","B","XOBVTCPL",18)

"BLD",4063,"KRN",9.8,"NM","B","XOBVTLS",20)

"BLD",4063,"KRN",19,0)
19
"BLD",4063,"KRN",19,"NM",0)
^9.68A^31^3
"BLD",4063,"KRN",19,"NM",29,0)
XOBV LISTENER STARTUP^^0
"BLD",4063,"KRN",19,"NM",30,0)
XOBV VISTALINK TESTER^^0
"BLD",4063,"KRN",19,"NM",31,0)
XOBV JUNIT TESTER^^1^
"BLD",4063,"KRN",19,"NM","B","XOBV JUNIT TESTER",31)

"BLD",4063,"KRN",19,"NM","B","XOBV LISTENER STARTUP",29)

"BLD",4063,"KRN",19,"NM","B","XOBV VISTALINK TESTER",30)

"BLD",4063,"KRN",19.1,0)
19.1
"BLD",4063,"KRN",19.1,"NM",0)
^9.68A^^
"BLD",4063,"KRN",101,0)
101
"BLD",4063,"KRN",101,"NM",0)
^9.68A^18^7
"BLD",4063,"KRN",101,"NM",12,0)
XOBV LISTENER BOX-VOL^^0
"BLD",4063,"KRN",101,"NM",13,0)
XOBV LISTENER CONFIG^^0
"BLD",4063,"KRN",101,"NM",14,0)
XOBV LISTENER LOG CLEAR^^0
"BLD",4063,"KRN",101,"NM",15,0)
XOBV LISTENER START^^0
"BLD",4063,"KRN",101,"NM",16,0)
XOBU FOUNDATIONS MAIN MENU^^2
"BLD",4063,"KRN",101,"NM",17,0)
XOBV LISTENER STOP^^0
"BLD",4063,"KRN",101,"NM",18,0)
XOBV LISTENER CONNECTOR PROXY^^0
"BLD",4063,"KRN",101,"NM","B","XOBU FOUNDATIONS MAIN MENU",16)

"BLD",4063,"KRN",101,"NM","B","XOBV LISTENER BOX-VOL",12)

"BLD",4063,"KRN",101,"NM","B","XOBV LISTENER CONFIG",13)

"BLD",4063,"KRN",101,"NM","B","XOBV LISTENER CONNECTOR PROXY",18)

"BLD",4063,"KRN",101,"NM","B","XOBV LISTENER LOG CLEAR",14)

"BLD",4063,"KRN",101,"NM","B","XOBV LISTENER START",15)

"BLD",4063,"KRN",101,"NM","B","XOBV LISTENER STOP",17)

"BLD",4063,"KRN",409.61,0)
409.61
"BLD",4063,"KRN",409.61,"NM",0)
^9.68A^^0
"BLD",4063,"KRN",771,0)
771
"BLD",4063,"KRN",771,"NM",0)
^9.68A^^
"BLD",4063,"KRN",870,0)
870
"BLD",4063,"KRN",870,"NM",0)
^9.68A^^
"BLD",4063,"KRN",8994,0)
8994
"BLD",4063,"KRN",8994,"NM",0)
^9.68A^32^23
"BLD",4063,"KRN",8994,"NM",1,0)
XOBV TEST GLOBAL ARRAY^^0
"BLD",4063,"KRN",8994,"NM",2,0)
XOBV TEST GLOBAL NODE^^0
"BLD",4063,"KRN",8994,"NM",3,0)
XOBV TEST LOCAL ARRAY^^0
"BLD",4063,"KRN",8994,"NM",4,0)
XOBV TEST NOT IN CONTEXT^^0
"BLD",4063,"KRN",8994,"NM",5,0)
XOBV TEST PING^^0
"BLD",4063,"KRN",8994,"NM",6,0)
XOBV TEST RPC LIST^^0
"BLD",4063,"KRN",8994,"NM",7,0)
XOBV TEST STRING^^0
"BLD",4063,"KRN",8994,"NM",9,0)
XOBV TEST WORD PROCESSING^^0
"BLD",4063,"KRN",8994,"NM",10,0)
XOBV TEST XML RESULTS^^0
"BLD",4063,"KRN",8994,"NM",11,0)
XOBV TEST MULTIPLE SUBSCRIPTS^^0
"BLD",4063,"KRN",8994,"NM",19,0)
XOBV TEST MULT ARRAY PARAMS^^0
"BLD",4063,"KRN",8994,"NM",20,0)
XOBV SYSTEMINFO^^0
"BLD",4063,"KRN",8994,"NM",22,0)
XOBV TEST EXTENDED ASCII^^1^
"BLD",4063,"KRN",8994,"NM",23,0)
XOBV TEST JUNIT RPC VERSION^^1^
"BLD",4063,"KRN",8994,"NM",24,0)
XOBV TEST JUNIT SWITCH ARR2GLB^^1^
"BLD",4063,"KRN",8994,"NM",25,0)
XOBV TEST JUNIT SWITCH ARR2SV^^1^
"BLD",4063,"KRN",8994,"NM",26,0)
XOBV TEST JUNIT SWITCH GLB2ARR^^1^
"BLD",4063,"KRN",8994,"NM",27,0)
XOBV TEST JUNIT SWITCH GLB2SV^^1^
"BLD",4063,"KRN",8994,"NM",28,0)
XOBV TEST JUNIT SWITCH SV2ARR^^1^
"BLD",4063,"KRN",8994,"NM",29,0)
XOBV TEST JUNIT SWITCH SV2GLB^^1^
"BLD",4063,"KRN",8994,"NM",30,0)
XOBV TEST JUNIT NOAPPPROXY^^1^
"BLD",4063,"KRN",8994,"NM",31,0)
XOBV TEST JUNIT EXTENDED ASCII^^1^
"BLD",4063,"KRN",8994,"NM",32,0)
XOBV TEST JUNIT RPC TIMEOUT^^1^
"BLD",4063,"KRN",8994,"NM","B","XOBV SYSTEMINFO",20)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST EXTENDED ASCII",22)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST GLOBAL ARRAY",1)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST GLOBAL NODE",2)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST JUNIT EXTENDED ASCII",31)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST JUNIT NOAPPPROXY",30)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST JUNIT RPC TIMEOUT",32)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST JUNIT RPC VERSION",23)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST JUNIT SWITCH ARR2GLB",24)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST JUNIT SWITCH ARR2SV",25)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST JUNIT SWITCH GLB2ARR",26)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST JUNIT SWITCH GLB2SV",27)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST JUNIT SWITCH SV2ARR",28)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST JUNIT SWITCH SV2GLB",29)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST LOCAL ARRAY",3)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST MULT ARRAY PARAMS",19)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST MULTIPLE SUBSCRIPTS",11)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST NOT IN CONTEXT",4)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST PING",5)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST RPC LIST",6)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST STRING",7)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST WORD PROCESSING",9)

"BLD",4063,"KRN",8994,"NM","B","XOBV TEST XML RESULTS",10)

"BLD",4063,"KRN","B",.4,.4)

"BLD",4063,"KRN","B",.401,.401)

"BLD",4063,"KRN","B",.402,.402)

"BLD",4063,"KRN","B",.403,.403)

"BLD",4063,"KRN","B",.5,.5)

"BLD",4063,"KRN","B",.84,.84)

"BLD",4063,"KRN","B",3.6,3.6)

"BLD",4063,"KRN","B",3.8,3.8)

"BLD",4063,"KRN","B",9.2,9.2)

"BLD",4063,"KRN","B",9.8,9.8)

"BLD",4063,"KRN","B",19,19)

"BLD",4063,"KRN","B",19.1,19.1)

"BLD",4063,"KRN","B",101,101)

"BLD",4063,"KRN","B",409.61,409.61)

"BLD",4063,"KRN","B",771,771)

"BLD",4063,"KRN","B",870,870)

"BLD",4063,"KRN","B",8994,8994)

"BLD",4063,"QUES",0)
^9.62^^
"BLD",4063,"REQB",0)
^9.611^3^2
"BLD",4063,"REQB",2,0)
XOBU 1.6^2
"BLD",4063,"REQB",3,0)
XU*8.0*425^2
"BLD",4063,"REQB","B","XOBU 1.6",2)

"BLD",4063,"REQB","B","XU*8.0*425",3)

"DATA",18.05,1,0)
XOBV RPC REQUEST^gov.va.med.foundations.rpc.request^1^1^XOBVRPCI^1^XOB RPC
"DATA",18.05,2,0)
XOBS REQUEST^gov.va.med.foundations.security.request^1^0^XOBSCI^1
"DATA",18.05,3,0)
XOBV SYSTEM REQUEST^gov.va.med.foundations.vistalink.system.request^1^0^XOBVSYSI^1
"FIA",18.03)
VISTALINK LISTENER CONFIGURATION
"FIA",18.03,0)
^XOB(18.03,
"FIA",18.03,0,0)
18.03I
"FIA",18.03,0,1)
y^y^f^^^^n
"FIA",18.03,0,10)

"FIA",18.03,0,11)

"FIA",18.03,0,"RLRO")

"FIA",18.03,0,"VR")
1.6^XOBV
"FIA",18.03,18.03)
0
"FIA",18.03,18.031)
0
"FIA",18.04)
VISTALINK LISTENER STARTUP LOG
"FIA",18.04,0)
^XOB(18.04,
"FIA",18.04,0,0)
18.04PI
"FIA",18.04,0,1)
y^y^f^^^^n
"FIA",18.04,0,10)

"FIA",18.04,0,11)

"FIA",18.04,0,"RLRO")

"FIA",18.04,0,"VR")
1.6^XOBV
"FIA",18.04,18.04)
0
"FIA",18.05)
VISTALINK MESSAGE TYPE
"FIA",18.05,0)
^XOB(18.05,
"FIA",18.05,0,0)
18.05
"FIA",18.05,0,1)
y^y^f^^n^^y^o^n
"FIA",18.05,0,10)

"FIA",18.05,0,11)

"FIA",18.05,0,"RLRO")

"FIA",18.05,0,"VR")
1.6^XOBV
"FIA",18.05,18.05)
0
"INI")
EN^XOBVPRE
"INIT")
EN^XOBVPOST
"IX",18.04,18.04,"C",0)
18.04^C^Used to find BOX-VOL / PORT for stopping listener^R^^R^IR^I^18.04^^^^^LS
"IX",18.04,18.04,"C",1)
S ^XOB(18.04,"C",X(1),X(2),DA)=""
"IX",18.04,18.04,"C",2)
K ^XOB(18.04,"C",X(1),X(2),DA)
"IX",18.04,18.04,"C",2.5)
K ^XOB(18.04,"C")
"IX",18.04,18.04,"C",11.1,0)
^.114IA^2^2
"IX",18.04,18.04,"C",11.1,1,0)
1^F^18.04^.01^^1^F
"IX",18.04,18.04,"C",11.1,1,3)

"IX",18.04,18.04,"C",11.1,2,0)
2^F^18.04^.02^^2^F
"IX",18.04,18.04,"C",11.1,2,3)

"IX",18.05,18.05,"MSGTYPE",0)
18.05^MSGTYPE^Message type cross reference^R^^F^IR^I^18.05^^^^^LS
"IX",18.05,18.05,"MSGTYPE",1)
S ^XOB(18.05,"MSGTYPE",$E(X,1,80),DA)=""
"IX",18.05,18.05,"MSGTYPE",2)
K ^XOB(18.05,"MSGTYPE",$E(X,1,80),DA)
"IX",18.05,18.05,"MSGTYPE",2.5)
K ^XOB(18.05,"MSGTYPE")
"IX",18.05,18.05,"MSGTYPE",11.1,0)
^.114IA^1^1
"IX",18.05,18.05,"MSGTYPE",11.1,1,0)
1^F^18.05^.02^80^1^F
"IX",18.05,18.05,"MSGTYPE",11.1,1,3)

"IX",18.05,18.05,"NAME",0)
18.05^NAME^Name cross reference^R^^F^IR^I^18.05^^^^^LS
"IX",18.05,18.05,"NAME",1)
S ^XOB(18.05,"NAME",$E(X,1,30),DA)=""
"IX",18.05,18.05,"NAME",2)
K ^XOB(18.05,"NAME",$E(X,1,30),DA)
"IX",18.05,18.05,"NAME",2.5)
K ^XOB(18.05,"NAME")
"IX",18.05,18.05,"NAME",11.1,0)
^.114IA^1^1
"IX",18.05,18.05,"NAME",11.1,1,0)
1^F^18.05^.01^30^1^F
"IX",18.05,18.05,"NAME",11.1,1,3)

"KEY",18.05,18.05,"A",0)
18.05^A^P^60
"KEY",18.05,18.05,"A",2,0)
^.312IA^1^1
"KEY",18.05,18.05,"A",2,1,0)
.01^18.05^1
"KEY",18.05,18.05,"B",0)
18.05^B^S^59
"KEY",18.05,18.05,"B",2,0)
^.312IA^1^1
"KEY",18.05,18.05,"B",2,1,0)
.02^18.05^1
"KEYPTR",18.05,18.05,"A")
18.05^NAME
"KEYPTR",18.05,18.05,"B")
18.05^MSGTYPE
"KRN",.402,2167,-1)
0^2
"KRN",.402,2167,0)
XOBV LISTENER CONFIG EDIT^3030330.1949^@^18.03^^@^3090306
"KRN",.402,2167,"%D",0)
^^3^3^3030409^
"KRN",.402,2167,"%D",1,0)
This template is used to add/edit a VistALink Listener configuration.
"KRN",.402,2167,"%D",2,0)
  
"KRN",.402,2167,"%D",3,0)
The XOBV LISTENER CONFIG protocol executes this template.  
"KRN",.402,2167,"DR",1,18.03)
.01;100;
"KRN",.402,2167,"DR",2,18.031)
.01;.02;
"KRN",.84,181001,-1)
0^1
"KRN",.84,181001,0)
181001^1^y^VISTALINK^VistALink System Error
"KRN",.84,181001,1,0)
^.842^7^7^3050317^^
"KRN",.84,181001,1,1,0)
Error reported when an unanticipated error occurs on the M server e.g., an
"KRN",.84,181001,1,2,0)
undefined error.
"KRN",.84,181001,1,3,0)
 
"KRN",.84,181001,1,4,0)
 Java Exception Information:
"KRN",.84,181001,1,5,0)
 
"KRN",.84,181001,1,6,0)
 Category: Interaction Fault 
"KRN",.84,181001,1,7,0)
 Exception: VistaLinkFaultException
"KRN",.84,181001,2,0)
^.844^1^1^3030407^^^
"KRN",.84,181001,2,1,0)
A system error occurred in M: |1|
"KRN",.84,181001,3,0)
^.845^1^1
"KRN",.84,181001,3,1,0)
1^Error message to be returned.
"KRN",.84,181001,5,0)
^.841^1^1
"KRN",.84,181001,5,1,0)
XOBVLL^SYSERR
"KRN",.84,181001,5,"B","XOBVLL",1)

"KRN",.84,181002,-1)
0^2
"KRN",.84,181002,0)
181002^1^^VISTALINK^No Null Device
"KRN",.84,181002,1,0)
^.842^7^7^3050317^^^
"KRN",.84,181002,1,1,0)
Error reported when the M server does not have a null device defined.
"KRN",.84,181002,1,2,0)
 
"KRN",.84,181002,1,3,0)
 
"KRN",.84,181002,1,4,0)
 Java Exception Information:
"KRN",.84,181002,1,5,0)
 
"KRN",.84,181002,1,6,0)
 Category: Interaction Fault
"KRN",.84,181002,1,7,0)
 Exception: VistaLinkFaultException
"KRN",.84,181002,2,0)
^.844^1^1^3030407^^
"KRN",.84,181002,2,1,0)
System does not have a null device.
"KRN",.84,181002,5,0)
^.841^1^1
"KRN",.84,181002,5,1,0)
XOBVLL^NXTCALL
"KRN",.84,181002,5,"B","XOBVLL",1)

"KRN",.84,181003,-1)
0^11
"KRN",.84,181003,0)
181003^1^^VISTALINK^No jobs slots available
"KRN",.84,181003,1,0)
^^7^7^3030411^
"KRN",.84,181003,1,1,0)
Error reported when there are no license slots available to start another
"KRN",.84,181003,1,2,0)
process.
"KRN",.84,181003,1,3,0)
 
"KRN",.84,181003,1,4,0)
 Java Exception Information:
"KRN",.84,181003,1,5,0)
 
"KRN",.84,181003,1,6,0)
 Category: Connection Fault
"KRN",.84,181003,1,7,0)
 Exception: NoJobSlostAvailableFaultException
"KRN",.84,181003,2,0)
^.844^1^1^3030407^^^
"KRN",.84,181003,2,1,0)
No jobs slots available
"KRN",.84,181003,5,0)
^.841^1^1
"KRN",.84,181003,5,1,0)
XOBVTCPL^NEWOK
"KRN",.84,181003,5,"B","XOBVTCPL",1)

"KRN",.84,181004,-1)
0^12
"KRN",.84,181004,0)
181004^1^^VISTALINK^Logins Disabled
"KRN",.84,181004,1,0)
^.842^6^6^3031210^^^^
"KRN",.84,181004,1,1,0)
Error reported when the site sets the parameter to not allow any logins.
"KRN",.84,181004,1,2,0)
 
"KRN",.84,181004,1,3,0)
 Java Exception Information: 
"KRN",.84,181004,1,4,0)
 
"KRN",.84,181004,1,5,0)
 Category: Connection Fault
"KRN",.84,181004,1,6,0)
 Exception: LoginsDisabledFaultException
"KRN",.84,181004,2,0)
^.844^1^1^3030414^^^^
"KRN",.84,181004,2,1,0)
Logins Disabled
"KRN",.84,181004,5,0)
^.841^2^2
"KRN",.84,181004,5,1,0)
XOBVTCPL^NEWOK
"KRN",.84,181004,5,2,0)
XOBSRA^LOGINH
"KRN",.84,181004,5,"B","XOBSRA",2)

"KRN",.84,181004,5,"B","XOBVTCPL",1)

"KRN",.84,182001,-1)
0^3
"KRN",.84,182001,0)
182001^1^^VISTALINK^No RPC name
"KRN",.84,182001,1,0)
^.842^7^7^3031021^^^^
"KRN",.84,182001,1,1,0)
Error reported when the request fails to indicate an RPC name.
"KRN",.84,182001,1,2,0)
 
"KRN",.84,182001,1,3,0)
 
"KRN",.84,182001,1,4,0)
 Java Exception Information:
"KRN",.84,182001,1,5,0)
 
"KRN",.84,182001,1,6,0)
 Category: RPC Processing Fault
"KRN",.84,182001,1,7,0)
 Exception: RpcFaultException
"KRN",.84,182001,2,0)
^.844^1^1^3030407^^
"KRN",.84,182001,2,1,0)
No Remote Procedure Specified.
"KRN",.84,182001,5,0)
^.841^2^2
"KRN",.84,182001,5,1,0)
XOBRPC^EN
"KRN",.84,182001,5,2,0)
XOBVRPC^EN
"KRN",.84,182001,5,"B","XOBRPC",1)

"KRN",.84,182001,5,"B","XOBVRPC",2)

"KRN",.84,182002,-1)
0^4
"KRN",.84,182002,0)
182002^1^y^VISTALINK^RPC Unknown
"KRN",.84,182002,1,0)
^.842^8^8^3030407^^^
"KRN",.84,182002,1,1,0)
Error reported when the RPC passed as part of the request does not exist 
"KRN",.84,182002,1,2,0)
on the M server.
"KRN",.84,182002,1,3,0)
 
"KRN",.84,182002,1,4,0)
 
"KRN",.84,182002,1,5,0)
 Java Exception Information:
"KRN",.84,182002,1,6,0)
 
"KRN",.84,182002,1,7,0)
 Category: RPC Processing Fault
"KRN",.84,182002,1,8,0)
 Exception: RpcFaultException
"KRN",.84,182002,2,0)
^.844^1^1^3030407^^^
"KRN",.84,182002,2,1,0)
Remote Procedure Unknown: '|1|' cannot be found.
"KRN",.84,182002,3,0)
^.845^1^1
"KRN",.84,182002,3,1,0)
1^Name of unknown RPC
"KRN",.84,182002,5,0)
^.841^2^2
"KRN",.84,182002,5,1,0)
XOBRPC^EN
"KRN",.84,182002,5,2,0)
XOBVRPC^EN
"KRN",.84,182002,5,"B","XOBRPC",1)

"KRN",.84,182002,5,"B","XOBVRPC",2)

"KRN",.84,182003,-1)
0^5
"KRN",.84,182003,0)
182003^1^y^VISTALINK^Blank RPC data
"KRN",.84,182003,1,0)
^.842^8^8^3050317^^
"KRN",.84,182003,1,1,0)
Error reported when the entry for the RPC in the REMOTE PROCEDURE file 
"KRN",.84,182003,1,2,0)
does not exist. The cross reference exists for the name but the data does 
"KRN",.84,182003,1,3,0)
not. (very rare)
"KRN",.84,182003,1,4,0)
 
"KRN",.84,182003,1,5,0)
 Java Exception Information:
"KRN",.84,182003,1,6,0)
 
"KRN",.84,182003,1,7,0)
 Category: RPC Processing Fault
"KRN",.84,182003,1,8,0)
 Exception: RpcFaultException
"KRN",.84,182003,2,0)
^.844^1^1^3030407^^
"KRN",.84,182003,2,1,0)
Remote Procedure Blank: '|1|' contains no information.
"KRN",.84,182003,3,0)
^.845^1^1
"KRN",.84,182003,3,1,0)
1^Name of RPC
"KRN",.84,182003,5,0)
^.841^2^2
"KRN",.84,182003,5,1,0)
XOBRPC^EN
"KRN",.84,182003,5,2,0)
XOBVRPC^EN
"KRN",.84,182003,5,"B","XOBRPC",1)

"KRN",.84,182003,5,"B","XOBVRPC",2)

"KRN",.84,182004,-1)
0^6
"KRN",.84,182004,0)
182004^1^y^VISTALINK^Inactive RPC
"KRN",.84,182004,1,0)
^.842^7^7^3030407^^^
"KRN",.84,182004,1,1,0)
Error reported when the RPC has been disabled on the M server.
"KRN",.84,182004,1,2,0)
 
"KRN",.84,182004,1,3,0)
 
"KRN",.84,182004,1,4,0)
 Java Exception Information:
"KRN",.84,182004,1,5,0)
 
"KRN",.84,182004,1,6,0)
 Category: RPC Processing Fault
"KRN",.84,182004,1,7,0)
 Exception: RpcFaultException
"KRN",.84,182004,2,0)
^.844^1^1^3030407^^
"KRN",.84,182004,2,1,0)
Remote Procedure InActive: '|1|' cannot be run at this time.
"KRN",.84,182004,3,0)
^.845^1^1
"KRN",.84,182004,3,1,0)
1^Name of RPC
"KRN",.84,182004,5,0)
^.841^2^2
"KRN",.84,182004,5,1,0)
XOBRPC^EN
"KRN",.84,182004,5,2,0)
XOBVRPC^EN
"KRN",.84,182004,5,"B","XOBRPC",1)

"KRN",.84,182004,5,"B","XOBVRPC",2)

"KRN",.84,182005,-1)
0^7
"KRN",.84,182005,0)
182005^1^y^VISTALINK^RPC not in context
"KRN",.84,182005,1,0)
^.842^7^7^3050310^^^^
"KRN",.84,182005,1,1,0)
Error reported when the RPC requested to be executed is not contained in 
"KRN",.84,182005,1,2,0)
the current RPC context.
"KRN",.84,182005,1,3,0)
 
"KRN",.84,182005,1,4,0)
 Java Exception Information:
"KRN",.84,182005,1,5,0)
 
"KRN",.84,182005,1,6,0)
 Category: RPC Processing Fault
"KRN",.84,182005,1,7,0)
 Exception: RpcNotInContextFaultException
"KRN",.84,182005,2,0)
^.844^1^1^3050310^^^
"KRN",.84,182005,2,1,0)
RPC Context Error :: |1|
"KRN",.84,182005,3,0)
^.845^1^1
"KRN",.84,182005,3,1,0)
1^Error message returned. Message contains name of RPC and context name.
"KRN",.84,182005,5,0)
^.841^2^2
"KRN",.84,182005,5,1,0)
XOBRPC^EN
"KRN",.84,182005,5,2,0)
XOBVRPC^EN
"KRN",.84,182005,5,"B","XOBRPC",1)

"KRN",.84,182005,5,"B","XOBVRPC",2)

"KRN",.84,182006,-1)
0^8
"KRN",.84,182006,0)
182006^1^y^VISTALINK^No RPC Context
"KRN",.84,182006,1,0)
^^9^9^3030411^
"KRN",.84,182006,1,1,0)
Error reported when either: 1) the RPC context option does not exit on the
"KRN",.84,182006,1,2,0)
M server or 2) the current user has not been given access to the
"KRN",.84,182006,1,3,0)
associated option for the context.
"KRN",.84,182006,1,4,0)
 
"KRN",.84,182006,1,5,0)
 
"KRN",.84,182006,1,6,0)
 Java Exception Information:
"KRN",.84,182006,1,7,0)
 
"KRN",.84,182006,1,8,0)
 Category: RPC Processing Fault
"KRN",.84,182006,1,9,0)
 Exception: NoRpcContextFaultException
"KRN",.84,182006,2,0)
^.844^1^1^3030407^^
"KRN",.84,182006,2,1,0)
|1|
"KRN",.84,182006,3,0)
^.845^1^1
"KRN",.84,182006,3,1,0)
1^Error message to be returned. Message contains the name of the context.
"KRN",.84,182006,5,0)
^.841^2^2
"KRN",.84,182006,5,1,0)
XOBRPC^EN
"KRN",.84,182006,5,2,0)
XOBVRPC^EN
"KRN",.84,182006,5,"B","XOBRPC",1)

"KRN",.84,182006,5,"B","XOBVRPC",2)

"KRN",.84,182007,-1)
0^9
"KRN",.84,182007,0)
182007^1^y^VISTALINK^RPC Timeout
"KRN",.84,182007,1,0)
^^11^11^3030411^
"KRN",.84,182007,1,1,0)
Error reported when the M server cannot return the RPC results before the 
"KRN",.84,182007,1,2,0)
RPC timeout expires.
"KRN",.84,182007,1,3,0)
 
"KRN",.84,182007,1,4,0)
Note: This error can only be returned if the RPC code honors the timeout 
"KRN",.84,182007,1,5,0)
specification.
"KRN",.84,182007,1,6,0)
 
"KRN",.84,182007,1,7,0)
 
"KRN",.84,182007,1,8,0)
 Java Exception Information:
"KRN",.84,182007,1,9,0)
 
"KRN",.84,182007,1,10,0)
 Category: RPC Processing Fault
"KRN",.84,182007,1,11,0)
 Exception: RpcTimeOutFaultException
"KRN",.84,182007,2,0)
^.844^1^1^3030407^^^
"KRN",.84,182007,2,1,0)
Remote Procedure: '|1|' timed out. (|2| seconds)
"KRN",.84,182007,3,0)
^.845^2^2
"KRN",.84,182007,3,1,0)
1^Name of RPC
"KRN",.84,182007,3,2,0)
2^Timeout duration in seconds
"KRN",.84,182007,5,0)
^.841^2^2
"KRN",.84,182007,5,1,0)
XOBRPC^EN
"KRN",.84,182007,5,2,0)
XOBVRPC^EN
"KRN",.84,182007,5,"B","XOBRPC",1)

"KRN",.84,182007,5,"B","XOBVRPC",2)

"KRN",.84,182008,-1)
0^10
"KRN",.84,182008,0)
182008^1^y^VISTALINK^RPC Entry Different
"KRN",.84,182008,1,0)
^^8^8^3030411^
"KRN",.84,182008,1,1,0)
Error reported when the entry for the RPC in the REMOTE PROCEDURE file 
"KRN",.84,182008,1,2,0)
is different than the RPC requested. The cross reference exists for the
"KRN",.84,182008,1,3,0)
name but the entry is not for the RPC in the cross reference. (very rare)
"KRN",.84,182008,1,4,0)
 
"KRN",.84,182008,1,5,0)
 Java Exception Information:
"KRN",.84,182008,1,6,0)
 
"KRN",.84,182008,1,7,0)
 Category: RPC Processing Fault
"KRN",.84,182008,1,8,0)
 Exception: RpcFaultException
"KRN",.84,182008,2,0)
^.844^1^1^3030407^^
"KRN",.84,182008,2,1,0)
Remote Procedure Name '|1|' is different than file entry (|2|).
"KRN",.84,182008,3,0)
^.845^2^2
"KRN",.84,182008,3,1,0)
1^Name of RPC requested
"KRN",.84,182008,3,2,0)
2^Name of RPC for entry in file.
"KRN",.84,182008,5,0)
^.841^2^2
"KRN",.84,182008,5,1,0)
XOBRPC^EN
"KRN",.84,182008,5,2,0)
XOBVRPC^EN
"KRN",.84,182008,5,"B","XOBRPC",1)

"KRN",.84,182008,5,"B","XOBVRPC",2)

"KRN",.84,182009,-1)
0^14
"KRN",.84,182009,0)
182009^1^y^VISTALINK^RPC Version Handler Mismatch
"KRN",.84,182009,1,0)
^.842^9^9^3031021^^
"KRN",.84,182009,1,1,0)
Error reported when the client is using an RPC handler version not 
"KRN",.84,182009,1,2,0)
compatible with the M server RPC handler version.
"KRN",.84,182009,1,3,0)
 
"KRN",.84,182009,1,4,0)
 
"KRN",.84,182009,1,5,0)
 
"KRN",.84,182009,1,6,0)
 Java Exception Information: 
"KRN",.84,182009,1,7,0)
 
"KRN",.84,182009,1,8,0)
 Category: RPC Processing Fault 
"KRN",.84,182009,1,9,0)
 Exception: RpcFaultException
"KRN",.84,182009,2,0)
^^1^1^3031021^
"KRN",.84,182009,2,1,0)
RPC Handler Version Error: Client Ver: |1|  Server Ver: |2|  [|3|]
"KRN",.84,182009,3,0)
^.845^3^3
"KRN",.84,182009,3,1,0)
1^Client RPC Handler Version
"KRN",.84,182009,3,2,0)
2^Current Server RPC Handler Version
"KRN",.84,182009,3,3,0)
3^Comment
"KRN",.84,182009,5,0)
^.841^1^1
"KRN",.84,182009,5,1,0)
XOBVRPC^VER
"KRN",.84,182009,5,"B","XOBVRPC",1)

"KRN",.84,182010,-1)
0^15
"KRN",.84,182010,0)
182010^1^y^VISTALINK SECURITY^Application Proxy not allowed to run RPC
"KRN",.84,182010,1,0)
^^7^7^3050317^
"KRN",.84,182010,1,1,0)
Returned if an Application Proxy user is not allowed to run the 
"KRN",.84,182010,1,2,0)
specified RPC.
"KRN",.84,182010,1,3,0)
 
"KRN",.84,182010,1,4,0)
 Java Exception Information: 
"KRN",.84,182010,1,5,0)
  
"KRN",.84,182010,1,6,0)
 Category: RPC Processing Fault
"KRN",.84,182010,1,7,0)
 Exception: RpcNotOkForProxyUseException
"KRN",.84,182010,2,0)
^.844^1^1^3050311^^^^
"KRN",.84,182010,2,1,0)
Application Proxy user not allowed to run RPC: '|1|'
"KRN",.84,182010,3,0)
^.845^1^1
"KRN",.84,182010,3,1,0)
1^Error message returned containing RPC name.
"KRN",.84,182010,5,0)
^.841^1^1
"KRN",.84,182010,5,1,0)
XOBVRPC^EN
"KRN",.84,182010,5,"B","XOBVRPC",1)

"KRN",.84,184001,-1)
0^13
"KRN",.84,184001,0)
184001^1^y^VISTALINK^Unable to load request handler
"KRN",.84,184001,1,0)
^^8^8^3030411^
"KRN",.84,184001,1,1,0)
Error reported when the Request Manager can not process the message
"KRN",.84,184001,1,2,0)
request type passed as part of the request.
"KRN",.84,184001,1,3,0)
 
"KRN",.84,184001,1,4,0)
 
"KRN",.84,184001,1,5,0)
 Java Exception Information:
"KRN",.84,184001,1,6,0)
 
"KRN",.84,184001,1,7,0)
 Category: Request Manager Processing Fault
"KRN",.84,184001,1,8,0)
 Exception: RequestManagerFaultException
"KRN",.84,184001,2,0)
^.844^1^1^3030407^^^^
"KRN",.84,184001,2,1,0)
Request Handler Loading Error: |1|
"KRN",.84,184001,3,0)
^.845^1^1
"KRN",.84,184001,3,1,0)
1^Error message to be returned. Message contains the proprietary string indicator.
"KRN",.84,184001,5,0)
^.841^3^3
"KRN",.84,184001,5,1,0)
XOBRM^EN
"KRN",.84,184001,5,2,0)
XOBVLL^SPAWN
"KRN",.84,184001,5,3,0)
XOBVRM^EN
"KRN",.84,184001,5,"B","XOBRM",1)

"KRN",.84,184001,5,"B","XOBVLL",2)

"KRN",.84,184001,5,"B","XOBVRM",3)

"KRN",19,12439,-1)
0^30
"KRN",19,12439,0)
XOBV VISTALINK TESTER^VistALink Tester^^B^^^^^^^^VISTALINK
"KRN",19,12439,1,0)
^19.06^4^4^3060127^^^^
"KRN",19,12439,1,1,0)
This option is the VistALink Tester application context.
"KRN",19,12439,1,2,0)
 
"KRN",19,12439,1,3,0)
This application is used the help developers learn how to use VistALink
"KRN",19,12439,1,4,0)
and also for site staff to test VistALink Listener ports.
"KRN",19,12439,99.1)
61255,40974
"KRN",19,12439,"RPC",0)
^19.05P^14^13
"KRN",19,12439,"RPC",1,0)
XOBV TEST GLOBAL ARRAY
"KRN",19,12439,"RPC",2,0)
XOBV TEST GLOBAL NODE
"KRN",19,12439,"RPC",3,0)
XOBV TEST LOCAL ARRAY
"KRN",19,12439,"RPC",4,0)
XOBV TEST PING
"KRN",19,12439,"RPC",5,0)
XOBV TEST RPC LIST
"KRN",19,12439,"RPC",6,0)
XOBV TEST STRING
"KRN",19,12439,"RPC",8,0)
XOBV TEST WORD PROCESSING
"KRN",19,12439,"RPC",9,0)
XOBV TEST XML RESULTS
"KRN",19,12439,"RPC",10,0)
XWB EGCHO SORT LIST
"KRN",19,12439,"RPC",11,0)
XWB GET VARIABLE VALUE
"KRN",19,12439,"RPC",12,0)
XOBV TEST MULTIPLE SUBSCRIPTS
"KRN",19,12439,"RPC",13,0)
XOBV TEST MULT ARRAY PARAMS
"KRN",19,12439,"RPC",14,0)
XOBV SYSTEMINFO
"KRN",19,12439,"U")
VISTALINK TESTER
"KRN",19,12440,-1)
0^29
"KRN",19,12440,0)
XOBV LISTENER STARTUP^Start VistaLink Listener Configuration^^A^^^^^^^^VISTALINK^^1
"KRN",19,12440,1,0)
^^5^5^3030410^
"KRN",19,12440,1,1,0)
This option will get the VistALink Listener default configuration for 
"KRN",19,12440,1,2,0)
the BOX-VOLUME pair from the VISTALINK LISTENER CONFIGURATION file
"KRN",19,12440,1,3,0)
(#18.03) and start all applicable Listeners contained within the
"KRN",19,12440,1,4,0)
configuration.  This option is currently used by TaskMan for OpenM-NT
"KRN",19,12440,1,5,0)
systems only and is scheduled to run on system startup.
"KRN",19,12440,20)
DO STARTUP^XOBVTCP
"KRN",19,12440,"U")
START VISTALINK LISTENER CONFI
"KRN",19,12585,-1)
1^31
"KRN",19,12585,0)
XOBV JUNIT TESTER
"KRN",101,4968,-1)
0^15
"KRN",101,4968,0)
XOBV LISTENER START^Start Listener^^A^^^^^^^^VISTALINK
"KRN",101,4968,1,0)
^^1^1^3030410^
"KRN",101,4968,1,1,0)
This action protocol will start a single VistALink Listener.
"KRN",101,4968,20)
DO START^XOBUM
"KRN",101,4968,24)
IF $$GETOS^XOBVTCP()["OpenM"
"KRN",101,4968,99)
59263,43468
"KRN",101,4969,-1)
0^17
"KRN",101,4969,0)
XOBV LISTENER STOP^Stop Listener^^A^^^^^^^^VISTALINK
"KRN",101,4969,1,0)
^^1^1^3030410^
"KRN",101,4969,1,1,0)
This action protocol will stop a single VistALink Listener.
"KRN",101,4969,20)
DO STOP^XOBUM
"KRN",101,4969,24)
IF $$GETOS^XOBVTCP()["OpenM"
"KRN",101,4969,99)
59263,43468
"KRN",101,4970,-1)
0^13
"KRN",101,4970,0)
XOBV LISTENER CONFIG^Manage Configurations^^A^^^^^^^^VISTALINK
"KRN",101,4970,1,0)
^101.06^3^3^3050407^^
"KRN",101,4970,1,1,0)
This action protocol will add/edit an entry in the VISTALINK LISTENER
"KRN",101,4970,1,2,0)
CONFIGURATION file (#18.03) by invoking the XOBV LISTENER CONFIG EDIT
"KRN",101,4970,1,3,0)
input template.
"KRN",101,4970,20)
DO CFG^XOBUM
"KRN",101,4970,24)
IF $$GETOS^XOBVTCP()["OpenM"
"KRN",101,4970,99)
59263,43468
"KRN",101,4973,-1)
0^14
"KRN",101,4973,0)
XOBV LISTENER LOG CLEAR^Clean Up Log^^A^^^^^^^^VISTALINK
"KRN",101,4973,1,0)
^^2^2^3030410^
"KRN",101,4973,1,1,0)
This action protocol will delete non-active VistALink Listener log entries
"KRN",101,4973,1,2,0)
in the VISTALINK LISTENER STARTUP LOG file (#18.04).
"KRN",101,4973,20)
DO CLEAR^XOBUM
"KRN",101,4973,99)
59263,43468
"KRN",101,4976,-1)
0^12
"KRN",101,4976,0)
XOBV LISTENER BOX-VOL^Start Box^^A^^^^^^^^VISTALINK
"KRN",101,4976,1,0)
^^3^3^3030410^
"KRN",101,4976,1,1,0)
This action protocol will start all VistALink Listeners contained in the
"KRN",101,4976,1,2,0)
default configuration for the BOX-VOLUME pair whose STARTUP field is set
"KRN",101,4976,1,3,0)
to YES.
"KRN",101,4976,20)
DO BOX^XOBUM
"KRN",101,4976,24)
IF $$GETOS^XOBVTCP()["OpenM"
"KRN",101,4976,99)
59263,43468
"KRN",101,4979,-1)
0^18
"KRN",101,4979,0)
XOBV LISTENER CONNECTOR PROXY^Enter/Edit Connector Proxy User^^A^^^^^^^^VISTALINK
"KRN",101,4979,1,0)
^^5^5^3050407^
"KRN",101,4979,1,1,0)
This action protocol will allow the enter/edit of a connector proxy users.
"KRN",101,4979,1,2,0)
 
"KRN",101,4979,1,3,0)
If more detailed editing of a connector proxy user becomes necessary,
"KRN",101,4979,1,4,0)
utilize the usual user editing options, such as the Edit an Existing User
"KRN",101,4979,1,5,0)
[XUSEREDIT] option located on the User Management [XUSER] menu.
"KRN",101,4979,4)
^^^
"KRN",101,4979,20)
DO CP^XOBUM
"KRN",101,4979,24)
IF $DATA(^XUSEC("XUMGR",DUZ))
"KRN",101,4979,99)
59997,50690
"KRN",101,5016,-1)
2^16
"KRN",101,5016,0)
XOBU FOUNDATIONS MAIN MENU^Foundations Manager Menu^^M^1000000002^^^^^^^555
"KRN",101,5016,10,0)
^101.01PA^10^10
"KRN",101,5016,10,2,0)
4970^CFG^12^
"KRN",101,5016,10,2,"^")
XOBV LISTENER CONFIG
"KRN",101,5016,10,3,0)
4968^SL^21^
"KRN",101,5016,10,3,"^")
XOBV LISTENER START
"KRN",101,5016,10,4,0)
4969^STP^22^
"KRN",101,5016,10,4,"^")
XOBV LISTENER STOP
"KRN",101,5016,10,6,0)
4973^CU^24^
"KRN",101,5016,10,6,"^")
XOBV LISTENER LOG CLEAR
"KRN",101,5016,10,8,0)
4976^SB^23^
"KRN",101,5016,10,8,"^")
XOBV LISTENER BOX-VOL
"KRN",101,5016,10,9,0)
4979^CP^13^
"KRN",101,5016,10,9,"^")
XOBV LISTENER CONNECTOR PROXY
"KRN",8994,1440,-1)
0^7
"KRN",8994,1440,0)
XOBV TEST STRING^STRRP^XOBVLT^1^P^0^^^1^^1
"KRN",8994,1440,1,0)
^^5^5^3030408^
"KRN",8994,1440,1,1,0)
This simple RPC takes a string as input, adds some additional text 
"KRN",8994,1440,1,2,0)
to the string and returns the string back to the client.
"KRN",8994,1440,1,3,0)
 
"KRN",8994,1440,1,4,0)
This RPC is used as part of the test and learning application distributed
"KRN",8994,1440,1,5,0)
as part of VistALink.
"KRN",8994,1440,2,0)
^8994.02A^1^1
"KRN",8994,1440,2,1,0)
STRING^1^^1^1
"KRN",8994,1440,2,1,1,0)
^8994.021^1^1^3030408^^
"KRN",8994,1440,2,1,1,1,0)
A string to be returned back to the client.
"KRN",8994,1440,2,"B","STRING",1)

"KRN",8994,1440,2,"PARAMSEQ",1,1)

"KRN",8994,1440,3,0)
^^1^1^3030408^
"KRN",8994,1440,3,1,0)
Returns the input parameter string with additional text added.
"KRN",8994,1441,-1)
0^1
"KRN",8994,1441,0)
XOBV TEST GLOBAL ARRAY^GARRRP^XOBVLT^4^P^0^^1^1^^1
"KRN",8994,1441,1,0)
^8994.01^5^5^3060228^^
"KRN",8994,1441,1,1,0)
This simple RPC takes an array as input, sets the array into a global 
"KRN",8994,1441,1,2,0)
array and returns the global array information back to the client.
"KRN",8994,1441,1,3,0)
 
"KRN",8994,1441,1,4,0)
This RPC is used as part of the test and learning application distributed 
"KRN",8994,1441,1,5,0)
as part of VistALink.
"KRN",8994,1441,2,0)
^8994.02A^1^1
"KRN",8994,1441,2,1,0)
ARRAY^2^^1^1
"KRN",8994,1441,2,1,1,0)
^8994.021^1^1^3030408^^
"KRN",8994,1441,2,1,1,1,0)
An array of information.
"KRN",8994,1441,2,"B","ARRAY",1)

"KRN",8994,1441,2,"PARAMSEQ",1,1)

"KRN",8994,1441,3,0)
^^2^2^3030408^
"KRN",8994,1441,3,1,0)
Returns the input array information to the client after being placed in
"KRN",8994,1441,3,2,0)
a global array.
"KRN",8994,1442,-1)
0^2
"KRN",8994,1442,0)
XOBV TEST GLOBAL NODE^GNODERP^XOBVLT^5^P^0^^^1^^1
"KRN",8994,1442,1,0)
^^5^5^3030411^
"KRN",8994,1442,1,1,0)
This simple RPC takes a string as input, sets it as a global node and
"KRN",8994,1442,1,2,0)
returns the global node back to the client.
"KRN",8994,1442,1,3,0)
 
"KRN",8994,1442,1,4,0)
This RPC is used as part of the test and learning application distributed
"KRN",8994,1442,1,5,0)
as part of VistALink. 
"KRN",8994,1442,2,0)
^8994.02A^1^1
"KRN",8994,1442,2,1,0)
STRING^1^^1^1
"KRN",8994,1442,2,1,1,0)
^8994.021^1^1^3030408^^
"KRN",8994,1442,2,1,1,1,0)
A single string of information.
"KRN",8994,1442,2,"B","STRING",1)

"KRN",8994,1442,2,"PARAMSEQ",1,1)

"KRN",8994,1442,3,0)
^^2^2^3030408^
"KRN",8994,1442,3,1,0)
Returns the input string of information to the client after being
"KRN",8994,1442,3,2,0)
placed in a global node.
"KRN",8994,1443,-1)
0^3
"KRN",8994,1443,0)
XOBV TEST LOCAL ARRAY^LARRRP^XOBVLT^2^P^0^^0^1^^1
"KRN",8994,1443,1,0)
^^5^5^3030408^
"KRN",8994,1443,1,1,0)
This simple RPC takes an array as input, sets the array into a local 
"KRN",8994,1443,1,2,0)
array and returns the local array information back to the client.
"KRN",8994,1443,1,3,0)
 
"KRN",8994,1443,1,4,0)
This RPC is used as part of the test and learning application distributed 
"KRN",8994,1443,1,5,0)
as part of VistALink.
"KRN",8994,1443,2,0)
^8994.02A^1^1
"KRN",8994,1443,2,1,0)
ARRAY^2^^1^1
"KRN",8994,1443,2,1,1,0)
^8994.021^1^1^3030408^^
"KRN",8994,1443,2,1,1,1,0)
An array of information.
"KRN",8994,1443,2,"B","ARRAY",1)

"KRN",8994,1443,2,"PARAMSEQ",1,1)

"KRN",8994,1443,3,0)
^^2^2^3030408^
"KRN",8994,1443,3,1,0)
Returns the input array information returned to the client after being
"KRN",8994,1443,3,2,0)
placed in a local array.
"KRN",8994,1445,-1)
0^9
"KRN",8994,1445,0)
XOBV TEST WORD PROCESSING^WPRP^XOBVLT^3^P^0^^1^1^^1
"KRN",8994,1445,1,0)
^^6^6^3030411^
"KRN",8994,1445,1,1,0)
This simple RPC takes no input parameters and returns a 'chunk' of text.
"KRN",8994,1445,1,2,0)
This RPC is used to test whether VistALink properly transports 'chunks' of
"KRN",8994,1445,1,3,0)
text.
"KRN",8994,1445,1,4,0)
 
"KRN",8994,1445,1,5,0)
This RPC is used as part of the test and learning application distributed
"KRN",8994,1445,1,6,0)
as part of VistALink.
"KRN",8994,1445,3,0)
^^1^1^3030408^
"KRN",8994,1445,3,1,0)
Returns a 'chunk' of text. (Lincoln's Gettysburg Address)
"KRN",8994,1446,-1)
0^5
"KRN",8994,1446,0)
XOBV TEST PING^PINGRP^XOBVLT^1^P^0^^^1^^1
"KRN",8994,1446,1,0)
^8994.01^6^6^3060203^^
"KRN",8994,1446,1,1,0)
This simple RPC takes no input and returns a success message. This is the 
"KRN",8994,1446,1,2,0)
primary mechanism to test whether the client successfully connects to
"KRN",8994,1446,1,3,0)
an M server using VistALink.
"KRN",8994,1446,1,4,0)
                                      
"KRN",8994,1446,1,5,0)
This RPC is used as part of the test and learning application distributed
"KRN",8994,1446,1,6,0)
as part of VistALink.
"KRN",8994,1446,2,0)
^8994.02A^^0
"KRN",8994,1446,3,0)
^8994.03^3^3^3060203^^^
"KRN",8994,1446,3,1,0)
Returns a message that the execution of the RPC has been successful.
"KRN",8994,1446,3,2,0)
 
"KRN",8994,1446,3,3,0)
The message is: Ping Successful!
"KRN",8994,1447,-1)
0^6
"KRN",8994,1447,0)
XOBV TEST RPC LIST^RPCRP^XOBVLT^2^P^0^^^1^^1
"KRN",8994,1447,1,0)
^8994.01^5^5^3030411^^
"KRN",8994,1447,1,1,0)
This RPC returns a list of RPC names that begin with the characters 
"KRN",8994,1447,1,2,0)
indicated in the one input parameter.
"KRN",8994,1447,1,3,0)
 
"KRN",8994,1447,1,4,0)
This RPC is used as part of the test and learning application distributed
"KRN",8994,1447,1,5,0)
as part of VistALink.
"KRN",8994,1447,2,0)
^8994.02A^1^1
"KRN",8994,1447,2,1,0)
PREFIX^1^20^1^1
"KRN",8994,1447,2,1,1,0)
^8994.021^2^2^3030408^^
"KRN",8994,1447,2,1,1,1,0)
This parameter indicates the starting characters for the RPCs desired. 
"KRN",8994,1447,2,1,1,2,0)
(ie. the namespace prefix)
"KRN",8994,1447,2,"B","PREFIX",1)

"KRN",8994,1447,2,"PARAMSEQ",1,1)

"KRN",8994,1447,3,0)
^^2^2^3030408^
"KRN",8994,1447,3,1,0)
Returns a list of RPC names all beginning with the prefix indicated by the
"KRN",8994,1447,3,2,0)
one input parameter.
"KRN",8994,1448,-1)
0^10
"KRN",8994,1448,0)
XOBV TEST XML RESULTS^XMLRP^XOBVLT^1^P^0^^^1^^1
"KRN",8994,1448,1,0)
^^8^8^3030411^
"KRN",8994,1448,1,1,0)
This simple RPC takes no input parameters and returns a 'chunk' of data 
"KRN",8994,1448,1,2,0)
that is in XML format.
"KRN",8994,1448,1,3,0)
 
"KRN",8994,1448,1,4,0)
This RPC is used to test whether VistALink properly transports and parses 
"KRN",8994,1448,1,5,0)
application results in XML format.
"KRN",8994,1448,1,6,0)
 
"KRN",8994,1448,1,7,0)
This RPC is used as part of the test and learning application distributed
"KRN",8994,1448,1,8,0)
as part of VistALink.
"KRN",8994,1448,2,0)
^8994.02A^^0
"KRN",8994,1448,3,0)
^8994.03^1^1^3030408^^
"KRN",8994,1448,3,1,0)
Returns a string in XML format.
"KRN",8994,1449,-1)
0^4
"KRN",8994,1449,0)
XOBV TEST NOT IN CONTEXT^NOCNTXT^XOBVLT^1^R^0^^^1^^1
"KRN",8994,1449,1,0)
^8994.01^9^9^3030905^^
"KRN",8994,1449,1,1,0)
This RPC should not be used and returns the empty string (null).
"KRN",8994,1449,1,2,0)
 
"KRN",8994,1449,1,3,0)
This RPC is used to test the 'not in RPC context' check. 
"KRN",8994,1449,1,4,0)
 
"KRN",8994,1449,1,5,0)
For this reason, this RPC is specifically NOT in the 'XOBV VISTALINK
"KRN",8994,1449,1,6,0)
TESTER' B-type option in the OPTION (#19) file.
"KRN",8994,1449,1,7,0)
 
"KRN",8994,1449,1,8,0)
This RPC is used as part of the test and learning application distributed
"KRN",8994,1449,1,9,0)
as part of VistALink.
"KRN",8994,1449,3,0)
^8994.03^3^3^3030905^^^
"KRN",8994,1449,3,1,0)
Returns the empty string.
"KRN",8994,1449,3,2,0)
 
"KRN",8994,1449,3,3,0)
See description on the use of this RPC.
"KRN",8994,1457,-1)
0^11
"KRN",8994,1457,0)
XOBV TEST MULTIPLE SUBSCRIPTS^MSUBS^XOBVLT^2^P^0^^0^1^^1
"KRN",8994,1457,1,0)
^^9^9^3040623^
"KRN",8994,1457,1,1,0)
This RPC receives an array set up by a client. The client code indicates
"KRN",8994,1457,1,2,0)
that the array should be presented to the RPC as multiple M subscripts
"KRN",8994,1457,1,3,0)
(ex: DATA("TEXT",1,0) and not the usual DATA(1).
"KRN",8994,1457,1,4,0)
 
"KRN",8994,1457,1,5,0)
It sets the array into a local array and returns the local array
"KRN",8994,1457,1,6,0)
information back to the client.
"KRN",8994,1457,1,7,0)
 
"KRN",8994,1457,1,8,0)
This RPC is used as part of the test and learning application distributed 
"KRN",8994,1457,1,9,0)
as part of VistALink.
"KRN",8994,1457,2,0)
^8994.02A^1^1
"KRN",8994,1457,2,1,0)
ARRAY^2^^1^1
"KRN",8994,1457,2,1,1,0)
^8994.021^1^1^3040623^^^^
"KRN",8994,1457,2,1,1,1,0)
An array of information.
"KRN",8994,1457,2,"B","ARRAY",1)

"KRN",8994,1457,2,"PARAMSEQ",1,1)

"KRN",8994,1457,3,0)
^^2^2^3040625^
"KRN",8994,1457,3,1,0)
Returns the input array information returned to the client after being 
"KRN",8994,1457,3,2,0)
placed in a local array.
"KRN",8994,1461,-1)
0^19
"KRN",8994,1461,0)
XOBV TEST MULT ARRAY PARAMS^MARRAYS^XOBVLT^2^R^0^^0^1^^1
"KRN",8994,1461,1,0)
^^8^8^3041012^
"KRN",8994,1461,1,1,0)
This RPC receives 3 arrays set up by a client. This tests the capability
"KRN",8994,1461,1,2,0)
of VistaLink to support multiple array-type RPC parameters.
"KRN",8994,1461,1,3,0)
 
"KRN",8994,1461,1,4,0)
It sets each of the three arrays into a local array, sequentially, and
"KRN",8994,1461,1,5,0)
returns the local array back to the client.
"KRN",8994,1461,1,6,0)
 
"KRN",8994,1461,1,7,0)
This RPC is used as part of the test and learning application distributed
"KRN",8994,1461,1,8,0)
part of VistALink.
"KRN",8994,1461,2,0)
^8994.02A^3^3
"KRN",8994,1461,2,1,0)
ARRAY^2^^1^1
"KRN",8994,1461,2,1,1,0)
^^1^1^3041012^
"KRN",8994,1461,2,1,1,1,0)
An array of information.
"KRN",8994,1461,2,2,0)
ARRAY2^2^^1^2
"KRN",8994,1461,2,2,1,0)
^^1^1^3041012^
"KRN",8994,1461,2,2,1,1,0)
An array of information.
"KRN",8994,1461,2,3,0)
ARRAY3^2^^1^3
"KRN",8994,1461,2,3,1,0)
^^1^1^3041012^
"KRN",8994,1461,2,3,1,1,0)
An array of information.
"KRN",8994,1461,2,"B","ARRAY",1)

"KRN",8994,1461,2,"B","ARRAY2",2)

"KRN",8994,1461,2,"B","ARRAY3",3)

"KRN",8994,1461,2,"PARAMSEQ",1,1)

"KRN",8994,1461,2,"PARAMSEQ",2,2)

"KRN",8994,1461,2,"PARAMSEQ",3,3)

"KRN",8994,1461,3,0)
^^2^2^3041012^
"KRN",8994,1461,3,1,0)
The input array information returned to the client after being placed in a
"KRN",8994,1461,3,2,0)
local array.
"KRN",8994,1473,-1)
0^20
"KRN",8994,1473,0)
XOBV SYSTEMINFO^RPC^XOBVSYSI^2^R^^^^^^1
"KRN",8994,1473,1,0)
^^1^1^3041228^
"KRN",8994,1473,1,1,0)
Returns name^value pairs of system information about the M system.
"KRN",8994,1528,-1)
1^22
"KRN",8994,1528,0)
XOBV TEST EXTENDED ASCII
"KRN",8994,1529,-1)
1^23
"KRN",8994,1529,0)
XOBV TEST JUNIT RPC VERSION
"KRN",8994,1530,-1)
1^24
"KRN",8994,1530,0)
XOBV TEST JUNIT SWITCH ARR2GLB
"KRN",8994,1531,-1)
1^25
"KRN",8994,1531,0)
XOBV TEST JUNIT SWITCH ARR2SV
"KRN",8994,1532,-1)
1^26
"KRN",8994,1532,0)
XOBV TEST JUNIT SWITCH GLB2ARR
"KRN",8994,1533,-1)
1^27
"KRN",8994,1533,0)
XOBV TEST JUNIT SWITCH GLB2SV
"KRN",8994,1534,-1)
1^28
"KRN",8994,1534,0)
XOBV TEST JUNIT SWITCH SV2ARR
"KRN",8994,1535,-1)
1^29
"KRN",8994,1535,0)
XOBV TEST JUNIT SWITCH SV2GLB
"KRN",8994,1536,-1)
1^30
"KRN",8994,1536,0)
XOBV TEST JUNIT NOAPPPROXY
"KRN",8994,1537,-1)
1^31
"KRN",8994,1537,0)
XOBV TEST JUNIT EXTENDED ASCII
"KRN",8994,1538,-1)
1^32
"KRN",8994,1538,0)
XOBV TEST JUNIT RPC TIMEOUT
"MBREQ")
0
"ORD",0,9.8)
9.8;;1;RTNF^XPDTA;RTNE^XPDTA
"ORD",0,9.8,0)
ROUTINE
"ORD",7,.402)
.402;7;;;EDEOUT^DIFROMSO(.402,DA,"",XPDA);FPRE^DIFROMSI(.402,"",XPDA);EPRE^DIFROMSI(.402,DA,$E("N",$G(XPDNEW)),XPDA,"",OLDA);;EPOST^DIFROMSI(.402,DA,"",XPDA);DEL^DIFROMSK(.402,"",%)
"ORD",7,.402,0)
INPUT TEMPLATE
"ORD",9,.84)
.84;9;;;EDEOUT^DIFROMSO(.84,DA,"",XPDA);FPRE^DIFROMSI(.84,"",XPDA);EPRE^DIFROMSI(.84,DA,"",XPDA,"",OLDA);;EPOST^DIFROMSI(.84,DA,"",XPDA);DEL^DIFROMSK(.84,"",%)
"ORD",9,.84,0)
DIALOG
"ORD",15,101)
101;15;;;PRO^XPDTA;PROF1^XPDIA;PROE1^XPDIA;PROF2^XPDIA;;PRODEL^XPDIA
"ORD",15,101,0)
PROTOCOL
"ORD",16,8994)
8994;16;1;;;;;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",554,-1)
1^1
"PKG",554,0)
VISTALINK^XOBV^VistaLink
"PKG",554,20,0)
^9.402P^^
"PKG",554,22,0)
^9.49I^1^1
"PKG",554,22,1,0)
1.6^3090508
"PKG",554,22,1,1,0)
^^35^35^3090508
"PKG",554,22,1,1,1,0)
This build contains TCP/IP transport functionality that enables
"PKG",554,22,1,1,2,0)
synchronous communication from the following:
"PKG",554,22,1,1,3,0)
   1) from non-M based systems to M-based VistA servers
"PKG",554,22,1,1,4,0)
   2) from M VistA servers to non-M systems (typically Java/J2EE based
"PKG",554,22,1,1,5,0)
      systems)
"PKG",554,22,1,1,6,0)
 
"PKG",554,22,1,1,7,0)
The communications are in the form of requests. For requests received by
"PKG",554,22,1,1,8,0)
the M-based system, the VISTALINK package contains a Request Manager to
"PKG",554,22,1,1,9,0)
manage these requests. Requests are forwarded to the appropriate Request
"PKG",554,22,1,1,10,0)
Handler.
"PKG",554,22,1,1,11,0)
 
"PKG",554,22,1,1,12,0)
The VISTALINK package contains two native request handlers. One handles 
"PKG",554,22,1,1,13,0)
system-type requests, like client heartbeats and close socket requests. 
"PKG",554,22,1,1,14,0)
The other handler processes RPC requests.
"PKG",554,22,1,1,15,0)
 
"PKG",554,22,1,1,16,0)
Other packages can also supply handlers. For example, VISTALINK SECURITY
"PKG",554,22,1,1,17,0)
(XOBS) supplies a handler that is used to process VistA security-related
"PKG",554,22,1,1,18,0)
requests.
"PKG",554,22,1,1,19,0)
 
"PKG",554,22,1,1,20,0)
VISTALINK allows the following request formats:
"PKG",554,22,1,1,21,0)
   1) XML and conform to a XML Schema 
"PKG",554,22,1,1,22,0)
   2) a proprietary format (package must supply a proprietary parser)
"PKG",554,22,1,1,23,0)
   3) both 1 and 2
"PKG",554,22,1,1,24,0)
 
"PKG",554,22,1,1,25,0)
VISTALINK also supplies a Java/J2EE component that allows developers of
"PKG",554,22,1,1,26,0)
Java applications to make synchronous requests on the M server and for M
"PKG",554,22,1,1,27,0)
applications to make synchronous requests of Java/J2EE application
"PKG",554,22,1,1,28,0)
servers. The Java/J2EE side implements the J2EE Connector Architecture
"PKG",554,22,1,1,29,0)
v1.0 framework (J2CA).
"PKG",554,22,1,1,30,0)
 
"PKG",554,22,1,1,31,0)
** NOTE: As of 7/2005, VISTALINK only supports Java to M communication.
"PKG",554,22,1,1,32,0)
 
"PKG",554,22,1,1,33,0)
Finally, VISTALINK contains a number of library calls available to 
"PKG",554,22,1,1,34,0)
other packages for developing a request handler if needed. (Currently, 
"PKG",554,22,1,1,35,0)
only VISTALINK SECURITY is allowed to use these calls.)
"PKG",554,"VERSION")
1.6
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
17
"RTN","XOBVLIB")
0^3^B29603500
"RTN","XOBVLIB",1,0)
XOBVLIB ;; mjk/alb - VistaLink Programmer Library ; 07/27/2002  13:00
"RTN","XOBVLIB",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVLIB",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVLIB",4,0)
 QUIT
"RTN","XOBVLIB",5,0)
 ; --------------------------------------------------------------
"RTN","XOBVLIB",6,0)
 ;              Application Developer Supported Calls
"RTN","XOBVLIB",7,0)
 ; --------------------------------------------------------------
"RTN","XOBVLIB",8,0)
 ;
"RTN","XOBVLIB",9,0)
XMLHDR() ; -- provides current XML standard header 
"RTN","XOBVLIB",10,0)
 QUIT "<?xml version=""1.0"" encoding=""utf-8"" ?>"
"RTN","XOBVLIB",11,0)
 ;
"RTN","XOBVLIB",12,0)
CHARCHK(STR) ; -- replace xml character limits with entities
"RTN","XOBVLIB",13,0)
 NEW A,I,X,Y,Z,NEWSTR
"RTN","XOBVLIB",14,0)
 SET (Y,Z)=""
"RTN","XOBVLIB",15,0)
 IF STR["&" SET NEWSTR=STR DO  SET STR=Y_Z
"RTN","XOBVLIB",16,0)
 . FOR X=1:1  SET Y=Y_$PIECE(NEWSTR,"&",X)_"&amp;",Z=$PIECE(STR,"&",X+1,999) QUIT:Z'["&"
"RTN","XOBVLIB",17,0)
 IF STR["<" FOR  SET STR=$PIECE(STR,"<",1)_"&lt;"_$PIECE(STR,"<",2,99) QUIT:STR'["<"
"RTN","XOBVLIB",18,0)
 IF STR[">" FOR  SET STR=$PIECE(STR,">",1)_"&gt;"_$PIECE(STR,">",2,99) QUIT:STR'[">"
"RTN","XOBVLIB",19,0)
 IF STR["'" FOR  SET STR=$PIECE(STR,"'",1)_"&apos;"_$PIECE(STR,"'",2,99) QUIT:STR'["'"
"RTN","XOBVLIB",20,0)
 IF STR["""" FOR  SET STR=$PIECE(STR,"""",1)_"&quot;"_$PIECE(STR,"""",2,99) QUIT:STR'[""""
"RTN","XOBVLIB",21,0)
 ;
"RTN","XOBVLIB",22,0)
 FOR I=1:1:$LENGTH(STR) DO
"RTN","XOBVLIB",23,0)
 . SET X=$EXTRACT(STR,I)
"RTN","XOBVLIB",24,0)
 . SET A=$ASCII(X)
"RTN","XOBVLIB",25,0)
 . IF A<31 SET STR=$PIECE(STR,X,1)_$PIECE(STR,X,2,99)
"RTN","XOBVLIB",26,0)
 QUIT STR
"RTN","XOBVLIB",27,0)
 ;
"RTN","XOBVLIB",28,0)
STOP() ; -- called by application to determine if processing should stop gracefully
"RTN","XOBVLIB",29,0)
 NEW XOBFLAG
"RTN","XOBVLIB",30,0)
 ;
"RTN","XOBVLIB",31,0)
 ; -- do checks (only one now is time out)
"RTN","XOBVLIB",32,0)
 DO TOFLAG
"RTN","XOBVLIB",33,0)
 ;
"RTN","XOBVLIB",34,0)
 ; -- set 'stop' flag
"RTN","XOBVLIB",35,0)
 SET XOBFLAG=$$TOCHK()
"RTN","XOBVLIB",36,0)
 ;
"RTN","XOBVLIB",37,0)
 QUIT XOBFLAG
"RTN","XOBVLIB",38,0)
 ;
"RTN","XOBVLIB",39,0)
GETTO() ; -- get time out value
"RTN","XOBVLIB",40,0)
 QUIT $GET(XOBDATA("XOB RPC","TIMEOUT"),300)
"RTN","XOBVLIB",41,0)
 ;
"RTN","XOBVLIB",42,0)
SETTO(TO) ; -- set time out value on the fly
"RTN","XOBVLIB",43,0)
 SET XOBDATA("XOB RPC","TIMEOUT")=TO
"RTN","XOBVLIB",44,0)
 QUIT 1
"RTN","XOBVLIB",45,0)
 ;
"RTN","XOBVLIB",46,0)
 ; --------------------------------------------------------------
"RTN","XOBVLIB",47,0)
 ;                 Foundations Developer Calls (Unsupported)
"RTN","XOBVLIB",48,0)
 ; --------------------------------------------------------------
"RTN","XOBVLIB",49,0)
 ; 
"RTN","XOBVLIB",50,0)
VLHDR(NUM) ; -- provides current VistaLink standard header
"RTN","XOBVLIB",51,0)
 NEW X,TYPE,SCHEMA
"RTN","XOBVLIB",52,0)
 ;
"RTN","XOBVLIB",53,0)
 ; -- get type info
"RTN","XOBVLIB",54,0)
 SET X=$PIECE($TEXT(TYPE+NUM),";;",2)
"RTN","XOBVLIB",55,0)
 SET TYPE=$PIECE(X,"^",2)
"RTN","XOBVLIB",56,0)
 SET SCHEMA=$PIECE(X,"^",3)
"RTN","XOBVLIB",57,0)
 QUIT $$ENVHDR(TYPE,SCHEMA)
"RTN","XOBVLIB",58,0)
 ;
"RTN","XOBVLIB",59,0)
TYPE ; -- return message types [ number ^ message type ^ schema file ]
"RTN","XOBVLIB",60,0)
 ;;1^gov.va.med.foundations.rpc.response^rpcResponse.xsd
"RTN","XOBVLIB",61,0)
 ;;2^gov.va.med.foundations.rpc.fault^rpcFault.xsd
"RTN","XOBVLIB",62,0)
 ;;3^gov.va.med.foundations.vistalink.system.fault^vlFault.xsd
"RTN","XOBVLIB",63,0)
 ;;4^gov.va.med.foundations.vistalink.system.response^vlSimpleResponse.xsd
"RTN","XOBVLIB",64,0)
 ;
"RTN","XOBVLIB",65,0)
ERROR(XOBDAT) ; -- send error type message
"RTN","XOBVLIB",66,0)
 NEW XOBI,XOBY,XOBOS
"RTN","XOBVLIB",67,0)
 SET XOBY="XOBY"
"RTN","XOBVLIB",68,0)
 ; -- build xml
"RTN","XOBVLIB",69,0)
 DO BUILD(.XOBY,.XOBDAT)
"RTN","XOBVLIB",70,0)
 ;
"RTN","XOBVLIB",71,0)
 USE XOBPORT
"RTN","XOBVLIB",72,0)
 DO OS^XOBVSKT
"RTN","XOBVLIB",73,0)
 ; -- write xml
"RTN","XOBVLIB",74,0)
 DO PRE^XOBVSKT
"RTN","XOBVLIB",75,0)
 SET XOBI=0 FOR  SET XOBI=$ORDER(XOBY(XOBI)) QUIT:'XOBI  DO WRITE^XOBVSKT(XOBY(XOBI))
"RTN","XOBVLIB",76,0)
 ; -- send eot and flush buffer
"RTN","XOBVLIB",77,0)
 DO POST^XOBVSKT
"RTN","XOBVLIB",78,0)
 QUIT
"RTN","XOBVLIB",79,0)
 ;
"RTN","XOBVLIB",80,0)
BUILD(XOBY,XOBDAT) ;  -- store built xml in passed store reference (XOBY)
"RTN","XOBVLIB",81,0)
 ; -- input format
"RTN","XOBVLIB",82,0)
 ; XOBDAT("MESSAGE TYPE") = # type of message (ex. 2 = gov.va.med.foundations.vistalink.rpc.fault :: See TYPE tag) 
"RTN","XOBVLIB",83,0)
 ; XOBDAT("ERRORS",<integer>,"CODE")         = error code
"RTN","XOBVLIB",84,0)
 ; XOBDAT("ERRORS",<integer>,"ERROR TYPE")   = type of error (system/application/security)
"RTN","XOBVLIB",85,0)
 ; XOBDAT("ERRORS",<integer>,"MESSAGE",<integer>) = error message
"RTN","XOBVLIB",86,0)
 ; 
"RTN","XOBVLIB",87,0)
 ;  -- SOAP related information
"RTN","XOBVLIB",88,0)
 ; XOBDAT("ERRORS",<integer>,"FAULT CODE")   = high level code on where error occurred (ex. Client, Server, etc.)
"RTN","XOBVLIB",89,0)
 ;          - Default: Server
"RTN","XOBVLIB",90,0)
 ; XOBDAT("ERRORS",<integer>,"FAULT STRING") = high level fault type text (ex. System Error)
"RTN","XOBVLIB",91,0)
 ;          - Default: System Error
"RTN","XOBVLIB",92,0)
 ; XOBDAT("ERRORS",<integer>,"FAULT ACTOR")  = RPC, routine, etc. running when error occurred
"RTN","XOBVLIB",93,0)
 ;          - Default: [none]
"RTN","XOBVLIB",94,0)
 ; 
"RTN","XOBVLIB",95,0)
 NEW XOBCODE,XOBI,XOBERR,XOBLINE,XOBETYPE
"RTN","XOBVLIB",96,0)
 SET XOBLINE=0
"RTN","XOBVLIB",97,0)
 ;
"RTN","XOBVLIB",98,0)
 DO ADD($$VLHDR($GET(XOBDAT("MESSAGE TYPE"))))
"RTN","XOBVLIB",99,0)
 DO ADD("<Fault>")
"RTN","XOBVLIB",100,0)
 DO ADD("<FaultCode>"_$GET(XOBDAT("ERRORS",1,"FAULT CODE"),"Server")_"</FaultCode>")
"RTN","XOBVLIB",101,0)
 DO ADD("<FaultString>"_$GET(XOBDAT("ERRORS",1,"FAULT STRING"),"System Error")_"</FaultString>")
"RTN","XOBVLIB",102,0)
 DO ADD("<FaultActor>"_$GET(XOBDAT("ERRORS",1,"FAULT ACTOR"))_"</FaultActor>")
"RTN","XOBVLIB",103,0)
 DO ADD("<Detail>")
"RTN","XOBVLIB",104,0)
 SET XOBERR=0
"RTN","XOBVLIB",105,0)
 FOR  SET XOBERR=$ORDER(XOBDAT("ERRORS",XOBERR)) QUIT:'XOBERR  DO
"RTN","XOBVLIB",106,0)
 . SET XOBCODE=$GET(XOBDAT("ERRORS",XOBERR,"CODE"),0)
"RTN","XOBVLIB",107,0)
 . SET XOBETYPE=$GET(XOBDAT("ERRORS",XOBERR,"ERROR TYPE"),0)
"RTN","XOBVLIB",108,0)
 . DO ADD("<Error type="""_XOBETYPE_""" code="""_XOBCODE_""" >")
"RTN","XOBVLIB",109,0)
 . DO ADD("<Message>")
"RTN","XOBVLIB",110,0)
 . IF $GET(XOBDAT("ERRORS",XOBERR,"CDATA")) DO ADD("<![CDATA[")
"RTN","XOBVLIB",111,0)
 . SET XOBI=0
"RTN","XOBVLIB",112,0)
 . FOR  SET XOBI=$ORDER(XOBDAT("ERRORS",XOBERR,"MESSAGE",XOBI)) QUIT:'XOBI  DO
"RTN","XOBVLIB",113,0)
 . . DO ADD(XOBDAT("ERRORS",XOBERR,"MESSAGE",XOBI))
"RTN","XOBVLIB",114,0)
 . IF $GET(XOBDAT("ERRORS",XOBERR,"CDATA")) DO ADD("]]>")
"RTN","XOBVLIB",115,0)
 . DO ADD("</Message>")
"RTN","XOBVLIB",116,0)
 . DO ADD("</Error>")
"RTN","XOBVLIB",117,0)
 DO ADD("</Detail>")
"RTN","XOBVLIB",118,0)
 DO ADD("</Fault>")
"RTN","XOBVLIB",119,0)
 DO ADD($$ENVFTR())
"RTN","XOBVLIB",120,0)
 ;
"RTN","XOBVLIB",121,0)
 QUIT
"RTN","XOBVLIB",122,0)
 ;
"RTN","XOBVLIB",123,0)
ADD(TXT) ; -- add line
"RTN","XOBVLIB",124,0)
 SET XOBLINE=XOBLINE+1
"RTN","XOBVLIB",125,0)
 SET @XOBY@(XOBLINE)=TXT
"RTN","XOBVLIB",126,0)
 QUIT
"RTN","XOBVLIB",127,0)
 ;
"RTN","XOBVLIB",128,0)
GETRATE() ; -- get J2SE heartbeat rate in seconds
"RTN","XOBVLIB",129,0)
 NEW X
"RTN","XOBVLIB",130,0)
 SET X=$PIECE($GET(^XOB(18.01,1,0)),"^",2)
"RTN","XOBVLIB",131,0)
 QUIT $SELECT(X:X,1:180)
"RTN","XOBVLIB",132,0)
 ;
"RTN","XOBVLIB",133,0)
GETDELTA() ; -- get J2SE latency delta in seconds
"RTN","XOBVLIB",134,0)
 NEW X
"RTN","XOBVLIB",135,0)
 SET X=$PIECE($GET(^XOB(18.01,1,0)),"^",3)
"RTN","XOBVLIB",136,0)
 QUIT $SELECT(X:X,1:180)
"RTN","XOBVLIB",137,0)
 ;
"RTN","XOBVLIB",138,0)
GETASTO() ; -- get J2EE application server time out in seconds (one day = 86400)
"RTN","XOBVLIB",139,0)
 NEW X
"RTN","XOBVLIB",140,0)
 SET X=$PIECE($GET(^XOB(18.01,1,0)),"^",4)
"RTN","XOBVLIB",141,0)
 QUIT $SELECT(X:X,1:86400)
"RTN","XOBVLIB",142,0)
 ;
"RTN","XOBVLIB",143,0)
GETRASTO() ; -- get J2EE application server reauthenticated session time out in seconds (ten minutes = 600)
"RTN","XOBVLIB",144,0)
 NEW X
"RTN","XOBVLIB",145,0)
 SET X=$PIECE($GET(^XOB(18.01,1,0)),"^",5)
"RTN","XOBVLIB",146,0)
 QUIT $SELECT(X:X,1:600)
"RTN","XOBVLIB",147,0)
 ;
"RTN","XOBVLIB",148,0)
TOFLAG ; -- set timed out flag
"RTN","XOBVLIB",149,0)
 ; -- if run in non-VistALink environment never time out ; set both now & start = $h
"RTN","XOBVLIB",150,0)
 SET XOBDATA("XOB RPC","TIMED OUT")=($$HDIFF^XLFDT($HOROLOG,$GET(XOBDATA("XOB RPC","START"),$HOROLOG),2)>$$GETTO())
"RTN","XOBVLIB",151,0)
 QUIT
"RTN","XOBVLIB",152,0)
 ;
"RTN","XOBVLIB",153,0)
TOCHK() ; -- did RPC timeout?
"RTN","XOBVLIB",154,0)
 QUIT +$GET(XOBDATA("XOB RPC","TIMED OUT"))
"RTN","XOBVLIB",155,0)
 ;
"RTN","XOBVLIB",156,0)
ENVHDR(TYPE,SCHEMA) ; -- vistalink beg tag (header)
"RTN","XOBVLIB",157,0)
 NEW X,VLVER
"RTN","XOBVLIB",158,0)
 SET X=$$XMLHDR()
"RTN","XOBVLIB",159,0)
 SET X=X_"<VistaLink"
"RTN","XOBVLIB",160,0)
 SET X=X_" messageType="""_TYPE_""""
"RTN","XOBVLIB",161,0)
 SET VLVER="1.6"
"RTN","XOBVLIB",162,0)
 ; -- indicates to VL v1.5 client that this VL v1.6 server is backwards compatible
"RTN","XOBVLIB",163,0)
 IF $GET(XOBDATA("VL VERSION"))="1.5" SET VLVER="1.5"
"RTN","XOBVLIB",164,0)
 ; -- indicates to VL v1.0 client that this VL v1.6 server is backwards compatible
"RTN","XOBVLIB",165,0)
 IF $GET(XOBDATA("VL VERSION"))="1.0" SET VLVER="1.0"
"RTN","XOBVLIB",166,0)
 SET X=X_" version="""_VLVER_""""
"RTN","XOBVLIB",167,0)
 SET X=X_" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"""
"RTN","XOBVLIB",168,0)
 SET X=X_" xsi:noNamespaceSchemaLocation="""_SCHEMA_""""
"RTN","XOBVLIB",169,0)
 ;SET X=X_" xmlns=""http://med.va.gov/Foundations"""
"RTN","XOBVLIB",170,0)
 SET X=X_">"
"RTN","XOBVLIB",171,0)
 QUIT X
"RTN","XOBVLIB",172,0)
 ;
"RTN","XOBVLIB",173,0)
ENVFTR() ; -- vistalink end tag (footer)
"RTN","XOBVLIB",174,0)
 QUIT "</VistaLink>"
"RTN","XOBVLIB",175,0)
 ;
"RTN","XOBVLIB",176,0)
SYSOS(XOBOS) ; -- get system operating system
"RTN","XOBVLIB",177,0)
 ; -- DBIA #3522
"RTN","XOBVLIB",178,0)
 QUIT $SELECT(XOBOS["OpenM":$$OS^%ZOSV(),XOBOS["DSM":"VMS",1:"Unknown")
"RTN","XOBVLIB",179,0)
 ;
"RTN","XOBVLJU")
1^21
"RTN","XOBVLL")
0^4^B20760795
"RTN","XOBVLL",1,0)
XOBVLL ;; mjk/alb - VistALink Listen and Spawn Code ; 07/27/2002  13:00
"RTN","XOBVLL",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVLL",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVLL",4,0)
 QUIT
"RTN","XOBVLL",5,0)
 ;
"RTN","XOBVLL",6,0)
 ; ***deprecated*** tag ; Use START^XOBVTCP instead
"RTN","XOBVLL",7,0)
START(SOCKET) ; -- start listener
"RTN","XOBVLL",8,0)
 DO START^XOBVTCP(SOCKET)
"RTN","XOBVLL",9,0)
 QUIT
"RTN","XOBVLL",10,0)
 ;
"RTN","XOBVLL",11,0)
 ; ***deprecated*** tag ; Use UCX^XOBVTCP instead
"RTN","XOBVLL",12,0)
UCX ; -- VMS TCPIP (UCX) multi-thread entry point
"RTN","XOBVLL",13,0)
 ; -- Called from VistALink .com files
"RTN","XOBVLL",14,0)
 GOTO UCX^XOBVTCP
"RTN","XOBVLL",15,0)
 ;
"RTN","XOBVLL",16,0)
SPAWN ; -- spawned process
"RTN","XOBVLL",17,0)
 NEW X,XOBSTOP,XOBPORT,XOBHDLR,XOBLASTR,XOBCMREF
"RTN","XOBVLL",18,0)
 ;
"RTN","XOBVLL",19,0)
 SET XOBSTOP=0
"RTN","XOBVLL",20,0)
 SET XOBPORT=IO
"RTN","XOBVLL",21,0)
 SET U="^"
"RTN","XOBVLL",22,0)
 ;
"RTN","XOBVLL",23,0)
 ; -- initialize timestamp for last time request made (used for debugging)
"RTN","XOBVLL",24,0)
 SET XOBLASTR=0
"RTN","XOBVLL",25,0)
 ;
"RTN","XOBVLL",26,0)
 ; -- set error trap
"RTN","XOBVLL",27,0)
 ;Set up the error trap
"RTN","XOBVLL",28,0)
 SET $ETRAP="DO ^%ZTER HALT"
"RTN","XOBVLL",29,0)
 ;
"RTN","XOBVLL",30,0)
 ; -- attempt to share the license; must have TCP port open first
"RTN","XOBVLL",31,0)
 USE XOBPORT IF $TEXT(SHARELIC^%ZOSV)'="" DO SHARELIC^%ZOSV(1)
"RTN","XOBVLL",32,0)
 ;
"RTN","XOBVLL",33,0)
 ; -- start RUM for VistALink Handler
"RTN","XOBVLL",34,0)
 DO LOGRSRC^%ZOSV("$VISTALINK HANDLER$",2,1)
"RTN","XOBVLL",35,0)
 ;
"RTN","XOBVLL",36,0)
 ; -- cache/initialize startup request handlers 
"RTN","XOBVLL",37,0)
 SET X=$$CACHE^XOBVRH(.XOBHDLR)
"RTN","XOBVLL",38,0)
 IF 'X DO RMERR^XOBVRM(184001,$PIECE(X,U,2)) QUIT
"RTN","XOBVLL",39,0)
 ;
"RTN","XOBVLL",40,0)
 ; -- initialize tcp processing variables
"RTN","XOBVLL",41,0)
 DO INIT^XOBVSKT
"RTN","XOBVLL",42,0)
 ;
"RTN","XOBVLL",43,0)
 ; -- change job name if possible
"RTN","XOBVLL",44,0)
 DO SETNM^%ZOSV("VLink_"_$$CNV^XLFUTL($J,16))
"RTN","XOBVLL",45,0)
 ;
"RTN","XOBVLL",46,0)
 ; -- setup for Connection Mgr: get ref; kill data @ ref
"RTN","XOBVLL",47,0)
 SET XOBCMREF=$$GETREF^XOBUZAP1()
"RTN","XOBVLL",48,0)
 DO KILL^XOBUZAP0(XOBCMREF)
"RTN","XOBVLL",49,0)
 ;
"RTN","XOBVLL",50,0)
 ; -- loop until told to stop
"RTN","XOBVLL",51,0)
 FOR  DO NXTCALL QUIT:XOBSTOP
"RTN","XOBVLL",52,0)
 ;
"RTN","XOBVLL",53,0)
 ; -- kill ^XTMP ref node
"RTN","XOBVLL",54,0)
 DO KILL^XOBUZAP0(XOBCMREF)
"RTN","XOBVLL",55,0)
 ;
"RTN","XOBVLL",56,0)
 ; -- final/clean tcp processing variables
"RTN","XOBVLL",57,0)
 DO FINAL^XOBVSKT
"RTN","XOBVLL",58,0)
 ;
"RTN","XOBVLL",59,0)
 ; -- stop RUM for VistALink Handler
"RTN","XOBVLL",60,0)
 DO LOGRSRC^%ZOSV("$VISTALINK HANDLER$",2,2)
"RTN","XOBVLL",61,0)
 ;
"RTN","XOBVLL",62,0)
 QUIT
"RTN","XOBVLL",63,0)
 ;
"RTN","XOBVLL",64,0)
NXTCALL ; -- do next call
"RTN","XOBVLL",65,0)
 NEW X,XOBROOT,XOBREAD,XOBTO,XOBFIRST,XOBOK,XOBRL,XOBDATA
"RTN","XOBVLL",66,0)
 ;
"RTN","XOBVLL",67,0)
 ; -- set up error trap
"RTN","XOBVLL",68,0)
 NEW $ESTACK SET $ETRAP="DO SYSERR^XOBVLL"
"RTN","XOBVLL",69,0)
 ;
"RTN","XOBVLL",70,0)
 ; -- setup environment variables
"RTN","XOBVLL",71,0)
 NEW DIQUIET SET DIQUIET=1
"RTN","XOBVLL",72,0)
 SET U="^",DTIME=$GET(DTIME,900),DT=$$DT^XLFDT()
"RTN","XOBVLL",73,0)
 ;
"RTN","XOBVLL",74,0)
 ; -- set ^XTMP for Connection Mgr usage if DUZ not 1st piece
"RTN","XOBVLL",75,0)
 IF '$$GETDUZ^XOBUZAP0(XOBCMREF) DO
"RTN","XOBVLL",76,0)
 . NEW XOBDUZ,XOBIP
"RTN","XOBVLL",77,0)
 . SET XOBDUZ=$GET(XOBSYS("DUZ"),$GET(DUZ))
"RTN","XOBVLL",78,0)
 . SET XOBIP=$GET(IO("IP"))
"RTN","XOBVLL",79,0)
 . DO SETVI^XOBUZAP0(XOBCMREF,XOBDUZ,XOBIP,$$GETDESC^XOBUZAP1())
"RTN","XOBVLL",80,0)
 ;
"RTN","XOBVLL",81,0)
 ; -- initialize 'current' request handler to empty string
"RTN","XOBVLL",82,0)
 SET XOBHDLR=""
"RTN","XOBVLL",83,0)
 ;
"RTN","XOBVLL",84,0)
 ; -- # of chars to get on first read / read 11 for Broker initial read
"RTN","XOBVLL",85,0)
 SET XOBREAD=11
"RTN","XOBVLL",86,0)
 ;
"RTN","XOBVLL",87,0)
 ; -- get J2SE heartbeat rate for timeout plus network latency factor
"RTN","XOBVLL",88,0)
 SET XOBTO=$$GETRATE^XOBVLIB()+$$GETDELTA^XOBVLIB()
"RTN","XOBVLL",89,0)
 ;
"RTN","XOBVLL",90,0)
 ; -- get J2EE timeout value for app serv environment
"RTN","XOBVLL",91,0)
 IF $GET(XOBSYS("ENV"))="j2ee" SET XOBTO=$$GETASTO^XOBVLIB()
"RTN","XOBVLL",92,0)
 ;
"RTN","XOBVLL",93,0)
 ; -- set first read flag
"RTN","XOBVLL",94,0)
 SET XOBFIRST=1
"RTN","XOBVLL",95,0)
 ;
"RTN","XOBVLL",96,0)
 ; -- setup intake global
"RTN","XOBVLL",97,0)
 SET XOBROOT=$NAME(^TMP("XOBVLL",$JOB))
"RTN","XOBVLL",98,0)
 KILL @XOBROOT
"RTN","XOBVLL",99,0)
 ;
"RTN","XOBVLL",100,0)
 ; -- read from socket port
"RTN","XOBVLL",101,0)
 USE XOBPORT
"RTN","XOBVLL",102,0)
 SET XOBOK=$$READ^XOBVSKT(XOBROOT,.XOBREAD,.XOBTO,.XOBFIRST,.XOBSTOP,.XOBDATA,.XOBHDLR)
"RTN","XOBVLL",103,0)
 ;
"RTN","XOBVLL",104,0)
 ; -- timed out ; cleanup user and exit
"RTN","XOBVLL",105,0)
 IF 'XOBOK!(XOBSTOP) DO  GOTO NXTCALLQ
"RTN","XOBVLL",106,0)
 . IF $GET(DUZ) DO CLEAN^XOBSCAV1
"RTN","XOBVLL",107,0)
 . SET XOBSTOP=1
"RTN","XOBVLL",108,0)
 ;
"RTN","XOBVLL",109,0)
 ; -- need null device
"RTN","XOBVLL",110,0)
 IF '$DATA(XOBNULL) DO ERROR(181002,$$EZBLD^DIALOG(181002),XOBPORT) SET XOBSTOP=1 GOTO NXTCALLQ
"RTN","XOBVLL",111,0)
 ;
"RTN","XOBVLL",112,0)
 ; -- call request manager                   
"RTN","XOBVLL",113,0)
 SET XOBOK=$$EN^XOBVRM(XOBROOT,.XOBDATA,.XOBHDLR)
"RTN","XOBVLL",114,0)
 ; -- timestamp last time request made
"RTN","XOBVLL",115,0)
 SET XOBLASTR=$$NOW^XLFDT()
"RTN","XOBVLL",116,0)
 ; -- cleanup intake global
"RTN","XOBVLL",117,0)
 KILL @XOBROOT
"RTN","XOBVLL",118,0)
 ;
"RTN","XOBVLL",119,0)
NXTCALLQ ; -- exit
"RTN","XOBVLL",120,0)
 QUIT
"RTN","XOBVLL",121,0)
 ;
"RTN","XOBVLL",122,0)
 ; ----------------------------------------------------------------------------------
"RTN","XOBVLL",123,0)
 ;                                System Error Handler
"RTN","XOBVLL",124,0)
 ; ----------------------------------------------------------------------------------
"RTN","XOBVLL",125,0)
SYSERR ; -- send system error message
"RTN","XOBVLL",126,0)
 ; -- If we get an error in the error handler just Halt
"RTN","XOBVLL",127,0)
 SET $ETRAP="D ^%ZTER HALT"
"RTN","XOBVLL",128,0)
 ;
"RTN","XOBVLL",129,0)
 DO ERROR(181001,$$EZBLD^DIALOG(181001,$$EC^%ZOSV),XOBPORT)      ; -- Get the error code
"RTN","XOBVLL",130,0)
 QUIT
"RTN","XOBVLL",131,0)
 ;
"RTN","XOBVLL",132,0)
ERROR(XOBEC,XOBMSG,XOBPORT) ; -- send error message
"RTN","XOBVLL",133,0)
 NEW XOBDAT
"RTN","XOBVLL",134,0)
 ;
"RTN","XOBVLL",135,0)
 ; -- If we get an error in the error handler just Halt
"RTN","XOBVLL",136,0)
 SET $ETRAP="D ^%ZTER HALT"
"RTN","XOBVLL",137,0)
 ;
"RTN","XOBVLL",138,0)
 ; -- set up error info
"RTN","XOBVLL",139,0)
 SET XOBDAT("MESSAGE TYPE")=3
"RTN","XOBVLL",140,0)
 SET XOBDAT("ERRORS",1,"CODE")=XOBEC
"RTN","XOBVLL",141,0)
 SET XOBDAT("ERRORS",1,"ERROR TYPE")="system"
"RTN","XOBVLL",142,0)
 SET XOBDAT("ERRORS",1,"FAULT STRING")="System Error"
"RTN","XOBVLL",143,0)
 SET XOBDAT("ERRORS",1,"CDATA")=1
"RTN","XOBVLL",144,0)
 SET XOBDAT("ERRORS",1,"MESSAGE",1)=XOBMSG
"RTN","XOBVLL",145,0)
 ;
"RTN","XOBVLL",146,0)
 ; -- if serious error, save error info, logout, and halt
"RTN","XOBVLL",147,0)
 IF XOBMSG["<READ>"!(XOBMSG["<WRITE>")!(XOBMSG["<SYSTEM>")!(XOBMSG["READERR")!(XOBMSG["WRITERR")!(XOBMSG["SYSERR") DO  HALT
"RTN","XOBVLL",148,0)
 . DO ^%ZTER
"RTN","XOBVLL",149,0)
 . IF $GET(DUZ) DO CLEAN^XOBSCAV1
"RTN","XOBVLL",150,0)
 ;
"RTN","XOBVLL",151,0)
 ; -- send error back to client
"RTN","XOBVLL",152,0)
 USE XOBPORT
"RTN","XOBVLL",153,0)
 DO ERROR^XOBVLIB(.XOBDAT)
"RTN","XOBVLL",154,0)
 ;
"RTN","XOBVLL",155,0)
 ; -- just quit if no slots are available or logins are disabled
"RTN","XOBVLL",156,0)
 IF (XOBEC=181003)!(XOBEC=181004) QUIT
"RTN","XOBVLL",157,0)
 ;
"RTN","XOBVLL",158,0)
 ; -- need to make sure any locks are released since code aborted ungracefully
"RTN","XOBVLL",159,0)
 LOCK
"RTN","XOBVLL",160,0)
 ;
"RTN","XOBVLL",161,0)
 ; -- Save off the error
"RTN","XOBVLL",162,0)
 DO ^%ZTER
"RTN","XOBVLL",163,0)
 ;
"RTN","XOBVLL",164,0)
 ; -- go back to listening
"RTN","XOBVLL",165,0)
 SET $ETRAP="Q:($ESTACK&'$QUIT)  Q:$ESTACK -9 S $ECODE="""" DO KILL^XOBVLL G NXTCALLQ^XOBVLL",$ECODE=",U99,"
"RTN","XOBVLL",166,0)
 QUIT
"RTN","XOBVLL",167,0)
 ;
"RTN","XOBVLL",168,0)
KILL ; -- new VistALink variables and then do big KILL
"RTN","XOBVLL",169,0)
 NEW XOBPORT,XOBSTOP,XOBNULL,XOBOS,XOBSYS,XOBHDLR,XOBOK,XOBLASTR,XOBCMREF
"RTN","XOBVLL",170,0)
 DO KILL^XUSCLEAN
"RTN","XOBVLL",171,0)
 QUIT
"RTN","XOBVLL",172,0)
 ;
"RTN","XOBVLT")
0^5^B32764303
"RTN","XOBVLT",1,0)
XOBVLT ;; mjk/alb - VistALink Tester  ; 07/27/2002  13:00
"RTN","XOBVLT",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVLT",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVLT",4,0)
 QUIT
"RTN","XOBVLT",5,0)
 ;
"RTN","XOBVLT",6,0)
 ; ----------------------------------------------------------
"RTN","XOBVLT",7,0)
 ;                 XOB Remote Procedure Testers
"RTN","XOBVLT",8,0)
 ; ----------------------------------------------------------
"RTN","XOBVLT",9,0)
 ; 
"RTN","XOBVLT",10,0)
PINGRP(XOBY) ; -- rpc: XOBV TEST PING
"RTN","XOBVLT",11,0)
 SET XOBY="Ping Successful!"
"RTN","XOBVLT",12,0)
 QUIT
"RTN","XOBVLT",13,0)
 ;
"RTN","XOBVLT",14,0)
STRRP(XOBY,XOBSTR) ; -- rpc: XOBV TEST STRING
"RTN","XOBVLT",15,0)
 SET XOBY="Returned Input Value: "_XOBSTR
"RTN","XOBVLT",16,0)
 QUIT
"RTN","XOBVLT",17,0)
 ;
"RTN","XOBVLT",18,0)
XMLRP(XOBY) ; -- rpc: XOBV TEST XML RESULTS
"RTN","XOBVLT",19,0)
 ; -- send back XML node
"RTN","XOBVLT",20,0)
 SET XOBY="<?xml version='1.0' encoding='utf-8' ?>"
"RTN","XOBVLT",21,0)
 SET XOBY=XOBY_"<fruits>"
"RTN","XOBVLT",22,0)
 SET XOBY=XOBY_"   <fruit color='yellow' >banana</fruit>"
"RTN","XOBVLT",23,0)
 SET XOBY=XOBY_"   <fruit color='red' >apple</fruit>"
"RTN","XOBVLT",24,0)
 SET XOBY=XOBY_"   <fruit color='orange' >orange</fruit>"
"RTN","XOBVLT",25,0)
 SET XOBY=XOBY_"</fruits>"
"RTN","XOBVLT",26,0)
 QUIT
"RTN","XOBVLT",27,0)
 ;
"RTN","XOBVLT",28,0)
LARRRP(XOBY,XOBARR) ; -- rpc: XOBV TEST LOCAL ARRAY
"RTN","XOBVLT",29,0)
 NEW XOBX,XOBLINE
"RTN","XOBVLT",30,0)
 SET XOBLINE=0
"RTN","XOBVLT",31,0)
 SET XOBX="" FOR  SET XOBX=$ORDER(XOBARR(XOBX)) QUIT:XOBX=""  DO
"RTN","XOBVLT",32,0)
 . SET XOBLINE=XOBLINE+1
"RTN","XOBVLT",33,0)
 . SET XOBY(XOBLINE)=XOBX_" / "_XOBARR(XOBX)
"RTN","XOBVLT",34,0)
 QUIT
"RTN","XOBVLT",35,0)
 ;
"RTN","XOBVLT",36,0)
MSUBS(XOBY,XOBARR) ; -- rpc: XOBV TEST MULTIPLE SUBSCRIPTS
"RTN","XOBVLT",37,0)
 NEW XOBX,XOBLINE
"RTN","XOBVLT",38,0)
 SET XOBLINE=0
"RTN","XOBVLT",39,0)
 SET XOBX="" FOR  SET XOBX=$ORDER(XOBARR("FRUIT",XOBX)) QUIT:XOBX=""  DO
"RTN","XOBVLT",40,0)
 . SET XOBLINE=XOBLINE+1
"RTN","XOBVLT",41,0)
 . SET XOBY(XOBLINE)=XOBX_" / "_XOBARR("FRUIT",XOBX)
"RTN","XOBVLT",42,0)
 QUIT
"RTN","XOBVLT",43,0)
 ;
"RTN","XOBVLT",44,0)
MARRAYS(XOBY,XOBARR,XOBARR2,XOBARR3) ; -- rpc: XOBV TEST MULT ARRAY PARAMS
"RTN","XOBVLT",45,0)
 NEW XOBX,XOBLINE
"RTN","XOBVLT",46,0)
 SET XOBLINE=0
"RTN","XOBVLT",47,0)
 SET XOBX="" FOR  SET XOBX=$ORDER(XOBARR(XOBX)) QUIT:XOBX=""  DO 
"RTN","XOBVLT",48,0)
 . SET XOBLINE=XOBLINE+1
"RTN","XOBVLT",49,0)
 . SET XOBY(XOBLINE)=XOBLINE_" / "_XOBARR(XOBX)
"RTN","XOBVLT",50,0)
 SET XOBX="" FOR  SET XOBX=$ORDER(XOBARR2(XOBX)) QUIT:XOBX=""  DO 
"RTN","XOBVLT",51,0)
 . SET XOBLINE=XOBLINE+1
"RTN","XOBVLT",52,0)
 . SET XOBY(XOBLINE)=XOBLINE_" / "_XOBARR2(XOBX)
"RTN","XOBVLT",53,0)
 SET XOBX="" FOR  SET XOBX=$ORDER(XOBARR3(XOBX)) QUIT:XOBX=""  DO 
"RTN","XOBVLT",54,0)
 . SET XOBLINE=XOBLINE+1
"RTN","XOBVLT",55,0)
 . SET XOBY(XOBLINE)=XOBLINE_" / "_XOBARR3(XOBX)
"RTN","XOBVLT",56,0)
 QUIT  ;
"RTN","XOBVLT",57,0)
 ;
"RTN","XOBVLT",58,0)
GARRRP(XOBY,XOBARR) ; -- rpc: XOBV TEST GLOBAL ARRAY
"RTN","XOBVLT",59,0)
 SET XOBY=$NAME(^TMP("XOB VL TEST",$JOB))
"RTN","XOBVLT",60,0)
 KILL @XOBY
"RTN","XOBVLT",61,0)
 MERGE @XOBY=XOBARR
"RTN","XOBVLT",62,0)
 QUIT
"RTN","XOBVLT",63,0)
 ;
"RTN","XOBVLT",64,0)
RPCRP(XOBY,XOBSTR) ; -- rpc: XOBV TEST RPC LIST
"RTN","XOBVLT",65,0)
 ;
"RTN","XOBVLT",66,0)
 ;-- List all RPC's starting with same string (i.e. namespace)
"RTN","XOBVLT",67,0)
 ;
"RTN","XOBVLT",68,0)
 ;  Input:
"RTN","XOBVLT",69,0)
 ;    XOBSTR  -   string to look up (ex. "XOBV" will look up all RPCs starting with XOBV)
"RTN","XOBVLT",70,0)
 ;
"RTN","XOBVLT",71,0)
 ; Output:
"RTN","XOBVLT",72,0)
 ;    XOBY    -   output array, passed by reference, defined as:
"RTN","XOBVLT",73,0)
 ;                  XOBY(0)   contains either error message or header line
"RTN","XOBVLT",74,0)
 ;                  XOBY(1-n) contains data line
"RTN","XOBVLT",75,0)
 ;
"RTN","XOBVLT",76,0)
 IF $LENGTH($GET(XOBSTR))=0 SET XOBY(0)="<no RPC prefix defined>" QUIT
"RTN","XOBVLT",77,0)
 SET XOBY(0)="RPCs Starting with '"_XOBSTR_"'..."
"RTN","XOBVLT",78,0)
 DO LIST^DIC(8994,"","","","",XOBSTR,XOBSTR,"","","","")
"RTN","XOBVLT",79,0)
 SET XOBY(0)=XOBY(0)_" ("_+^TMP("DILIST",$JOB,0)_") entries found."
"RTN","XOBVLT",80,0)
 MERGE XOBY=^TMP("DILIST",$JOB,1)
"RTN","XOBVLT",81,0)
 KILL ^TMP("DILIST",$JOB),^TMP("DIERR",$JOB)
"RTN","XOBVLT",82,0)
 QUIT
"RTN","XOBVLT",83,0)
 ;
"RTN","XOBVLT",84,0)
 ;
"RTN","XOBVLT",85,0)
NOCNTXT(XOBY) ; -- rpc: XOB VL NOT IN CONTEXT TEST
"RTN","XOBVLT",86,0)
 ; This code is not used.
"RTN","XOBVLT",87,0)
 ; See REMOTE PROCEDURE file entry for description why.
"RTN","XOBVLT",88,0)
 QUIT ""
"RTN","XOBVLT",89,0)
 ;
"RTN","XOBVLT",90,0)
WPRP(XOBY) ; -- rpc: XOBV TEST WORD PROCESSING
"RTN","XOBVLT",91,0)
 NEW I,X
"RTN","XOBVLT",92,0)
 FOR I=1:1 SET X=$PIECE($TEXT(GA+I),";;",2) QUIT:X="$$END$$"  SET XOBY(I)=X
"RTN","XOBVLT",93,0)
 QUIT
"RTN","XOBVLT",94,0)
 ;
"RTN","XOBVLT",95,0)
GA ;; -- 'Gettysburg Address' text
"RTN","XOBVLT",96,0)
 ;;==================
"RTN","XOBVLT",97,0)
 ;;Gettysburg Address
"RTN","XOBVLT",98,0)
 ;;==================
"RTN","XOBVLT",99,0)
 ;;Four score and seven years ago our fathers brought forth, 
"RTN","XOBVLT",100,0)
 ;;upon this continent, a new nation, conceived in liberty, 
"RTN","XOBVLT",101,0)
 ;;and dedicated to the proposition that 'all men are 
"RTN","XOBVLT",102,0)
 ;;created equal'. 
"RTN","XOBVLT",103,0)
 ;; 
"RTN","XOBVLT",104,0)
 ;;Now we are engaged in a great civil war, testing whether that 
"RTN","XOBVLT",105,0)
 ;;nation, or any nation so conceived, and so dedicated, can long 
"RTN","XOBVLT",106,0)
 ;;endure. We are met on a great battle field of that war. We come 
"RTN","XOBVLT",107,0)
 ;;to dedicate a portion of it, as a final resting place for those 
"RTN","XOBVLT",108,0)
 ;;who died here, that the nation might live. This we may, in all 
"RTN","XOBVLT",109,0)
 ;;propriety do. But, in a larger sense, we can not dedicate -- we 
"RTN","XOBVLT",110,0)
 ;;can not consecrate -- we can not hallow, this ground -- The brave 
"RTN","XOBVLT",111,0)
 ;;men, living and dead, who struggled here, have hallowed it, far 
"RTN","XOBVLT",112,0)
 ;;above our poor power to add or detract. The world will little 
"RTN","XOBVLT",113,0)
 ;;note,nor long remember what we say here; while it can never 
"RTN","XOBVLT",114,0)
 ;;forget what they did here."
"RTN","XOBVLT",115,0)
 ;; 
"RTN","XOBVLT",116,0)
 ;;It is rather for us, the living, we here be dedicated to the great 
"RTN","XOBVLT",117,0)
 ;;task remaining before us -- that, from these honored dead we take 
"RTN","XOBVLT",118,0)
 ;;increased devotion to that cause for which they here, gave the 
"RTN","XOBVLT",119,0)
 ;;last full measure of devotion -- that we here highly resolve these 
"RTN","XOBVLT",120,0)
 ;;dead shall not have died in vain; that the nation, shall have a 
"RTN","XOBVLT",121,0)
 ;;new birth of freedom, and that government of the people by the 
"RTN","XOBVLT",122,0)
 ;;people for the people, shall not perish from the earth.
"RTN","XOBVLT",123,0)
 ;;$$END$$
"RTN","XOBVLT",124,0)
 ;
"RTN","XOBVLT",125,0)
GNODERP(XOBY,XOBSTR) ; -- rpc: XOBV TEST GLOBAL NODE
"RTN","XOBVLT",126,0)
 SET XOBY=$NAME(^TMP("XOB VL TEST",$JOB))
"RTN","XOBVLT",127,0)
 KILL @XOBY
"RTN","XOBVLT",128,0)
 SET @XOBY="Returned Input Value: "_XOBSTR
"RTN","XOBVLT",129,0)
 QUIT
"RTN","XOBVLT",130,0)
 ;
"RTN","XOBVLT",131,0)
EXTASCII(XOBY,XOBSTR) ; -- rpc: XOBV TEST EXTENDED ASCII
"RTN","XOBVLT",132,0)
 ; return value (array): 
"RTN","XOBVLT",133,0)
 ; XOBY(1): 0^XOBSTR if didn't get ASCII extended chars 128-255, 1^XOBSTR if did
"RTN","XOBVLT",134,0)
 ; XOBY(128-255): ASCII value expected^ASCII value received
"RTN","XOBVLT",135,0)
 ; 
"RTN","XOBVLT",136,0)
 NEW XOBI,XOBCH,XOBPOS
"RTN","XOBVLT",137,0)
 SET XOBY(1)="0^"_XOBSTR
"RTN","XOBVLT",138,0)
 QUIT:$LENGTH(XOBSTR)'=123  ;(128-255, but 5 chars undefined)
"RTN","XOBVLT",139,0)
 SET XOBY(1)="1^"_XOBSTR
"RTN","XOBVLT",140,0)
 SET XOBPOS=1
"RTN","XOBVLT",141,0)
 FOR XOBI=128,130:1:140,142,145:1:156,158:1:255 DO
"RTN","XOBVLT",142,0)
 .SET XOBCH=$EXTRACT(XOBSTR,XOBPOS)
"RTN","XOBVLT",143,0)
 .SET XOBY(XOBI)=XOBI_"^"_$ASCII(XOBCH)
"RTN","XOBVLT",144,0)
 .SET:$ASCII(XOBCH)'=(XOBI) XOBY(1)="0^"_XOBSTR,XOBY(XOBI)=XOBY(XOBI)_"^PROBLEM"
"RTN","XOBVLT",145,0)
 .SET XOBPOS=XOBPOS+1
"RTN","XOBVLT",146,0)
 QUIT
"RTN","XOBVLT",147,0)
 ;
"RTN","XOBVPOST")
0^^B74051370
"RTN","XOBVPOST",1,0)
XOBVPOST ;; ld,mjk/alb - VistaLink Post-Init ; 07/27/2002  13:00
"RTN","XOBVPOST",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVPOST",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVPOST",4,0)
 QUIT
"RTN","XOBVPOST",5,0)
 ;
"RTN","XOBVPOST",6,0)
EN ; -- add post-init code here
"RTN","XOBVPOST",7,0)
 NEW XOBCFG,XOBOS
"RTN","XOBVPOST",8,0)
 SET XOBOS=$$GETOS^XOBVTCP()
"RTN","XOBVPOST",9,0)
 SET XOBCFG=0
"RTN","XOBVPOST",10,0)
 ;
"RTN","XOBVPOST",11,0)
 ; -- add config if Cache NT
"RTN","XOBVPOST",12,0)
 IF XOBOS="OpenM-NT" SET XOBCFG=$$CFG()
"RTN","XOBVPOST",13,0)
 ;
"RTN","XOBVPOST",14,0)
 ; -- add params entry
"RTN","XOBVPOST",15,0)
 DO PARMS(XOBCFG)
"RTN","XOBVPOST",16,0)
 ;
"RTN","XOBVPOST",17,0)
 ; -- add STARTUP task if OpenM-NT and on Windows
"RTN","XOBVPOST",18,0)
 IF XOBOS="OpenM-NT",$$SYSOS^XOBVLIB(XOBOS)="NT" DO SCHEDOPT
"RTN","XOBVPOST",19,0)
 ;
"RTN","XOBVPOST",20,0)
 ; -- add XOBVTESTER,APPLICATION PROXY user if not present
"RTN","XOBVPOST",21,0)
 DO ADDPROXY("XOBVTESTER,APPLICATION PROXY")
"RTN","XOBVPOST",22,0)
 ;
"RTN","XOBVPOST",23,0)
 QUIT
"RTN","XOBVPOST",24,0)
 ;
"RTN","XOBVPOST",25,0)
 ;
"RTN","XOBVPOST",26,0)
CFG() ; -- add default config if not present
"RTN","XOBVPOST",27,0)
 NEW DIC,X,Y,XOBDA,XOBNEW
"RTN","XOBVPOST",28,0)
 ;
"RTN","XOBVPOST",29,0)
 ; -- DEFAULT configuration --
"RTN","XOBVPOST",30,0)
 SET DIC="^XOB(18.03,"
"RTN","XOBVPOST",31,0)
 SET DIC(0)="LX"
"RTN","XOBVPOST",32,0)
 SET X="DEFAULT"
"RTN","XOBVPOST",33,0)
 DO ^DIC
"RTN","XOBVPOST",34,0)
 ; -- quit if lookup failed
"RTN","XOBVPOST",35,0)
 IF Y=-1 GOTO CFGQ
"RTN","XOBVPOST",36,0)
 ;
"RTN","XOBVPOST",37,0)
 SET XOBDA=+Y
"RTN","XOBVPOST",38,0)
 SET XOBNEW=$PIECE(Y,U,3)
"RTN","XOBVPOST",39,0)
 ;
"RTN","XOBVPOST",40,0)
 ; -- add default port to multiple
"RTN","XOBVPOST",41,0)
 IF XOBNEW,'$$PORTS(XOBDA) GOTO CFGQ
"RTN","XOBVPOST",42,0)
 ;
"RTN","XOBVPOST",43,0)
CFGQ ;
"RTN","XOBVPOST",44,0)
 QUIT +$GET(XOBDA)
"RTN","XOBVPOST",45,0)
 ;
"RTN","XOBVPOST",46,0)
 ;
"RTN","XOBVPOST",47,0)
PORTS(XOBDA) ; -- add 8000 port
"RTN","XOBVPOST",48,0)
 NEW XOBOK,XOBNEW,DIC,DIE,DR,X,DA,Y
"RTN","XOBVPOST",49,0)
 ;
"RTN","XOBVPOST",50,0)
 ; -- set 0th of multiple is needed
"RTN","XOBVPOST",51,0)
 IF $DATA(^XOB(18.03,1,"PORTS",0))=0 SET ^XOB(18.03,1,"PORTS",0)="^18.031^^"
"RTN","XOBVPOST",52,0)
 ;
"RTN","XOBVPOST",53,0)
 SET DA(1)=XOBDA
"RTN","XOBVPOST",54,0)
 SET DIC="^XOB(18.03,"_XOBDA_",""PORTS"","
"RTN","XOBVPOST",55,0)
 SET DIC(0)="LX"
"RTN","XOBVPOST",56,0)
 SET X=8000
"RTN","XOBVPOST",57,0)
 DO ^DIC
"RTN","XOBVPOST",58,0)
 ;
"RTN","XOBVPOST",59,0)
 ; -- quit if lookup failed
"RTN","XOBVPOST",60,0)
 IF Y=-1 SET XOBOK=0 GOTO PORTSQ
"RTN","XOBVPOST",61,0)
 SET XOBNEW=$PIECE(Y,U,3)
"RTN","XOBVPOST",62,0)
 ;
"RTN","XOBVPOST",63,0)
 ; -- if multiple entry is new, set port to NOT startup when config is started
"RTN","XOBVPOST",64,0)
 ;    (site should change to startup explicitly)
"RTN","XOBVPOST",65,0)
 IF XOBNEW DO
"RTN","XOBVPOST",66,0)
 . SET DA(1)=XOBDA
"RTN","XOBVPOST",67,0)
 . SET DA=+Y
"RTN","XOBVPOST",68,0)
 . SET DR=".02////0"
"RTN","XOBVPOST",69,0)
 . SET DIE="^XOB(18.03,"_XOBDA_",""PORTS"","
"RTN","XOBVPOST",70,0)
 . DO ^DIE
"RTN","XOBVPOST",71,0)
 ;
"RTN","XOBVPOST",72,0)
 SET XOBOK=1
"RTN","XOBVPOST",73,0)
PORTSQ ;
"RTN","XOBVPOST",74,0)
 QUIT XOBOK
"RTN","XOBVPOST",75,0)
 ;
"RTN","XOBVPOST",76,0)
 ;
"RTN","XOBVPOST",77,0)
PARMS(XOBCFG) ; -- add parameter entry
"RTN","XOBVPOST",78,0)
 NEW DIC,X,Y,DIE,DA,DR,XOBBOX,XOBDA,XOBMULI,XOBNEW
"RTN","XOBVPOST",79,0)
 ;
"RTN","XOBVPOST",80,0)
 ; -- box-pair name, no ien
"RTN","XOBVPOST",81,0)
 SET XOBBOX=$PIECE($$GETENV^XOBVTCP(),U,4)
"RTN","XOBVPOST",82,0)
 ; 
"RTN","XOBVPOST",83,0)
 ; -- Top-Level Parameters --
"RTN","XOBVPOST",84,0)
 SET DIC="^XOB(18.01,",DIC(0)="LXZ",X=$$DOMAIN() DO ^DIC
"RTN","XOBVPOST",85,0)
 ;
"RTN","XOBVPOST",86,0)
 ; -- quit if lookup failed or if already exists
"RTN","XOBVPOST",87,0)
 IF Y=-1 GOTO PARMSQ
"RTN","XOBVPOST",88,0)
 ;
"RTN","XOBVPOST",89,0)
 SET XOBDA=+Y
"RTN","XOBVPOST",90,0)
 SET XOBNEW=0
"RTN","XOBVPOST",91,0)
 IF $PIECE(Y(0),U,2)="",$PIECE(Y(0),U,3)="" SET XOBNEW=1
"RTN","XOBVPOST",92,0)
 ;
"RTN","XOBVPOST",93,0)
 ; -- set basic parameters (HEARTBEAT RATE and LATENCY DELTA)
"RTN","XOBVPOST",94,0)
 IF XOBNEW DO
"RTN","XOBVPOST",95,0)
 . SET DA=XOBDA
"RTN","XOBVPOST",96,0)
 . SET DR=".02////180;.03////180"
"RTN","XOBVPOST",97,0)
 . SET DIE="^XOB(18.01,"
"RTN","XOBVPOST",98,0)
 . DO ^DIE
"RTN","XOBVPOST",99,0)
 ;
"RTN","XOBVPOST",100,0)
 ; -- Listeners Multiple --
"RTN","XOBVPOST",101,0)
 ;
"RTN","XOBVPOST",102,0)
 ; -- quit if no config passed in (ie. not Cache NT) 
"RTN","XOBVPOST",103,0)
 IF '$GET(XOBCFG) GOTO PARMSQ
"RTN","XOBVPOST",104,0)
 ;
"RTN","XOBVPOST",105,0)
 ; -- set oth of multiple is needed
"RTN","XOBVPOST",106,0)
 IF $DATA(^XOB(18.01,1,"CONFIG",0))=0 SET ^XOB(18.01,1,"CONFIG",0)="^18.012P^^"
"RTN","XOBVPOST",107,0)
 ;
"RTN","XOBVPOST",108,0)
 SET DA(1)=XOBDA
"RTN","XOBVPOST",109,0)
 SET DIC="^XOB(18.01,"_XOBDA_",""CONFIG"","
"RTN","XOBVPOST",110,0)
 SET DIC(0)="LX"
"RTN","XOBVPOST",111,0)
 SET X=XOBBOX
"RTN","XOBVPOST",112,0)
 DO ^DIC
"RTN","XOBVPOST",113,0)
 ;
"RTN","XOBVPOST",114,0)
 ; -- quit if lookup failed or if already exists
"RTN","XOBVPOST",115,0)
 IF Y=-1 GOTO PARMSQ
"RTN","XOBVPOST",116,0)
 ;
"RTN","XOBVPOST",117,0)
 SET XOBMULI=+Y
"RTN","XOBVPOST",118,0)
 SET XOBNEW=$PIECE(Y,U,3)
"RTN","XOBVPOST",119,0)
 ;
"RTN","XOBVPOST",120,0)
 ; -- set listener config default
"RTN","XOBVPOST",121,0)
 IF XOBNEW DO
"RTN","XOBVPOST",122,0)
 . SET DA(1)=XOBDA
"RTN","XOBVPOST",123,0)
 . SET DA=XOBMULI
"RTN","XOBVPOST",124,0)
 . SET DR=".02////"_XOBCFG
"RTN","XOBVPOST",125,0)
 . SET DIE="^XOB(18.01,"_XOBDA_",""CONFIG"","
"RTN","XOBVPOST",126,0)
 . DO ^DIE
"RTN","XOBVPOST",127,0)
 ;
"RTN","XOBVPOST",128,0)
PARMSQ ;
"RTN","XOBVPOST",129,0)
 QUIT
"RTN","XOBVPOST",130,0)
 ;
"RTN","XOBVPOST",131,0)
 ;
"RTN","XOBVPOST",132,0)
DOMAIN() ; -- get account's domain entry
"RTN","XOBVPOST",133,0)
 ;
"RTN","XOBVPOST",134,0)
 QUIT $$KSP^XUPARAM("WHERE")
"RTN","XOBVPOST",135,0)
 ;
"RTN","XOBVPOST",136,0)
 ;
"RTN","XOBVPOST",137,0)
SCHEDOPT ;-- Schedule XOBV LISTENER STARTUP option in TaskMan
"RTN","XOBVPOST",138,0)
 ;
"RTN","XOBVPOST",139,0)
 ;  This procedure will schedule the XOBV LISTENER STARTUP option
"RTN","XOBVPOST",140,0)
 ;  in the OPTION SCHEDULING file (#19.2).
"RTN","XOBVPOST",141,0)
 ;
"RTN","XOBVPOST",142,0)
 NEW XOBMSG,XOBOIEN,XOBSIEN
"RTN","XOBVPOST",143,0)
 ;
"RTN","XOBVPOST",144,0)
 ;-- XOBOIEN = IEN (OPTION file), XOBSIEN = IEN (OPTION SCHEDULING file)
"RTN","XOBVPOST",145,0)
 SET (XOBOIEN,XOBSIEN)=0
"RTN","XOBVPOST",146,0)
 ;
"RTN","XOBVPOST",147,0)
 DO BMES^XPDUTL(">>> Scheduling the XOBV LISTENER STARTUP option...")
"RTN","XOBVPOST",148,0)
 ;
"RTN","XOBVPOST",149,0)
 ;-- Check that option was added to OPTION file #19 during installation
"RTN","XOBVPOST",150,0)
 SET XOBOIEN=$$FIND1^DIC(19,"","BX","XOBV LISTENER STARTUP","","","")
"RTN","XOBVPOST",151,0)
 ;
"RTN","XOBVPOST",152,0)
 ;-- Error XOBMSG and quit if option was not added
"RTN","XOBVPOST",153,0)
 IF 'XOBOIEN DO  QUIT
"RTN","XOBVPOST",154,0)
 . SET XOBMSG(1)=""
"RTN","XOBVPOST",155,0)
 . SET XOBMSG(2)=">>> Error: Option XOBV LISTENER STARTUP was not created in the OPTION (#19)"
"RTN","XOBVPOST",156,0)
 . SET XOBMSG(3)="           file during the KIDS installation.  Please reinstall."
"RTN","XOBVPOST",157,0)
 . DO BMES^XPDUTL(.XOBMSG)
"RTN","XOBVPOST",158,0)
 ;
"RTN","XOBVPOST",159,0)
 ;-- Check if option was already scheduled
"RTN","XOBVPOST",160,0)
 SET XOBSIEN=$$CHKOPT(XOBOIEN)
"RTN","XOBVPOST",161,0)
 ;
"RTN","XOBVPOST",162,0)
 ;-- Display option and quit if option was previously added
"RTN","XOBVPOST",163,0)
 IF XOBSIEN DO  QUIT
"RTN","XOBVPOST",164,0)
 . DO BMES^XPDUTL(">>> The XOBV LISTENER STARTUP option has previously been scheduled:")
"RTN","XOBVPOST",165,0)
 . DO DSPLYOP(XOBSIEN)
"RTN","XOBVPOST",166,0)
 ;
"RTN","XOBVPOST",167,0)
 ;-- Schedule the option
"RTN","XOBVPOST",168,0)
 SET XOBSIEN=$$FILEOPT(XOBSIEN,XOBOIEN,,,,"S")
"RTN","XOBVPOST",169,0)
 IF XOBSIEN DO
"RTN","XOBVPOST",170,0)
 . DO BMES^XPDUTL(">>> The XOBV LISTENER STARTUP option has been scheduled as follows:")
"RTN","XOBVPOST",171,0)
 . DO DSPLYOP(XOBSIEN)
"RTN","XOBVPOST",172,0)
 ELSE  DO
"RTN","XOBVPOST",173,0)
 . SET XOBMSG(1)=">>> Error: There was an error scheduling the XOBV LISTENER STARTUP option."
"RTN","XOBVPOST",174,0)
 . SET XOBMSG(2)="           Please schedule this option using 'Schedule/Unschedule Options'"
"RTN","XOBVPOST",175,0)
 . SET XOBMSG(3)="           in the Taskman Management menu."
"RTN","XOBVPOST",176,0)
 . DO BMES^XPDUTL(.XOBMSG)
"RTN","XOBVPOST",177,0)
 QUIT
"RTN","XOBVPOST",178,0)
 ;
"RTN","XOBVPOST",179,0)
 ;
"RTN","XOBVPOST",180,0)
CHKOPT(IEN) ;-- Check if option is already scheduled
"RTN","XOBVPOST",181,0)
 ;
"RTN","XOBVPOST",182,0)
 ;  Input:
"RTN","XOBVPOST",183,0)
 ;    IEN     -  IEN of option in OPTION file (#19)
"RTN","XOBVPOST",184,0)
 ;
"RTN","XOBVPOST",185,0)
 ; Output:
"RTN","XOBVPOST",186,0)
 ;    XOBSIEN -  IEN of option in OPTION SCHEDULING file (#19.2) or zero if it does not exist
"RTN","XOBVPOST",187,0)
 ;
"RTN","XOBVPOST",188,0)
 NEW X,X1,X2,XOBARY,XOBI,XOBIEN2
"RTN","XOBVPOST",189,0)
 SET (X1,X2,XOBI,XOBIEN2)=0
"RTN","XOBVPOST",190,0)
 DO FIND^DIC(19.2,"","@;.01I;9I","","XOBV LISTENER STARTUP","*","B","","","XOBARY")
"RTN","XOBVPOST",191,0)
 SET X=+$PIECE($GET(XOBARY("DILIST",0)),"^")
"RTN","XOBVPOST",192,0)
 FOR  SET XOBI=$ORDER(XOBARY("DILIST","ID",X,XOBI)) QUIT:'XOBI  DO
"RTN","XOBVPOST",193,0)
 . IF XOBI=.01,$GET(XOBARY("DILIST","ID",X,XOBI))=IEN SET X1=1
"RTN","XOBVPOST",194,0)
 . IF XOBI=9,$GET(XOBARY("DILIST","ID",X,XOBI))["S" SET X2=1
"RTN","XOBVPOST",195,0)
 . IF X1,X2 SET XOBIEN2=+$GET(XOBARY("DILIST",2,X))
"RTN","XOBVPOST",196,0)
 QUIT XOBIEN2
"RTN","XOBVPOST",197,0)
 ;
"RTN","XOBVPOST",198,0)
 ;
"RTN","XOBVPOST",199,0)
DSPLYOP(IEN) ;-- Display fields from OPTION SCHEDULING file (#19.2)
"RTN","XOBVPOST",200,0)
 ;
"RTN","XOBVPOST",201,0)
 ;  Input:
"RTN","XOBVPOST",202,0)
 ;    IEN  -  IEN of record in file #19.2
"RTN","XOBVPOST",203,0)
 ;
"RTN","XOBVPOST",204,0)
 ; Output:
"RTN","XOBVPOST",205,0)
 ;    Display of fields in record
"RTN","XOBVPOST",206,0)
 ;
"RTN","XOBVPOST",207,0)
 QUIT:'$GET(IEN)
"RTN","XOBVPOST",208,0)
 NEW DA,DIC,DIQ
"RTN","XOBVPOST",209,0)
 SET DIC="^DIC(19.2,",DA=IEN,DIQ(0)="CAR"
"RTN","XOBVPOST",210,0)
 DO MES^XPDUTL("")
"RTN","XOBVPOST",211,0)
 DO EN^DIQ
"RTN","XOBVPOST",212,0)
 DO BMES^XPDUTL("")
"RTN","XOBVPOST",213,0)
 QUIT
"RTN","XOBVPOST",214,0)
 ;
"RTN","XOBVPOST",215,0)
 ;
"RTN","XOBVPOST",216,0)
FILEOPT(XOBIEN,XOBOPT,XOBQUE,XOBDEV,XOBRSCH,XOBSPARM)   ;-- Schedule the option
"RTN","XOBVPOST",217,0)
 ;
"RTN","XOBVPOST",218,0)
 ;-- File a new record in file #19.2 or edit existing
"RTN","XOBVPOST",219,0)
 ;
"RTN","XOBVPOST",220,0)
 ;  Input:
"RTN","XOBVPOST",221,0)
 ;    XOBIEN   -   IEN from record in file #19.2 if it exists
"RTN","XOBVPOST",222,0)
 ;    XOBOPT   -   IEN of option (file #19); (required)
"RTN","XOBVPOST",223,0)
 ;    XOBQUE   -   Queued to run at what time; (optional)
"RTN","XOBVPOST",224,0)
 ;    XOBDEV   -   Device for queued job output; (optional)
"RTN","XOBVPOST",225,0)
 ;    XOBRSCH  -   Rescheduling frequency; (optional)
"RTN","XOBVPOST",226,0)
 ;    XOBSPARM -   Special queuing; (optional)
"RTN","XOBVPOST",227,0)
 ;
"RTN","XOBVPOST",228,0)
 ; Output:
"RTN","XOBVPOST",229,0)
 ;    Function Value - Returns IEN of record on success, 0 on failure
"RTN","XOBVPOST",230,0)
 ;
"RTN","XOBVPOST",231,0)
 NEW XOBFDA,XOBFDAI,XOBERR,XOBIENS
"RTN","XOBVPOST",232,0)
 ;
"RTN","XOBVPOST",233,0)
 SET XOBIEN=+$GET(XOBIEN)
"RTN","XOBVPOST",234,0)
 ;
"RTN","XOBVPOST",235,0)
 ;-- If record doesn't already exist, create new
"RTN","XOBVPOST",236,0)
 IF XOBIEN SET XOBIENS=XOBIEN_","
"RTN","XOBVPOST",237,0)
 ELSE  SET XOBIENS="+1,"
"RTN","XOBVPOST",238,0)
 ;
"RTN","XOBVPOST",239,0)
 ;-- Set up array with field values
"RTN","XOBVPOST",240,0)
 SET XOBFDA(19.2,XOBIENS,.01)=$GET(XOBOPT)
"RTN","XOBVPOST",241,0)
 SET XOBFDA(19.2,XOBIENS,2)=$GET(XOBQUE)
"RTN","XOBVPOST",242,0)
 SET XOBFDA(19.2,XOBIENS,3)=$GET(XOBDEV)
"RTN","XOBVPOST",243,0)
 SET XOBFDA(19.2,XOBIENS,6)=$GET(XOBRSCH)
"RTN","XOBVPOST",244,0)
 SET XOBFDA(19.2,XOBIENS,9)=$GET(XOBSPARM)
"RTN","XOBVPOST",245,0)
 ;
"RTN","XOBVPOST",246,0)
 IF XOBIEN DO
"RTN","XOBVPOST",247,0)
 . DO FILE^DIE("","XOBFDA","XOBERR")
"RTN","XOBVPOST",248,0)
 . IF $DATA(XOBERR) SET XOBIEN=0
"RTN","XOBVPOST",249,0)
 ELSE  DO
"RTN","XOBVPOST",250,0)
 . DO UPDATE^DIE("","XOBFDA","XOBFDAI","XOBERR")
"RTN","XOBVPOST",251,0)
 . IF '$DATA(XOBERR) SET XOBIEN=$GET(XOBFDAI(1))
"RTN","XOBVPOST",252,0)
 ;
"RTN","XOBVPOST",253,0)
 QUIT $SELECT($GET(XOBIEN)>0:XOBIEN,1:0)
"RTN","XOBVPOST",254,0)
 ;
"RTN","XOBVPOST",255,0)
ADDPROXY(XOBANAME) ; add application proxy if not present
"RTN","XOBVPOST",256,0)
 ; depends on XU*8*361
"RTN","XOBVPOST",257,0)
 NEW XOBID,XOBMSG,XOBSUBER,XOBSUBTX,XOBLINE
"RTN","XOBVPOST",258,0)
 ;
"RTN","XOBVPOST",259,0)
 ; if already present don't add
"RTN","XOBVPOST",260,0)
 QUIT:(+$$APFIND^XUSAP(XOBANAME))>0
"RTN","XOBVPOST",261,0)
 ;
"RTN","XOBVPOST",262,0)
 SET XOBID=$$CREATE^XUSAP(XOBANAME,"","XOBV VISTALINK TESTER")
"RTN","XOBVPOST",263,0)
 IF (+XOBID)>0 DO
"RTN","XOBVPOST",264,0)
 . SET XOBMSG(1)=" Added new Kernel Application Proxy User '"_XOBANAME_"'."
"RTN","XOBVPOST",265,0)
 . SET XOBMSG(2)="  ::This application proxy user account is used in the VistALink sample web"
"RTN","XOBVPOST",266,0)
 . SET XOBMSG(3)="  ::application, to demonstrate usage of the VistaLinkAppProxyConnectionSpec"
"RTN","XOBVPOST",267,0)
 . SET XOBMSG(4)="  ::connection spec."
"RTN","XOBVPOST",268,0)
 . DO BMES^XPDUTL(.XOBMSG)
"RTN","XOBVPOST",269,0)
 IF (+XOBID)=0 DO
"RTN","XOBVPOST",270,0)
 . ; already checked if user present, should never get 0 back
"RTN","XOBVPOST",271,0)
 . SET XOBMSG(1)=">>> Error: Could not add VistALink Application Proxy User '"_XOBANAME_"' -- Already exists."
"RTN","XOBVPOST",272,0)
 . DO BMES^XPDUTL(.XOBMSG)
"RTN","XOBVPOST",273,0)
 IF (+XOBID)<0 DO
"RTN","XOBVPOST",274,0)
 . SET XOBMSG(1)=">>> Error: Could not add VistALink Application Proxy User '"_XOBANAME_"'."
"RTN","XOBVPOST",275,0)
 . SET XOBMSG(2)="    DIERR nodes: <start of error(s)>"
"RTN","XOBVPOST",276,0)
 . SET XOBLINE=3,XOBSUBER=0 FOR  SET XOBSUBER=$O(^TMP("DIERR",$J,XOBSUBER)) QUIT:(+XOBSUBER)'>0  DO
"RTN","XOBVPOST",277,0)
 . . SET XOBMSG(XOBLINE)="    "_^TMP("DIERR",$J,XOBSUBER),XOBLINE=XOBLINE+1
"RTN","XOBVPOST",278,0)
 . . SET XOBSUBTX=0 FOR  SET XOBSUBTX=$O(^TMP("DIERR",$J,XOBSUBER,"TEXT",XOBSUBTX)) QUIT:(+XOBSUBTX)'>0  DO
"RTN","XOBVPOST",279,0)
 . . . SET XOBMSG(XOBLINE)="    "_^TMP("DIERR",$J,XOBSUBER,"TEXT",XOBSUBTX),XOBLINE=XOBLINE+1
"RTN","XOBVPOST",280,0)
 . SET XOBMSG(XOBLINE+1)="    <end of error(s)>"
"RTN","XOBVPOST",281,0)
 . DO BMES^XPDUTL(.XOBMSG)
"RTN","XOBVPOST",282,0)
 . K ^TMP("DIERR",$J)
"RTN","XOBVPOST",283,0)
 ;
"RTN","XOBVPOST",284,0)
 QUIT
"RTN","XOBVPRE")
0^^B568396
"RTN","XOBVPRE",1,0)
XOBVPRE ;; mjk/alb - VistaLimk Pre-Init ; 07/27/2002  13:00
"RTN","XOBVPRE",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVPRE",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVPRE",4,0)
 QUIT
"RTN","XOBVPRE",5,0)
 ;
"RTN","XOBVPRE",6,0)
EN ; -- add pre-init code here
"RTN","XOBVPRE",7,0)
 ; -- delete VISTALINK MESSAGE TYPE file (18.05)
"RTN","XOBVPRE",8,0)
 DO DEL(18.05)
"RTN","XOBVPRE",9,0)
 ;
"RTN","XOBVPRE",10,0)
 QUIT
"RTN","XOBVPRE",11,0)
 ;
"RTN","XOBVPRE",12,0)
DEL(XOBFILE) ; -- delete file
"RTN","XOBVPRE",13,0)
 NEW DIU,XOBRES
"RTN","XOBVPRE",14,0)
 ;
"RTN","XOBVPRE",15,0)
 DO FILE^DID(XOBFILE,"","NAME","XOBRES")
"RTN","XOBVPRE",16,0)
 ;
"RTN","XOBVPRE",17,0)
 ; -- if file present then delete
"RTN","XOBVPRE",18,0)
 IF $GET(XOBRES("NAME"))'="" DO
"RTN","XOBVPRE",19,0)
 . ; -- delete security provider file
"RTN","XOBVPRE",20,0)
 . SET DIU=XOBFILE,DIU(0)="TD" DO EN^DIU2
"RTN","XOBVPRE",21,0)
 ;
"RTN","XOBVPRE",22,0)
 QUIT
"RTN","XOBVPRE",23,0)
 ;
"RTN","XOBVRH")
0^9^B12957948
"RTN","XOBVRH",1,0)
XOBVRH ;mjk/alb - VistaLink Request Handler Utilities ; 07/27/2002  13:00
"RTN","XOBVRH",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVRH",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVRH",4,0)
 QUIT
"RTN","XOBVRH",5,0)
 ;
"RTN","XOBVRH",6,0)
 ; ------------------------------------------------------------------
"RTN","XOBVRH",7,0)
 ;                       Message Type Handler Utilities
"RTN","XOBVRH",8,0)
 ; ------------------------------------------------------------------
"RTN","XOBVRH",9,0)
 ; 
"RTN","XOBVRH",10,0)
 ; -- set up msg type info using message name
"RTN","XOBVRH",11,0)
MSGNAME(XOBMSG,XOBHDLR) ; -- set up msg type info
"RTN","XOBVRH",12,0)
 QUIT $$SETMSG(XOBMSG,"NAME",.XOBHDLR)
"RTN","XOBVRH",13,0)
 ;
"RTN","XOBVRH",14,0)
 ; -- set up msg type info using message type
"RTN","XOBVRH",15,0)
MSGTYPE(XOBMSG,XOBHDLR) ; -- set up msg type info
"RTN","XOBVRH",16,0)
 QUIT $$SETMSG(XOBMSG,"MSGTYPE",.XOBHDLR)
"RTN","XOBVRH",17,0)
 ;
"RTN","XOBVRH",18,0)
 ; -- set up msg type info using proprietary string
"RTN","XOBVRH",19,0)
MSGSINK(XOBMSG,XOBHDLR) ; -- set up msg type info
"RTN","XOBVRH",20,0)
 QUIT $$SETMSG(XOBMSG,"D",.XOBHDLR)
"RTN","XOBVRH",21,0)
 ;
"RTN","XOBVRH",22,0)
CACHE(XOBHDLR) ; -- cache req handlers
"RTN","XOBVRH",23,0)
 NEW TYPE,TYPE0,XOBOK
"RTN","XOBVRH",24,0)
 SET TYPE=0
"RTN","XOBVRH",25,0)
 SET XOBOK=1
"RTN","XOBVRH",26,0)
 ;
"RTN","XOBVRH",27,0)
 ; -- load request handler info
"RTN","XOBVRH",28,0)
 FOR  SET TYPE=$ORDER(^XOB(18.05,"AS",1,TYPE)) QUIT:'TYPE  DO  QUIT:'XOBOK
"RTN","XOBVRH",29,0)
 . SET TYPE0=$GET(^XOB(18.05,TYPE,0))
"RTN","XOBVRH",30,0)
 . DO SET(TYPE,TYPE0,.XOBHDLR)
"RTN","XOBVRH",31,0)
 . SET XOBOK=$GET(XOBHDLR(TYPE))
"RTN","XOBVRH",32,0)
 . IF 'XOBOK SET XOBOK=XOBOK_U_$GET(XOBHDLR,"ERROR")
"RTN","XOBVRH",33,0)
 QUIT XOBOK
"RTN","XOBVRH",34,0)
 ;
"RTN","XOBVRH",35,0)
 ;  -- set up msg type info
"RTN","XOBVRH",36,0)
SETMSG(XOBMSG,XOBXREF,XOBHDLR) ;
"RTN","XOBVRH",37,0)
 NEW TYPE,TYPEO
"RTN","XOBVRH",38,0)
 KILL XOBHDLR(0)
"RTN","XOBVRH",39,0)
 ;
"RTN","XOBVRH",40,0)
 ; -- bad message type (empty)
"RTN","XOBVRH",41,0)
 IF $GET(XOBMSG)="" DO  QUIT TYPE
"RTN","XOBVRH",42,0)
 . SET TYPE=0
"RTN","XOBVRH",43,0)
 . SET XOBHDLR(0)=0
"RTN","XOBVRH",44,0)
 . SET XOBHDLR(0,"ERROR")="No message type defined"
"RTN","XOBVRH",45,0)
 ;
"RTN","XOBVRH",46,0)
 ; -- already cached?
"RTN","XOBVRH",47,0)
 SET TYPE=$ORDER(XOBHDLR(XOBXREF,XOBMSG,""))
"RTN","XOBVRH",48,0)
 IF TYPE QUIT TYPE
"RTN","XOBVRH",49,0)
 ;
"RTN","XOBVRH",50,0)
 ; -- load req handler
"RTN","XOBVRH",51,0)
 SET TYPE=+$ORDER(^XOB(18.05,XOBXREF,XOBMSG,""))
"RTN","XOBVRH",52,0)
 IF TYPE DO
"RTN","XOBVRH",53,0)
 . SET TYPE0=$GET(^XOB(18.05,TYPE,0))
"RTN","XOBVRH",54,0)
 . DO SET(.TYPE,.TYPE0,.XOBHDLR)
"RTN","XOBVRH",55,0)
 IF 'TYPE DO
"RTN","XOBVRH",56,0)
 . SET XOBHDLR(0)=0
"RTN","XOBVRH",57,0)
 . SET XOBHDLR(0,"ERROR")="No message type defined"
"RTN","XOBVRH",58,0)
 QUIT TYPE
"RTN","XOBVRH",59,0)
 ;
"RTN","XOBVRH",60,0)
SET(TYPE,TYPE0,XOBHDLR) ; -- set nodes
"RTN","XOBVRH",61,0)
 NEW IRTN,XOBICBK
"RTN","XOBVRH",62,0)
 KILL XOBHDLR(TYPE)
"RTN","XOBVRH",63,0)
 SET IRTN=$$IRTN(TYPE0)
"RTN","XOBVRH",64,0)
 IF IRTN="" DO  GOTO SETQ
"RTN","XOBVRH",65,0)
 . SET XOBHDLR(TYPE)=0
"RTN","XOBVRH",66,0)
 . IF TYPE0="" SET XOBHDLR(TYPE,"ERROR")="No entry for message type ["_TYPE_"]" QUIT
"RTN","XOBVRH",67,0)
 . IF IRTN="" SET XOBHDLR(TYPE,"ERROR")="Invalid interface routine specified ["_$PIECE(TYPE0,U,5)_"]" QUIT
"RTN","XOBVRH",68,0)
 ;
"RTN","XOBVRH",69,0)
 SET XOBHDLR(TYPE)=1
"RTN","XOBVRH",70,0)
 SET XOBHDLR(TYPE,"AUTHENTICATE")=+$PIECE(TYPE0,U,4)
"RTN","XOBVRH",71,0)
 SET XOBHDLR(TYPE,"REQHDLR")="DO REQHDLR^"_IRTN_"(.XOBDATA)"
"RTN","XOBVRH",72,0)
 SET XOBHDLR(TYPE,"READER")="DO READER^"_IRTN_"(.XOBX,.XOBDATA)"
"RTN","XOBVRH",73,0)
 IF $PIECE(TYPE0,U,1)]"" SET XOBHDLR("NAME",$PIECE(TYPE0,U,1),TYPE)=""
"RTN","XOBVRH",74,0)
 IF $PIECE(TYPE0,U,2)]"" SET XOBHDLR("MSGTYPE",$PIECE(TYPE0,U,2),TYPE)=""
"RTN","XOBVRH",75,0)
 IF $PIECE(TYPE0,U,7)]"" SET XOBHDLR("D",$PIECE(TYPE0,U,7),TYPE)=""
"RTN","XOBVRH",76,0)
 ;
"RTN","XOBVRH",77,0)
 ; -- set up SAX callbacks
"RTN","XOBVRH",78,0)
 SET XOBHDLR(TYPE,"CB","ELEST")="QUIT"
"RTN","XOBVRH",79,0)
 SET XOBHDLR(TYPE,"CB","ELEND")="QUIT"
"RTN","XOBVRH",80,0)
 SET XOBHDLR(TYPE,"CB","CHR")="QUIT"
"RTN","XOBVRH",81,0)
 ;
"RTN","XOBVRH",82,0)
 XECUTE "DO CALLBACK^"_IRTN_"(.XOBICBK)"
"RTN","XOBVRH",83,0)
 IF $DATA(XOBICBK("STARTELEMENT")) SET XOBHDLR(TYPE,"CB","ELEST")="DO "_XOBICBK("STARTELEMENT")_"(.ELE,.ATR)"
"RTN","XOBVRH",84,0)
 IF $DATA(XOBICBK("ENDELEMENT")) SET XOBHDLR(TYPE,"CB","ELEND")="DO "_XOBICBK("ENDELEMENT")_"(.ELE)"
"RTN","XOBVRH",85,0)
 IF $DATA(XOBICBK("CHARACTERS")) SET XOBHDLR(TYPE,"CB","CHR")="DO "_XOBICBK("CHARACTERS")_"(.TXT)"
"RTN","XOBVRH",86,0)
SETQ ;
"RTN","XOBVRH",87,0)
 QUIT
"RTN","XOBVRH",88,0)
 ;
"RTN","XOBVRH",89,0)
 ; -- get interface routine and test for existence
"RTN","XOBVRH",90,0)
IRTN(XOBTYPE0) ;
"RTN","XOBVRH",91,0)
 NEW X,RTN
"RTN","XOBVRH",92,0)
 SET RTN=""
"RTN","XOBVRH",93,0)
 SET X=$PIECE(XOBTYPE0,"^",5)
"RTN","XOBVRH",94,0)
 IF X]"" DO
"RTN","XOBVRH",95,0)
 . XECUTE ^%ZOSF("TEST")
"RTN","XOBVRH",96,0)
 . IF $TEST SET RTN=X
"RTN","XOBVRH",97,0)
 QUIT RTN
"RTN","XOBVRH",98,0)
 ;
"RTN","XOBVRM")
0^10^B4502318
"RTN","XOBVRM",1,0)
XOBVRM ;; mjk/alb - VistaLink Request Manager ; 07/27/2002  13:00
"RTN","XOBVRM",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVRM",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVRM",4,0)
 QUIT
"RTN","XOBVRM",5,0)
 ;
"RTN","XOBVRM",6,0)
 ; --------------------------------------------------------------------------------
"RTN","XOBVRM",7,0)
 ;                                Request Manager
"RTN","XOBVRM",8,0)
 ; --------------------------------------------------------------------------------
"RTN","XOBVRM",9,0)
 ;                   
"RTN","XOBVRM",10,0)
EN(XOBROOT,XOBDATA,XOBHDLR) ; -- main entry point for Request Manager
"RTN","XOBVRM",11,0)
 NEW XOBOK,XOBOPT
"RTN","XOBVRM",12,0)
 SET XOBOK=0
"RTN","XOBVRM",13,0)
 ;
"RTN","XOBVRM",14,0)
 ; -- if 'current' request handler is not defined then parse xml global buffer
"RTN","XOBVRM",15,0)
 ;    Note: 'Current' request handler could be define already via proprietary format reader
"RTN","XOBVRM",16,0)
 IF $GET(XOBHDLR)="" SET XOBOPT="" DO EN^XOBVRMX(XOBROOT,.XOBOPT,.XOBDATA,.XOBHDLR)
"RTN","XOBVRM",17,0)
 ;
"RTN","XOBVRM",18,0)
 ; -- default single call processing if not specified by request handler
"RTN","XOBVRM",19,0)
 IF $GET(XOBDATA("MODE"),"single call")="single call" SET XOBSTOP=1
"RTN","XOBVRM",20,0)
 ;
"RTN","XOBVRM",21,0)
 ; -- check if request handler info was successfully initialized / if not, throw exception
"RTN","XOBVRM",22,0)
 SET XOBHDLR=+$GET(XOBHDLR)
"RTN","XOBVRM",23,0)
 IF '$GET(XOBHDLR(XOBHDLR)) DO  GOTO ENQ
"RTN","XOBVRM",24,0)
 . SET XWBTIP=$$GETPEER^%ZOSV ; try get client IP for error trap. Use of GETPEER^%ZOSV: DBIA #4056
"RTN","XOBVRM",25,0)
 . DO RMERR(184001,$GET(XOBHDLR(XOBHDLR,"ERROR"),"Request Manager not defined"))
"RTN","XOBVRM",26,0)
 . SET XOBOK=0
"RTN","XOBVRM",27,0)
 ;
"RTN","XOBVRM",28,0)
 ; -- do authentication check for message type?
"RTN","XOBVRM",29,0)
 IF $GET(XOBHDLR(XOBHDLR,"AUTHENTICATE")) DO
"RTN","XOBVRM",30,0)
 . SET XOBOK=$$LOGGEDON^XOBSCAV()
"RTN","XOBVRM",31,0)
 ELSE  DO
"RTN","XOBVRM",32,0)
 . SET XOBOK=1
"RTN","XOBVRM",33,0)
 ;
"RTN","XOBVRM",34,0)
 ; -- call request handler
"RTN","XOBVRM",35,0)
 IF XOBOK XECUTE $GET(XOBHDLR(XOBHDLR,"REQHDLR"))
"RTN","XOBVRM",36,0)
 ;
"RTN","XOBVRM",37,0)
ENQ ;
"RTN","XOBVRM",38,0)
 QUIT XOBOK
"RTN","XOBVRM",39,0)
 ;
"RTN","XOBVRM",40,0)
 ; ----------------------------------------------------------------------------------
"RTN","XOBVRM",41,0)
 ;                    Request Manager Error Handler
"RTN","XOBVRM",42,0)
 ; ----------------------------------------------------------------------------------
"RTN","XOBVRM",43,0)
RMERR(XOBCODE,XOBMSG) ; -- send request error message
"RTN","XOBVRM",44,0)
 NEW XOBDAT
"RTN","XOBVRM",45,0)
 SET XOBDAT("MESSAGE TYPE")=3
"RTN","XOBVRM",46,0)
 SET XOBDAT("ERRORS",1,"FAULT STRING")="System Error"
"RTN","XOBVRM",47,0)
 SET XOBDAT("ERRORS",1,"FAULT ACTOR")="Request Manager"
"RTN","XOBVRM",48,0)
 SET XOBDAT("ERRORS",1,"CODE")=XOBCODE
"RTN","XOBVRM",49,0)
 SET XOBDAT("ERRORS",1,"ERROR TYPE")="Request Manager"
"RTN","XOBVRM",50,0)
 SET XOBDAT("ERRORS",1,"CDATA")=0
"RTN","XOBVRM",51,0)
 SET XOBDAT("ERRORS",1,"MESSAGE",1)=$$EZBLD^DIALOG(XOBCODE,XOBMSG)
"RTN","XOBVRM",52,0)
 DO ERROR^XOBVLIB(.XOBDAT)
"RTN","XOBVRM",53,0)
 DO ^%ZTER
"RTN","XOBVRM",54,0)
 QUIT
"RTN","XOBVRM",55,0)
 ;
"RTN","XOBVRMX")
0^11^B3008010
"RTN","XOBVRMX",1,0)
XOBVRMX ;mjk/alb - VistaLink Request Manager - Parse XML Requests using SAX interface ; 07/27/2002  13:00
"RTN","XOBVRMX",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVRMX",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVRMX",4,0)
 QUIT
"RTN","XOBVRMX",5,0)
 ;
"RTN","XOBVRMX",6,0)
 ; -- parse xml
"RTN","XOBVRMX",7,0)
EN(DOC,XOBOPT,XOBDATA,XOBHDLR) ; -- uses SAX parser
"RTN","XOBVRMX",8,0)
 NEW XOBCBK,XOBICBK
"RTN","XOBVRMX",9,0)
 DO SET(.XOBCBK)
"RTN","XOBVRMX",10,0)
 DO EN^MXMLPRSE(DOC,.XOBCBK,.XOBOPT)
"RTN","XOBVRMX",11,0)
ENQ QUIT
"RTN","XOBVRMX",12,0)
 ;
"RTN","XOBVRMX",13,0)
SET(XOBCBK) ; -- set the event interface entry points
"RTN","XOBVRMX",14,0)
 SET XOBCBK("STARTELEMENT")="ELEST^XOBVRMX"
"RTN","XOBVRMX",15,0)
 SET XOBCBK("ENDELEMENT")="ELEND^XOBVRMX"
"RTN","XOBVRMX",16,0)
 SET XOBCBK("CHARACTERS")="CHR^XOBVRMX"
"RTN","XOBVRMX",17,0)
 QUIT
"RTN","XOBVRMX",18,0)
 ;
"RTN","XOBVRMX",19,0)
ELEST(ELE,ATR) ; -- element start callback
"RTN","XOBVRMX",20,0)
 IF ELE="VistaLink" DO
"RTN","XOBVRMX",21,0)
 . SET XOBDATA("VL VERSION")=$GET(ATR("version"),"1.0")
"RTN","XOBVRMX",22,0)
 . ;
"RTN","XOBVRMX",23,0)
 . ; -- set up request handler for message type
"RTN","XOBVRMX",24,0)
 . SET XOBHDLR=+$$MSGTYPE^XOBVRH($GET(ATR("messageType"),"[unknown]"),.XOBHDLR)
"RTN","XOBVRMX",25,0)
 ;
"RTN","XOBVRMX",26,0)
 ; -- do start element callback for request handler
"RTN","XOBVRMX",27,0)
 IF $GET(XOBHDLR(XOBHDLR)) XECUTE $GET(XOBHDLR(XOBHDLR,"CB","ELEST"))
"RTN","XOBVRMX",28,0)
 QUIT
"RTN","XOBVRMX",29,0)
 ;
"RTN","XOBVRMX",30,0)
ELEND(ELE) ; -- element end callback
"RTN","XOBVRMX",31,0)
 ; -- do end element callback for request handler
"RTN","XOBVRMX",32,0)
 IF $GET(XOBHDLR(XOBHDLR)) XECUTE $GET(XOBHDLR(XOBHDLR,"CB","ELEND"))
"RTN","XOBVRMX",33,0)
 QUIT
"RTN","XOBVRMX",34,0)
 ;
"RTN","XOBVRMX",35,0)
CHR(TXT) ; -- handler characters callback
"RTN","XOBVRMX",36,0)
 ; -- do character callback for request handler
"RTN","XOBVRMX",37,0)
 IF $GET(XOBHDLR(XOBHDLR)) XECUTE $GET(XOBHDLR(XOBHDLR,"CB","CHR"))
"RTN","XOBVRMX",38,0)
 QUIT
"RTN","XOBVRMX",39,0)
 ;
"RTN","XOBVRMX",40,0)
ESC(X) ; -- convert special characters to \x format ; not currently used -- note QUIT at start
"RTN","XOBVRMX",41,0)
 QUIT X
"RTN","XOBVRMX",42,0)
 ;
"RTN","XOBVRMX",43,0)
 NEW C,Y,Z
"RTN","XOBVRMX",44,0)
 FOR Z=1:1 SET C=$EXTRACT(X,Z) QUIT:C=""  DO
"RTN","XOBVRMX",45,0)
 .SET Y=$TRANSLATE(C,$CHAR(9,10,13,92),"tnc")
"RTN","XOBVRMX",46,0)
 .SET:C'=Y $EXTRACT(X,Z)="" ;$S(Y="":"\\",1:"\"_Y),Z=Z+1
"RTN","XOBVRMX",47,0)
 QUIT X
"RTN","XOBVRMX",48,0)
 ;
"RTN","XOBVRPC")
0^12^B55791656
"RTN","XOBVRPC",1,0)
XOBVRPC ;; mjk/alb - VistaLink RPC Server Listener Code ; 07/27/2002  13:00
"RTN","XOBVRPC",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVRPC",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVRPC",4,0)
 QUIT
"RTN","XOBVRPC",5,0)
 ;
"RTN","XOBVRPC",6,0)
 ; ------------------------------------------------------------------------
"RTN","XOBVRPC",7,0)
 ;                   RPC Server: Message Request Handler         
"RTN","XOBVRPC",8,0)
 ; ------------------------------------------------------------------------
"RTN","XOBVRPC",9,0)
 ; 
"RTN","XOBVRPC",10,0)
EN(XOBDATA) ; -- handle parsed messages request
"RTN","XOBVRPC",11,0)
 NEW DX,DY,RPC0,RPCNAME,RPCIEN,TAG,ROU,METHSIG,XOBERR,XOBR,XOBSEC,XOBWRAP,XOBPTYPE,XRTN,XOBRA,XOBVER
"RTN","XOBVRPC",12,0)
 ;
"RTN","XOBVRPC",13,0)
 IF $GET(XOBDATA("XOB RPC","RPC NAME"))="" DO  GOTO ENQ
"RTN","XOBVRPC",14,0)
 . DO ERROR(182001,"[No RPC]","")
"RTN","XOBVRPC",15,0)
 ;
"RTN","XOBVRPC",16,0)
 SET RPCNAME=XOBDATA("XOB RPC","RPC NAME")
"RTN","XOBVRPC",17,0)
 ;
"RTN","XOBVRPC",18,0)
 IF $DATA(^XWB(8994,"B",RPCNAME))=0 DO  GOTO ENQ
"RTN","XOBVRPC",19,0)
 . DO ERROR(182002,RPCNAME,RPCNAME)
"RTN","XOBVRPC",20,0)
 ;
"RTN","XOBVRPC",21,0)
 IF $DATA(^XWB(8994,"B",RPCNAME))=10 SET RPCIEN=+$ORDER(^XWB(8994,"B",RPCNAME,""))
"RTN","XOBVRPC",22,0)
 ;
"RTN","XOBVRPC",23,0)
 ; -- get zero node
"RTN","XOBVRPC",24,0)
 SET RPC0=$GET(^XWB(8994,RPCIEN,0))
"RTN","XOBVRPC",25,0)
 ;
"RTN","XOBVRPC",26,0)
 ; -- make sure there is data on node
"RTN","XOBVRPC",27,0)
 IF RPC0="" DO  GOTO ENQ
"RTN","XOBVRPC",28,0)
 . DO ERROR(182003,RPCNAME,RPCNAME)
"RTN","XOBVRPC",29,0)
 ;
"RTN","XOBVRPC",30,0)
 ; -- make sure x-ref is not corrupt and found the wrong entry
"RTN","XOBVRPC",31,0)
 IF RPCNAME'=$PIECE(RPC0,U) DO  GOTO ENQ
"RTN","XOBVRPC",32,0)
 . NEW PARAMS SET PARAMS(1)=RPCNAME,PARAMS(2)=$PIECE(RPC0,U)
"RTN","XOBVRPC",33,0)
 . DO ERROR(182008,RPCNAME,.PARAMS)
"RTN","XOBVRPC",34,0)
 ;
"RTN","XOBVRPC",35,0)
 ; -- check inactive flag
"RTN","XOBVRPC",36,0)
 IF $PIECE(RPC0,U,6)=1!($PIECE(RPC0,U,6)=2) DO  GOTO ENQ
"RTN","XOBVRPC",37,0)
 . DO ERROR(182004,RPCNAME,RPCNAME)
"RTN","XOBVRPC",38,0)
 ;
"RTN","XOBVRPC",39,0)
 ; -- if not already performed, check version, environment and set re-auth check flag
"RTN","XOBVRPC",40,0)
 SET XOBERR=$SELECT($DATA(XOBSYS("RPC REAUTH")):0,1:$$VER())
"RTN","XOBVRPC",41,0)
 IF XOBERR DO  GOTO ENQ
"RTN","XOBVRPC",42,0)
 . DO ERROR(XOBERR,RPCNAME)
"RTN","XOBVRPC",43,0)
 ;
"RTN","XOBVRPC",44,0)
 ; -- reauthentication checks
"RTN","XOBVRPC",45,0)
 SET XOBERR=0
"RTN","XOBVRPC",46,0)
 IF +$GET(XOBSYS("RPC REAUTH")) DO  GOTO:XOBERR ENQ
"RTN","XOBVRPC",47,0)
 . ;
"RTN","XOBVRPC",48,0)
 . ; -- reauthenticate user based on type (i.e. DUZ,AV,VPID,CCOW,APPPROXY)
"RTN","XOBVRPC",49,0)
 . SET XOBERR=$$SETUPDUZ^XOBSRA()
"RTN","XOBVRPC",50,0)
 . IF XOBERR DO ERROR(XOBERR,RPCNAME) QUIT
"RTN","XOBVRPC",51,0)
 . ;
"RTN","XOBVRPC",52,0)
 . ; -- if application proxy user, check if allowed to run RPC
"RTN","XOBVRPC",53,0)
 . IF $$UP^XLFSTR(XOBDATA("XOB RPC","SECURITY","TYPE"))="APPPROXY",'$$RPC^XUSAP($GET(RPCIEN)) DO  QUIT
"RTN","XOBVRPC",54,0)
 .. SET XOBERR=182010
"RTN","XOBVRPC",55,0)
 .. DO ERROR(XOBERR,RPCNAME,RPCNAME)
"RTN","XOBVRPC",56,0)
 ;
"RTN","XOBVRPC",57,0)
 ; -- set context
"RTN","XOBVRPC",58,0)
 SET XOBSEC=$$CRCONTXT^XOBSCAV($GET(XOBDATA("XOB RPC","RPC CONTEXT")))
"RTN","XOBVRPC",59,0)
 IF '+XOBSEC DO  GOTO ENQ
"RTN","XOBVRPC",60,0)
 . DO ERROR(182005,RPCNAME,XOBSEC)
"RTN","XOBVRPC",61,0)
 ;
"RTN","XOBVRPC",62,0)
 ; -- check if appropriate context created
"RTN","XOBVRPC",63,0)
 SET XOBSEC=$$CHKCTXT^XOBSCAV(RPCNAME)
"RTN","XOBVRPC",64,0)
 IF '+XOBSEC DO  GOTO ENQ
"RTN","XOBVRPC",65,0)
 . DO ERROR(182006,RPCNAME,XOBSEC)
"RTN","XOBVRPC",66,0)
 ;
"RTN","XOBVRPC",67,0)
 ; -- setup timeout info
"RTN","XOBVRPC",68,0)
 SET XOBDATA("XOB RPC","TIMED OUT")=0
"RTN","XOBVRPC",69,0)
 SET XOBDATA("XOB RPC","START")=$HOROLOG
"RTN","XOBVRPC",70,0)
 ;
"RTN","XOBVRPC",71,0)
 ; -- setup info needed for RPC execution
"RTN","XOBVRPC",72,0)
 SET TAG=$PIECE(RPC0,U,2)
"RTN","XOBVRPC",73,0)
 SET ROU=$PIECE(RPC0,U,3)
"RTN","XOBVRPC",74,0)
 SET XOBPTYPE=$PIECE(RPC0,U,4)
"RTN","XOBVRPC",75,0)
 SET XOBWRAP=$PIECE(RPC0,U,8)
"RTN","XOBVRPC",76,0)
 SET XOBVER=$$GETVER^XOBVRPCX()
"RTN","XOBVRPC",77,0)
 ;
"RTN","XOBVRPC",78,0)
 ; -- build method signature
"RTN","XOBVRPC",79,0)
 SET METHSIG=TAG_"^"_ROU_"(.XOBR"_$GET(XOBDATA("XOB RPC","PARAMS"))_")"
"RTN","XOBVRPC",80,0)
 ;
"RTN","XOBVRPC",81,0)
 ; -- start RTL
"RTN","XOBVRPC",82,0)
 DO:$DATA(XRTL) T0^%ZOSV
"RTN","XOBVRPC",83,0)
 ;
"RTN","XOBVRPC",84,0)
 ; -- use null device in case of writing during RPC execution
"RTN","XOBVRPC",85,0)
 USE XOBNULL
"RTN","XOBVRPC",86,0)
 ;
"RTN","XOBVRPC",87,0)
 ; -- start RUM for RPC Name
"RTN","XOBVRPC",88,0)
 DO LOGRSRC^%ZOSV(RPCNAME,2,1)
"RTN","XOBVRPC",89,0)
 ;
"RTN","XOBVRPC",90,0)
 ; -- execute RPC
"RTN","XOBVRPC",91,0)
 DO CALLRPC(.XOBPTYPE,.XOBWRAP,.XOBVER,METHSIG)
"RTN","XOBVRPC",92,0)
 ;
"RTN","XOBVRPC",93,0)
 ; -- re-start RUM for VistaLink Handler
"RTN","XOBVRPC",94,0)
 DO LOGRSRC^%ZOSV("$VISTALINK HANDLER$",2,1)
"RTN","XOBVRPC",95,0)
 ;
"RTN","XOBVRPC",96,0)
 ; -- stop RTL
"RTN","XOBVRPC",97,0)
 SET:$DATA(XRT0) XRTN=RPCNAME DO:$DATA(XRT0) T1^%ZOSV
"RTN","XOBVRPC",98,0)
 ;
"RTN","XOBVRPC",99,0)
 ; -- empty write buffer of null device
"RTN","XOBVRPC",100,0)
 USE XOBNULL SET DX=0,DY=0 XECUTE ^%ZOSF("XY")
"RTN","XOBVRPC",101,0)
 ;
"RTN","XOBVRPC",102,0)
 ; -- reset to use tcp port device to send results
"RTN","XOBVRPC",103,0)
 USE XOBPORT
"RTN","XOBVRPC",104,0)
 ;
"RTN","XOBVRPC",105,0)
 ; -- check for RPC processing timeout
"RTN","XOBVRPC",106,0)
 IF $$TOCHK^XOBVLIB() DO  GOTO ENQ
"RTN","XOBVRPC",107,0)
 . NEW PARAMS SET PARAMS(1)=RPCNAME,PARAMS(2)=$$GETTO^XOBVLIB()
"RTN","XOBVRPC",108,0)
 . DO ERROR(182007,RPCNAME,.PARAMS)
"RTN","XOBVRPC",109,0)
 ;
"RTN","XOBVRPC",110,0)
 ; -- send results
"RTN","XOBVRPC",111,0)
 DO SEND(.XOBR)
"RTN","XOBVRPC",112,0)
 ;
"RTN","XOBVRPC",113,0)
ENQ ; -- end message handler
"RTN","XOBVRPC",114,0)
 DO CLEAN
"RTN","XOBVRPC",115,0)
 QUIT
"RTN","XOBVRPC",116,0)
 ;
"RTN","XOBVRPC",117,0)
CALLRPC(XWBPTYPE,XWBWRAP,XWBAPVER,METHSIG) ;-- execute RPC (use Broker RPC return type & wrap flag if there)
"RTN","XOBVRPC",118,0)
 DO @METHSIG
"RTN","XOBVRPC",119,0)
 QUIT
"RTN","XOBVRPC",120,0)
 ;
"RTN","XOBVRPC",121,0)
CLEAN ; -- clean up message handler environment
"RTN","XOBVRPC",122,0)
 NEW POS
"RTN","XOBVRPC",123,0)
 ; -- kill parameters
"RTN","XOBVRPC",124,0)
 SET POS=0
"RTN","XOBVRPC",125,0)
 FOR  SET POS=$ORDER(XOBDATA("XOB RPC","PARAMS",POS)) QUIT:'POS  KILL @XOBDATA("XOB RPC","PARAMS",POS)
"RTN","XOBVRPC",126,0)
 QUIT
"RTN","XOBVRPC",127,0)
 ;
"RTN","XOBVRPC",128,0)
SEND(XOBR) ; -- stream rpc data to client
"RTN","XOBVRPC",129,0)
 NEW XOBFMT,XOBFILL
"RTN","XOBVRPC",130,0)
 ;
"RTN","XOBVRPC",131,0)
 SET XOBFMT=$$GETFMT()
"RTN","XOBVRPC",132,0)
 ; -- prepare socket for writing
"RTN","XOBVRPC",133,0)
 DO PRE^XOBVSKT
"RTN","XOBVRPC",134,0)
 ; -- initialize XML headers
"RTN","XOBVRPC",135,0)
 DO WRITE^XOBVSKT($$VLHDR^XOBVLIB(1))
"RTN","XOBVRPC",136,0)
 ; -- start response
"RTN","XOBVRPC",137,0)
 DO WRITE^XOBVSKT("<Response type="""_XOBFMT_""" ><![CDATA[")
"RTN","XOBVRPC",138,0)
 ; -- results
"RTN","XOBVRPC",139,0)
 DO PROCESS
"RTN","XOBVRPC",140,0)
 ; -- finalize
"RTN","XOBVRPC",141,0)
 DO WRITE^XOBVSKT("]]></Response>"_$$ENVFTR^XOBVLIB())
"RTN","XOBVRPC",142,0)
 ; -- send eot and flush buffer
"RTN","XOBVRPC",143,0)
 DO POST^XOBVSKT
"RTN","XOBVRPC",144,0)
 ;
"RTN","XOBVRPC",145,0)
 QUIT
"RTN","XOBVRPC",146,0)
 ;
"RTN","XOBVRPC",147,0)
DOCTYPE ;
"RTN","XOBVRPC",148,0)
 DO WRITE^XOBVSKT("<!DOCTYPE vistalink [<!ELEMENT vistalink (results) ><!ELEMENT results (#PCDATA)><!ATTLIST vistalink type CDATA ""Gov.VA.Med.RPC.Response"" ><!ATTLIST results type (array|string) >]>")
"RTN","XOBVRPC",149,0)
 QUIT
"RTN","XOBVRPC",150,0)
 ;
"RTN","XOBVRPC",151,0)
GETFMT() ; -- determine response format type
"RTN","XOBVRPC",152,0)
 IF XOBPTYPE=1!(XOBPTYPE=5)!(XOBPTYPE=6) QUIT "string"
"RTN","XOBVRPC",153,0)
 IF XOBPTYPE=2 QUIT "array"
"RTN","XOBVRPC",154,0)
 ;
"RTN","XOBVRPC",155,0)
 QUIT $SELECT(XOBWRAP:"array",1:"string")
"RTN","XOBVRPC",156,0)
 ;
"RTN","XOBVRPC",157,0)
PROCESS ; -- send the real results
"RTN","XOBVRPC",158,0)
 NEW I,T,D
"RTN","XOBVRPC",159,0)
 ; -- single value
"RTN","XOBVRPC",160,0)
 IF XOBPTYPE=1 SET XOBR=$GET(XOBR) DO WRITE^XOBVSKT(XOBR) QUIT
"RTN","XOBVRPC",161,0)
 ; -- table delimited by CR+LF
"RTN","XOBVRPC",162,0)
 IF XOBPTYPE=2 DO  QUIT
"RTN","XOBVRPC",163,0)
 . SET I="" FOR  SET I=$ORDER(XOBR(I)) QUIT:I=""  DO WRITE^XOBVSKT(XOBR(I)),WRITE^XOBVSKT($CHAR(10))
"RTN","XOBVRPC",164,0)
 ; -- word processing
"RTN","XOBVRPC",165,0)
 IF XOBPTYPE=3 DO  QUIT
"RTN","XOBVRPC",166,0)
 . SET I="" FOR  SET I=$ORDER(XOBR(I)) QUIT:I=""  DO WRITE^XOBVSKT(XOBR(I)) DO:XOBWRAP WRITE^XOBVSKT($CHAR(10))
"RTN","XOBVRPC",167,0)
 ; -- global array
"RTN","XOBVRPC",168,0)
 IF XOBPTYPE=4 DO  QUIT
"RTN","XOBVRPC",169,0)
 . IF $EXTRACT($GET(XOBR))'="^" QUIT
"RTN","XOBVRPC",170,0)
 . SET I=$GET(XOBR) QUIT:I=""  SET T=$EXTRACT(I,1,$LENGTH(I)-1)
"RTN","XOBVRPC",171,0)
 . ;Only send root node if non-null.
"RTN","XOBVRPC",172,0)
 . IF $DATA(@I)>10 SET D=@I IF $LENGTH(D) DO WRITE^XOBVSKT(D),WRITE^XOBVSKT($CHAR(10)):XOBWRAP&(D'=$CHAR(10))
"RTN","XOBVRPC",173,0)
 . FOR  SET I=$QUERY(@I) QUIT:I=""!(I'[T)  SET D=@I DO WRITE^XOBVSKT(D),WRITE^XOBVSKT($CHAR(10)):XOBWRAP&(D'=$CHAR(10))
"RTN","XOBVRPC",174,0)
 . IF $DATA(@XOBR) KILL @XOBR
"RTN","XOBVRPC",175,0)
 ; -- global instance
"RTN","XOBVRPC",176,0)
 IF XOBPTYPE=5 DO  QUIT
"RTN","XOBVRPC",177,0)
 . IF $EXTRACT($GET(XOBR))'="^" QUIT
"RTN","XOBVRPC",178,0)
 . SET XOBR=$GET(@XOBR) DO WRITE^XOBVSKT(XOBR)
"RTN","XOBVRPC",179,0)
 ; -- variable length records only good up to 255 char)
"RTN","XOBVRPC",180,0)
 IF XOBPTYPE=6 DO
"RTN","XOBVRPC",181,0)
 . SET I="" FOR  SET I=$ORDER(XOBR(I)) QUIT:I=""  DO WRITE^XOBVSKT($CHAR($LENGTH(XOBR(I)))),WRITE^XOBVSKT(XOBR(I))
"RTN","XOBVRPC",182,0)
 QUIT
"RTN","XOBVRPC",183,0)
 ;
"RTN","XOBVRPC",184,0)
ERROR(CODE,RPCNAME,PARAMS) ; -- send rpc application error
"RTN","XOBVRPC",185,0)
 NEW XOBI,XOBDAT
"RTN","XOBVRPC",186,0)
 ; -- if parameters are passed as in CODE (where CODE = code^param1^param2^...)
"RTN","XOBVRPC",187,0)
 ; -- parse CODE and put parameters into PARAMS array.
"RTN","XOBVRPC",188,0)
 IF CODE[U,$DATA(PARAMS)=0 DO
"RTN","XOBVRPC",189,0)
 . KILL PARAMS
"RTN","XOBVRPC",190,0)
 . FOR XOBI=2:1:$LENGTH(XOBERR,U) SET PARAMS(XOBI-1)=$PIECE(XOBERR,U,XOBI)
"RTN","XOBVRPC",191,0)
 . SET CODE=+CODE
"RTN","XOBVRPC",192,0)
 ;
"RTN","XOBVRPC",193,0)
 SET XOBDAT("MESSAGE TYPE")=2
"RTN","XOBVRPC",194,0)
 SET XOBDAT("ERRORS",1,"FAULT STRING")="Internal Application Error"
"RTN","XOBVRPC",195,0)
 SET XOBDAT("ERRORS",1,"FAULT ACTOR")=RPCNAME
"RTN","XOBVRPC",196,0)
 SET XOBDAT("ERRORS",1,"CODE")=CODE
"RTN","XOBVRPC",197,0)
 SET XOBDAT("ERRORS",1,"ERROR TYPE")=RPCNAME
"RTN","XOBVRPC",198,0)
 SET XOBDAT("ERRORS",1,"CDATA")=0
"RTN","XOBVRPC",199,0)
 SET XOBDAT("ERRORS",1,"MESSAGE",1)=$$EZBLD^DIALOG(CODE,.PARAMS)
"RTN","XOBVRPC",200,0)
 DO ERROR^XOBVLIB(.XOBDAT)
"RTN","XOBVRPC",201,0)
 ;
"RTN","XOBVRPC",202,0)
 ; -- save info in error system
"RTN","XOBVRPC",203,0)
 ;DO ^%ZTER
"RTN","XOBVRPC",204,0)
 QUIT
"RTN","XOBVRPC",205,0)
 ;
"RTN","XOBVRPC",206,0)
VER() ; -- check version and if re-authentication check is needed
"RTN","XOBVRPC",207,0)
 ; -- IMPORTANT: This tag needs updating for version numbers for each target release.
"RTN","XOBVRPC",208,0)
 ; -- This call needs only be called once per connection.
"RTN","XOBVRPC",209,0)
 ; 
"RTN","XOBVRPC",210,0)
 NEW XOBERR,CV,SV,ENV
"RTN","XOBVRPC",211,0)
 ;
"RTN","XOBVRPC",212,0)
 KILL XOBSYS("RPC REAUTH")
"RTN","XOBVRPC",213,0)
 ;
"RTN","XOBVRPC",214,0)
 SET XOBERR=0
"RTN","XOBVRPC",215,0)
 ; -- default re-auh flag to true
"RTN","XOBVRPC",216,0)
 SET XOBRA=1
"RTN","XOBVRPC",217,0)
 ; -- client version
"RTN","XOBVRPC",218,0)
 SET CV=XOBDATA("XOB RPC","RPC HANDLER VERSION")
"RTN","XOBVRPC",219,0)
 ; -- current server version
"RTN","XOBVRPC",220,0)
 SET SV="1.6"
"RTN","XOBVRPC",221,0)
 ; -- client environment
"RTN","XOBVRPC",222,0)
 SET ENV=XOBSYS("ENV")
"RTN","XOBVRPC",223,0)
 ;
"RTN","XOBVRPC",224,0)
 ; -- if client version is not supported then return error
"RTN","XOBVRPC",225,0)
 IF ("^1.0^1.5^1.6^")'[(U_CV_U) DO  GOTO VERQ
"RTN","XOBVRPC",226,0)
 . SET XOBERR=182009_U_CV_U_SV_U_"Client version not supported"
"RTN","XOBVRPC",227,0)
 ;
"RTN","XOBVRPC",228,0)
 ; -- if client environment is not supported then return error
"RTN","XOBVRPC",229,0)
 IF ("^j2se^j2ee^.net^")'[(U_ENV_U) DO  GOTO VERQ
"RTN","XOBVRPC",230,0)
 . SET XOBERR=182009_U_CV_U_SV_U_"Client environment ("_$$UP^XLFSTR(ENV)_") not supported"
"RTN","XOBVRPC",231,0)
 ;
"RTN","XOBVRPC",232,0)
 ; -- if client/server environment then ok
"RTN","XOBVRPC",233,0)
 IF ("^j2se^.net^")[(U_ENV_U) SET XOBRA=0 GOTO VERQ
"RTN","XOBVRPC",234,0)
 ;
"RTN","XOBVRPC",235,0)
 ; -- if client version is "1.0" and client is j2ee then return error
"RTN","XOBVRPC",236,0)
 IF CV="1.0",ENV="j2ee" DO  GOTO VERQ
"RTN","XOBVRPC",237,0)
 . SET XOBERR=182009_U_CV_U_SV_U_"Client RPC version does not support "_$$UP^XLFSTR(ENV)
"RTN","XOBVRPC",238,0)
 ;
"RTN","XOBVRPC",239,0)
 ; -- if client version supports j2ee and client is j2ee then ok (default)
"RTN","XOBVRPC",240,0)
 ;IF ENV="j2ee" GOTO VERQ
"RTN","XOBVRPC",241,0)
 ;
"RTN","XOBVRPC",242,0)
VERQ ;
"RTN","XOBVRPC",243,0)
 IF 'XOBERR SET XOBSYS("RPC REAUTH")=XOBRA
"RTN","XOBVRPC",244,0)
 QUIT XOBERR
"RTN","XOBVRPC",245,0)
 ;
"RTN","XOBVRPCI")
0^13^B31578368
"RTN","XOBVRPCI",1,0)
XOBVRPCI ;; ld,mjk/alb - VistaLink Interface Implementation for RPCs; 07/27/2002  13:00
"RTN","XOBVRPCI",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVRPCI",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVRPCI",4,0)
 ;
"RTN","XOBVRPCI",5,0)
CALLBACK(CB) ; -- init callbacks implementation
"RTN","XOBVRPCI",6,0)
 SET CB("STARTELEMENT")="ELEST^XOBVRPCI"
"RTN","XOBVRPCI",7,0)
 SET CB("ENDELEMENT")="ELEND^XOBVRPCI"
"RTN","XOBVRPCI",8,0)
 SET CB("CHARACTERS")="CHR^XOBVRPCI"
"RTN","XOBVRPCI",9,0)
 QUIT
"RTN","XOBVRPCI",10,0)
 ;
"RTN","XOBVRPCI",11,0)
READER(XOBUF,XOBDATA) ; -- proprietary format reader implementation
"RTN","XOBVRPCI",12,0)
 DO START^XOBVRPCX(.XOBUF,.XOBDATA)
"RTN","XOBVRPCI",13,0)
 QUIT
"RTN","XOBVRPCI",14,0)
 ;
"RTN","XOBVRPCI",15,0)
REQHDLR(XOBDATA) ; -- request handler implementation
"RTN","XOBVRPCI",16,0)
 DO EN^XOBVRPC(.XOBDATA)
"RTN","XOBVRPCI",17,0)
 QUIT
"RTN","XOBVRPCI",18,0)
 ;
"RTN","XOBVRPCI",19,0)
 ; ------------------------------------------------------------------------
"RTN","XOBVRPCI",20,0)
 ;             RPC Server: Request Message XML SAX Parser Callbacks         
"RTN","XOBVRPCI",21,0)
 ; ------------------------------------------------------------------------
"RTN","XOBVRPCI",22,0)
ELEST(ELE,ATR) ; -- element start event handler
"RTN","XOBVRPCI",23,0)
 IF ELE="VistaLink" DO  QUIT
"RTN","XOBVRPCI",24,0)
 . KILL XOBPARAM,XOBCTXT,XOBPN,XOBPTYPE
"RTN","XOBVRPCI",25,0)
 . ; -- if called from VL v1.0 client then set up J2SE defaults
"RTN","XOBVRPCI",26,0)
 . IF $GET(XOBDATA("VL VERSION"))="1.0" DO V1^XOBVRPCX
"RTN","XOBVRPCI",27,0)
 ;
"RTN","XOBVRPCI",28,0)
 IF ELE="RpcHandler" SET XOBDATA("XOB RPC","RPC HANDLER VERSION")=$GET(ATR("version")) QUIT
"RTN","XOBVRPCI",29,0)
 ;
"RTN","XOBVRPCI",30,0)
 IF ELE="Request" DO  QUIT
"RTN","XOBVRPCI",31,0)
 . SET XOBDATA("XOB RPC","RPC NAME")=$$ESC^XOBVRMX($GET(ATR("rpcName"),"##Unkown RPC##"))
"RTN","XOBVRPCI",32,0)
 . NEW X
"RTN","XOBVRPCI",33,0)
 . SET X=$$SETTO^XOBVLIB($GET(ATR("rpcClientTimeOut"),9000))
"RTN","XOBVRPCI",34,0)
 . SET X=$$SETVER^XOBVRPCX($GET(ATR("rpcVersion"),0))
"RTN","XOBVRPCI",35,0)
 ;
"RTN","XOBVRPCI",36,0)
 IF ELE="RpcContext" SET XOBCTXT="" QUIT
"RTN","XOBVRPCI",37,0)
 ;
"RTN","XOBVRPCI",38,0)
 ; --------------------  Param Node Start Event Processing  ---------------------------
"RTN","XOBVRPCI",39,0)
 ; 
"RTN","XOBVRPCI",40,0)
 IF ELE="Param" DO  QUIT
"RTN","XOBVRPCI",41,0)
 . SET XOBPARAM=""
"RTN","XOBVRPCI",42,0)
 . SET XOBPN="XOBP"_ATR("position")
"RTN","XOBVRPCI",43,0)
 . SET XOBDATA("XOB RPC","PARAMS",ATR("position"))=XOBPN
"RTN","XOBVRPCI",44,0)
 . SET XOBPTYPE=ATR("type")
"RTN","XOBVRPCI",45,0)
 . SET:XOBPTYPE="array" @XOBPN=""
"RTN","XOBVRPCI",46,0)
 ;
"RTN","XOBVRPCI",47,0)
 IF ELE="Index" DO  QUIT
"RTN","XOBVRPCI",48,0)
 . KILL XOBPARAM
"RTN","XOBVRPCI",49,0)
 . IF $DATA(ATR("name"))&$DATA(ATR("value")) DO
"RTN","XOBVRPCI",50,0)
 . . SET @XOBPN@($$ESC^XOBVRMX(ATR("name")))=$$ESC^XOBVRMX(ATR("value"))
"RTN","XOBVRPCI",51,0)
 ;
"RTN","XOBVRPCI",52,0)
 IF ELE="Name" DO  QUIT
"RTN","XOBVRPCI",53,0)
 . SET XOBPARNM=""
"RTN","XOBVRPCI",54,0)
 ;
"RTN","XOBVRPCI",55,0)
 IF ELE="Value" DO  QUIT
"RTN","XOBVRPCI",56,0)
 . SET XOBPARVL=""
"RTN","XOBVRPCI",57,0)
 ;
"RTN","XOBVRPCI",58,0)
 ; --------------------  Security Node Start Event Processing  ---------------------------
"RTN","XOBVRPCI",59,0)
 ; 
"RTN","XOBVRPCI",60,0)
 IF ELE="Security" DO  QUIT
"RTN","XOBVRPCI",61,0)
 . SET XOBDATA("XOB RPC","SECURITY","TYPE")=$GET(ATR("type"))
"RTN","XOBVRPCI",62,0)
 . SET XOBDATA("XOB RPC","SECURITY","DIV")=$GET(ATR("division"))
"RTN","XOBVRPCI",63,0)
 . SET XOBDATA("XOB RPC","SECURITY","STATE")=$GET(ATR("state"),"notauthenticated")
"RTN","XOBVRPCI",64,0)
 . KILL XOBSECFL
"RTN","XOBVRPCI",65,0)
 . ;
"RTN","XOBVRPCI",66,0)
 . ; -- use to make sure child nodes are from Security
"RTN","XOBVRPCI",67,0)
 . ;    parent when processing child node names
"RTN","XOBVRPCI",68,0)
 . SET XOBSECFL=1
"RTN","XOBVRPCI",69,0)
 ;
"RTN","XOBVRPCI",70,0)
 IF ELE="AccessVerify",$GET(XOBSECFL),$EXTRACT($GET(XOBDATA("XOB RPC","SECURITY","TYPE")),1,2)="av" DO  QUIT
"RTN","XOBVRPCI",71,0)
 . SET XOBAVCOD=""
"RTN","XOBVRPCI",72,0)
 ;
"RTN","XOBVRPCI",73,0)
 IF ELE="KernelCcowToken",$GET(XOBSECFL),$GET(XOBDATA("XOB RPC","SECURITY","TYPE"))="ccow" DO  QUIT
"RTN","XOBVRPCI",74,0)
 . SET XOBCCOWT=""
"RTN","XOBVRPCI",75,0)
 ;
"RTN","XOBVRPCI",76,0)
 IF ELE="Duz",$GET(XOBSECFL),$GET(XOBDATA("XOB RPC","SECURITY","TYPE"))="duz" DO  QUIT
"RTN","XOBVRPCI",77,0)
 . SET XOBDATA("XOB RPC","SECURITY","TYPE","VALUE")=$GET(ATR("value"))
"RTN","XOBVRPCI",78,0)
 ;
"RTN","XOBVRPCI",79,0)
 IF ELE="Vpid",$GET(XOBSECFL),$GET(XOBDATA("XOB RPC","SECURITY","TYPE"))="vpid" DO  QUIT
"RTN","XOBVRPCI",80,0)
 . SET XOBDATA("XOB RPC","SECURITY","TYPE","VALUE")=$GET(ATR("value"))
"RTN","XOBVRPCI",81,0)
 ;
"RTN","XOBVRPCI",82,0)
 IF ELE="ApplicationProxyName",$GET(XOBSECFL),$GET(XOBDATA("XOB RPC","SECURITY","TYPE"))="appproxy" DO  QUIT
"RTN","XOBVRPCI",83,0)
 . SET XOBDATA("XOB RPC","SECURITY","TYPE","VALUE")=$GET(ATR("value"))
"RTN","XOBVRPCI",84,0)
 ;
"RTN","XOBVRPCI",85,0)
 ; ---------------------------------------------------------------------------
"RTN","XOBVRPCI",86,0)
 ;
"RTN","XOBVRPCI",87,0)
 QUIT
"RTN","XOBVRPCI",88,0)
 ;
"RTN","XOBVRPCI",89,0)
ELEND(ELE) ; -- element end event handler
"RTN","XOBVRPCI",90,0)
 IF ELE="VistaLink" DO  QUIT
"RTN","XOBVRPCI",91,0)
 . SET XOBDATA("MODE")=$GET(ATR("mode"),"singleton")
"RTN","XOBVRPCI",92,0)
 . KILL XOBPOS,XOBPARAM,XOBCTXT,XOBPN,XOBPTYPE
"RTN","XOBVRPCI",93,0)
 ;
"RTN","XOBVRPCI",94,0)
 IF ELE="RpcContext" DO  QUIT
"RTN","XOBVRPCI",95,0)
 . SET XOBDATA("XOB RPC","RPC CONTEXT")=$GET(XOBCTXT)
"RTN","XOBVRPCI",96,0)
 ;
"RTN","XOBVRPCI",97,0)
 IF ELE="Param" DO  KILL XOBPARAM QUIT
"RTN","XOBVRPCI",98,0)
 . IF XOBPTYPE="string" SET @XOBPN=$$ESC^XOBVRMX(XOBPARAM) QUIT
"RTN","XOBVRPCI",99,0)
 . IF XOBPTYPE="ref" SET @XOBPN=$GET(@$$ESC^XOBVRMX(XOBPARAM)) QUIT
"RTN","XOBVRPCI",100,0)
 ;
"RTN","XOBVRPCI",101,0)
 IF ELE="Params" DO  QUIT
"RTN","XOBVRPCI",102,0)
 . NEW POS,PARAMS
"RTN","XOBVRPCI",103,0)
 . SET PARAMS="",POS=0
"RTN","XOBVRPCI",104,0)
 . FOR  SET POS=$ORDER(XOBDATA("XOB RPC","PARAMS",POS)) QUIT:'POS  SET PARAMS=PARAMS_",."_XOBDATA("XOB RPC","PARAMS",POS)
"RTN","XOBVRPCI",105,0)
 . SET XOBDATA("XOB RPC","PARAMS")=PARAMS
"RTN","XOBVRPCI",106,0)
 ;
"RTN","XOBVRPCI",107,0)
 IF ELE="Index" DO  QUIT
"RTN","XOBVRPCI",108,0)
 . IF $DATA(XOBPARNM)&$DATA(XOBPARVL) DO
"RTN","XOBVRPCI",109,0)
 . . KILL XOBPARAM
"RTN","XOBVRPCI",110,0)
 . . IF $EXTRACT(XOBPARNM,1)=$CHAR(13) DO
"RTN","XOBVRPCI",111,0)
 . . . SET @("@XOBPN@("_$$ESC^XOBVRMX($EXTRACT(XOBPARNM,2,$LENGTH(XOBPARNM)))_")=$$ESC^XOBVRMX(XOBPARVL)")
"RTN","XOBVRPCI",112,0)
 . . ELSE  DO
"RTN","XOBVRPCI",113,0)
 . . . SET @XOBPN@($$ESC^XOBVRMX(XOBPARNM))=$$ESC^XOBVRMX(XOBPARVL)
"RTN","XOBVRPCI",114,0)
 . . KILL XOBPARNM,XOBPARVL
"RTN","XOBVRPCI",115,0)
 ;
"RTN","XOBVRPCI",116,0)
 IF ELE="Name" DO  QUIT
"RTN","XOBVRPCI",117,0)
 . SET XOBPARNM("DONE")=1
"RTN","XOBVRPCI",118,0)
 ;
"RTN","XOBVRPCI",119,0)
 IF ELE="Value" DO  QUIT
"RTN","XOBVRPCI",120,0)
 . SET XOBPARVL("DONE")=1
"RTN","XOBVRPCI",121,0)
 ;
"RTN","XOBVRPCI",122,0)
 IF ELE="AccessVerify",$GET(XOBSECFL),$EXTRACT($GET(XOBDATA("XOB RPC","SECURITY","TYPE")),1,2)="av" DO  QUIT
"RTN","XOBVRPCI",123,0)
 . SET XOBDATA("XOB RPC","SECURITY","TYPE","AVCODE")=XOBAVCOD KILL XOBAVCOD
"RTN","XOBVRPCI",124,0)
 IF ELE="KernelCcowToken",$GET(XOBSECFL),$GET(XOBDATA("XOB RPC","SECURITY","TYPE"))="ccow" DO  QUIT
"RTN","XOBVRPCI",125,0)
 . SET XOBDATA("XOB RPC","SECURITY","TYPE","CCOW")=XOBCCOWT KILL XOBCCOWT
"RTN","XOBVRPCI",126,0)
 IF ELE="Security" KILL XOBSECFL QUIT
"RTN","XOBVRPCI",127,0)
 ;
"RTN","XOBVRPCI",128,0)
 QUIT
"RTN","XOBVRPCI",129,0)
 ;
"RTN","XOBVRPCI",130,0)
CHR(TEXT) ; -- character value event handler <tag>TEXT</tag)
"RTN","XOBVRPCI",131,0)
 ; -- need to concatenate because MXML parses on ENTITY characters (<>& etc.) and
"RTN","XOBVRPCI",132,0)
 ;    callback gets hit multiple times even though the tag text value is just one piece of data.
"RTN","XOBVRPCI",133,0)
 ;    (Yes, this seems kludgie!)
"RTN","XOBVRPCI",134,0)
 IF $DATA(XOBPARAM) SET XOBPARAM=XOBPARAM_TEXT
"RTN","XOBVRPCI",135,0)
 IF $DATA(XOBPARNM),'+$GET(XOBPARNM("DONE")) SET XOBPARNM=XOBPARNM_TEXT QUIT
"RTN","XOBVRPCI",136,0)
 IF $DATA(XOBPARVL),'+$GET(XOBPARVL("DONE")) SET XOBPARVL=XOBPARVL_TEXT QUIT
"RTN","XOBVRPCI",137,0)
 IF $DATA(XOBCTXT) SET XOBCTXT=XOBCTXT_TEXT QUIT
"RTN","XOBVRPCI",138,0)
 IF $DATA(XOBAVCOD) SET XOBAVCOD=XOBAVCOD_TEXT QUIT
"RTN","XOBVRPCI",139,0)
 IF $DATA(XOBCCOWT) SET XOBCCOWT=XOBCCOWT_TEXT QUIT
"RTN","XOBVRPCI",140,0)
 QUIT
"RTN","XOBVRPCI",141,0)
 ;
"RTN","XOBVRPCX")
0^14^B22239279
"RTN","XOBVRPCX",1,0)
XOBVRPCX ;; mjk/alb - VistaLink RPC Formatter Sink ; 07/27/2002  13:00
"RTN","XOBVRPCX",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVRPCX",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVRPCX",4,0)
 QUIT
"RTN","XOBVRPCX",5,0)
 ;
"RTN","XOBVRPCX",6,0)
 ; -- unwrap stream
"RTN","XOBVRPCX",7,0)
START(XOBUF,XOBDATA) ;
"RTN","XOBVRPCX",8,0)
 NEW PARAMS,POS,TYP,PCNT,CNTP,ICNT,CNTI,XOBPN,SUB,VAL,DEBUG,EOT,RESV,LENSIZE,X
"RTN","XOBVRPCX",9,0)
 ;
"RTN","XOBVRPCX",10,0)
 ; -- get debugging byte
"RTN","XOBVRPCX",11,0)
 SET DEBUG=$$GETSTR(1)
"RTN","XOBVRPCX",12,0)
 ;
"RTN","XOBVRPCX",13,0)
 ; -- get size of length chunk
"RTN","XOBVRPCX",14,0)
 SET LENSIZE=$$GETSTR(1)
"RTN","XOBVRPCX",15,0)
 ;
"RTN","XOBVRPCX",16,0)
 ; -- get VistaLink version
"RTN","XOBVRPCX",17,0)
 SET XOBDATA("VL VERSION")=$$GETVAL()
"RTN","XOBVRPCX",18,0)
 ;
"RTN","XOBVRPCX",19,0)
 ; -- get RpcHandler version
"RTN","XOBVRPCX",20,0)
 SET XOBDATA("XOB RPC","RPC HANDLER VERSION")=$$GETVAL()
"RTN","XOBVRPCX",21,0)
 ;
"RTN","XOBVRPCX",22,0)
 ; -- Set basic constant attributes
"RTN","XOBVRPCX",23,0)
 SET XOBDATA("MODE")="singleton"
"RTN","XOBVRPCX",24,0)
 ;
"RTN","XOBVRPCX",25,0)
 ; -- get RPC info from stream
"RTN","XOBVRPCX",26,0)
 IF XOBDATA("XOB RPC","RPC HANDLER VERSION")>1.0 SET X=$$SETVER($$GETVAL())
"RTN","XOBVRPCX",27,0)
 SET XOBDATA("XOB RPC","RPC NAME")=$$GETVAL()
"RTN","XOBVRPCX",28,0)
 SET XOBDATA("XOB RPC","RPC CONTEXT")=$$GETVAL()
"RTN","XOBVRPCX",29,0)
 ;
"RTN","XOBVRPCX",30,0)
 ; -- set RPC time out
"RTN","XOBVRPCX",31,0)
 SET X=$$SETTO^XOBVLIB($$GETVAL())
"RTN","XOBVRPCX",32,0)
 ;
"RTN","XOBVRPCX",33,0)
 ; -- set security info
"RTN","XOBVRPCX",34,0)
 DO SECURITY
"RTN","XOBVRPCX",35,0)
 ;
"RTN","XOBVRPCX",36,0)
 ; -- set RPC parameters
"RTN","XOBVRPCX",37,0)
 DO PARMS
"RTN","XOBVRPCX",38,0)
 ;
"RTN","XOBVRPCX",39,0)
 ; -- read end of text character EOT to empty buffer
"RTN","XOBVRPCX",40,0)
 SET EOT=$$GETSTR(1)
"RTN","XOBVRPCX",41,0)
 QUIT
"RTN","XOBVRPCX",42,0)
 ;
"RTN","XOBVRPCX",43,0)
GETVAL() ; -- get next VALue from stream buffer
"RTN","XOBVRPCX",44,0)
 QUIT $$GETSTR($$GETLEN())
"RTN","XOBVRPCX",45,0)
 ;
"RTN","XOBVRPCX",46,0)
GETLEN() ; -- get the length of the next value
"RTN","XOBVRPCX",47,0)
 IF 'DEBUG QUIT +$$GETSTR(LENSIZE)
"RTN","XOBVRPCX",48,0)
 ; -- Ex. of why 4: VAL=00001
"RTN","XOBVRPCX",49,0)
 QUIT +$PIECE($$GETSTR(LENSIZE+4),"=",2)
"RTN","XOBVRPCX",50,0)
 ;
"RTN","XOBVRPCX",51,0)
GETSTR(LEN) ; -- extracts string of length, LEN, from stream buffer and returns extracted string 
"RTN","XOBVRPCX",52,0)
 NEW X
"RTN","XOBVRPCX",53,0)
 FOR  QUIT:($LENGTH(XOBUF)'<LEN)  DO READ(LEN-$LENGTH(XOBUF))
"RTN","XOBVRPCX",54,0)
 SET X=$EXTRACT(XOBUF,1,LEN)
"RTN","XOBVRPCX",55,0)
 SET XOBUF=$EXTRACT(XOBUF,LEN+1,999)
"RTN","XOBVRPCX",56,0)
 QUIT X
"RTN","XOBVRPCX",57,0)
 ;
"RTN","XOBVRPCX",58,0)
READ(LEN) ; -- read more from stream buffer but only needed amount
"RTN","XOBVRPCX",59,0)
 NEW X
"RTN","XOBVRPCX",60,0)
 FOR  QUIT:LEN<512  SET LEN=LEN-511 READ X#511:1 SET XOBUF=XOBUF_X
"RTN","XOBVRPCX",61,0)
 IF LEN>0 READ X#LEN:1 SET XOBUF=XOBUF_X
"RTN","XOBVRPCX",62,0)
 QUIT
"RTN","XOBVRPCX",63,0)
 ;
"RTN","XOBVRPCX",64,0)
 ;
"RTN","XOBVRPCX",65,0)
 ; ----------------  Security Information Processing ----------------
"RTN","XOBVRPCX",66,0)
SECURITY ;
"RTN","XOBVRPCX",67,0)
 ;
"RTN","XOBVRPCX",68,0)
 ; -- if called from VL v1.0 client then set up J2SE defaults
"RTN","XOBVRPCX",69,0)
 IF $GET(XOBDATA("VL VERSION"))="1.0" DO V1 QUIT
"RTN","XOBVRPCX",70,0)
 ;
"RTN","XOBVRPCX",71,0)
 ; -- set security info
"RTN","XOBVRPCX",72,0)
 SET XOBDATA("XOB RPC","SECURITY","TYPE")=$$GETVAL()
"RTN","XOBVRPCX",73,0)
 SET XOBDATA("XOB RPC","SECURITY","DIV")=$$GETVAL()
"RTN","XOBVRPCX",74,0)
 SET XOBDATA("XOB RPC","SECURITY","STATE")=$$GETVAL()
"RTN","XOBVRPCX",75,0)
 ;
"RTN","XOBVRPCX",76,0)
 ; -- get needed type vars if not authenticated
"RTN","XOBVRPCX",77,0)
 IF XOBDATA("XOB RPC","SECURITY","STATE")'="authenticated" DO
"RTN","XOBVRPCX",78,0)
 . DO @($$UP^XLFSTR($GET(XOBDATA("XOB RPC","SECURITY","TYPE"))))
"RTN","XOBVRPCX",79,0)
 ;
"RTN","XOBVRPCX",80,0)
 QUIT
"RTN","XOBVRPCX",81,0)
 ;
"RTN","XOBVRPCX",82,0)
AV ; -- access and verify code type (KAAJEE)
"RTN","XOBVRPCX",83,0)
 SET XOBDATA("XOB RPC","SECURITY","TYPE","AVCODE")=$$GETVAL()
"RTN","XOBVRPCX",84,0)
 QUIT
"RTN","XOBVRPCX",85,0)
 ;
"RTN","XOBVRPCX",86,0)
CCOW ; -- CCOW type (FatKAAT)
"RTN","XOBVRPCX",87,0)
 SET XOBDATA("XOB RPC","SECURITY","TYPE","CCOW")=$$GETVAL()
"RTN","XOBVRPCX",88,0)
 QUIT
"RTN","XOBVRPCX",89,0)
 ;
"RTN","XOBVRPCX",90,0)
DUZ ; -- simple duz type
"RTN","XOBVRPCX",91,0)
 SET XOBDATA("XOB RPC","SECURITY","TYPE","VALUE")=$$GETVAL()
"RTN","XOBVRPCX",92,0)
 QUIT
"RTN","XOBVRPCX",93,0)
 ;
"RTN","XOBVRPCX",94,0)
VPID ; -- vpid type
"RTN","XOBVRPCX",95,0)
 SET XOBDATA("XOB RPC","SECURITY","TYPE","VALUE")=$$GETVAL()
"RTN","XOBVRPCX",96,0)
 QUIT
"RTN","XOBVRPCX",97,0)
 ;
"RTN","XOBVRPCX",98,0)
APPPROXY ; -- application proxy type
"RTN","XOBVRPCX",99,0)
 SET XOBDATA("XOB RPC","SECURITY","TYPE","VALUE")=$$GETVAL()
"RTN","XOBVRPCX",100,0)
 QUIT
"RTN","XOBVRPCX",101,0)
 ;
"RTN","XOBVRPCX",102,0)
J2SE ; -- c/s type
"RTN","XOBVRPCX",103,0)
 ; -- this line should never be executed since state will
"RTN","XOBVRPCX",104,0)
 ;    always be authenticated ; entered for completeness
"RTN","XOBVRPCX",105,0)
 QUIT
"RTN","XOBVRPCX",106,0)
 ;
"RTN","XOBVRPCX",107,0)
V1 ; -- set up security compatibility for VL v1.0 client
"RTN","XOBVRPCX",108,0)
 ;      (tag also called by ELST^XOBRPCI)
"RTN","XOBVRPCX",109,0)
 ;     
"RTN","XOBVRPCX",110,0)
 SET XOBDATA("XOB RPC","SECURITY","TYPE")="j2se"
"RTN","XOBVRPCX",111,0)
 SET XOBDATA("XOB RPC","SECURITY","DIV")=""
"RTN","XOBVRPCX",112,0)
 SET XOBDATA("XOB RPC","SECURITY","STATE")="authenticated"
"RTN","XOBVRPCX",113,0)
 QUIT
"RTN","XOBVRPCX",114,0)
 ; ---------------------   RPC Parameter Processing  -----------------
"RTN","XOBVRPCX",115,0)
PARMS ;
"RTN","XOBVRPCX",116,0)
 ;
"RTN","XOBVRPCX",117,0)
 ; -- get how many parameters to expect
"RTN","XOBVRPCX",118,0)
 SET XOBDATA("XOB RPC","PARAMS")=""
"RTN","XOBVRPCX",119,0)
 SET PCNT=+$$GETVAL()
"RTN","XOBVRPCX",120,0)
 ;
"RTN","XOBVRPCX",121,0)
 ; -- get the parameters
"RTN","XOBVRPCX",122,0)
 IF PCNT>0 FOR CNTP=1:1:PCNT DO
"RTN","XOBVRPCX",123,0)
 . SET TYP=$$GETVAL()
"RTN","XOBVRPCX",124,0)
 . SET POS=+$$GETVAL()
"RTN","XOBVRPCX",125,0)
 . SET XOBPN="XOBP"_POS
"RTN","XOBVRPCX",126,0)
 . SET XOBDATA("XOB RPC","PARAMS",POS)=XOBPN
"RTN","XOBVRPCX",127,0)
 . ;
"RTN","XOBVRPCX",128,0)
 . ; -- get single value 
"RTN","XOBVRPCX",129,0)
 . IF TYP'="array" DO  QUIT
"RTN","XOBVRPCX",130,0)
 . . ; -- get value for ref type
"RTN","XOBVRPCX",131,0)
 . . IF TYP="ref" SET @XOBPN=@$$GETVAL() QUIT
"RTN","XOBVRPCX",132,0)
 . . ;
"RTN","XOBVRPCX",133,0)
 . . ; -- get value for other non-array types
"RTN","XOBVRPCX",134,0)
 . . SET @XOBPN=$$GETVAL()
"RTN","XOBVRPCX",135,0)
 . ;
"RTN","XOBVRPCX",136,0)
 . ; -- get how many subscripts to expect for an array
"RTN","XOBVRPCX",137,0)
 . SET ICNT=+$$GETVAL()
"RTN","XOBVRPCX",138,0)
 . ;
"RTN","XOBVRPCX",139,0)
 . ; -- set root node of array to ""
"RTN","XOBVRPCX",140,0)
 . SET @XOBPN=""
"RTN","XOBVRPCX",141,0)
 . ;
"RTN","XOBVRPCX",142,0)
 . ; -- get the subscripts and values for the array
"RTN","XOBVRPCX",143,0)
 . IF ICNT>0 FOR CNTI=1:1:ICNT DO
"RTN","XOBVRPCX",144,0)
 . . SET SUB=$$GETVAL()
"RTN","XOBVRPCX",145,0)
 . . SET VAL=$$GETVAL()
"RTN","XOBVRPCX",146,0)
 . . IF $EXTRACT(SUB,1)=$CHAR(13) DO
"RTN","XOBVRPCX",147,0)
 . . . SET @("@XOBPN@("_$EXTRACT(SUB,2,$LENGTH(SUB))_")=VAL")
"RTN","XOBVRPCX",148,0)
 . . ELSE  DO
"RTN","XOBVRPCX",149,0)
 . . . SET @XOBPN@(SUB)=VAL
"RTN","XOBVRPCX",150,0)
 ;
"RTN","XOBVRPCX",151,0)
 ; -- build parameter signature for RPC call
"RTN","XOBVRPCX",152,0)
 SET PARAMS="",POS=0
"RTN","XOBVRPCX",153,0)
 FOR  SET POS=$ORDER(XOBDATA("XOB RPC","PARAMS",POS)) QUIT:'POS  SET PARAMS=PARAMS_",."_XOBDATA("XOB RPC","PARAMS",POS)
"RTN","XOBVRPCX",154,0)
 SET XOBDATA("XOB RPC","PARAMS")=PARAMS
"RTN","XOBVRPCX",155,0)
 ;
"RTN","XOBVRPCX",156,0)
 QUIT
"RTN","XOBVRPCX",157,0)
 ;
"RTN","XOBVRPCX",158,0)
 ; ------------------------------------------------------------------
"RTN","XOBVRPCX",159,0)
 ;
"RTN","XOBVRPCX",160,0)
GETVER() ; -- get rpc version
"RTN","XOBVRPCX",161,0)
 QUIT $GET(XOBDATA("XOB RPC","VERSION"),0)
"RTN","XOBVRPCX",162,0)
 ;
"RTN","XOBVRPCX",163,0)
SETVER(VERSION) ; -- set rpc version
"RTN","XOBVRPCX",164,0)
 SET XOBDATA("XOB RPC","VERSION")=VERSION
"RTN","XOBVRPCX",165,0)
 QUIT 1
"RTN","XOBVRPCX",166,0)
 ;
"RTN","XOBVSKT")
0^15^B19091287
"RTN","XOBVSKT",1,0)
XOBVSKT ;; mjk/alb - VistaLink Socket Methods ; 07/27/2002  13:00
"RTN","XOBVSKT",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVSKT",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVSKT",4,0)
 QUIT
"RTN","XOBVSKT",5,0)
 ;
"RTN","XOBVSKT",6,0)
 ; ------------------------------------------------------------------------------------
"RTN","XOBVSKT",7,0)
 ;                          Methods for Read from/to TCP/IP Socket
"RTN","XOBVSKT",8,0)
 ; ------------------------------------------------------------------------------------
"RTN","XOBVSKT",9,0)
READ(XOBROOT,XOBREAD,XOBTO,XOBFIRST,XOBSTOP,XOBDATA,XOBHDLR) ;
"RTN","XOBVSKT",10,0)
 NEW X,EOT,OUT,STR,LINE,PIECES,DONE,TOFLAG,XOBCNT,XOBLEN,XOBBH,XOBEH,BS,ES,XOBOK,XOBX
"RTN","XOBVSKT",11,0)
 ;
"RTN","XOBVSKT",12,0)
 SET STR="",EOT=$CHAR(4),DONE=0,LINE=0,XOBOK=1
"RTN","XOBVSKT",13,0)
 ;
"RTN","XOBVSKT",14,0)
 ; -- READ tcp stream to global buffer | main calling tag NXTCALL^XOBVLL
"RTN","XOBVSKT",15,0)
 FOR  READ XOBX#XOBREAD:XOBTO SET TOFLAG=$TEST DO:XOBFIRST CHK DO:'XOBSTOP!('DONE)  QUIT:DONE
"RTN","XOBVSKT",16,0)
 . ;
"RTN","XOBVSKT",17,0)
 . ; -- if length of (new intake + current) is too large for buffer then store current
"RTN","XOBVSKT",18,0)
 . IF $LENGTH(STR)+$LENGTH(XOBX)>400 DO ADD(STR) SET STR=""
"RTN","XOBVSKT",19,0)
 . SET STR=STR_XOBX
"RTN","XOBVSKT",20,0)
 . ;
"RTN","XOBVSKT",21,0)
 . ; -- add node at each line-feed character
"RTN","XOBVSKT",22,0)
 . ; COMMENTED OUT: Not needed anymore, and has side effect of stripping out line feeds in input
"RTN","XOBVSKT",23,0)
 . ;                array-type parameter values (in XML mode)
"RTN","XOBVSKT",24,0)
 . ; FOR  QUIT:STR'[$CHAR(10)  DO ADD($PIECE(STR,$CHAR(10))) SET STR=$PIECE(STR,$CHAR(10),2,999)
"RTN","XOBVSKT",25,0)
 . ;
"RTN","XOBVSKT",26,0)
 . ; -- if end-of-text marker found then wrap up and quit
"RTN","XOBVSKT",27,0)
 . IF STR[EOT SET STR=$PIECE(STR,EOT) DO ADD(STR) SET DONE=1 QUIT
"RTN","XOBVSKT",28,0)
 . ; 
"RTN","XOBVSKT",29,0)
 . ; -- M XML parser cannot handle an element name split across nodes
"RTN","XOBVSKT",30,0)
 . SET PIECES=$LENGTH(STR,">")
"RTN","XOBVSKT",31,0)
 . IF PIECES>1 DO ADD($PIECE(STR,">",1,PIECES-1)_">") SET STR=$PIECE(STR,">",PIECES,999)
"RTN","XOBVSKT",32,0)
 ;
"RTN","XOBVSKT",33,0)
 QUIT XOBOK
"RTN","XOBVSKT",34,0)
 ;
"RTN","XOBVSKT",35,0)
ADD(TXT) ; -- add new intake line
"RTN","XOBVSKT",36,0)
 SET LINE=LINE+1
"RTN","XOBVSKT",37,0)
 SET @XOBROOT@(LINE)=TXT
"RTN","XOBVSKT",38,0)
 QUIT
"RTN","XOBVSKT",39,0)
 ;
"RTN","XOBVSKT",40,0)
CHK ; -- check if first read and change timeout and chars to read
"RTN","XOBVSKT",41,0)
 SET XOBFIRST=0
"RTN","XOBVSKT",42,0)
 ;
"RTN","XOBVSKT",43,0)
 ; -- abort if time out occurred and nothing was read
"RTN","XOBVSKT",44,0)
 IF 'TOFLAG,$GET(XOBX)="" SET XOBSTOP=1,DONE=1,XOBOK=0 QUIT
"RTN","XOBVSKT",45,0)
 ;
"RTN","XOBVSKT",46,0)
 ; -- intercept for transport sinks
"RTN","XOBVSKT",47,0)
 IF $EXTRACT(XOBX)'="<" DO SINK
"RTN","XOBVSKT",48,0)
 ;
"RTN","XOBVSKT",49,0)
 ; -- set up for subsequent reads
"RTN","XOBVSKT",50,0)
 SET XOBREAD=200,XOBTO=1
"RTN","XOBVSKT",51,0)
 QUIT
"RTN","XOBVSKT",52,0)
 ;
"RTN","XOBVSKT",53,0)
 ; ------------------------------------------------------------------------------------
"RTN","XOBVSKT",54,0)
 ;                      Execute Proprietary Format Reader
"RTN","XOBVSKT",55,0)
 ; ------------------------------------------------------------------------------------
"RTN","XOBVSKT",56,0)
SINK ;
"RTN","XOBVSKT",57,0)
 ; -- get size of sink indicator >> then get sink indicator >> load req handler
"RTN","XOBVSKT",58,0)
 SET XOBHDLR=$$MSGSINK^XOBVRH($$GETSTR(+$$GETSTR(2,.XOBX),.XOBX),.XOBHDLR)
"RTN","XOBVSKT",59,0)
 ;
"RTN","XOBVSKT",60,0)
 ; -- execute proprietary stream reader
"RTN","XOBVSKT",61,0)
 IF $GET(XOBHDLR(XOBHDLR)) XECUTE $GET(XOBHDLR(XOBHDLR,"READER"))
"RTN","XOBVSKT",62,0)
 ;
"RTN","XOBVSKT",63,0)
 SET DONE=1
"RTN","XOBVSKT",64,0)
 QUIT
"RTN","XOBVSKT",65,0)
 ;
"RTN","XOBVSKT",66,0)
 ; -- get string of length LEN from stream buffer
"RTN","XOBVSKT",67,0)
GETSTR(LEN,XOBUF) ;
"RTN","XOBVSKT",68,0)
 NEW X
"RTN","XOBVSKT",69,0)
 FOR  QUIT:($LENGTH(XOBUF)'<LEN)  DO RMORE(LEN-$LENGTH(XOBUF),.XOBUF)
"RTN","XOBVSKT",70,0)
 SET X=$EXTRACT(XOBUF,1,LEN)
"RTN","XOBVSKT",71,0)
 SET XOBUF=$EXTRACT(XOBUF,LEN+1,999)
"RTN","XOBVSKT",72,0)
 QUIT X
"RTN","XOBVSKT",73,0)
 ;
"RTN","XOBVSKT",74,0)
 ; -- read more from stream buffer but only needed amount
"RTN","XOBVSKT",75,0)
RMORE(LEN,XOBUF) ;
"RTN","XOBVSKT",76,0)
 NEW X
"RTN","XOBVSKT",77,0)
 READ X#LEN:1 SET XOBUF=XOBUF_X
"RTN","XOBVSKT",78,0)
 QUIT
"RTN","XOBVSKT",79,0)
 ;
"RTN","XOBVSKT",80,0)
 ; ------------------------------------------------------------------------------------
"RTN","XOBVSKT",81,0)
 ;                      Methods for Opening and Closing Socket
"RTN","XOBVSKT",82,0)
 ; ------------------------------------------------------------------------------------
"RTN","XOBVSKT",83,0)
OPEN(XOBPARMS) ; -- Open tcp/ip socket
"RTN","XOBVSKT",84,0)
 NEW I,POP
"RTN","XOBVSKT",85,0)
 SET POP=1
"RTN","XOBVSKT",86,0)
 ;
"RTN","XOBVSKT",87,0)
 ; -- set up os var
"RTN","XOBVSKT",88,0)
 DO OS
"RTN","XOBVSKT",89,0)
 ;
"RTN","XOBVSKT",90,0)
 ; -- preserve client io
"RTN","XOBVSKT",91,0)
 DO SAVDEV^%ZISUTL("XOB CLIENT")
"RTN","XOBVSKT",92,0)
 ;
"RTN","XOBVSKT",93,0)
 FOR I=1:1:XOBPARMS("RETRIES") DO CALL^%ZISTCP(XOBPARMS("ADDRESS"),XOBPARMS("PORT")) QUIT:'POP
"RTN","XOBVSKT",94,0)
 ; -- device open
"RTN","XOBVSKT",95,0)
 IF 'POP USE IO QUIT 1
"RTN","XOBVSKT",96,0)
 ; -- device not open
"RTN","XOBVSKT",97,0)
 QUIT 0
"RTN","XOBVSKT",98,0)
 ;
"RTN","XOBVSKT",99,0)
CLOSE(XOBPARMS) ; -- close tcp/ip socket
"RTN","XOBVSKT",100,0)
 ; -- tell server to Stop() connection if close message is needed to close
"RTN","XOBVSKT",101,0)
 IF $GET(XOBPARMS("CLOSE MESSAGE"))]"" DO
"RTN","XOBVSKT",102,0)
 . DO PRE
"RTN","XOBVSKT",103,0)
 . DO WRITE($$XMLHDR^XOBVLIB()_XOBPARMS("CLOSE MESSAGE"))
"RTN","XOBVSKT",104,0)
 . DO POST
"RTN","XOBVSKT",105,0)
 ;
"RTN","XOBVSKT",106,0)
 DO FINAL
"RTN","XOBVSKT",107,0)
 DO CLOSE^%ZISTCP
"RTN","XOBVSKT",108,0)
 DO USE^%ZISUTL("XOB CLIENT")
"RTN","XOBVSKT",109,0)
 DO RMDEV^%ZISUTL("XOB CLIENT")
"RTN","XOBVSKT",110,0)
 QUIT
"RTN","XOBVSKT",111,0)
 ;
"RTN","XOBVSKT",112,0)
INIT ; -- set up variables needed in tcp/ip processing
"RTN","XOBVSKT",113,0)
 KILL XOBNULL
"RTN","XOBVSKT",114,0)
 ;
"RTN","XOBVSKT",115,0)
 ; -- setup os var
"RTN","XOBVSKT",116,0)
 DO OS
"RTN","XOBVSKT",117,0)
 ;
"RTN","XOBVSKT",118,0)
 ; -- set RPC Broker os variable (so $$BROKER^XWBLIB returns true)
"RTN","XOBVSKT",119,0)
 SET XWBOS=XOBOS
"RTN","XOBVSKT",120,0)
 ;
"RTN","XOBVSKT",121,0)
 ; -- setup null device called "NULL"
"RTN","XOBVSKT",122,0)
 SET %ZIS="0H",IOP="NULL" DO ^%ZIS
"RTN","XOBVSKT",123,0)
 IF 'POP DO
"RTN","XOBVSKT",124,0)
 . SET XOBNULL=IO
"RTN","XOBVSKT",125,0)
 . DO SAVDEV^%ZISUTL("XOBNULL")
"RTN","XOBVSKT",126,0)
 QUIT
"RTN","XOBVSKT",127,0)
 ;
"RTN","XOBVSKT",128,0)
OS ; -- os var
"RTN","XOBVSKT",129,0)
 SET XOBOS=$SELECT(^%ZOSF("OS")["OpenM":"OpenM",^("OS")["DSM":"DSM",^("OS")["UNIX":"UNIX",^("OS")["MSM":"MSM",1:"")
"RTN","XOBVSKT",130,0)
 QUIT
"RTN","XOBVSKT",131,0)
 ;
"RTN","XOBVSKT",132,0)
FINAL ; -- kill variables used in tcp/ip processing
"RTN","XOBVSKT",133,0)
 ;
"RTN","XOBVSKT",134,0)
 ; -- close null device
"RTN","XOBVSKT",135,0)
 IF $DATA(XOBNULL) DO
"RTN","XOBVSKT",136,0)
 . DO USE^%ZISUTL("XOBNULL")
"RTN","XOBVSKT",137,0)
 . DO CLOSE^%ZISUTL("XOBNULL")
"RTN","XOBVSKT",138,0)
 . KILL XOBNULL
"RTN","XOBVSKT",139,0)
 ;
"RTN","XOBVSKT",140,0)
 KILL XOBOS,XWBOS
"RTN","XOBVSKT",141,0)
 ;
"RTN","XOBVSKT",142,0)
 QUIT
"RTN","XOBVSKT",143,0)
 ;
"RTN","XOBVSKT",144,0)
 ; ------------------------------------------------------------------------------------
"RTN","XOBVSKT",145,0)
 ;                          Methods for Writing to TCP/IP Socket
"RTN","XOBVSKT",146,0)
 ; ------------------------------------------------------------------------------------
"RTN","XOBVSKT",147,0)
PRE ; -- prepare socket for writing
"RTN","XOBVSKT",148,0)
 SET $X=0
"RTN","XOBVSKT",149,0)
 QUIT
"RTN","XOBVSKT",150,0)
 ;
"RTN","XOBVSKT",151,0)
WRITE(STR) ; -- Write a data string to socket
"RTN","XOBVSKT",152,0)
 IF XOBOS="MSM" WRITE STR QUIT
"RTN","XOBVSKT",153,0)
 ; 
"RTN","XOBVSKT",154,0)
 ; -- handle a short string
"RTN","XOBVSKT",155,0)
 IF $LENGTH(STR)<511 DO:($X+$LENGTH(STR))>511 FLUSH WRITE STR QUIT
"RTN","XOBVSKT",156,0)
 ;
"RTN","XOBVSKT",157,0)
 ; -- handle a long string
"RTN","XOBVSKT",158,0)
 DO FLUSH
"RTN","XOBVSKT",159,0)
 FOR  QUIT:'$LENGTH(STR)  WRITE $EXTRACT(STR,1,511) DO FLUSH SET STR=$EXTRACT(STR,512,99999)
"RTN","XOBVSKT",160,0)
 ;
"RTN","XOBVSKT",161,0)
 QUIT
"RTN","XOBVSKT",162,0)
 ;
"RTN","XOBVSKT",163,0)
POST ; -- send eot and flush socket buffer
"RTN","XOBVSKT",164,0)
 DO WRITE($CHAR(4))
"RTN","XOBVSKT",165,0)
 DO FLUSH
"RTN","XOBVSKT",166,0)
 QUIT
"RTN","XOBVSKT",167,0)
 ;
"RTN","XOBVSKT",168,0)
FLUSH ; flush buffer
"RTN","XOBVSKT",169,0)
 IF XOBOS="OpenM" WRITE ! QUIT
"RTN","XOBVSKT",170,0)
 IF XOBOS="DSM" WRITE:$X>0 ! QUIT
"RTN","XOBVSKT",171,0)
 ;IF XOBOS="GTM" WRITE # QUIT
"RTN","XOBVSKT",172,0)
 QUIT
"RTN","XOBVSKT",173,0)
 ;
"RTN","XOBVSYSI")
0^16^B53927220
"RTN","XOBVSYSI",1,0)
XOBVSYSI ;; ld,mjk/alb - VistaLink Interface Implementation ; 07/27/2002  13:00
"RTN","XOBVSYSI",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVSYSI",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVSYSI",4,0)
CALLBACK(CB) ; -- init callbacks implementation
"RTN","XOBVSYSI",5,0)
 SET CB("STARTELEMENT")="ELEST^XOBVSYSI"
"RTN","XOBVSYSI",6,0)
 QUIT
"RTN","XOBVSYSI",7,0)
 ;
"RTN","XOBVSYSI",8,0)
 ; ------------------------------------------------------------------------
"RTN","XOBVSYSI",9,0)
 ;             RPC Server: Request Message XML SAX Parser Callbacks         
"RTN","XOBVSYSI",10,0)
 ; ------------------------------------------------------------------------
"RTN","XOBVSYSI",11,0)
ELEST(ELE,ATR) ; -- element start event handler
"RTN","XOBVSYSI",12,0)
 IF ELE="VistaLink" DO  QUIT
"RTN","XOBVSYSI",13,0)
 . SET XOBDATA("MODE")=$GET(ATR("mode"),"single call")
"RTN","XOBVSYSI",14,0)
 ;
"RTN","XOBVSYSI",15,0)
 IF ELE="Request" DO  QUIT
"RTN","XOBVSYSI",16,0)
 . SET XOBDATA("XOB SYSTEM","TYPE")=$GET(ATR("type"),"unknown")
"RTN","XOBVSYSI",17,0)
 . SET XOBDATA("XOB SYSTEM","ENV")=$$LOW^XLFSTR($GET(ATR("environment"),"j2se"))
"RTN","XOBVSYSI",18,0)
 ;
"RTN","XOBVSYSI",19,0)
 QUIT
"RTN","XOBVSYSI",20,0)
 ;
"RTN","XOBVSYSI",21,0)
READER(XOBUF,XOBDATA) ; -- proprietary format reader implementation
"RTN","XOBVSYSI",22,0)
 QUIT
"RTN","XOBVSYSI",23,0)
 ;
"RTN","XOBVSYSI",24,0)
REQHDLR(XOBDATA) ; -- request handler implementation
"RTN","XOBVSYSI",25,0)
 NEW TYPE
"RTN","XOBVSYSI",26,0)
 SET TYPE=$GET(XOBDATA("XOB SYSTEM","TYPE"),"unknown")
"RTN","XOBVSYSI",27,0)
 ;
"RTN","XOBVSYSI",28,0)
 ; -- initialize socket partition request
"RTN","XOBVSYSI",29,0)
 IF TYPE="initializeSocket" DO INIT(.TYPE) GOTO REQHDLRQ
"RTN","XOBVSYSI",30,0)
 ;
"RTN","XOBVSYSI",31,0)
 ; -- set stop flag to close socket request
"RTN","XOBVSYSI",32,0)
 IF TYPE="closeSocket" DO CLOSE(.TYPE) GOTO REQHDLRQ
"RTN","XOBVSYSI",33,0)
 ;
"RTN","XOBVSYSI",34,0)
 ; -- cleanup partition request 
"RTN","XOBVSYSI",35,0)
 IF TYPE="cleanupPartition" DO CLEANUP(.TYPE) GOTO REQHDLRQ
"RTN","XOBVSYSI",36,0)
 ;
"RTN","XOBVSYSI",37,0)
 ; --  heartbeat request 
"RTN","XOBVSYSI",38,0)
 IF TYPE="heartbeat" DO HB(.TYPE) GOTO REQHDLRQ
"RTN","XOBVSYSI",39,0)
 ;
"RTN","XOBVSYSI",40,0)
 ; --  system info request 
"RTN","XOBVSYSI",41,0)
 IF TYPE="systemInfo" DO SYSINFO(.TYPE) GOTO REQHDLRQ
"RTN","XOBVSYSI",42,0)
 ;
"RTN","XOBVSYSI",43,0)
 ; -- failure if processing get here
"RTN","XOBVSYSI",44,0)
 DO RESPONSE(.TYPE,"failure")
"RTN","XOBVSYSI",45,0)
 ;
"RTN","XOBVSYSI",46,0)
REQHDLRQ ;
"RTN","XOBVSYSI",47,0)
 QUIT
"RTN","XOBVSYSI",48,0)
 ;
"RTN","XOBVSYSI",49,0)
ENV ; -- set env variable
"RTN","XOBVSYSI",50,0)
 SET XOBSYS("ENV")=$GET(XOBDATA("XOB SYSTEM","ENV"))
"RTN","XOBVSYSI",51,0)
 QUIT
"RTN","XOBVSYSI",52,0)
 ;
"RTN","XOBVSYSI",53,0)
PSTANUM ; -- set primary station number
"RTN","XOBVSYSI",54,0)
 SET XOBSYS("PRIMARY STATION#")=$$TRUNCCH($$STA^XUAF4($$KSP^XUPARAM("INST")))
"RTN","XOBVSYSI",55,0)
 ; note: AAC 200M is truncated to 200
"RTN","XOBVSYSI",56,0)
 QUIT
"RTN","XOBVSYSI",57,0)
 ;
"RTN","XOBVSYSI",58,0)
INIT(TYPE) ; -- handle initialize request
"RTN","XOBVSYSI",59,0)
 KILL XOBSYS
"RTN","XOBVSYSI",60,0)
 DO ENV
"RTN","XOBVSYSI",61,0)
 DO PSTANUM
"RTN","XOBVSYSI",62,0)
 ;
"RTN","XOBVSYSI",63,0)
 IF "^j2se^j2ee^.net^"[(U_XOBSYS("ENV")_U) DO
"RTN","XOBVSYSI",64,0)
 . DO RESPONSE(.TYPE,"success",$$RATE()_$$JOB()_$$RASTO())
"RTN","XOBVSYSI",65,0)
 ELSE  DO
"RTN","XOBVSYSI",66,0)
 . DO RESPONSE(.TYPE,"failure")
"RTN","XOBVSYSI",67,0)
 QUIT
"RTN","XOBVSYSI",68,0)
 ;
"RTN","XOBVSYSI",69,0)
CLOSE(TYPE) ; -- handle close socket request
"RTN","XOBVSYSI",70,0)
 SET XOBSTOP=1
"RTN","XOBVSYSI",71,0)
 DO RESPONSE(.TYPE,"success")
"RTN","XOBVSYSI",72,0)
 QUIT
"RTN","XOBVSYSI",73,0)
 ;
"RTN","XOBVSYSI",74,0)
CLEANUP(TYPE) ; -- handle cleanup partition request
"RTN","XOBVSYSI",75,0)
 ; -- unlock any pending locks
"RTN","XOBVSYSI",76,0)
 LOCK
"RTN","XOBVSYSI",77,0)
 ;
"RTN","XOBVSYSI",78,0)
 ; -- clean ^TMP, ^UTILITY, ^XUTL
"RTN","XOBVSYSI",79,0)
 DO XUTL^XUSCLEAN
"RTN","XOBVSYSI",80,0)
 ;
"RTN","XOBVSYSI",81,0)
 ; -- restore DUZ to connector user
"RTN","XOBVSYSI",82,0)
 KILL DUZ
"RTN","XOBVSYSI",83,0)
 MERGE DUZ=XOBSYS("DUZ")
"RTN","XOBVSYSI",84,0)
 ;
"RTN","XOBVSYSI",85,0)
 ; -- clean symbol table
"RTN","XOBVSYSI",86,0)
 DO KILL^XOBVLL
"RTN","XOBVSYSI",87,0)
 ;
"RTN","XOBVSYSI",88,0)
 DO RESPONSE(.TYPE,"success")
"RTN","XOBVSYSI",89,0)
 QUIT
"RTN","XOBVSYSI",90,0)
 ;
"RTN","XOBVSYSI",91,0)
DUZSV(DUZ) ; -- save initial DUZ info for session
"RTN","XOBVSYSI",92,0)
 IF $GET(XOBSYS("ENV"))="j2ee" DO
"RTN","XOBVSYSI",93,0)
 . KILL XOBSYS("DUZ")
"RTN","XOBVSYSI",94,0)
 . MERGE XOBSYS("DUZ")=DUZ
"RTN","XOBVSYSI",95,0)
 QUIT
"RTN","XOBVSYSI",96,0)
 ;
"RTN","XOBVSYSI",97,0)
HB(TYPE) ; -- handle heartbeat request
"RTN","XOBVSYSI",98,0)
 DO ENV
"RTN","XOBVSYSI",99,0)
 DO RESPONSE(.TYPE,"success",$$RATE())
"RTN","XOBVSYSI",100,0)
 QUIT
"RTN","XOBVSYSI",101,0)
 ;
"RTN","XOBVSYSI",102,0)
RATE() ; -- set up rate attribute for response
"RTN","XOBVSYSI",103,0)
 NEW XOBRATE
"RTN","XOBVSYSI",104,0)
 ; -- get J2EE timeout value for app serv environment
"RTN","XOBVSYSI",105,0)
 IF $GET(XOBSYS("ENV"))="j2ee" DO
"RTN","XOBVSYSI",106,0)
 . SET XOBRATE=$$GETASTO^XOBVLIB()
"RTN","XOBVSYSI",107,0)
 ELSE  DO
"RTN","XOBVSYSI",108,0)
 . SET XOBRATE=$$GETRATE^XOBVLIB()
"RTN","XOBVSYSI",109,0)
 QUIT " rate="""_XOBRATE_""""
"RTN","XOBVSYSI",110,0)
 ;
"RTN","XOBVSYSI",111,0)
JOB() ; -- set up $JOB attribute for response
"RTN","XOBVSYSI",112,0)
 QUIT " mJob="""_$JOB_""""
"RTN","XOBVSYSI",113,0)
 ;
"RTN","XOBVSYSI",114,0)
RASTO() ; -- set up ReAuthenticated Session TimeOut
"RTN","XOBVSYSI",115,0)
 QUIT " reAuthSessionTimeout="""_$$GETRASTO^XOBVLIB()_""""
"RTN","XOBVSYSI",116,0)
 ;
"RTN","XOBVSYSI",117,0)
RESPONSE(TYPE,STATUS,ATTRS) ; -- build xml response
"RTN","XOBVSYSI",118,0)
 ; -- initialize
"RTN","XOBVSYSI",119,0)
 DO PRE^XOBVSKT
"RTN","XOBVSYSI",120,0)
 DO WRITE^XOBVSKT($$VLHDR^XOBVLIB(4))
"RTN","XOBVSYSI",121,0)
 DO WRITE^XOBVSKT("<Response type="""_$GET(TYPE)_""" status="""_$GET(STATUS)_""""_$GET(ATTRS,"")_" />")
"RTN","XOBVSYSI",122,0)
 DO WRITE^XOBVSKT($$ENVFTR^XOBVLIB())
"RTN","XOBVSYSI",123,0)
 ; -- send eot and flush buffer
"RTN","XOBVSYSI",124,0)
 DO POST^XOBVSKT
"RTN","XOBVSYSI",125,0)
 QUIT
"RTN","XOBVSYSI",126,0)
 ;
"RTN","XOBVSYSI",127,0)
SYSINFO(TYPE) ; -- build system info response
"RTN","XOBVSYSI",128,0)
 NEW XOBINFO,XOBELE,XOBDEFLT,XOBINTRO,XOBI
"RTN","XOBVSYSI",129,0)
 ;
"RTN","XOBVSYSI",130,0)
 ; -- set up default value
"RTN","XOBVSYSI",131,0)
 SET XOBDEFLT="unknown"
"RTN","XOBVSYSI",132,0)
 ;
"RTN","XOBVSYSI",133,0)
 ; -- get system info array
"RTN","XOBVSYSI",134,0)
 DO GETSINFO(.XOBINFO)
"RTN","XOBVSYSI",135,0)
 ;
"RTN","XOBVSYSI",136,0)
 ; -- build <SystemInfo> element
"RTN","XOBVSYSI",137,0)
 SET XOBELE="<SystemInfo"
"RTN","XOBVSYSI",138,0)
 SET XOBELE=XOBELE_" vistalinkVersion="""_$GET(XOBINFO("version"),XOBDEFLT)_""""
"RTN","XOBVSYSI",139,0)
 SET XOBELE=XOBELE_" vistalinkBuild="""_$GET(XOBINFO("build"),XOBDEFLT)_""""
"RTN","XOBVSYSI",140,0)
 SET XOBELE=XOBELE_" appServerTimeout="""_$GET(XOBINFO("appServerTimeout"),XOBDEFLT)_""""
"RTN","XOBVSYSI",141,0)
 SET XOBELE=XOBELE_" reAuthSessionTimeout="""_$GET(XOBINFO("reAuthSessionTimeout"),XOBDEFLT)_""""
"RTN","XOBVSYSI",142,0)
 SET XOBELE=XOBELE_" uci="""_$GET(XOBINFO("uci"),XOBDEFLT)_""""
"RTN","XOBVSYSI",143,0)
 SET XOBELE=XOBELE_" vol="""_$GET(XOBINFO("vol"),XOBDEFLT)_""""
"RTN","XOBVSYSI",144,0)
 SET XOBELE=XOBELE_" boxVolume="""_$GET(XOBINFO("boxVolume"),XOBDEFLT)_""""
"RTN","XOBVSYSI",145,0)
 SET XOBELE=XOBELE_" mVersion="""_$GET(XOBINFO("mVersion"),XOBDEFLT)_""""
"RTN","XOBVSYSI",146,0)
 SET XOBELE=XOBELE_" operatingSystem="""_$GET(XOBINFO("operatingSystem"),XOBDEFLT)_""""
"RTN","XOBVSYSI",147,0)
 SET XOBELE=XOBELE_" domainName="""_$GET(XOBINFO("domainName"),XOBDEFLT)_""""
"RTN","XOBVSYSI",148,0)
 SET XOBELE=XOBELE_" vistaProduction="""_$GET(XOBINFO("vistaProduction"),XOBDEFLT)_""""
"RTN","XOBVSYSI",149,0)
 SET XOBELE=XOBELE_" defaultInstitution="""_$GET(XOBINFO("defaultInstitution"),XOBDEFLT)_""""
"RTN","XOBVSYSI",150,0)
 SET XOBELE=XOBELE_" cpName="""_$GET(XOBINFO("cpName"),XOBDEFLT)_""""
"RTN","XOBVSYSI",151,0)
 SET XOBELE=XOBELE_" />"
"RTN","XOBVSYSI",152,0)
 ;
"RTN","XOBVSYSI",153,0)
 SET XOBINTRO=$GET(XOBINFO("introductoryText"))
"RTN","XOBVSYSI",154,0)
 ;
"RTN","XOBVSYSI",155,0)
 ; -- build and send complete message
"RTN","XOBVSYSI",156,0)
 DO PRE^XOBVSKT
"RTN","XOBVSYSI",157,0)
 DO WRITE^XOBVSKT($$VLHDR^XOBVLIB(4))
"RTN","XOBVSYSI",158,0)
 DO WRITE^XOBVSKT("<Response type="""_$GET(TYPE)_""" status=""success"" >")
"RTN","XOBVSYSI",159,0)
 DO WRITE^XOBVSKT(XOBELE)
"RTN","XOBVSYSI",160,0)
 FOR XOBI=1:1  QUIT:'$DATA(XOBINFO("introductoryText",XOBI))  DO
"RTN","XOBVSYSI",161,0)
 . DO WRITE^XOBVSKT(XOBINFO("introductoryText",XOBI))
"RTN","XOBVSYSI",162,0)
 DO WRITE^XOBVSKT("</Response>")
"RTN","XOBVSYSI",163,0)
 DO WRITE^XOBVSKT($$ENVFTR^XOBVLIB())
"RTN","XOBVSYSI",164,0)
 DO POST^XOBVSKT
"RTN","XOBVSYSI",165,0)
 ;
"RTN","XOBVSYSI",166,0)
 QUIT
"RTN","XOBVSYSI",167,0)
 ;
"RTN","XOBVSYSI",168,0)
GETSINFO(XOBINFO) ; -- gather system info into array
"RTN","XOBVSYSI",169,0)
 NEW X,Y
"RTN","XOBVSYSI",170,0)
 ;
"RTN","XOBVSYSI",171,0)
 ; -- get version
"RTN","XOBVSYSI",172,0)
 SET XOBINFO("version")=$PIECE($TEXT(XOBVSYSI+1),";",3)
"RTN","XOBVSYSI",173,0)
 ;
"RTN","XOBVSYSI",174,0)
 ; -- get build number
"RTN","XOBVSYSI",175,0)
 SET XOBINFO("build")=$PIECE($TEXT(XOBVSYSI+1),";",7)
"RTN","XOBVSYSI",176,0)
 ;
"RTN","XOBVSYSI",177,0)
 ; -- get application server connection timeout
"RTN","XOBVSYSI",178,0)
 SET XOBINFO("appServerTimeout")=$$GETASTO^XOBVLIB()
"RTN","XOBVSYSI",179,0)
 ;
"RTN","XOBVSYSI",180,0)
 ; -- get reauthentication session timeout
"RTN","XOBVSYSI",181,0)
 SET XOBINFO("reAuthSessionTimeout")=$$GETRASTO^XOBVLIB()
"RTN","XOBVSYSI",182,0)
 ;
"RTN","XOBVSYSI",183,0)
 ; -- get basic M environment information
"RTN","XOBVSYSI",184,0)
 SET Y=""
"RTN","XOBVSYSI",185,0)
 DO GETENV^%ZOSV
"RTN","XOBVSYSI",186,0)
 ;
"RTN","XOBVSYSI",187,0)
 ; -- get uci
"RTN","XOBVSYSI",188,0)
 SET XOBINFO("uci")=$PIECE(Y,U,1)
"RTN","XOBVSYSI",189,0)
 ;
"RTN","XOBVSYSI",190,0)
 ; -- get vol
"RTN","XOBVSYSI",191,0)
 SET XOBINFO("vol")=$PIECE(Y,U,2)
"RTN","XOBVSYSI",192,0)
 ;
"RTN","XOBVSYSI",193,0)
 ; -- get box volume
"RTN","XOBVSYSI",194,0)
 SET XOBINFO("boxVolume")=$PIECE(Y,U,4)
"RTN","XOBVSYSI",195,0)
 ;
"RTN","XOBVSYSI",196,0)
 ; -- get M version (full name)
"RTN","XOBVSYSI",197,0)
 SET XOBINFO("mVersion")=$$SYMENC^MXMLUTL($$VERSION^%ZOSV(1))
"RTN","XOBVSYSI",198,0)
 ;
"RTN","XOBVSYSI",199,0)
 ; -- get operating system
"RTN","XOBVSYSI",200,0)
 SET XOBINFO("operatingSystem")=$$SYMENC^MXMLUTL($$SYSOS^XOBVLIB(XOBOS))
"RTN","XOBVSYSI",201,0)
 ;
"RTN","XOBVSYSI",202,0)
 ; -- get domain name
"RTN","XOBVSYSI",203,0)
 SET XOBINFO("domainName")=$$SYMENC^MXMLUTL($$KSP^XUPARAM("WHERE"))
"RTN","XOBVSYSI",204,0)
 ;
"RTN","XOBVSYSI",205,0)
 ; -- production or test
"RTN","XOBVSYSI",206,0)
 SET XOBINFO("vistaProduction")=$S($$PROD^XUPROD(0):"true",1:"false")
"RTN","XOBVSYSI",207,0)
 ;
"RTN","XOBVSYSI",208,0)
 ; -- default institution
"RTN","XOBVSYSI",209,0)
 SET XOBINFO("defaultInstitution")=$$SYMENC^MXMLUTL($$STA^XUAF4($$KSP^XUPARAM("INST"))_"/"_$$NAME^XUAF4($$KSP^XUPARAM("INST")))
"RTN","XOBVSYSI",210,0)
 ;
"RTN","XOBVSYSI",211,0)
 ; -- get intro text
"RTN","XOBVSYSI",212,0)
 D GETINTRO^XOBSCAV2("XOBINFO(""introductoryText"")",1)
"RTN","XOBVSYSI",213,0)
 ;
"RTN","XOBVSYSI",214,0)
 ; -- get c/p username
"RTN","XOBVSYSI",215,0)
 SET XOBINFO("cpName")=$$NAME^XUSER(DUZ)
"RTN","XOBVSYSI",216,0)
 ;
"RTN","XOBVSYSI",217,0)
 QUIT
"RTN","XOBVSYSI",218,0)
 ;
"RTN","XOBVSYSI",219,0)
RPC(XOBY) ;
"RTN","XOBVSYSI",220,0)
 NEW XOBX,XOBLINE,XOBARR
"RTN","XOBVSYSI",221,0)
 D GETSINFO(.XOBARR)
"RTN","XOBVSYSI",222,0)
 SET XOBLINE=0
"RTN","XOBVSYSI",223,0)
 S XOBX="" F  S XOBX=$O(XOBARR(XOBX)) Q:XOBX']""  D
"RTN","XOBVSYSI",224,0)
 . SET XOBLINE=XOBLINE+1
"RTN","XOBVSYSI",225,0)
 . SET XOBY(XOBLINE)=XOBX_"~"_XOBARR(XOBX)
"RTN","XOBVSYSI",226,0)
 QUIT
"RTN","XOBVSYSI",227,0)
 ;
"RTN","XOBVSYSI",228,0)
TRUNCCH(XOBSTR) ; truncate before first non-numeric char
"RTN","XOBVSYSI",229,0)
 NEW XOBI,XOBSTOP,XOBSTR1
"RTN","XOBVSYSI",230,0)
 SET XOBSTOP=0,XOBSTR1=""
"RTN","XOBVSYSI",231,0)
 FOR XOBI=1:1:$L(XOBSTR) QUIT:XOBSTOP  DO
"RTN","XOBVSYSI",232,0)
 . IF "0123456789"'[$E(XOBSTR,XOBI) SET XOBSTOP=1 QUIT
"RTN","XOBVSYSI",233,0)
 . SET XOBSTR1=XOBSTR1_$E(XOBSTR,XOBI)
"RTN","XOBVSYSI",234,0)
 QUIT XOBSTR1
"RTN","XOBVTCP")
0^17^B48106146
"RTN","XOBVTCP",1,0)
XOBVTCP ;; mjk/alb - VistALink TCP Utilities ; 07/27/2002  13:00
"RTN","XOBVTCP",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVTCP",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVTCP",4,0)
 QUIT
"RTN","XOBVTCP",5,0)
 ;
"RTN","XOBVTCP",6,0)
 ; -- called from protocol action at START^XOBUM1 
"RTN","XOBVTCP",7,0)
START(XOBPORT,XOBCFG) ;
"RTN","XOBVTCP",8,0)
 ; 
"RTN","XOBVTCP",9,0)
 ; -- set up environment
"RTN","XOBVTCP",10,0)
 NEW XOBOK
"RTN","XOBVTCP",11,0)
 SET XOBOK=0
"RTN","XOBVTCP",12,0)
 SET U="^" DO HOME^%ZIS
"RTN","XOBVTCP",13,0)
 ;
"RTN","XOBVTCP",14,0)
 ; -- if no port, set to default
"RTN","XOBVTCP",15,0)
 IF $GET(XOBPORT)="" NEW XOBPORT SET XOBPORT=8000
"RTN","XOBVTCP",16,0)
 ;
"RTN","XOBVTCP",17,0)
 IF $$LOCK(XOBPORT) DO
"RTN","XOBVTCP",18,0)
 . DO UNLOCK(XOBPORT)
"RTN","XOBVTCP",19,0)
 . ; -- JOB command same for CacheNT and DSM
"RTN","XOBVTCP",20,0)
 . JOB LISTENER^XOBVTCPL(XOBPORT,$GET(XOBCFG))::5
"RTN","XOBVTCP",21,0)
 . SET XOBOK=$TEST
"RTN","XOBVTCP",22,0)
 ELSE  DO
"RTN","XOBVTCP",23,0)
 . SET XOBOK=0
"RTN","XOBVTCP",24,0)
 QUIT XOBOK
"RTN","XOBVTCP",25,0)
 ;
"RTN","XOBVTCP",26,0)
UCX ; -- old VMS TCPIP (UCX) multi-thread entry point [for DSM]
"RTN","XOBVTCP",27,0)
 ; -- Called from VistALink .com files
"RTN","XOBVTCP",28,0)
 ;
"RTN","XOBVTCP",29,0)
 NEW XOBEC
"RTN","XOBVTCP",30,0)
 DO ESET
"RTN","XOBVTCP",31,0)
 SET (IO,IO(0))="SYS$NET"
"RTN","XOBVTCP",32,0)
 ; **VMS specific code, need to share device**
"RTN","XOBVTCP",33,0)
 OPEN IO:(TCPDEV:BLOCKSIZE=512):60 ELSE  SET ^TMP("XOB DSM CONNECT FAILURE",$HOROLOG)="" QUIT
"RTN","XOBVTCP",34,0)
 USE IO
"RTN","XOBVTCP",35,0)
 SET XOBEC=$$NEWOK^XOBVTCPL()
"RTN","XOBVTCP",36,0)
 IF XOBEC DO LOGINERR^XOBVTCPL(XOBEC,IO)
"RTN","XOBVTCP",37,0)
 IF 'XOBEC DO SPAWN^XOBVLL
"RTN","XOBVTCP",38,0)
 QUIT
"RTN","XOBVTCP",39,0)
 ;
"RTN","XOBVTCP",40,0)
CACHEVMS ; -- VMS TCPIP (UCX) multi-thread entry point for Cache for VMS
"RTN","XOBVTCP",41,0)
 ; -- Called from VistALink .com files
"RTN","XOBVTCP",42,0)
 ;
"RTN","XOBVTCP",43,0)
 NEW XOBEC
"RTN","XOBVTCP",44,0)
 DO ESET
"RTN","XOBVTCP",45,0)
 SET (IO,IO(0))="SYS$NET"
"RTN","XOBVTCP",46,0)
 ;
"RTN","XOBVTCP",47,0)
 OPEN IO::5
"RTN","XOBVTCP",48,0)
 USE IO:(::"-M") ;Packet mode like DSM
"RTN","XOBVTCP",49,0)
 ;
"RTN","XOBVTCP",50,0)
 SET XOBEC=$$NEWOK^XOBVTCPL()
"RTN","XOBVTCP",51,0)
 IF XOBEC DO LOGINERR^XOBVTCPL(XOBEC,IO)
"RTN","XOBVTCP",52,0)
 IF 'XOBEC DO SPAWN^XOBVLL
"RTN","XOBVTCP",53,0)
 QUIT
"RTN","XOBVTCP",54,0)
 ;
"RTN","XOBVTCP",55,0)
CACHELNX ; -- multi-thread entry point for Cache for Linux
"RTN","XOBVTCP",56,0)
 ; -- Called from XINETD service files
"RTN","XOBVTCP",57,0)
 ;
"RTN","XOBVTCP",58,0)
 NEW XOBEC
"RTN","XOBVTCP",59,0)
 DO ESET
"RTN","XOBVTCP",60,0)
 SET (IO,IO(0))=$PRINCIPAL
"RTN","XOBVTCP",61,0)
 ;
"RTN","XOBVTCP",62,0)
 OPEN IO::5
"RTN","XOBVTCP",63,0)
 USE IO:(::"-M") ;Packet mode like DSM
"RTN","XOBVTCP",64,0)
 ;
"RTN","XOBVTCP",65,0)
 SET XOBEC=$$NEWOK^XOBVTCPL()
"RTN","XOBVTCP",66,0)
 IF XOBEC DO LOGINERR^XOBVTCPL(XOBEC,IO)
"RTN","XOBVTCP",67,0)
 IF 'XOBEC DO SPAWN^XOBVLL
"RTN","XOBVTCP",68,0)
 QUIT
"RTN","XOBVTCP",69,0)
 ;
"RTN","XOBVTCP",70,0)
GTMLNX ; -- Linux xinetd multi-thread entry point for GT.M
"RTN","XOBVTCP",71,0)
 ;
"RTN","XOBVTCP",72,0)
 NEW XOBEC,TMP,X,%
"RTN","XOBVTCP",73,0)
 DO ESET
"RTN","XOBVTCP",74,0)
 ;
"RTN","XOBVTCP",75,0)
 ; **GTM/linux specific code**
"RTN","XOBVTCP",76,0)
 SET (IO,IO(0))=$P,@("$ZT=""""")
"RTN","XOBVTCP",77,0)
 X "U IO:(nowrap:nodelimiter:IOERROR=""TRAP"")" ;Setup device
"RTN","XOBVTCP",78,0)
 S @("$ZINTERRUPT=""I $$JOBEXAM^ZU($ZPOSITION)"""),X=""
"RTN","XOBVTCP",79,0)
 X "ZSHOW ""D"":TMP"
"RTN","XOBVTCP",80,0)
 F %=1:1 Q:'$D(TMP("D",%))  S X=TMP("D",%) Q:X["LOCAL"
"RTN","XOBVTCP",81,0)
 S IO("IP")=$P($P(X,"REMOTE=",2),"@"),IO("PORT")=+$P($P(X,"LOCAL=",2),"@",2)
"RTN","XOBVTCP",82,0)
 ;End GT.M code
"RTN","XOBVTCP",83,0)
 ;
"RTN","XOBVTCP",84,0)
 SET XOBEC=$$NEWOK^XOBVTCPL()
"RTN","XOBVTCP",85,0)
 IF XOBEC DO LOGINERR^XOBVTCPL(XOBEC,IO)
"RTN","XOBVTCP",86,0)
 IF 'XOBEC DO COUNT^XUSCNT(1),SPAWN^XOBVLL,COUNT^XUSCNT(-1)
"RTN","XOBVTCP",87,0)
 QUIT
"RTN","XOBVTCP",88,0)
 ;
"RTN","XOBVTCP",89,0)
 ;Sample linux scripts
"RTN","XOBVTCP",90,0)
 ;xinetd script
"RTN","XOBVTCP",91,0)
 ;vvvvvvvvvvvvvvvvvvvvvvvvv
"RTN","XOBVTCP",92,0)
 ;service vistalink
"RTN","XOBVTCP",93,0)
 ;{
"RTN","XOBVTCP",94,0)
 ;   socket_type     = stream
"RTN","XOBVTCP",95,0)
 ;   port            = 18001
"RTN","XOBVTCP",96,0)
 ;   type            = UNLISTED
"RTN","XOBVTCP",97,0)
 ;   user            = vista
"RTN","XOBVTCP",98,0)
 ;   wait            = no
"RTN","XOBVTCP",99,0)
 ;   disable         = no
"RTN","XOBVTCP",100,0)
 ;   server          = /bin/bash
"RTN","XOBVTCP",101,0)
 ;   server_args     = /home/vista/dev/vistalink.sh
"RTN","XOBVTCP",102,0)
 ;   passenv         = REMOTE_HOST
"RTN","XOBVTCP",103,0)
 ;}
"RTN","XOBVTCP",104,0)
 ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^
"RTN","XOBVTCP",105,0)
 ;
"RTN","XOBVTCP",106,0)
 ;cat /home/vista/dev/vistalink.sh
"RTN","XOBVTCP",107,0)
 ;vvvvvvvvvvvvvvvvvvvvvvvvvvvv
"RTN","XOBVTCP",108,0)
 ;#!/bin/bash
"RTN","XOBVTCP",109,0)
 ;#RPC Broker
"RTN","XOBVTCP",110,0)
 ;cd /home/vista/dev
"RTN","XOBVTCP",111,0)
 ;. ./gtmprofile
"RTN","XOBVTCP",112,0)
 ;$gtm_dist/mumps -r GTMLNX^XOBVTCP
"RTN","XOBVTCP",113,0)
 ;exit 0
"RTN","XOBVTCP",114,0)
 ;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
"RTN","XOBVTCP",115,0)
 ;
"RTN","XOBVTCP",116,0)
SERVICE ; -- service entry point (for VMS TCP/IP & LINUX XINETD utilities)
"RTN","XOBVTCP",117,0)
 ; TODO: possible single entry point for os service calls; needs work and has not been tested
"RTN","XOBVTCP",118,0)
 NEW XOBEC,XOBMOS,XOBSOS
"RTN","XOBVTCP",119,0)
 DO ESET
"RTN","XOBVTCP",120,0)
 SET XOBMOS=$$OS^XOBVSKT()
"RTN","XOBVTCP",121,0)
 IF XOBMOS'["OpenM" SET $ECODE=",U98,"
"RTN","XOBVTCP",122,0)
 SET XOBSOS=$$SYSOS^XOBVLIB(XOBMOS)
"RTN","XOBVTCP",123,0)
 IF XOBMOS'["VMS"!(XOBMOS'["UNIX") SET $ECODE=",U97,"
"RTN","XOBVTCP",124,0)
 ;
"RTN","XOBVTCP",125,0)
 SET (IO,IO(0))=$SELECT(XOBSOS="VMS":"SYS$NET","UNIX":$PRINCIPAL)
"RTN","XOBVTCP",126,0)
 ;
"RTN","XOBVTCP",127,0)
 OPEN IO::5
"RTN","XOBVTCP",128,0)
 USE IO:(::"-M") ;Packet mode like DSM
"RTN","XOBVTCP",129,0)
 ;
"RTN","XOBVTCP",130,0)
 SET XOBEC=$$NEWOK^XOBVTCPL()
"RTN","XOBVTCP",131,0)
 IF XOBEC DO LOGINERR^XOBVTCPL(XOBEC,IO)
"RTN","XOBVTCP",132,0)
 IF 'XOBEC DO SPAWN^XOBVLL
"RTN","XOBVTCP",133,0)
 QUIT
"RTN","XOBVTCP",134,0)
 ;
"RTN","XOBVTCP",135,0)
ESET ;Set initial error trap
"RTN","XOBVTCP",136,0)
 SET U="^",$ETRAP="D ^%ZTER H" ;Set up the error trap
"RTN","XOBVTCP",137,0)
 QUIT
"RTN","XOBVTCP",138,0)
 ;
"RTN","XOBVTCP",139,0)
STARTUP ; -- called by TaskMan startup option [Option: XOBV LISTENER STARTUP]
"RTN","XOBVTCP",140,0)
 ;           and could be called by VMS .com procedure
"RTN","XOBVTCP",141,0)
 ;
"RTN","XOBVTCP",142,0)
 ; -- quit if not Cache OS
"RTN","XOBVTCP",143,0)
 IF $$GETOS()'["OpenM" GOTO STARTUPQ
"RTN","XOBVTCP",144,0)
 ; -- clear log of non-active listeners
"RTN","XOBVTCP",145,0)
 DO CLEARLOG
"RTN","XOBVTCP",146,0)
 ; -- get config for BOX-VOL and start it!
"RTN","XOBVTCP",147,0)
 DO STARTCFG($$GETCFG())
"RTN","XOBVTCP",148,0)
STARTUPQ ;
"RTN","XOBVTCP",149,0)
 QUIT
"RTN","XOBVTCP",150,0)
 ;
"RTN","XOBVTCP",151,0)
CLEARLOG ; -- clear log of non-active listeners
"RTN","XOBVTCP",152,0)
 NEW DIK,DA,Y,XOBI,XOB0,XOBPORT
"RTN","XOBVTCP",153,0)
 ;
"RTN","XOBVTCP",154,0)
 SET XOBI=0
"RTN","XOBVTCP",155,0)
 FOR  SET XOBI=$ORDER(^XOB(18.04,XOBI)) QUIT:'XOBI  DO
"RTN","XOBVTCP",156,0)
 . SET XOB0=$GET(^XOB(18.04,XOBI,0))
"RTN","XOBVTCP",157,0)
 . SET XOBPORT=+$PIECE(XOB0,U,2)
"RTN","XOBVTCP",158,0)
 . ; -- make sure listener is not running
"RTN","XOBVTCP",159,0)
 . IF $$LOCK(XOBPORT) DO
"RTN","XOBVTCP",160,0)
 . . SET DIK="^XOB(18.04,",DA=XOBI DO ^DIK
"RTN","XOBVTCP",161,0)
 . . DO UNLOCK(XOBPORT)
"RTN","XOBVTCP",162,0)
 ;
"RTN","XOBVTCP",163,0)
 QUIT
"RTN","XOBVTCP",164,0)
 ;
"RTN","XOBVTCP",165,0)
STARTCFG(XOBCFG) ; -- start a configurations listeners
"RTN","XOBVTCP",166,0)
 NEW CFG0,LSTR,LSTR0,XOBPORT,STARTUP,XOBOK
"RTN","XOBVTCP",167,0)
 SET CFG0=$GET(^XOB(18.03,XOBCFG,0))
"RTN","XOBVTCP",168,0)
 ;
"RTN","XOBVTCP",169,0)
 ; -- quit if no configuration
"RTN","XOBVTCP",170,0)
 IF CFG0="" GOTO CFGQ
"RTN","XOBVTCP",171,0)
 ;
"RTN","XOBVTCP",172,0)
 ; -- quit if not Cache...for now!
"RTN","XOBVTCP",173,0)
 IF $$GETOS()'["OpenM" GOTO CFGQ
"RTN","XOBVTCP",174,0)
 ;
"RTN","XOBVTCP",175,0)
 SET LSTR=0
"RTN","XOBVTCP",176,0)
 FOR  SET LSTR=$ORDER(^XOB(18.03,XOBCFG,"PORTS",LSTR)) QUIT:'LSTR  DO
"RTN","XOBVTCP",177,0)
 . SET LSTR0=$GET(^XOB(18.03,XOBCFG,"PORTS",LSTR,0))
"RTN","XOBVTCP",178,0)
 . SET XOBPORT=+$PIECE(LSTR0,U,1)
"RTN","XOBVTCP",179,0)
 . SET STARTUP=$PIECE(LSTR0,U,2)
"RTN","XOBVTCP",180,0)
 . ;
"RTN","XOBVTCP",181,0)
 . ; -- if ok to start, port # defined and not already started
"RTN","XOBVTCP",182,0)
 . IF XOBPORT,STARTUP,$$LOCK^XOBVTCP(XOBPORT) DO
"RTN","XOBVTCP",183,0)
 . . DO UNLOCK(XOBPORT)
"RTN","XOBVTCP",184,0)
 . . DO UPDATE^XOBVTCP(XOBPORT,1,XOBCFG)
"RTN","XOBVTCP",185,0)
 . . SET XOBOK=$$START(XOBPORT,XOBCFG)
"RTN","XOBVTCP",186,0)
 . . IF 'XOBOK DO UPDATE(XOBPORT,5,XOBCFG)
"RTN","XOBVTCP",187,0)
 ;
"RTN","XOBVTCP",188,0)
CFGQ ;
"RTN","XOBVTCP",189,0)
 QUIT
"RTN","XOBVTCP",190,0)
 ;
"RTN","XOBVTCP",191,0)
LOCK(XOBPORT) ;-- Lock port
"RTN","XOBVTCP",192,0)
 ;
"RTN","XOBVTCP",193,0)
 ;  Used to prevent another process from attempting to start the Listener
"RTN","XOBVTCP",194,0)
 ;  when it is already running.
"RTN","XOBVTCP",195,0)
 ;
"RTN","XOBVTCP",196,0)
 ;    Input:
"RTN","XOBVTCP",197,0)
 ;      XOBPORT - Port #
"RTN","XOBVTCP",198,0)
 ;
"RTN","XOBVTCP",199,0)
 ;   Output:
"RTN","XOBVTCP",200,0)
 ;      Function Value - Returns 1 if lock was successful, 0 otherwise
"RTN","XOBVTCP",201,0)
 ;
"RTN","XOBVTCP",202,0)
 QUIT $$ACTION("LOCK",XOBPORT)
"RTN","XOBVTCP",203,0)
 ;
"RTN","XOBVTCP",204,0)
 ;
"RTN","XOBVTCP",205,0)
UNLOCK(XOBPORT) ;-- Unlock port
"RTN","XOBVTCP",206,0)
 ;
"RTN","XOBVTCP",207,0)
 ;  Used to release a lock created by $$LOCK.
"RTN","XOBVTCP",208,0)
 ;
"RTN","XOBVTCP",209,0)
 ;    Input:
"RTN","XOBVTCP",210,0)
 ;      XOBPORT - Port #
"RTN","XOBVTCP",211,0)
 ;
"RTN","XOBVTCP",212,0)
 ;   Output:
"RTN","XOBVTCP",213,0)
 ;      None
"RTN","XOBVTCP",214,0)
 ;
"RTN","XOBVTCP",215,0)
 NEW X
"RTN","XOBVTCP",216,0)
 SET X=$$ACTION("UNLOCK",XOBPORT)
"RTN","XOBVTCP",217,0)
 QUIT
"RTN","XOBVTCP",218,0)
 ;
"RTN","XOBVTCP",219,0)
ACTION(ACTION,XOBPORT) ; -- do lock action
"RTN","XOBVTCP",220,0)
 NEW ENV,VOL,UCI,BOX
"RTN","XOBVTCP",221,0)
 ;
"RTN","XOBVTCP",222,0)
 SET XOBPORT=+$GET(XOBPORT)
"RTN","XOBVTCP",223,0)
 ;
"RTN","XOBVTCP",224,0)
 SET ENV=$$GETENV()
"RTN","XOBVTCP",225,0)
 SET VOL=$PIECE(ENV,U,2)
"RTN","XOBVTCP",226,0)
 SET UCI=$PIECE(ENV,U)
"RTN","XOBVTCP",227,0)
 SET BOX=$PIECE(ENV,U,4)
"RTN","XOBVTCP",228,0)
 ;
"RTN","XOBVTCP",229,0)
 IF ACTION="LOCK",XOBPORT LOCK +^XOB(18.01,"VistALink Listener",VOL,UCI,BOX,XOBPORT):1 QUIT $TEST
"RTN","XOBVTCP",230,0)
 IF ACTION="UNLOCK",XOBPORT LOCK -^XOB(18.01,"VistALink Listener",VOL,UCI,BOX,XOBPORT) QUIT 1
"RTN","XOBVTCP",231,0)
 QUIT 0
"RTN","XOBVTCP",232,0)
 ;
"RTN","XOBVTCP",233,0)
 ;
"RTN","XOBVTCP",234,0)
UPDATE(XOBPORT,XOBSTAT,XOBCFG) ; -- update VISTALINK LISTENER STARTUP LOG for listener
"RTN","XOBVTCP",235,0)
 NEW DIC,Y,X,XOBBOX
"RTN","XOBVTCP",236,0)
 SET XOBBOX=$$GETBOXN()
"RTN","XOBVTCP",237,0)
 ;
"RTN","XOBVTCP",238,0)
 ; -- set up lookup call
"RTN","XOBVTCP",239,0)
 SET DIC="^XOB(18.04,"
"RTN","XOBVTCP",240,0)
 SET DIC(0)="MLX"
"RTN","XOBVTCP",241,0)
 SET DIC("DR")=".02////"_XOBPORT
"RTN","XOBVTCP",242,0)
 SET DIC("S")="IF $P(^(0),U,2)="_XOBPORT
"RTN","XOBVTCP",243,0)
 SET X=XOBBOX
"RTN","XOBVTCP",244,0)
 ;
"RTN","XOBVTCP",245,0)
 DO ^DIC
"RTN","XOBVTCP",246,0)
 ; -- quit if lookup failed
"RTN","XOBVTCP",247,0)
 IF +Y>0 DO UPDLOG(+Y,XOBPORT,XOBSTAT,$GET(XOBCFG))
"RTN","XOBVTCP",248,0)
 QUIT
"RTN","XOBVTCP",249,0)
 ;
"RTN","XOBVTCP",250,0)
UPDLOG(XOBDA,XOBPORT,XOBSTAT,XOBCFG) ; -- do edit
"RTN","XOBVTCP",251,0)
 NEW DA,DIE,DR,Y,X
"RTN","XOBVTCP",252,0)
 ;
"RTN","XOBVTCP",253,0)
 LOCK +^XOB(18.04,XOBDA,0)
"RTN","XOBVTCP",254,0)
 ; -- set basic fields
"RTN","XOBVTCP",255,0)
 SET DA=XOBDA
"RTN","XOBVTCP",256,0)
 SET DIE="^XOB(18.04,"
"RTN","XOBVTCP",257,0)
 SET DR=".02////"_XOBPORT_";.03////"_XOBSTAT_";.05////^S X=$$NOW^XLFDT"
"RTN","XOBVTCP",258,0)
 ; -- set config if defined, otherwise delete
"RTN","XOBVTCP",259,0)
 SET DR=DR_";.06////"_$SELECT($GET(XOBCFG)]"":XOBCFG,1:"@")
"RTN","XOBVTCP",260,0)
 ; -- set user if defined, otherwise delete
"RTN","XOBVTCP",261,0)
 SET DR=DR_";.04////"_$SELECT($GET(DUZ)]"":DUZ,1:"@")
"RTN","XOBVTCP",262,0)
 ;
"RTN","XOBVTCP",263,0)
 DO ^DIE
"RTN","XOBVTCP",264,0)
 LOCK -^XOB(18.04,XOBDA,0)
"RTN","XOBVTCP",265,0)
 ;
"RTN","XOBVTCP",266,0)
 QUIT
"RTN","XOBVTCP",267,0)
 ;
"RTN","XOBVTCP",268,0)
GETENV() ; -- get environment variable
"RTN","XOBVTCP",269,0)
 ;-- Get environment of current system i.e. Y=UCI^VOL/DIR^NODE^BOX LOOKUP
"RTN","XOBVTCP",270,0)
 NEW Y
"RTN","XOBVTCP",271,0)
 DO GETENV^%ZOSV
"RTN","XOBVTCP",272,0)
 QUIT Y
"RTN","XOBVTCP",273,0)
 ;
"RTN","XOBVTCP",274,0)
GETOS() ;-- Get operating system
"RTN","XOBVTCP",275,0)
 ;
"RTN","XOBVTCP",276,0)
 ;  This function will determine which operating system is being used.
"RTN","XOBVTCP",277,0)
 ;
"RTN","XOBVTCP",278,0)
 ;   Input:
"RTN","XOBVTCP",279,0)
 ;     None
"RTN","XOBVTCP",280,0)
 ;
"RTN","XOBVTCP",281,0)
 ;  Output:
"RTN","XOBVTCP",282,0)
 ;     Operating system value i.e. OpenM-NT for OpenM.
"RTN","XOBVTCP",283,0)
 ;
"RTN","XOBVTCP",284,0)
 ;-- Get operating system
"RTN","XOBVTCP",285,0)
 QUIT $PIECE($GET(^%ZOSF("OS")),"^")
"RTN","XOBVTCP",286,0)
 ;
"RTN","XOBVTCP",287,0)
 ;
"RTN","XOBVTCP",288,0)
GETBOX() ; -- get box ien
"RTN","XOBVTCP",289,0)
 ;
"RTN","XOBVTCP",290,0)
 QUIT $$FIND1^DIC(14.7,"","BX",$PIECE($$GETENV(),U,4),"","","")
"RTN","XOBVTCP",291,0)
 ;
"RTN","XOBVTCP",292,0)
GETBOXN() ; -- get box name
"RTN","XOBVTCP",293,0)
 ;
"RTN","XOBVTCP",294,0)
 QUIT $PIECE($$GETENV(),U,4)
"RTN","XOBVTCP",295,0)
 ;
"RTN","XOBVTCP",296,0)
GETCFG() ; -- get config ien for current BOX-VOL pair
"RTN","XOBVTCP",297,0)
 QUIT +$PIECE($GET(^XOB(18.01,1,"CONFIG",+$ORDER(^XOB(18.01,1,"CONFIG","B",+$$GETBOX(),"")),0)),U,2)
"RTN","XOBVTCP",298,0)
 ;
"RTN","XOBVTCPL")
0^18^B7619114
"RTN","XOBVTCPL",1,0)
XOBVTCPL ;; mjk/alb - VistALink TCP/IP Listener (Cache NT) ; 07/27/2002  13:00
"RTN","XOBVTCPL",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVTCPL",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVTCPL",4,0)
 QUIT
"RTN","XOBVTCPL",5,0)
 ;
"RTN","XOBVTCPL",6,0)
 ; -- Important: Should always be JOBed using START^XOBVTCP
"RTN","XOBVTCPL",7,0)
LISTENER(XOBPORT,XOBCFG) ; -- Start Listener
"RTN","XOBVTCPL",8,0)
 ;
"RTN","XOBVTCPL",9,0)
 ; -- quit if not Cache for NT
"RTN","XOBVTCPL",10,0)
 IF $$GETOS^XOBVTCP()'="OpenM-NT" QUIT
"RTN","XOBVTCPL",11,0)
 ;
"RTN","XOBVTCPL",12,0)
 NEW $ETRAP,$ESTACK SET $ETRAP="D ^%ZTER HALT"
"RTN","XOBVTCPL",13,0)
 ;
"RTN","XOBVTCPL",14,0)
 NEW X,POP,XOBDA,U,DTIME,DT,XOBIO
"RTN","XOBVTCPL",15,0)
 SET U="^",DTIME=900,DT=$$DT^XLFDT()
"RTN","XOBVTCPL",16,0)
 IF $GET(DUZ)="" NEW DUZ SET DUZ=.5,DUZ(0)="@"
"RTN","XOBVTCPL",17,0)
 ;
"RTN","XOBVTCPL",18,0)
 ; -- only start if not already started
"RTN","XOBVTCPL",19,0)
 IF $$LOCK^XOBVTCP(XOBPORT) DO
"RTN","XOBVTCPL",20,0)
 . IF $$OPENM(.XOBIO,XOBPORT) DO
"RTN","XOBVTCPL",21,0)
 . . ; -- listener started and now stopping
"RTN","XOBVTCPL",22,0)
 . . SET IO=XOBIO
"RTN","XOBVTCPL",23,0)
 . . DO CLOSE^%ZISTCP
"RTN","XOBVTCPL",24,0)
 . . ; -- update status to 'stopped'
"RTN","XOBVTCPL",25,0)
 . . DO UPDATE^XOBVTCP(XOBPORT,4,$GET(XOBCFG))
"RTN","XOBVTCPL",26,0)
 . ELSE  DO
"RTN","XOBVTCPL",27,0)
 . . ; -- listener failed to start
"RTN","XOBVTCPL",28,0)
 . . ; -- update status to 'failed'
"RTN","XOBVTCPL",29,0)
 . . DO UPDATE^XOBVTCP(XOBPORT,5,$GET(XOBCFG))
"RTN","XOBVTCPL",30,0)
 . ;
"RTN","XOBVTCPL",31,0)
 . DO UNLOCK^XOBVTCP(XOBPORT)
"RTN","XOBVTCPL",32,0)
 QUIT
"RTN","XOBVTCPL",33,0)
 ;
"RTN","XOBVTCPL",34,0)
 ; -- open/start listener port
"RTN","XOBVTCPL",35,0)
OPENM(XOBIO,XOBPORT) ;
"RTN","XOBVTCPL",36,0)
 NEW XOBBOX,%ZA
"RTN","XOBVTCPL",37,0)
 SET XOBBOX=+$$GETBOX^XOBVTCP()
"RTN","XOBVTCPL",38,0)
 SET XOBIO="|TCP|"_XOBPORT
"RTN","XOBVTCPL",39,0)
 OPEN XOBIO:(:XOBPORT:"AT"):30
"RTN","XOBVTCPL",40,0)
 ;
"RTN","XOBVTCPL",41,0)
 ; -- if listener port could not be opened then gracefully quit
"RTN","XOBVTCPL",42,0)
 ;    (other namespace using port maybe?)
"RTN","XOBVTCPL",43,0)
 IF '$TEST QUIT 0
"RTN","XOBVTCPL",44,0)
 ;
"RTN","XOBVTCPL",45,0)
 ; -- indicate listener is 'running'
"RTN","XOBVTCPL",46,0)
 DO UPDATE^XOBVTCP(XOBPORT,2,$GET(XOBCFG))
"RTN","XOBVTCPL",47,0)
 ; -- read & spawn loop
"RTN","XOBVTCPL",48,0)
 FOR  DO  QUIT:$$EXIT(XOBBOX,XOBPORT)
"RTN","XOBVTCPL",49,0)
 . USE XOBIO
"RTN","XOBVTCPL",50,0)
 . READ *X:60 IF '$TEST QUIT
"RTN","XOBVTCPL",51,0)
 . JOB CHILDNT^XOBVTCPL():(:4:XOBIO:XOBIO):10 SET %ZA=$ZA
"RTN","XOBVTCPL",52,0)
 . IF %ZA\8196#2=1 WRITE *-2 ;Job failed to clear bit
"RTN","XOBVTCPL",53,0)
 QUIT 1
"RTN","XOBVTCPL",54,0)
 ;
"RTN","XOBVTCPL",55,0)
CHILDNT() ;Child process for OpenM
"RTN","XOBVTCPL",56,0)
 NEW XOBEC
"RTN","XOBVTCPL",57,0)
 SET $ETRAP="D ^%ZTER L  HALT"
"RTN","XOBVTCPL",58,0)
 SET IO=$PRINCIPAL ;Reset IO to be $P
"RTN","XOBVTCPL",59,0)
 USE IO:(::"-M") ;Packet mode like DSM
"RTN","XOBVTCPL",60,0)
 ; -- do quit to save a stack level
"RTN","XOBVTCPL",61,0)
 SET XOBEC=$$NEWOK()
"RTN","XOBVTCPL",62,0)
 IF XOBEC DO LOGINERR(XOBEC,IO)
"RTN","XOBVTCPL",63,0)
 IF 'XOBEC DO VAR,SPAWN^XOBVLL
"RTN","XOBVTCPL",64,0)
 QUIT
"RTN","XOBVTCPL",65,0)
 ;
"RTN","XOBVTCPL",66,0)
VAR ;Setup IO variables
"RTN","XOBVTCPL",67,0)
 SET IO(0)=IO,IO(1,IO)="",POP=0
"RTN","XOBVTCPL",68,0)
 SET IOT="TCP",IOF="#",IOST="P-TCP",IOST(0)=0
"RTN","XOBVTCPL",69,0)
 QUIT
"RTN","XOBVTCPL",70,0)
 ;
"RTN","XOBVTCPL",71,0)
NEWOK() ;Is it OK to start a new process
"RTN","XOBVTCPL",72,0)
 NEW XQVOL,XUCI,XUENV,XUVOL,X,Y,XOBCODE
"RTN","XOBVTCPL",73,0)
 DO XUVOL^XUS
"RTN","XOBVTCPL",74,0)
 IF $$INHIB1^XUSRB() QUIT 181004
"RTN","XOBVTCPL",75,0)
 IF $$INHIB2^XUSRB() QUIT 181003
"RTN","XOBVTCPL",76,0)
 QUIT 0
"RTN","XOBVTCPL",77,0)
 ;
"RTN","XOBVTCPL",78,0)
 ; -- process error
"RTN","XOBVTCPL",79,0)
LOGINERR(XOBEC,XOBPORT) ;
"RTN","XOBVTCPL",80,0)
 DO ERROR^XOBVLL(XOBEC,$$EZBLD^DIALOG(XOBEC),XOBPORT)
"RTN","XOBVTCPL",81,0)
 ;
"RTN","XOBVTCPL",82,0)
 ; -- give client time to process stream
"RTN","XOBVTCPL",83,0)
 HANG 2
"RTN","XOBVTCPL",84,0)
 QUIT
"RTN","XOBVTCPL",85,0)
 ;
"RTN","XOBVTCPL",86,0)
EXIT(XOBBOX,XOBPORT) ;
"RTN","XOBVTCPL",87,0)
 ; -- is status 'stopping'
"RTN","XOBVTCPL",88,0)
 QUIT ($PIECE($GET(^XOB(18.04,+$$GETLOGID(XOBBOX,XOBPORT),0)),U,3)=3)
"RTN","XOBVTCPL",89,0)
 ;
"RTN","XOBVTCPL",90,0)
GETLOGID(XOBBOX,XOBPORT) ;
"RTN","XOBVTCPL",91,0)
 QUIT +$ORDER(^XOB(18.04,"C",XOBBOX,XOBPORT,""))
"RTN","XOBVTCPL",92,0)
 ;
"RTN","XOBVTLS")
0^20^B4033073
"RTN","XOBVTLS",1,0)
XOBVTLS ;; mjk/alb - VistALink Programmer Mode Support Tools ; 07/27/2002  13:00
"RTN","XOBVTLS",2,0)
 ;;1.6;VistALink;;May 08, 2009;Build 15
"RTN","XOBVTLS",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBVTLS",4,0)
 QUIT
"RTN","XOBVTLS",5,0)
 ;
"RTN","XOBVTLS",6,0)
DEBUG ; -- entry point for debugging
"RTN","XOBVTLS",7,0)
 NEW XOBDSKT
"RTN","XOBVTLS",8,0)
 ;
"RTN","XOBVTLS",9,0)
 WRITE !,"Before running this entry point set your debugger"
"RTN","XOBVTLS",10,0)
 WRITE !,"to stop at the place you want to debug."
"RTN","XOBVTLS",11,0)
 WRITE !!,"Some possible spots to use:"
"RTN","XOBVTLS",12,0)
 WRITE !,"     o  SERV+1^XOBVTLS  => where debugging starts"
"RTN","XOBVTLS",13,0)
 WRITE !,"     o  SPAWN+1^XOBVLL  => where VistALink spawn starts"
"RTN","XOBVTLS",14,0)
 WRITE !,"     o  or location of your choice.",!
"RTN","XOBVTLS",15,0)
 ;
"RTN","XOBVTLS",16,0)
 WRITE !,"IP Socket to Listen on ('^' to quit): "
"RTN","XOBVTLS",17,0)
 READ XOBDSKT:300
"RTN","XOBVTLS",18,0)
 ;
"RTN","XOBVTLS",19,0)
 ; -- quit if read timed out or up-arrow or number not entered
"RTN","XOBVTLS",20,0)
 IF '$TEST!(XOBDSKT["^")!(+XOBDSKT=0) DO  GOTO DEBUGQ
"RTN","XOBVTLS",21,0)
 . WRITE !,"Socket number not entered...debug listener not started.",!
"RTN","XOBVTLS",22,0)
 ;
"RTN","XOBVTLS",23,0)
 WRITE !!,"================================================"
"RTN","XOBVTLS",24,0)
 WRITE !,"Starting listener at port ",XOBDSKT," [Job: ",$JOB,"]..."
"RTN","XOBVTLS",25,0)
 ;
"RTN","XOBVTLS",26,0)
 ; -- use %ZISTCP to do a single server
"RTN","XOBVTLS",27,0)
 DO LISTEN^%ZISTCP(XOBDSKT,"SERV^XOBVTLS")
"RTN","XOBVTLS",28,0)
 ;
"RTN","XOBVTLS",29,0)
 USE $PRINCIPAL
"RTN","XOBVTLS",30,0)
 WRITE !!,"Listener stopped on port ",XOBDSKT,"."
"RTN","XOBVTLS",31,0)
 WRITE !,"Done."
"RTN","XOBVTLS",32,0)
 WRITE !,"================================================"
"RTN","XOBVTLS",33,0)
DEBUGQ QUIT
"RTN","XOBVTLS",34,0)
 ;
"RTN","XOBVTLS",35,0)
SERV ; -- service debug session
"RTN","XOBVTLS",36,0)
 NEW XOBDEBUG,XOBEC
"RTN","XOBVTLS",37,0)
 ;
"RTN","XOBVTLS",38,0)
 ; -- set a debug mode flag for reference
"RTN","XOBVTLS",39,0)
 SET XOBDEBUG=1
"RTN","XOBVTLS",40,0)
 ;
"RTN","XOBVTLS",41,0)
 USE $PRINCIPAL WRITE !!,"Debug mode started...",!
"RTN","XOBVTLS",42,0)
 USE IO
"RTN","XOBVTLS",43,0)
 ;
"RTN","XOBVTLS",44,0)
 ; -- do basic checks and then real spawn
"RTN","XOBVTLS",45,0)
 SET XOBEC=$$NEWOK^XOBVTCPL()
"RTN","XOBVTLS",46,0)
 IF XOBEC DO LOGINERR^XOBVTCPL(XOBEC,IO)
"RTN","XOBVTLS",47,0)
 IF 'XOBEC DO SPAWN^XOBVLL
"RTN","XOBVTLS",48,0)
 ;
"RTN","XOBVTLS",49,0)
 ; -- cause the listener to stop
"RTN","XOBVTLS",50,0)
 SET IO("C")=1
"RTN","XOBVTLS",51,0)
 QUIT
"RTN","XOBVTLS",52,0)
 ;
"SEC","^DIC",18.03,18.03,0,"AUDIT")
@
"SEC","^DIC",18.03,18.03,0,"DD")
@
"SEC","^DIC",18.03,18.03,0,"DEL")
@
"SEC","^DIC",18.03,18.03,0,"LAYGO")
@
"SEC","^DIC",18.03,18.03,0,"RD")
@
"SEC","^DIC",18.03,18.03,0,"WR")
@
"SEC","^DIC",18.04,18.04,0,"AUDIT")
@
"SEC","^DIC",18.04,18.04,0,"DD")
@
"SEC","^DIC",18.04,18.04,0,"DEL")
@
"SEC","^DIC",18.04,18.04,0,"LAYGO")
@
"SEC","^DIC",18.04,18.04,0,"RD")
@
"SEC","^DIC",18.04,18.04,0,"WR")
@
"SEC","^DIC",18.05,18.05,0,"AUDIT")
@
"SEC","^DIC",18.05,18.05,0,"DD")
@
"SEC","^DIC",18.05,18.05,0,"DEL")
@
"SEC","^DIC",18.05,18.05,0,"LAYGO")
@
"SEC","^DIC",18.05,18.05,0,"RD")
@
"SEC","^DIC",18.05,18.05,0,"WR")
@
"VER")
8.0^22.0
"^DD",18.03,18.03,0)
FIELD^^100^2
"^DD",18.03,18.03,0,"DDA")
N
"^DD",18.03,18.03,0,"DT")
3030310
"^DD",18.03,18.03,0,"IX","B",18.03,.01)

"^DD",18.03,18.03,0,"NM","VISTALINK LISTENER CONFIGURATION")

"^DD",18.03,18.03,0,"PT",18.012,.02)

"^DD",18.03,18.03,0,"PT",18.04,.06)

"^DD",18.03,18.03,0,"VRPK")
XOBV
"^DD",18.03,18.03,.01,0)
NAME^RF^^0;1^K:$L(X)>30!($L(X)<3) X
"^DD",18.03,18.03,.01,1,0)
^.1
"^DD",18.03,18.03,.01,1,1,0)
18.03^B
"^DD",18.03,18.03,.01,1,1,1)
S ^XOB(18.03,"B",$E(X,1,30),DA)=""
"^DD",18.03,18.03,.01,1,1,2)
K ^XOB(18.03,"B",$E(X,1,30),DA)
"^DD",18.03,18.03,.01,3)
Answer must be 3-30 characters in length
"^DD",18.03,18.03,.01,21,0)
^^3^3^3030410^
"^DD",18.03,18.03,.01,21,1,0)
This field contains the name of the default VistALink configuration used 
"^DD",18.03,18.03,.01,21,2,0)
with the associated BOX-VOLUME PAIR specified in the FOUNDATIONS SITE
"^DD",18.03,18.03,.01,21,3,0)
PARAMETERS file (#18.01).
"^DD",18.03,18.03,.01,"DT")
3030410
"^DD",18.03,18.03,100,0)
LISTENER PORTS^18.031^^PORTS;0
"^DD",18.03,18.03,100,21,0)
^^6^6^3030410^
"^DD",18.03,18.03,100,21,1,0)
This multiple field contains Listener port information associated with a 
"^DD",18.03,18.03,100,21,2,0)
specific VistALink configuration entry.
"^DD",18.03,18.03,100,21,3,0)
 
"^DD",18.03,18.03,100,21,4,0)
Each Listener port entry holds the port number to be used by the VistALink
"^DD",18.03,18.03,100,21,5,0)
Listener along with an indicator which will specify whether the Listener
"^DD",18.03,18.03,100,21,6,0)
should be automatically tasked to start on system startup.
"^DD",18.03,18.031,0)
LISTENER PORTS SUB-FIELD^^.02^2
"^DD",18.03,18.031,0,"DT")
3030310
"^DD",18.03,18.031,0,"IX","B",18.031,.01)

"^DD",18.03,18.031,0,"NM","LISTENER PORTS")

"^DD",18.03,18.031,0,"UP")
18.03
"^DD",18.03,18.031,.01,0)
PORT^MNJ5,0^^0;1^K:+X'=X!(X>65635)!(X<5000)!(X?.E1"."1N.N) X
"^DD",18.03,18.031,.01,1,0)
^.1
"^DD",18.03,18.031,.01,1,1,0)
18.031^B
"^DD",18.03,18.031,.01,1,1,1)
S ^XOB(18.03,DA(1),"PORTS","B",$E(X,1,30),DA)=""
"^DD",18.03,18.031,.01,1,1,2)
K ^XOB(18.03,DA(1),"PORTS","B",$E(X,1,30),DA)
"^DD",18.03,18.031,.01,3)
Type a Number between 5000 and 65635, 0 Decimal Digits
"^DD",18.03,18.031,.01,21,0)
^.001^2^2^3030409^^
"^DD",18.03,18.031,.01,21,1,0)
This field indicates the port number that will be used by the VistALink
"^DD",18.03,18.031,.01,21,2,0)
Listener configuration.
"^DD",18.03,18.031,.01,"DT")
3030409
"^DD",18.03,18.031,.02,0)
STARTUP^S^0:NO;1:YES;^0;2^Q
"^DD",18.03,18.031,.02,3)
Answer YES if Listener should be started on system startup, NO otherwise
"^DD",18.03,18.031,.02,21,0)
^^2^2^3030410^
"^DD",18.03,18.031,.02,21,1,0)
This field indicates whether the Listener should be automatically tasked 
"^DD",18.03,18.031,.02,21,2,0)
to start on system startup.
"^DD",18.03,18.031,.02,"DT")
3030410
"^DD",18.04,18.04,0)
FIELD^^.06^6
"^DD",18.04,18.04,0,"DDA")
N
"^DD",18.04,18.04,0,"DT")
3031021
"^DD",18.04,18.04,0,"ID",.02)
W "   ",$P(^(0),U,2)
"^DD",18.04,18.04,0,"ID",.03)
W "   ",@("$P($P($C(59)_$S($D(^DD(18.04,.03,0)):$P(^(0),U,3),1:0)_$E("_DIC_"Y,0),0),$C(59)_$P(^(0),U,3)_"":"",2),$C(59),1)")
"^DD",18.04,18.04,0,"IX","B",18.04,.01)

"^DD",18.04,18.04,0,"NM","VISTALINK LISTENER STARTUP LOG")

"^DD",18.04,18.04,0,"VRPK")
XOBV
"^DD",18.04,18.04,.01,0)
BOX-VOLUME PAIR^RP14.7'^%ZIS(14.7,^0;1^Q
"^DD",18.04,18.04,.01,1,0)
^.1
"^DD",18.04,18.04,.01,1,1,0)
18.04^B
"^DD",18.04,18.04,.01,1,1,1)
S ^XOB(18.04,"B",$E(X,1,30),DA)=""
"^DD",18.04,18.04,.01,1,1,2)
K ^XOB(18.04,"B",$E(X,1,30),DA)
"^DD",18.04,18.04,.01,3)
Enter the BOX-VOLUME pair name
"^DD",18.04,18.04,.01,21,0)
^^1^1^3030410^^
"^DD",18.04,18.04,.01,21,1,0)
This field indicates the BOX-VOLUME pair for the entry.
"^DD",18.04,18.04,.01,"DT")
3030410
"^DD",18.04,18.04,.02,0)
PORT^NJ5,0^^0;2^K:+X'=X!(X>65635)!(X<5000)!(X?.E1"."1N.N) X
"^DD",18.04,18.04,.02,3)
Type a Number between 5000 and 65635, 0 Decimal Digits
"^DD",18.04,18.04,.02,21,0)
^^1^1^3030409^
"^DD",18.04,18.04,.02,21,1,0)
This field indicates the port number used by the VistALink Listener entry.
"^DD",18.04,18.04,.02,"DT")
3030409
"^DD",18.04,18.04,.03,0)
STATUS^S^1:STARTING;2:RUNNING;3:STOPPING;4:STOPPED;5:FAILED;^0;3^Q
"^DD",18.04,18.04,.03,3)
Current status of the VistALink Listener
"^DD",18.04,18.04,.03,21,0)
^^1^1^3030410^^^
"^DD",18.04,18.04,.03,21,1,0)
This field indicates the current status of the VistALink Listener entry.
"^DD",18.04,18.04,.03,"DT")
3031021
"^DD",18.04,18.04,.04,0)
USER RESPONSIBLE^P200'^VA(200,^0;4^Q
"^DD",18.04,18.04,.04,1,0)
^.1^^0
"^DD",18.04,18.04,.04,3)
User responsible for the current status of the VistALink Listener
"^DD",18.04,18.04,.04,21,0)
^^3^3^3030409^
"^DD",18.04,18.04,.04,21,1,0)
This field indicates the user responsible for the current status of
"^DD",18.04,18.04,.04,21,2,0)
the VistALink Listener entry. This information is only entered if
"^DD",18.04,18.04,.04,21,3,0)
available at the time of the status update.
"^DD",18.04,18.04,.04,"DT")
3030410
"^DD",18.04,18.04,.05,0)
DATE/TIME OF LAST STATUS^D^^0;5^S %DT="ESTXR" D ^%DT S X=Y K:Y<1 X
"^DD",18.04,18.04,.05,3)
Date/Time of the current status of the VistALink Listener
"^DD",18.04,18.04,.05,21,0)
^^2^2^3030410^^^
"^DD",18.04,18.04,.05,21,1,0)
This field indicates the date/time that the current status of the
"^DD",18.04,18.04,.05,21,2,0)
VistALink Listener entry occurred.
"^DD",18.04,18.04,.05,"DT")
3030410
"^DD",18.04,18.04,.06,0)
ASSOCIATED CONFIGURATION^P18.03'^XOB(18.03,^0;6^Q
"^DD",18.04,18.04,.06,3)
Configuration associated with this log file entry
"^DD",18.04,18.04,.06,21,0)
^^2^2^3030416^
"^DD",18.04,18.04,.06,21,1,0)
This field indicates the VistALink Listener configuration (if one 
"^DD",18.04,18.04,.06,21,2,0)
exists) that is associated with the Listener log file entry.
"^DD",18.04,18.04,.06,"DT")
3030416
"^DD",18.05,18.05,0)
FIELD^^.07^7
"^DD",18.05,18.05,0,"DDA")
N
"^DD",18.05,18.05,0,"DT")
3030408
"^DD",18.05,18.05,0,"IX","AS",18.05,.06)

"^DD",18.05,18.05,0,"IX","B",18.05,.01)

"^DD",18.05,18.05,0,"IX","C",18.05,.02)

"^DD",18.05,18.05,0,"IX","D",18.05,.07)

"^DD",18.05,18.05,0,"NM","VISTALINK MESSAGE TYPE")

"^DD",18.05,18.05,0,"VRPK")
XOBV
"^DD",18.05,18.05,.01,0)
NAME^RF^^0;1^K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",18.05,18.05,.01,1,0)
^.1
"^DD",18.05,18.05,.01,1,1,0)
18.05^B
"^DD",18.05,18.05,.01,1,1,1)
S ^XOB(18.05,"B",$E(X,1,30),DA)=""
"^DD",18.05,18.05,.01,1,1,2)
K ^XOB(18.05,"B",$E(X,1,30),DA)
"^DD",18.05,18.05,.01,3)
Unique name must be 3-30 characters, not numeric or starting with punctuation
"^DD",18.05,18.05,.01,21,0)
^^5^5^3030411^
"^DD",18.05,18.05,.01,21,1,0)
This field contains a unique and keyed human readable name for the message
"^DD",18.05,18.05,.01,21,2,0)
type.
"^DD",18.05,18.05,.01,21,3,0)
 
"^DD",18.05,18.05,.01,21,4,0)
It is also recommended that the name be prefixed with namespace
"^DD",18.05,18.05,.01,21,5,0)
characters.
"^DD",18.05,18.05,.01,"DT")
3030411
"^DD",18.05,18.05,.02,0)
MESSAGE TYPE^F^^0;2^K:$L(X)>80!($L(X)<3) X
"^DD",18.05,18.05,.02,1,0)
^.1^^0
"^DD",18.05,18.05,.02,1,1,0)
18.05^C^MUMPS
"^DD",18.05,18.05,.02,1,1,1)
S ^XOB(18.05,"C",$E(X,1,80),DA)=""
"^DD",18.05,18.05,.02,1,1,2)
K ^XOB(18.05,"C",$E(X,1,80),DA)
"^DD",18.05,18.05,.02,1,1,"DT")
3030316
"^DD",18.05,18.05,.02,3)
Answer must be 3-80 characters in length
"^DD",18.05,18.05,.02,21,0)
^^6^6^3030410^
"^DD",18.05,18.05,.02,21,1,0)
This field contains the name of a unique XML message type, e.g.
"^DD",18.05,18.05,.02,21,2,0)
gov.va.med.foundations.rpc.request.
"^DD",18.05,18.05,.02,21,3,0)
 
"^DD",18.05,18.05,.02,21,4,0)
This field is a keyed field and is used by the VistALink request manager
"^DD",18.05,18.05,.02,21,5,0)
during SAX parsing to look up the correct request handler for an incoming
"^DD",18.05,18.05,.02,21,6,0)
request.
"^DD",18.05,18.05,.02,"DT")
3030410
"^DD",18.05,18.05,.03,0)
CATEGORY^S^1:REQUEST;2:RESPONSE;9:OTHER;^0;3^Q
"^DD",18.05,18.05,.03,3)
Enter whether this is a request or response message type
"^DD",18.05,18.05,.03,21,0)
^^8^8^3030410^
"^DD",18.05,18.05,.03,21,1,0)
This field allows for the categorization of the message type.
"^DD",18.05,18.05,.03,21,2,0)
 
"^DD",18.05,18.05,.03,21,3,0)
The field is not currently used in business logic and exists to allow for 
"^DD",18.05,18.05,.03,21,4,0)
filtering and sorting during reporting.
"^DD",18.05,18.05,.03,21,5,0)
 
"^DD",18.05,18.05,.03,21,6,0)
Currently, there are only two categories: request and response.
"^DD",18.05,18.05,.03,21,7,0)
 
"^DD",18.05,18.05,.03,21,8,0)
'Other' is also available but is not used at this time.
"^DD",18.05,18.05,.03,"DT")
3030410
"^DD",18.05,18.05,.04,0)
REQUIRE AUTHENTICATION?^S^0:NO;1:YES;^0;4^Q
"^DD",18.05,18.05,.04,3)
Indicate whether this message requires a VistALink security authenticated partition to be processed
"^DD",18.05,18.05,.04,21,0)
^^10^10^3030410^
"^DD",18.05,18.05,.04,21,1,0)
This field indicates whether or not a request of the message type 
"^DD",18.05,18.05,.04,21,2,0)
requires the user to be authenticated by VistALink security before
"^DD",18.05,18.05,.04,21,3,0)
the request handler for the type can be executed.
"^DD",18.05,18.05,.04,21,4,0)
 
"^DD",18.05,18.05,.04,21,5,0)
System and security message types do not need authentication since they 
"^DD",18.05,18.05,.04,21,6,0)
involve processing at a higher level like heartbeat messages and 
"^DD",18.05,18.05,.04,21,7,0)
messages establishing authentication.
"^DD",18.05,18.05,.04,21,8,0)
 
"^DD",18.05,18.05,.04,21,9,0)
On the other hand, RPC-type messages would require authentication before 
"^DD",18.05,18.05,.04,21,10,0)
the RPC request handler is executed.
"^DD",18.05,18.05,.04,"DT")
3030410
"^DD",18.05,18.05,.05,0)
REQUEST HANDLER^F^^0;5^K:$L(X)>8!($L(X)<2) X
"^DD",18.05,18.05,.05,3)
Answer must be 2-8 characters in length and the name of a routine
"^DD",18.05,18.05,.05,21,0)
^^27^27^3030410^
"^DD",18.05,18.05,.05,21,1,0)
This field contains the name of the M routine that implements the request 
"^DD",18.05,18.05,.05,21,2,0)
handler interface methods (tags).
"^DD",18.05,18.05,.05,21,3,0)
 
"^DD",18.05,18.05,.05,21,4,0)
Currently, those methods are the following:
"^DD",18.05,18.05,.05,21,5,0)
 
"^DD",18.05,18.05,.05,21,6,0)
  CALLBACK(CB)           :: Logic that sets the SAX callbacks for the
"^DD",18.05,18.05,.05,21,7,0)
                            message type in CB parameter. These callbacks
"^DD",18.05,18.05,.05,21,8,0)
                            are executed during the SAX XML parsing.
"^DD",18.05,18.05,.05,21,9,0)
 
"^DD",18.05,18.05,.05,21,10,0)
                            This method is required.
"^DD",18.05,18.05,.05,21,11,0)
 
"^DD",18.05,18.05,.05,21,12,0)
  READER(XOBUF,XOBDATA)  :: Stream reader logic called when the incoming
"^DD",18.05,18.05,.05,21,13,0)
                            request is in proprietary format.
"^DD",18.05,18.05,.05,21,14,0)
 
"^DD",18.05,18.05,.05,21,15,0)
                            XOBUF   :: characters already read from stream
"^DD",18.05,18.05,.05,21,16,0)
 
"^DD",18.05,18.05,.05,21,17,0)
                            XOBDATA :: where to store parsed request 
"^DD",18.05,18.05,.05,21,18,0)
                                       information or reference to such
"^DD",18.05,18.05,.05,21,19,0)
                                       information.
"^DD",18.05,18.05,.05,21,20,0)
 
"^DD",18.05,18.05,.05,21,21,0)
                            This method is optional.
"^DD",18.05,18.05,.05,21,22,0)
 
"^DD",18.05,18.05,.05,21,23,0)
  REQHDLR(XOBDATA)       :: Logic called to process request information
"^DD",18.05,18.05,.05,21,24,0)
                            stored in XOBDATA after XML parsing or
"^DD",18.05,18.05,.05,21,25,0)
                            proprietary parsing has completed.
"^DD",18.05,18.05,.05,21,26,0)
 
"^DD",18.05,18.05,.05,21,27,0)
                            This method is required.
"^DD",18.05,18.05,.05,"DT")
3030410
"^DD",18.05,18.05,.06,0)
CACHE REQUEST HANDLER INFO^S^0:NO;1:YES;^0;6^Q
"^DD",18.05,18.05,.06,1,0)
^.1
"^DD",18.05,18.05,.06,1,1,0)
18.05^AS
"^DD",18.05,18.05,.06,1,1,1)
S ^XOB(18.05,"AS",$E(X,1,30),DA)=""
"^DD",18.05,18.05,.06,1,1,2)
K ^XOB(18.05,"AS",$E(X,1,30),DA)
"^DD",18.05,18.05,.06,1,1,"DT")
3030325
"^DD",18.05,18.05,.06,3)
Answer YES or NO to cache request handler information upon socket connection
"^DD",18.05,18.05,.06,21,0)
^^7^7^3030408^
"^DD",18.05,18.05,.06,21,1,0)
This field indicates whether runtime information for the message type 
"^DD",18.05,18.05,.06,21,2,0)
should be cached as part of the initial connection logic of the request 
"^DD",18.05,18.05,.06,21,3,0)
manager.
"^DD",18.05,18.05,.06,21,4,0)
 
"^DD",18.05,18.05,.06,21,5,0)
Caching -- storing in a local array -- only the information needed for 
"^DD",18.05,18.05,.06,21,6,0)
request handling can benefit performance for those message types that are 
"^DD",18.05,18.05,.06,21,7,0)
executed often, like RPC requests.
"^DD",18.05,18.05,.06,"DT")
3030410
"^DD",18.05,18.05,.07,0)
PROPRIETARY INDICATOR^FX^^0;7^K:$L(X)>20!($L(X)<3) X IF $DATA(^XOB(18.05,"D",X)) DO EN^DDIOL("Value is not unique") KILL X
"^DD",18.05,18.05,.07,1,0)
^.1
"^DD",18.05,18.05,.07,1,1,0)
18.05^D
"^DD",18.05,18.05,.07,1,1,1)
S ^XOB(18.05,"D",$E(X,1,30),DA)=""
"^DD",18.05,18.05,.07,1,1,2)
K ^XOB(18.05,"D",$E(X,1,30),DA)
"^DD",18.05,18.05,.07,1,1,"DT")
3030322
"^DD",18.05,18.05,.07,3)
Answer must be 3-20 characters in length and unique
"^DD",18.05,18.05,.07,21,0)
^^7^7^3030414^
"^DD",18.05,18.05,.07,21,1,0)
This unique valued field is used during the processing of the first
"^DD",18.05,18.05,.07,21,2,0)
read of a new request stream. If this proprietary indicator is present
"^DD",18.05,18.05,.07,21,3,0)
then the READER method of the request handler routine is called.
"^DD",18.05,18.05,.07,21,4,0)
 
"^DD",18.05,18.05,.07,21,5,0)
No SAX XML parsing is performed if this READER method is executed.
"^DD",18.05,18.05,.07,21,6,0)
 
"^DD",18.05,18.05,.07,21,7,0)
See also: REQUEST HANDLER field.
"^DD",18.05,18.05,.07,"DT")
3030410
"^DIC",18.03,18.03,0)
VISTALINK LISTENER CONFIGURATION^18.03
"^DIC",18.03,18.03,0,"GL")
^XOB(18.03,
"^DIC",18.03,18.03,"%",0)
^1.005^^0
"^DIC",18.03,18.03,"%D",0)
^^9^9^3030410^
"^DIC",18.03,18.03,"%D",1,0)
This file holds VistALink Listener configurations.  A configuration may 
"^DIC",18.03,18.03,"%D",2,0)
contain multiple Listener ports, and each Listener port may be configured 
"^DIC",18.03,18.03,"%D",3,0)
to start upon system startup.  Note: This only applies to Cache NT 
"^DIC",18.03,18.03,"%D",4,0)
systems.  VMS/DSM systems need to use the TCP/IP (UCX) utility to have
"^DIC",18.03,18.03,"%D",5,0)
Listeners automatically started on reboot.
"^DIC",18.03,18.03,"%D",6,0)
 
"^DIC",18.03,18.03,"%D",7,0)
This file is pointed to by the Foundations Site Parameters file (#18.01)
"^DIC",18.03,18.03,"%D",8,0)
and is used when obtaining the default Listener configuration for a 
"^DIC",18.03,18.03,"%D",9,0)
specified BOX-VOLUME pair.
"^DIC",18.03,"B","VISTALINK LISTENER CONFIGURATION",18.03)

"^DIC",18.04,18.04,0)
VISTALINK LISTENER STARTUP LOG^18.04
"^DIC",18.04,18.04,0,"GL")
^XOB(18.04,
"^DIC",18.04,18.04,"%",0)
^1.005^^
"^DIC",18.04,18.04,"%D",0)
^^19^19^3030414^
"^DIC",18.04,18.04,"%D",1,0)
This file contains informational status pertaining to the current state of
"^DIC",18.04,18.04,"%D",2,0)
VistALink Listeners for each BOX-VOLUME pair.  
"^DIC",18.04,18.04,"%D",3,0)
 
"^DIC",18.04,18.04,"%D",4,0)
Note: This file only applies to Cache NT systems and is not utilized for
"^DIC",18.04,18.04,"%D",5,0)
VAX/DSM systems. Those systems must use the TCP/IP (UCX) utility to start
"^DIC",18.04,18.04,"%D",6,0)
and stop VistALink listeners.
"^DIC",18.04,18.04,"%D",7,0)
 
"^DIC",18.04,18.04,"%D",8,0)
This log file is initially populated when one or more VistALink Listeners
"^DIC",18.04,18.04,"%D",9,0)
are started.  This will occur when either the Start VistaLink Listener
"^DIC",18.04,18.04,"%D",10,0)
Configuration option [XOBV LISTENER STARTUP] is invoked, or by using the
"^DIC",18.04,18.04,"%D",11,0)
action protocols found under the Foundations Management Menu option
"^DIC",18.04,18.04,"%D",12,0)
[XOBU SITE SETUP MENU] to either start the BOX-VOLUME default
"^DIC",18.04,18.04,"%D",13,0)
configuration or start a single VistALink Listener.
"^DIC",18.04,18.04,"%D",14,0)
 
"^DIC",18.04,18.04,"%D",15,0)
When a Listener is stopped, the log file is edited with an updated
"^DIC",18.04,18.04,"%D",16,0)
status.  Non-active Listeners are deleted from the log file when the Clean
"^DIC",18.04,18.04,"%D",17,0)
Up Log action protocol is invoked.  As mentioned, this action protocol as
"^DIC",18.04,18.04,"%D",18,0)
well as the action protocols previously described above can be found under
"^DIC",18.04,18.04,"%D",19,0)
the Foundations Management Menu option [XOBU SITE SETUP MENU].
"^DIC",18.04,"B","VISTALINK LISTENER STARTUP LOG",18.04)

"^DIC",18.05,18.05,0)
VISTALINK MESSAGE TYPE^18.05
"^DIC",18.05,18.05,0,"GL")
^XOB(18.05,
"^DIC",18.05,18.05,"%",0)
^1.005^^
"^DIC",18.05,18.05,"%D",0)
^^11^11^3030410^
"^DIC",18.05,18.05,"%D",1,0)
This file contains the message type definitions used by the VistALink 
"^DIC",18.05,18.05,"%D",2,0)
request manager. Each message type is associated with a request handler.
"^DIC",18.05,18.05,"%D",3,0)
 
"^DIC",18.05,18.05,"%D",4,0)
The request manager uses TCP/IP input stream information to lookup entries
"^DIC",18.05,18.05,"%D",5,0)
by 'message type' or 'proprietary format indicator'.  Once an entry has
"^DIC",18.05,18.05,"%D",6,0)
been found, the request manager can execute the correct request handler
"^DIC",18.05,18.05,"%D",7,0)
methods for the incoming request stream.
"^DIC",18.05,18.05,"%D",8,0)
 
"^DIC",18.05,18.05,"%D",9,0)
Information contained in the entries of this file allow the request
"^DIC",18.05,18.05,"%D",10,0)
manager to dynamically determine which request handler to load and
"^DIC",18.05,18.05,"%D",11,0)
execute.
"^DIC",18.05,"B","VISTALINK MESSAGE TYPE",18.05)

**INSTALL NAME**
XOBS 1.6
"BLD",4061,0)
XOBS 1.6^VISTALINK SECURITY^0^3090508^y
"BLD",4061,1,0)
^^4^4^3071113^
"BLD",4061,1,1,0)
Contains the client/server M-side security module for VistALink. This
"BLD",4061,1,2,0)
module acts mainly as a wrapper around Kernel's login functionality, as
"BLD",4061,1,3,0)
well as around the RPC Broker's authorization functionality. VistALink
"BLD",4061,1,4,0)
uses this module for end-user authentication and for RPC authorization.
"BLD",4061,4,0)
^9.64PA^^0
"BLD",4061,6.3)
15
"BLD",4061,"ABPKG")
n
"BLD",4061,"KRN",0)
^9.67PA^8989.52^19
"BLD",4061,"KRN",.4,0)
.4
"BLD",4061,"KRN",.401,0)
.401
"BLD",4061,"KRN",.402,0)
.402
"BLD",4061,"KRN",.402,"NM",0)
^9.68A^^0
"BLD",4061,"KRN",.403,0)
.403
"BLD",4061,"KRN",.5,0)
.5
"BLD",4061,"KRN",.84,0)
.84
"BLD",4061,"KRN",.84,"NM",0)
^9.68A^18^17
"BLD",4061,"KRN",.84,"NM",1,0)
183001^^0
"BLD",4061,"KRN",.84,"NM",2,0)
183002^^0
"BLD",4061,"KRN",.84,"NM",3,0)
183003^^0
"BLD",4061,"KRN",.84,"NM",4,0)
183004^^0
"BLD",4061,"KRN",.84,"NM",5,0)
183005^^0
"BLD",4061,"KRN",.84,"NM",6,0)
183006^^0
"BLD",4061,"KRN",.84,"NM",7,0)
182301^^0
"BLD",4061,"KRN",.84,"NM",8,0)
182302^^0
"BLD",4061,"KRN",.84,"NM",9,0)
182303^^0
"BLD",4061,"KRN",.84,"NM",10,0)
182304^^0
"BLD",4061,"KRN",.84,"NM",11,0)
182305^^0
"BLD",4061,"KRN",.84,"NM",12,0)
182306^^0
"BLD",4061,"KRN",.84,"NM",13,0)
183007^^0
"BLD",4061,"KRN",.84,"NM",14,0)
183010^^0
"BLD",4061,"KRN",.84,"NM",15,0)
183008^^0
"BLD",4061,"KRN",.84,"NM",17,0)
182307^^0
"BLD",4061,"KRN",.84,"NM",18,0)
182308^^0
"BLD",4061,"KRN",.84,"NM","B",182301,7)

"BLD",4061,"KRN",.84,"NM","B",182302,8)

"BLD",4061,"KRN",.84,"NM","B",182303,9)

"BLD",4061,"KRN",.84,"NM","B",182304,10)

"BLD",4061,"KRN",.84,"NM","B",182305,11)

"BLD",4061,"KRN",.84,"NM","B",182306,12)

"BLD",4061,"KRN",.84,"NM","B",182307,17)

"BLD",4061,"KRN",.84,"NM","B",182308,18)

"BLD",4061,"KRN",.84,"NM","B",183001,1)

"BLD",4061,"KRN",.84,"NM","B",183002,2)

"BLD",4061,"KRN",.84,"NM","B",183003,3)

"BLD",4061,"KRN",.84,"NM","B",183004,4)

"BLD",4061,"KRN",.84,"NM","B",183005,5)

"BLD",4061,"KRN",.84,"NM","B",183006,6)

"BLD",4061,"KRN",.84,"NM","B",183007,13)

"BLD",4061,"KRN",.84,"NM","B",183008,15)

"BLD",4061,"KRN",.84,"NM","B",183010,14)

"BLD",4061,"KRN",3.6,0)
3.6
"BLD",4061,"KRN",3.6,"NM",0)
^9.68A^^
"BLD",4061,"KRN",3.8,0)
3.8
"BLD",4061,"KRN",9.2,0)
9.2
"BLD",4061,"KRN",9.8,0)
9.8
"BLD",4061,"KRN",9.8,"NM",0)
^9.68A^7^7
"BLD",4061,"KRN",9.8,"NM",1,0)
XOBSCAV^^0^B55844023
"BLD",4061,"KRN",9.8,"NM",2,0)
XOBSCAV1^^0^B81688032
"BLD",4061,"KRN",9.8,"NM",3,0)
XOBSCAV2^^0^B64619205
"BLD",4061,"KRN",9.8,"NM",4,0)
XOBSCI^^0^B583719
"BLD",4061,"KRN",9.8,"NM",5,0)
XOBSRA^^0^B61930744
"BLD",4061,"KRN",9.8,"NM",6,0)
XOBSRAKJ^^0^B10014384
"BLD",4061,"KRN",9.8,"NM",7,0)
XOBSRA1^^0^B2720328
"BLD",4061,"KRN",9.8,"NM","B","XOBSCAV",1)

"BLD",4061,"KRN",9.8,"NM","B","XOBSCAV1",2)

"BLD",4061,"KRN",9.8,"NM","B","XOBSCAV2",3)

"BLD",4061,"KRN",9.8,"NM","B","XOBSCI",4)

"BLD",4061,"KRN",9.8,"NM","B","XOBSRA",5)

"BLD",4061,"KRN",9.8,"NM","B","XOBSRA1",7)

"BLD",4061,"KRN",9.8,"NM","B","XOBSRAKJ",6)

"BLD",4061,"KRN",19,0)
19
"BLD",4061,"KRN",19,"NM",0)
^9.68A^^0
"BLD",4061,"KRN",19.1,0)
19.1
"BLD",4061,"KRN",101,0)
101
"BLD",4061,"KRN",409.61,0)
409.61
"BLD",4061,"KRN",771,0)
771
"BLD",4061,"KRN",870,0)
870
"BLD",4061,"KRN",8989.51,0)
8989.51
"BLD",4061,"KRN",8989.52,0)
8989.52
"BLD",4061,"KRN",8994,0)
8994
"BLD",4061,"KRN",8994,"NM",0)
^9.68A^^0
"BLD",4061,"KRN","B",.4,.4)

"BLD",4061,"KRN","B",.401,.401)

"BLD",4061,"KRN","B",.402,.402)

"BLD",4061,"KRN","B",.403,.403)

"BLD",4061,"KRN","B",.5,.5)

"BLD",4061,"KRN","B",.84,.84)

"BLD",4061,"KRN","B",3.6,3.6)

"BLD",4061,"KRN","B",3.8,3.8)

"BLD",4061,"KRN","B",9.2,9.2)

"BLD",4061,"KRN","B",9.8,9.8)

"BLD",4061,"KRN","B",19,19)

"BLD",4061,"KRN","B",19.1,19.1)

"BLD",4061,"KRN","B",101,101)

"BLD",4061,"KRN","B",409.61,409.61)

"BLD",4061,"KRN","B",771,771)

"BLD",4061,"KRN","B",870,870)

"BLD",4061,"KRN","B",8989.51,8989.51)

"BLD",4061,"KRN","B",8989.52,8989.52)

"BLD",4061,"KRN","B",8994,8994)

"BLD",4061,"QUES",0)
^9.62^^
"BLD",4061,"REQB",0)
^9.611^2^2
"BLD",4061,"REQB",1,0)
XU*8.0*337^2
"BLD",4061,"REQB",2,0)
XOBU 1.6^2
"BLD",4061,"REQB","B","XOBU 1.6",2)

"BLD",4061,"REQB","B","XU*8.0*337",1)

"KRN",.84,182301,-1)
0^7
"KRN",.84,182301,0)
182301^1^y^VISTALINK SECURITY^No valid DUZ found
"KRN",.84,182301,1,0)
^^7^7^3080402^
"KRN",.84,182301,1,1,0)
Error returned if the user's credentials (OID, Generic, etc.) could not
"KRN",.84,182301,1,2,0)
be mapped to an entry in the VistA New Person file.
"KRN",.84,182301,1,3,0)
 
"KRN",.84,182301,1,4,0)
 Java Exception Information:
"KRN",.84,182301,1,5,0)
 
"KRN",.84,182301,1,6,0)
 Category: Reauthentication Processing Fault
"KRN",.84,182301,1,7,0)
 Exception: SecurityIdentityDeterminationFaultException
"KRN",.84,182301,2,0)
^.844^1^1^3080402^
"KRN",.84,182301,2,1,0)
No valid DUZ found.  [Security Type: |1|]  |2|
"KRN",.84,182301,3,0)
^.845^2^2
"KRN",.84,182301,3,1,0)
1^Security Type
"KRN",.84,182301,3,2,0)
2^Error information
"KRN",.84,182301,5,0)
^.841^2^2
"KRN",.84,182301,5,1,0)
XOBSRA^SETUPDUZ
"KRN",.84,182301,5,2,0)
XOBSRA^GETERR
"KRN",.84,182301,5,"B","XOBSRA",1)

"KRN",.84,182301,5,"B","XOBSRA",2)

"KRN",.84,182302,-1)
0^8
"KRN",.84,182302,0)
182302^1^y^VISTALINK SECURITY^Invalid Division for User
"KRN",.84,182302,1,0)
^^6^6^3080402^
"KRN",.84,182302,1,1,0)
Error returned when the division passed is not valid.
"KRN",.84,182302,1,2,0)
 
"KRN",.84,182302,1,3,0)
 Java Exception Information:
"KRN",.84,182302,1,4,0)
 
"KRN",.84,182302,1,5,0)
 Category: Reauthentication Processing
"KRN",.84,182302,1,6,0)
 Exception: SecurityDivisionDeterminationFaultException
"KRN",.84,182302,2,0)
^^1^1^3080402^
"KRN",.84,182302,2,1,0)
Division specified is invalid for user. Security type [|1|]. DUZ: [|2|], Passed Division: [|3|].
"KRN",.84,182302,3,0)
^.845^3^3
"KRN",.84,182302,3,1,0)
1^Security Type
"KRN",.84,182302,3,2,0)
2^DUZ
"KRN",.84,182302,3,3,0)
3^Provided Division
"KRN",.84,182302,5,0)
^.841^1^1
"KRN",.84,182302,5,1,0)
XOBSRA^DUZENV
"KRN",.84,182302,5,"B","XOBSRA",1)

"KRN",.84,182303,-1)
0^9
"KRN",.84,182303,0)
182303^1^y^VISTALINK SECURITY^Verify code needs to be changed
"KRN",.84,182303,1,0)
^^7^7^3080402^
"KRN",.84,182303,1,1,0)
Error returned if the user's verify code is not defined, or has expired
"KRN",.84,182303,1,2,0)
and must be changed.
"KRN",.84,182303,1,3,0)
 
"KRN",.84,182303,1,4,0)
 Java Exception:
"KRN",.84,182303,1,5,0)
 
"KRN",.84,182303,1,6,0)
 Category: Reauthentication Processing Fault
"KRN",.84,182303,1,7,0)
 Exception: SecurityUserVerifyCodeException
"KRN",.84,182303,2,0)
^.844^1^1^3080402^
"KRN",.84,182303,2,1,0)
Verify code for user with DUZ '|1|' has expired or is not defined.
"KRN",.84,182303,3,0)
^.845^1^1
"KRN",.84,182303,3,1,0)
1^DUZ
"KRN",.84,182303,5,0)
^.841^1^1
"KRN",.84,182303,5,1,0)
XOBSRA^VCHG
"KRN",.84,182303,5,"B","XOBSRA",1)

"KRN",.84,182304,-1)
0^10
"KRN",.84,182304,0)
182304^1^y^VISTALINK SECURITY^User is not allowed to access the M server
"KRN",.84,182304,1,0)
^^8^8^3080402^
"KRN",.84,182304,1,1,0)
Error returned if the user is not allowed access to the M server because
"KRN",.84,182304,1,2,0)
they are terminated, access is disabled (DISUSER), a timed lockout is in
"KRN",.84,182304,1,3,0)
effect, or the current time is within the prohibited times for sign-on.
"KRN",.84,182304,1,4,0)
 
"KRN",.84,182304,1,5,0)
 Java Exception:
"KRN",.84,182304,1,6,0)
 
"KRN",.84,182304,1,7,0)
 Category: Reauthentication Processing Fault
"KRN",.84,182304,1,8,0)
 Exception: SecurityUserAuthorizationException
"KRN",.84,182304,2,0)
^.844^1^1^3080402^
"KRN",.84,182304,2,1,0)
The user is currently not allowed to sign-on to the M server. (DUZ: |1|, Reason : |2|).
"KRN",.84,182304,3,0)
^.845^2^2
"KRN",.84,182304,3,1,0)
1^DUZ
"KRN",.84,182304,3,2,0)
2^Reason sign-on is not allowed (Terminated, DISUSER, Timed Lockout, Prohibited Time).
"KRN",.84,182304,5,0)
^.841^2^2
"KRN",.84,182304,5,1,0)
XOBSRA^NOACCESS
"KRN",.84,182304,5,2,0)
XOBSRA^GETERR
"KRN",.84,182304,5,"B","XOBSRA",1)

"KRN",.84,182304,5,"B","XOBSRA",2)

"KRN",.84,182305,-1)
0^11
"KRN",.84,182305,0)
182305^1^y^VISTALINK SECURITY^Access and/or verify code is not valid
"KRN",.84,182305,1,0)
^^8^8^3080402^
"KRN",.84,182305,1,1,0)
Error returned if the access code does not correspond to an entry in the
"KRN",.84,182305,1,2,0)
New Person file or if the verify code does not match the value for the
"KRN",.84,182305,1,3,0)
user.
"KRN",.84,182305,1,4,0)
 
"KRN",.84,182305,1,5,0)
 Java Exception:
"KRN",.84,182305,1,6,0)
 
"KRN",.84,182305,1,7,0)
 Category: Reauthentication Processing Fault
"KRN",.84,182305,1,8,0)
 Exception: SecurityAccessVerifyCodePairInvalidException
"KRN",.84,182305,2,0)
^^1^1^3080402^
"KRN",.84,182305,2,1,0)
Invalid Kernel logon credentials. [Security Type: |1|] |2|
"KRN",.84,182305,3,0)
^.845^2^2
"KRN",.84,182305,3,1,0)
1^SECURITY TYPE
"KRN",.84,182305,3,2,0)
2^optional explanatory text
"KRN",.84,182305,5,0)
^.841^2^2
"KRN",.84,182305,5,1,0)
XOBSRA^AV
"KRN",.84,182305,5,2,0)
XOBSRA^CCOW
"KRN",.84,182305,5,"B","XOBSRA",1)

"KRN",.84,182305,5,"B","XOBSRA",2)

"KRN",.84,182306,-1)
0^12
"KRN",.84,182306,0)
182306^1^y^VISTALINK SECURITY^IP Address Locked -- Too Many Attempts
"KRN",.84,182306,1,0)
^.842^7^7^3080402^^^
"KRN",.84,182306,1,1,0)
Error returned if the IP address for the connecting client has been
"KRN",.84,182306,1,2,0)
locked by Kernel due to too many invalid signon attempts.
"KRN",.84,182306,1,3,0)
 
"KRN",.84,182306,1,4,0)
  Java Exception:
"KRN",.84,182306,1,5,0)
 
"KRN",.84,182306,1,6,0)
  Category: Reauthentication Processing Fault
"KRN",.84,182306,1,7,0)
  Exception: SecurityTooManyInvalidLoginAttemptsFaultException
"KRN",.84,182306,2,0)
^.844^1^1^3080402^^^^
"KRN",.84,182306,2,1,0)
IP address locked: '|1|'
"KRN",.84,182306,3,0)
^.845^1^1
"KRN",.84,182306,3,1,0)
1^Error Message
"KRN",.84,182306,5,0)
^.841^2^1
"KRN",.84,182306,5,2,0)
XOBSRAKJ^IPLOCKED
"KRN",.84,182306,5,"B","XOBSRAKJ",2)

"KRN",.84,182307,-1)
0^17
"KRN",.84,182307,0)
182307^1^y^VISTALINK SECURITY^Application Proxy Invalid
"KRN",.84,182307,1,0)
^^7^7^3080402^
"KRN",.84,182307,1,1,0)
Error returned if the application proxy user specified during
"KRN",.84,182307,1,2,0)
reauthentication is invalid.
"KRN",.84,182307,1,3,0)
 
"KRN",.84,182307,1,4,0)
 Java Exception:
"KRN",.84,182307,1,5,0)
 
"KRN",.84,182307,1,6,0)
 Category: Reauthentication Processing Fault
"KRN",.84,182307,1,7,0)
 Exception: SecurityIdentityDeterminationFaultException
"KRN",.84,182307,2,0)
^.844^1^1^3080402^^
"KRN",.84,182307,2,1,0)
Application Proxy '|1|' is invalid: |2|
"KRN",.84,182307,3,0)
^.845^2^2
"KRN",.84,182307,3,1,0)
1^application proxy name
"KRN",.84,182307,3,2,0)
2^reason for error
"KRN",.84,182307,5,0)
^.841^1^1
"KRN",.84,182307,5,1,0)
XOBSRA^APPPROXY
"KRN",.84,182307,5,"B","XOBSRA",1)

"KRN",.84,182308,-1)
0^18
"KRN",.84,182308,0)
182308^1^y^VISTALINK SECURITY^Invalid Division for Site
"KRN",.84,182308,1,0)
^^7^7^3080402^
"KRN",.84,182308,1,1,0)
Returned if a division is specified that is not supported on the current
"KRN",.84,182308,1,2,0)
system.
"KRN",.84,182308,1,3,0)
 
"KRN",.84,182308,1,4,0)
 Java Exception:
"KRN",.84,182308,1,5,0)
 
"KRN",.84,182308,1,6,0)
 Category: Reauthentication Processing Fault
"KRN",.84,182308,1,7,0)
 Exception: SecurityDivisionDeterminationFaultException
"KRN",.84,182308,2,0)
^^1^1^3080402^
"KRN",.84,182308,2,1,0)
Division [|4|] not supported: [|1|]  (security type [|2|], DUZ: [|3|]).
"KRN",.84,182308,3,0)
^.845^4^4
"KRN",.84,182308,3,1,0)
1^error description
"KRN",.84,182308,3,2,0)
2^Security type
"KRN",.84,182308,3,3,0)
3^DUZ
"KRN",.84,182308,3,4,0)
4^Passed division
"KRN",.84,182308,5,0)
^.841^1^1
"KRN",.84,182308,5,1,0)
XOBSRA^DUZENV
"KRN",.84,182308,5,"B","XOBSRA",1)

"KRN",.84,183001,-1)
0^1
"KRN",.84,183001,0)
183001^1^y^VISTALINK SECURITY^not a security message type
"KRN",.84,183001,1,0)
^^7^7^3080402^
"KRN",.84,183001,1,1,0)
Error returned by the Security Message Request Handler if the message it's
"KRN",.84,183001,1,2,0)
handling is not a security request message type.
"KRN",.84,183001,1,3,0)
 
"KRN",.84,183001,1,4,0)
 Java Exception Information:
"KRN",.84,183001,1,5,0)
 
"KRN",.84,183001,1,6,0)
 Category: Security Processing Fault
"KRN",.84,183001,1,7,0)
 Exception: SecurityFaultException
"KRN",.84,183001,2,0)
^^1^1^3080402^
"KRN",.84,183001,2,1,0)
Expecting a security message type '|1|', but found unrecognized message type: '|2|'
"KRN",.84,183001,3,0)
^.845^2^2
"KRN",.84,183001,3,1,0)
1^expected message type
"KRN",.84,183001,3,2,0)
2^received message type
"KRN",.84,183001,5,0)
^.841^1^1
"KRN",.84,183001,5,1,0)
XOBSCAV^EN
"KRN",.84,183001,5,"B","XOBSCAV",1)

"KRN",.84,183002,-1)
0^2
"KRN",.84,183002,0)
183002^1^y^VISTALINK SECURITY^unknown security action found
"KRN",.84,183002,1,0)
^^8^8^3080402^
"KRN",.84,183002,1,1,0)
When an unknown security action (e.g., "AV.LogonZ" rather than "AV.Logon")
"KRN",.84,183002,1,2,0)
is encountered by the security system, this error is returned.
"KRN",.84,183002,1,3,0)
 
"KRN",.84,183002,1,4,0)
 
"KRN",.84,183002,1,5,0)
 Java Exception Information:
"KRN",.84,183002,1,6,0)
 
"KRN",.84,183002,1,7,0)
 Category: Security Processing Fault
"KRN",.84,183002,1,8,0)
 Exception: SecurityFaultException
"KRN",.84,183002,2,0)
^^1^1^3080402^
"KRN",.84,183002,2,1,0)
Security message action '|1|' is an unknown security action.
"KRN",.84,183002,3,0)
^.845^1^1
"KRN",.84,183002,3,1,0)
1^unknown message action
"KRN",.84,183002,5,0)
^.841^1^1
"KRN",.84,183002,5,1,0)
XOBSCAV^EN
"KRN",.84,183002,5,"B","XOBSCAV",1)

"KRN",.84,183003,-1)
0^3
"KRN",.84,183003,0)
183003^1^^VISTALINK SECURITY^Already logged on
"KRN",.84,183003,1,0)
^^7^7^3080402^
"KRN",.84,183003,1,1,0)
Returned if a logon is attempted when a user is already logged on (i.e.,
"KRN",.84,183003,1,2,0)
DUZ is defined.)
"KRN",.84,183003,1,3,0)
 
"KRN",.84,183003,1,4,0)
 Java Exception Information:
"KRN",.84,183003,1,5,0)
 
"KRN",.84,183003,1,6,0)
 Category: Security Processing Fault
"KRN",.84,183003,1,7,0)
 Exception: SecurityFaultException
"KRN",.84,183003,2,0)
^^1^1^3080402^
"KRN",.84,183003,2,1,0)
Aborting signon because DUZ is already defined.
"KRN",.84,183003,5,0)
^.841^1^1
"KRN",.84,183003,5,1,0)
XOBSCAV1^LOGON
"KRN",.84,183003,5,"B","XOBSCAV1",1)

"KRN",.84,183004,-1)
0^4
"KRN",.84,183004,0)
183004^1^y^VISTALINK SECURITY^general logon failure
"KRN",.84,183004,1,0)
^^6^6^3080402^
"KRN",.84,183004,1,1,0)
This error is returned when a logon fails.
"KRN",.84,183004,1,2,0)
 
"KRN",.84,183004,1,3,0)
 Java Exception Information:
"KRN",.84,183004,1,4,0)
 
"KRN",.84,183004,1,5,0)
 Category: Security Processing Fault
"KRN",.84,183004,1,6,0)
 Exception: SecurityFaultException
"KRN",.84,183004,2,0)
^^1^1^3080402^
"KRN",.84,183004,2,1,0)
Logon failure: '|1|'
"KRN",.84,183004,3,0)
^.845^1^1
"KRN",.84,183004,3,1,0)
1^reason for failure
"KRN",.84,183004,5,0)
^.841^1^1
"KRN",.84,183004,5,1,0)
XOBSCAV1^LOGON
"KRN",.84,183004,5,"B","XOBSCAV1",1)

"KRN",.84,183005,-1)
0^5
"KRN",.84,183005,0)
183005^1^y^VISTALINK SECURITY^too many invalid login attempts
"KRN",.84,183005,1,0)
^^7^7^3080402^
"KRN",.84,183005,1,1,0)
This error is returned when a logon fails due to too many invalid login
"KRN",.84,183005,1,2,0)
attempts (device locked).
"KRN",.84,183005,1,3,0)
 
"KRN",.84,183005,1,4,0)
  Java Exception Information:
"KRN",.84,183005,1,5,0)
 
"KRN",.84,183005,1,6,0)
  Category: Security Processing Fault
"KRN",.84,183005,1,7,0)
  Exception: TooManyInvalidAttemptsFaultException
"KRN",.84,183005,2,0)
^^1^1^3080402^
"KRN",.84,183005,2,1,0)
Logon failure: '|1|'
"KRN",.84,183005,3,0)
^.845^1^1
"KRN",.84,183005,3,1,0)
1^text reason for failure
"KRN",.84,183005,5,0)
^.841^1^1
"KRN",.84,183005,5,1,0)
XOBSCAV1^LOGON
"KRN",.84,183005,5,"B","XOBSCAV1",1)

"KRN",.84,183006,-1)
0^6
"KRN",.84,183006,0)
183006^1^y^VISTALINK SECURITY^user demographics retrieval error
"KRN",.84,183006,1,0)
^.842^7^7^3080402^^^
"KRN",.84,183006,1,1,0)
This error is returned if there is a problem retrieving demographic
"KRN",.84,183006,1,2,0)
information for the user.
"KRN",.84,183006,1,3,0)
 
"KRN",.84,183006,1,4,0)
  Java Exception Information:
"KRN",.84,183006,1,5,0)
 
"KRN",.84,183006,1,6,0)
  Category: Security Processing Fault
"KRN",.84,183006,1,7,0)
  Exception: SecurityFaultException
"KRN",.84,183006,2,0)
^.844^1^1^3080402^^^
"KRN",.84,183006,2,1,0)
Error retrieving user demographics: '|1|'
"KRN",.84,183006,3,0)
^.845^1^1
"KRN",.84,183006,3,1,0)
1^error message
"KRN",.84,183006,5,0)
^.841^2^1
"KRN",.84,183006,5,2,0)
XOBSCAV2^SENDDEM
"KRN",.84,183006,5,"B","XOBSCAV2",2)

"KRN",.84,183007,-1)
0^13
"KRN",.84,183007,0)
183007^1^y^VISTALINK SECURITY^Production/Test Mismatch
"KRN",.84,183007,1,0)
^.842^7^7^3080516^^^
"KRN",.84,183007,1,1,0)
This error is returned when a production/test mismatch is detected between
"KRN",.84,183007,1,2,0)
the client and server.
"KRN",.84,183007,1,3,0)
 
"KRN",.84,183007,1,4,0)
 Java Exception:
"KRN",.84,183007,1,5,0)
 
"KRN",.84,183007,1,6,0)
 Category: Security Processing Fault
"KRN",.84,183007,1,7,0)
 Exception: SecurityProductionMismatchException
"KRN",.84,183007,2,0)
^.844^1^1^3080516^^^
"KRN",.84,183007,2,1,0)
A production/test mismatch was detected between the client (|1|) and the server (|2|).
"KRN",.84,183007,3,0)
^.845^2^2
"KRN",.84,183007,3,1,0)
1^Client production setting
"KRN",.84,183007,3,2,0)
2^Server production setting
"KRN",.84,183007,5,0)
^.841^1^1
"KRN",.84,183007,5,1,0)
XOBSCAV1^SENDITXT
"KRN",.84,183007,5,"B","XOBSCAV1",1)

"KRN",.84,183008,-1)
0^15
"KRN",.84,183008,0)
183008^1^y^VISTALINK SECURITY^Connector Proxy user error
"KRN",.84,183008,1,0)
^.842^7^7^3080516^^^
"KRN",.84,183008,1,1,0)
Returned if a logon is attempted and encounters a Connector Proxy user
"KRN",.84,183008,1,2,0)
error.
"KRN",.84,183008,1,3,0)
 
"KRN",.84,183008,1,4,0)
 Java Exception:
"KRN",.84,183008,1,5,0)
 
"KRN",.84,183008,1,6,0)
 Category: Security Processing Fault
"KRN",.84,183008,1,7,0)
 Exception: SecurityConnectionProxyException
"KRN",.84,183008,2,0)
^.844^1^1^3080516^^^
"KRN",.84,183008,2,1,0)
Connector Proxy user error. Reason: '|1|'
"KRN",.84,183008,3,0)
^.845^1^1
"KRN",.84,183008,3,1,0)
1^Connector Proxy user error
"KRN",.84,183008,5,0)
^.841^2^2
"KRN",.84,183008,5,1,0)
XOBSCAV1^ISCPROXY
"KRN",.84,183008,5,2,0)
XOBSCAV1^LOGON
"KRN",.84,183008,5,"B","XOBSCAV1",1)

"KRN",.84,183008,5,"B","XOBSCAV1",2)

"KRN",.84,183010,-1)
0^14
"KRN",.84,183010,0)
183010^1^y^VISTALINK SECURITY^Primary Station Mismatch
"KRN",.84,183010,1,0)
^^9^9^3080402^
"KRN",.84,183010,1,1,0)
Returned when a connection is attempted, if the primary station for
"KRN",.84,183010,1,2,0)
the connector does not match the primary station for the M system
"KRN",.84,183010,1,3,0)
being connected to (DEFAULT INSTITUTION field of the Kernel System
"KRN",.84,183010,1,4,0)
Parameters file).
"KRN",.84,183010,1,5,0)
 
"KRN",.84,183010,1,6,0)
 Java Exception:
"KRN",.84,183010,1,7,0)
 
"KRN",.84,183010,1,8,0)
 Category: Security Processing Fault
"KRN",.84,183010,1,9,0)
 Exception: SecurityPrimaryStationMismatchException
"KRN",.84,183010,2,0)
^.844^1^1^3080402^
"KRN",.84,183010,2,1,0)
Primary station '|1|' of the request does not match the primary station '|2|' of the M/Kernel system.
"KRN",.84,183010,3,0)
^.845^2^2
"KRN",.84,183010,3,1,0)
1^client request primary station#
"KRN",.84,183010,3,2,0)
2^M/Kernel account primary station#
"KRN",.84,183010,5,0)
^.841^1^1
"KRN",.84,183010,5,1,0)
XOBSCAV1^SENDITXT
"KRN",.84,183010,5,"B","XOBSCAV1",1)

"MBREQ")
0
"ORD",9,.84)
.84;9;;;EDEOUT^DIFROMSO(.84,DA,"",XPDA);FPRE^DIFROMSI(.84,"",XPDA);EPRE^DIFROMSI(.84,DA,"",XPDA,"",OLDA);;EPOST^DIFROMSI(.84,DA,"",XPDA);DEL^DIFROMSK(.84,"",%)
"ORD",9,.84,0)
DIALOG
"PKG",552,-1)
1^1
"PKG",552,0)
VISTALINK SECURITY^XOBS^SECURITY SUBSYSTEM FOR VISTALINK
"PKG",552,1,0)
^9.41A^1^1^3030919^^
"PKG",552,1,1,0)
CONTAINS ROUTINES COMPRISING THE SECURITY SUBSYSTEM FOR VISTALINK.
"PKG",552,5)
OAKLAND
"PKG",552,20,0)
^9.402P^^
"PKG",552,22,0)
^9.49I^1^1
"PKG",552,22,1,0)
1.6^3090508
"PKG",552,22,1,1,0)
^^4^4^3090508
"PKG",552,22,1,1,1,0)
Contains the client/server M-side security module for VistALink. This
"PKG",552,22,1,1,2,0)
module acts mainly as a wrapper around Kernel's login functionality, as
"PKG",552,22,1,1,3,0)
well as around the RPC Broker's authorization functionality. VistALink
"PKG",552,22,1,1,4,0)
uses this module for end-user authentication and for RPC authorization.
"PKG",552,"DEV")

"PKG",552,"VERSION")
1.6
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
7
"RTN","XOBSCAV")
0^1^B55844023
"RTN","XOBSCAV",1,0)
XOBSCAV ;; kec/oak - VistaLink Access/Verify Security ; 12/09/2002  17:00
"RTN","XOBSCAV",2,0)
 ;;1.6;VistALink Security;;May 08, 2009;Build 15
"RTN","XOBSCAV",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBSCAV",4,0)
 QUIT
"RTN","XOBSCAV",5,0)
 ;
"RTN","XOBSCAV",6,0)
 ; ---------------------------------------------------------------------
"RTN","XOBSCAV",7,0)
 ;      Access/Verify Security: Security Message Request Handler
"RTN","XOBSCAV",8,0)
 ;             (main entry point; utilities; constants)   
"RTN","XOBSCAV",9,0)
 ; ---------------------------------------------------------------------
"RTN","XOBSCAV",10,0)
 ; 
"RTN","XOBSCAV",11,0)
 ; ==== main entry point ====
"RTN","XOBSCAV",12,0)
 ; 
"RTN","XOBSCAV",13,0)
EN(XOBDATA) ; -- handle parsed messages request
"RTN","XOBSCAV",14,0)
 ;
"RTN","XOBSCAV",15,0)
 IF XOBDATA("XOB SECAV","SECURITYTYPE")'=$$MSGTYP^XOBSCAV("request") DO  QUIT
"RTN","XOBSCAV",16,0)
 .;this routine should never see a message not of this type.
"RTN","XOBSCAV",17,0)
 .NEW XOBSPAR SET XOBSPAR(1)=$$MSGTYP^XOBSCAV("request"),XOBSPAR(2)=XOBDATA("SECURITYTYPE")
"RTN","XOBSCAV",18,0)
 .DO ERROR(.XOBR,$PIECE($TEXT(FCLIENT),";;",2),"Unexpected Message Format",183001,$$CHARCHK^XOBVLIB($$EZBLD^DIALOG(183001,.XOBSPAR)))
"RTN","XOBSCAV",19,0)
 ;
"RTN","XOBSCAV",20,0)
 ;---- now process each security message type ----
"RTN","XOBSCAV",21,0)
 IF XOBDATA("XOB SECAV","SECURITYACTION")=$PIECE($TEXT(MSGSETUP),";;",2) DO SENDITXT^XOBSCAV1 QUIT
"RTN","XOBSCAV",22,0)
 IF XOBDATA("XOB SECAV","SECURITYACTION")=$PIECE($TEXT(MSGLGON),";;",2) DO LOGON^XOBSCAV1 QUIT
"RTN","XOBSCAV",23,0)
 IF XOBDATA("XOB SECAV","SECURITYACTION")=$PIECE($TEXT(MSGLGOUT),";;",2) DO LOGOUT^XOBSCAV1 QUIT
"RTN","XOBSCAV",24,0)
 IF XOBDATA("XOB SECAV","SECURITYACTION")=$PIECE($TEXT(MSGSELDV),";;",2) DO DIVSLCT^XOBSCAV1 QUIT
"RTN","XOBSCAV",25,0)
 IF XOBDATA("XOB SECAV","SECURITYACTION")=$PIECE($TEXT(MSGUPDVC),";;",2) DO SENDNVC^XOBSCAV2 QUIT
"RTN","XOBSCAV",26,0)
 IF XOBDATA("XOB SECAV","SECURITYACTION")=$PIECE($TEXT(MSGUSERD),";;",2) DO SENDDEM^XOBSCAV2 QUIT
"RTN","XOBSCAV",27,0)
 ;
"RTN","XOBSCAV",28,0)
 ; done processing all known message types
"RTN","XOBSCAV",29,0)
 NEW XOBSPAR SET XOBSPAR(1)=XOBDATA("XOB SECAV","SECURITYACTION")
"RTN","XOBSCAV",30,0)
 DO ERROR(.XOBR,$PIECE($TEXT(FCLIENT),";;",2),"Unexpected Message Format",183002,$$CHARCHK^XOBVLIB($$EZBLD^DIALOG(183002,.XOBSPAR)))
"RTN","XOBSCAV",31,0)
 QUIT
"RTN","XOBSCAV",32,0)
 ;
"RTN","XOBSCAV",33,0)
 ; ==== utilities ====
"RTN","XOBSCAV",34,0)
 ; 
"RTN","XOBSCAV",35,0)
SENDSEC(XOBR,XOBMSGTP,XOBRSTYP,XOBMSG,XOBSTAT,XOBSCHEM) ; -- stream XML security reply back
"RTN","XOBSCAV",36,0)
 ;
"RTN","XOBSCAV",37,0)
 ; XOBR: internal VistaLink variable
"RTN","XOBSCAV",38,0)
 ; XOBMSGTP: type of message (e.g., gov.va.med.foundations.security.response)
"RTN","XOBSCAV",39,0)
 ; XOBRSTYP: type of response (e.g., AV.SetupAndIntroText)
"RTN","XOBSCAV",40,0)
 ; XOBMSG: message lines to send inside standard wrapper
"RTN","XOBSCAV",41,0)
 ; XOBSTAT: type of result (e.g., success)
"RTN","XOBSCAV",42,0)
 ; XOBSCHEM: noNamespaceSchemaLocation
"RTN","XOBSCAV",43,0)
 ; 
"RTN","XOBSCAV",44,0)
 NEW XOBFILL
"RTN","XOBSCAV",45,0)
 ; -- prepare socket for writing
"RTN","XOBSCAV",46,0)
 DO PRE^XOBVSKT
"RTN","XOBSCAV",47,0)
 ; -- write XML header tag and VistaLink tag
"RTN","XOBSCAV",48,0)
 DO WRITE^XOBVSKT($$ENVHDR^XOBVLIB(XOBMSGTP,XOBSCHEM))
"RTN","XOBSCAV",49,0)
 ; -- write SecurityInfo tag
"RTN","XOBSCAV",50,0)
 DO WRITE^XOBVSKT("<SecurityInfo version="""_$PIECE($TEXT(VRSNSEC),";;",2)_""" />")
"RTN","XOBSCAV",51,0)
 ; -- write Response opening tag
"RTN","XOBSCAV",52,0)
 DO WRITE^XOBVSKT("<Response type="""_XOBRSTYP_""" status="""_XOBSTAT_""">")
"RTN","XOBSCAV",53,0)
  ; -- write lines of message passed in
"RTN","XOBSCAV",54,0)
 NEW XOBI SET XOBI=0 FOR  SET XOBI=$ORDER(XOBMSG(XOBI))  QUIT:'+XOBI  DO WRITE^XOBVSKT(XOBMSG(XOBI))
"RTN","XOBSCAV",55,0)
 ; -- write closing Response tag, closing VistaLink tag
"RTN","XOBSCAV",56,0)
 DO WRITE^XOBVSKT("</Response>")
"RTN","XOBSCAV",57,0)
 DO WRITE^XOBVSKT($$ENVFTR^XOBVLIB())
"RTN","XOBSCAV",58,0)
 ; -- send eot and flush buffer
"RTN","XOBSCAV",59,0)
 DO POST^XOBVSKT
"RTN","XOBSCAV",60,0)
 ;
"RTN","XOBSCAV",61,0)
 KILL XOBDATA("XOB SECAV")
"RTN","XOBSCAV",62,0)
 QUIT
"RTN","XOBSCAV",63,0)
 ;
"RTN","XOBSCAV",64,0)
ERROR(XOBR,XOBFCODE,XOBFSTR,XOBCODE,XOBSTR) ; -- send security error back to client
"RTN","XOBSCAV",65,0)
 ;
"RTN","XOBSCAV",66,0)
 ; XOBR: internal VistaLink variable
"RTN","XOBSCAV",67,0)
 ; XOBFCODE: the fault code
"RTN","XOBSCAV",68,0)
 ; XOBFSTRING: the fault string
"RTN","XOBSCAV",69,0)
 ; XOBCODE: error code
"RTN","XOBSCAV",70,0)
 ; XOBSTR: error message
"RTN","XOBSCAV",71,0)
 ; 
"RTN","XOBSCAV",72,0)
 NEW XOBFILL
"RTN","XOBSCAV",73,0)
 ; -- prepare socket for writing
"RTN","XOBSCAV",74,0)
 DO PRE^XOBVSKT
"RTN","XOBSCAV",75,0)
 ; -- write XML header tag and VistaLink tag
"RTN","XOBSCAV",76,0)
 DO WRITE^XOBVSKT($$ENVHDR^XOBVLIB($PIECE($TEXT(ERRTYPE^XOBSCAV),";;",2),$PIECE($TEXT(SCHERROR^XOBSCAV),";;",2)))
"RTN","XOBSCAV",77,0)
 ; -- write SecurityInfo tag
"RTN","XOBSCAV",78,0)
 DO WRITE^XOBVSKT("<SecurityInfo version="""_$PIECE($TEXT(VRSNSEC),";;",2)_""" />")
"RTN","XOBSCAV",79,0)
 ; -- write fault message
"RTN","XOBSCAV",80,0)
 DO WRITE^XOBVSKT("<Fault>")
"RTN","XOBSCAV",81,0)
 DO WRITE^XOBVSKT("<FaultCode>"_XOBFCODE_"</FaultCode>")
"RTN","XOBSCAV",82,0)
 DO WRITE^XOBVSKT("<FaultString>"_XOBFSTR_"</FaultString>")
"RTN","XOBSCAV",83,0)
 DO WRITE^XOBVSKT("<Detail>")
"RTN","XOBSCAV",84,0)
 DO WRITE^XOBVSKT("<Error code="""_XOBCODE_""">")
"RTN","XOBSCAV",85,0)
 DO WRITE^XOBVSKT("<Message>"_XOBSTR_"</Message>")
"RTN","XOBSCAV",86,0)
 DO WRITE^XOBVSKT("</Error>")
"RTN","XOBSCAV",87,0)
 DO WRITE^XOBVSKT("</Detail>")
"RTN","XOBSCAV",88,0)
 DO WRITE^XOBVSKT("</Fault>")
"RTN","XOBSCAV",89,0)
 DO WRITE^XOBVSKT($$ENVFTR^XOBVLIB())
"RTN","XOBSCAV",90,0)
 ; -- send eot and flush buffer
"RTN","XOBSCAV",91,0)
 DO POST^XOBVSKT
"RTN","XOBSCAV",92,0)
 ; -- log the error/fault unless it's "too many invalid login attempts"
"RTN","XOBSCAV",93,0)
 IF XOBCODE'=183005 DO
"RTN","XOBSCAV",94,0)
 .SET:$DATA(XOBDATA("XOB SECAV","AVCODE")) XOBDATA("XOB SECAV","AVCODE")="<masked>"
"RTN","XOBSCAV",95,0)
 .SET:$DATA(XOBDATA("XOB SECAV","OLDVC")) XOBDATA("XOB SECAV","OLDVC")="<masked>"
"RTN","XOBSCAV",96,0)
 .SET:$DATA(XOBDATA("XOB SECAV","NEWVC")) XOBDATA("XOB SECAV","NEWVC")="<masked>"
"RTN","XOBSCAV",97,0)
 .SET:$DATA(XOBDATA("XOB SECAV","NEWVCCHECK")) XOBDATA("XOB SECAV","NEWVCCHECK")="<masked>"
"RTN","XOBSCAV",98,0)
 .DO ^%ZTER
"RTN","XOBSCAV",99,0)
 KILL XOBDATA("XOB SECAV")
"RTN","XOBSCAV",100,0)
 QUIT
"RTN","XOBSCAV",101,0)
 ;
"RTN","XOBSCAV",102,0)
POSTTXT(XOBRET,XOBMSG) ; -- adds the post-sign-in-text to a message being prepared
"RTN","XOBSCAV",103,0)
 NEW XOBI,XOBLINE,XOBCNT
"RTN","XOBSCAV",104,0)
 SET XOBCNT="",XOBLINE=1 FOR  SET XOBCNT=$ORDER(XOBMSG(XOBCNT)) QUIT:XOBCNT']""  SET XOBLINE=XOBCNT
"RTN","XOBSCAV",105,0)
 SET XOBLINE=XOBLINE+1,XOBMSG(XOBLINE)="<PostSignInText>"
"RTN","XOBSCAV",106,0)
 ; only return post sign in text if the signon says that the text line count is > 0
"RTN","XOBSCAV",107,0)
 ; (even if, past XOBRET(5), there are actually messages from the post-sign-in text)
"RTN","XOBSCAV",108,0)
 IF XOBRET(5)>0 DO
"RTN","XOBSCAV",109,0)
 .SET XOBI=5 FOR  SET XOBI=$ORDER(XOBRET(XOBI)) QUIT:XOBI']""  DO
"RTN","XOBSCAV",110,0)
 ..SET XOBLINE=XOBLINE+1,XOBMSG(XOBLINE)="<Line>"_$$CHARCHK^XOBVLIB(XOBRET(XOBI))_"</Line>"
"RTN","XOBSCAV",111,0)
 SET XOBLINE=XOBLINE+1,XOBMSG(XOBLINE)="</PostSignInText>"
"RTN","XOBSCAV",112,0)
 QUIT XOBLINE
"RTN","XOBSCAV",113,0)
 ;
"RTN","XOBSCAV",114,0)
ADDDIVS(XOBRET,XOBMSG) ; -- adds division list to a message being prepared
"RTN","XOBSCAV",115,0)
 NEW XOBI,XOBLINE,XOBCNT,XOBDEF
"RTN","XOBSCAV",116,0)
 SET XOBCNT="",XOBLINE=1 FOR  SET XOBCNT=$ORDER(XOBMSG(XOBCNT)) QUIT:XOBCNT']""  SET XOBLINE=XOBCNT
"RTN","XOBSCAV",117,0)
 ;
"RTN","XOBSCAV",118,0)
 SET XOBDEF=$ORDER(^VA(200,DUZ,2,"AX1",1,"")) ; default division if any. Use of ^VA(200,,2,"AX1"): DBIA #4058
"RTN","XOBSCAV",119,0)
 SET XOBLINE=XOBLINE+1,XOBMSG(XOBLINE)="<"_$PIECE($TEXT(PARTTAG),";;",2)_" needDivisionSelection=""true"">"
"RTN","XOBSCAV",120,0)
 SET XOBLINE=XOBLINE+1,XOBMSG(XOBLINE)="<Divisions>"
"RTN","XOBSCAV",121,0)
 SET XOBI=0 FOR  SET XOBI=$ORDER(XOBDIVS(XOBI)) QUIT:XOBI']""  DO
"RTN","XOBSCAV",122,0)
 .SET XOBLINE=XOBLINE+1,XOBMSG(XOBLINE)="<Division ien="""_$PIECE(XOBDIVS(XOBI),U)_""" divName="""_$$CHARCHK^XOBVLIB($PIECE(XOBDIVS(XOBI),U,2))_""" divNumber="""_$$CHARCHK^XOBVLIB($PIECE(XOBDIVS(XOBI),U,3))_""""
"RTN","XOBSCAV",123,0)
 .SET:($PIECE(XOBDIVS(XOBI),U)=XOBDEF) XOBMSG(XOBLINE)=XOBMSG(XOBLINE)_" default=""true"" "
"RTN","XOBSCAV",124,0)
 .SET XOBMSG(XOBLINE)=XOBMSG(XOBLINE)_" />"
"RTN","XOBSCAV",125,0)
 SET XOBLINE=XOBLINE+1,XOBMSG(XOBLINE)="</Divisions>"
"RTN","XOBSCAV",126,0)
 SET XOBLINE=XOBLINE+1,XOBMSG(XOBLINE)="   </"_$PIECE($TEXT(PARTTAG),";;",2)_">"
"RTN","XOBSCAV",127,0)
 ;
"RTN","XOBSCAV",128,0)
 QUIT XOBLINE
"RTN","XOBSCAV",129,0)
 ;
"RTN","XOBSCAV",130,0)
LOGGEDON() ; -- checks if the environment was previously properly set up, e.g.,
"RTN","XOBSCAV",131,0)
 ; logon succeeded in some previous call
"RTN","XOBSCAV",132,0)
 QUIT +$GET(DUZ)
"RTN","XOBSCAV",133,0)
 ;
"RTN","XOBSCAV",134,0)
CRCONTXT(XOBOPTNM) ; -- create the context if it doesn't already exist
"RTN","XOBSCAV",135,0)
 ; INPUT VALUE: XOBOPTNM encoded with Kernel encoding algorithm
"RTN","XOBSCAV",136,0)
 ; RETURN VALUE: +result will be 1 if successful, or 0 if unsuccessful
"RTN","XOBSCAV",137,0)
 ; if unsuccessful, result may (or may not) also contain the textual reason for failure
"RTN","XOBSCAV",138,0)
 ; 
"RTN","XOBSCAV",139,0)
 ; Accessing, Setting and Killing of XQY and XQY0: DBIA #4059
"RTN","XOBSCAV",140,0)
 ; 
"RTN","XOBSCAV",141,0)
 NEW XOBRSLT,XOBOPTN1
"RTN","XOBSCAV",142,0)
 ;
"RTN","XOBSCAV",143,0)
 SET XOBOPTN1=$$DECRYP^XUSRB1(XOBOPTNM)
"RTN","XOBSCAV",144,0)
 ; -- if context already set, quit 1
"RTN","XOBSCAV",145,0)
 IF $LENGTH($GET(XQY0)),XQY0=XOBOPTN1 QUIT 1
"RTN","XOBSCAV",146,0)
 ; -- if param is empty string, then kill off the context
"RTN","XOBSCAV",147,0)
 IF XOBOPTN1="" KILL XQY0,XQY QUIT 1
"RTN","XOBSCAV",148,0)
 ; -- otherwise try to create the context
"RTN","XOBSCAV",149,0)
 DO CRCONTXT^XWBSEC(.XOBRSLT,XOBOPTNM) ; use of CRCONTXT^XWBSEC: DBIA #4053
"RTN","XOBSCAV",150,0)
 ; -- return the result
"RTN","XOBSCAV",151,0)
 QUIT XOBRSLT
"RTN","XOBSCAV",152,0)
 ;
"RTN","XOBSCAV",153,0)
CHKCTXT(XOBRPCNM) ; -- does user have access to RPC?
"RTN","XOBSCAV",154,0)
 NEW XWBSEC
"RTN","XOBSCAV",155,0)
 DO CHKPRMIT^XWBSEC(XOBRPCNM) ; use of CHKPRMIT^XWBSEC: DBIA # 4053
"RTN","XOBSCAV",156,0)
 QUIT:'+$LENGTH($GET(XWBSEC)) 1
"RTN","XOBSCAV",157,0)
 QUIT XWBSEC
"RTN","XOBSCAV",158,0)
 ;
"RTN","XOBSCAV",159,0)
 ; ==== Constants ====
"RTN","XOBSCAV",160,0)
 ; 
"RTN","XOBSCAV",161,0)
MSGTYP(XOBRQRS) ; return request message type
"RTN","XOBSCAV",162,0)
 IF XOBRQRS="request" QUIT $PIECE($TEXT(REQTYPE),";;",2)
"RTN","XOBSCAV",163,0)
 IF XOBRQRS="response" QUIT $PIECE($TEXT(RESTYPE),";;",2)
"RTN","XOBSCAV",164,0)
 IF XOBRQRS="error" QUIT $PIECE($TEXT(ERRTYPE),";;",2)
"RTN","XOBSCAV",165,0)
 QUIT ""
"RTN","XOBSCAV",166,0)
SUCCESS() ; resulttype
"RTN","XOBSCAV",167,0)
 QUIT $PIECE($TEXT(RESTYPES+1),";;",2)
"RTN","XOBSCAV",168,0)
FAILURE() ;
"RTN","XOBSCAV",169,0)
 QUIT $PIECE($TEXT(RESTYPES+2),";;",2)
"RTN","XOBSCAV",170,0)
PARTIAL() ;
"RTN","XOBSCAV",171,0)
 QUIT $PIECE($TEXT(RESTYPES+3),";;",2)
"RTN","XOBSCAV",172,0)
 ;
"RTN","XOBSCAV",173,0)
RESTYPES ;Result types
"RTN","XOBSCAV",174,0)
 ;;success
"RTN","XOBSCAV",175,0)
 ;;failure
"RTN","XOBSCAV",176,0)
 ;;partialSuccess
"RTN","XOBSCAV",177,0)
 ;
"RTN","XOBSCAV",178,0)
 ;Message types
"RTN","XOBSCAV",179,0)
REQTYPE ;;gov.va.med.foundations.security.request
"RTN","XOBSCAV",180,0)
RESTYPE ;;gov.va.med.foundations.security.response
"RTN","XOBSCAV",181,0)
ERRTYPE ;;gov.va.med.foundations.security.fault
"RTN","XOBSCAV",182,0)
 ;
"RTN","XOBSCAV",183,0)
 ;Message response types
"RTN","XOBSCAV",184,0)
MSGSETUP ;;AV.SetupAndIntroText
"RTN","XOBSCAV",185,0)
MSGLGON ;;AV.Logon
"RTN","XOBSCAV",186,0)
MSGLGOUT ;;AV.Logout
"RTN","XOBSCAV",187,0)
MSGSELDV ;;AV.SelectDivision
"RTN","XOBSCAV",188,0)
MSGUPDVC ;;AV.UpdateVC
"RTN","XOBSCAV",189,0)
MSGUSERD ;;AV.GetUserDemographics
"RTN","XOBSCAV",190,0)
 ;
"RTN","XOBSCAV",191,0)
 ;Attribute values for response XML messages
"RTN","XOBSCAV",192,0)
VRSNSEC ;;1.0
"RTN","XOBSCAV",193,0)
 ;
"RTN","XOBSCAV",194,0)
 ;XML Tag names
"RTN","XOBSCAV",195,0)
PARTTAG ;;PartialSuccessData
"RTN","XOBSCAV",196,0)
MSGTAG ;;Message
"RTN","XOBSCAV",197,0)
 ;
"RTN","XOBSCAV",198,0)
 ;XML Schemas
"RTN","XOBSCAV",199,0)
SCHERROR ;;secFault.xsd
"RTN","XOBSCAV",200,0)
SCHLGON ;;secLogonResponse.xsd
"RTN","XOBSCAV",201,0)
SCHPARTS ;;secPartialSuccessResponse.xsd
"RTN","XOBSCAV",202,0)
SCHSETUP ;;secSetupIntroResponse.xsd
"RTN","XOBSCAV",203,0)
SCHSIMPL ;;secSimpleResponse.xsd
"RTN","XOBSCAV",204,0)
SCHUSERD ;;secUserDemographicsResponse.xsd
"RTN","XOBSCAV",205,0)
 ;
"RTN","XOBSCAV",206,0)
 ;Faultcodes
"RTN","XOBSCAV",207,0)
FSERVER ;;Server
"RTN","XOBSCAV",208,0)
FCLIENT ;;Client
"RTN","XOBSCAV",209,0)
FVERSION ;;VersionMismatch
"RTN","XOBSCAV",210,0)
FUNDERST ;;MustUnderstand
"RTN","XOBSCAV1")
0^2^B81688032
"RTN","XOBSCAV1",1,0)
XOBSCAV1 ;; kec/oak - VistaLink Access/Verify Security ; 12/09/2002  17:00
"RTN","XOBSCAV1",2,0)
 ;;1.6;VistALink Security;;May 08, 2009;Build 15
"RTN","XOBSCAV1",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBSCAV1",4,0)
 QUIT
"RTN","XOBSCAV1",5,0)
 ; 
"RTN","XOBSCAV1",6,0)
 ; Access/Verify Security: Security Message Request Handler
"RTN","XOBSCAV1",7,0)
 ; specific message request/response pairs)  
"RTN","XOBSCAV1",8,0)
 ; 
"RTN","XOBSCAV1",9,0)
 ; ** Setting/Killing of DUZ covered by blanket SAC Kernel exemption for Foundations
"RTN","XOBSCAV1",10,0)
 ; 
"RTN","XOBSCAV1",11,0)
 ; ::AV.SetupAndIntroText.Request message processing
"RTN","XOBSCAV1",12,0)
SENDITXT ; Do Setup and send Intro Text
"RTN","XOBSCAV1",13,0)
 NEW XOBSTINF,XOBMSG,XOBTMP,XOBTMP1,XOBCCMSK,XOBI,XOBPROD
"RTN","XOBSCAV1",14,0)
 ;
"RTN","XOBSCAV1",15,0)
 ; define XWBTIP early so present in any error logs
"RTN","XOBSCAV1",16,0)
 ; NOTE: $$GETPEER^%ZOSV fails for TCP_SERVICES listeners if COM file doesn't set up VISTA$IP logical
"RTN","XOBSCAV1",17,0)
 ; 
"RTN","XOBSCAV1",18,0)
 SET XWBTIP=$$GETPEER^%ZOSV ; XWBTIP needed by SETUP^XUSRB. Use of GETPEER^%ZOSV: DBIA #4056
"RTN","XOBSCAV1",19,0)
 ; set ip from msg if not provided by OS
"RTN","XOBSCAV1",20,0)
 SET:'$LENGTH(XWBTIP) XWBTIP=XOBDATA("CLIENTIP")
"RTN","XOBSCAV1",21,0)
 ;
"RTN","XOBSCAV1",22,0)
 IF $$PRODMISM() DO  QUIT
"RTN","XOBSCAV1",23,0)
 . NEW XOBSPAR SET XOBSPAR(1)=$GET(XOBDATA("CLIENTISPRODUCTION")),XOBSPAR(2)=$SELECT($$PROD^XUPROD(0):"true",1:"false")
"RTN","XOBSCAV1",24,0)
 . DO ERROR^XOBSCAV(.XOBR,$PIECE($TEXT(FSERVER^XOBSCAV),";;",2),"Production-Test Mismatch",183007,$$CHARCHK^XOBVLIB($$EZBLD^DIALOG(183007,.XOBSPAR)))
"RTN","XOBSCAV1",25,0)
 ;
"RTN","XOBSCAV1",26,0)
 IF $$STATMISM() DO  QUIT
"RTN","XOBSCAV1",27,0)
 . NEW XOBSPAR SET XOBSPAR(1)=$GET(XOBDATA("CLIENTPRIMARYSTATION")),XOBSPAR(2)=XOBSYS("PRIMARY STATION#")
"RTN","XOBSCAV1",28,0)
 . DO ERROR^XOBSCAV(.XOBR,$PIECE($TEXT(FSERVER^XOBSCAV),";;",2),"Primary Station Mismatch",183010,$$CHARCHK^XOBVLIB($$EZBLD^DIALOG(183010,.XOBSPAR)))
"RTN","XOBSCAV1",29,0)
 ;
"RTN","XOBSCAV1",30,0)
 ; seq: SETUP^XUSRB, then INTRO^XUSRB
"RTN","XOBSCAV1",31,0)
 ; 
"RTN","XOBSCAV1",32,0)
 USE XOBNULL ; protect against direct writes to socket
"RTN","XOBSCAV1",33,0)
 ; note: SETUP^XUSRB sets current IO to null device
"RTN","XOBSCAV1",34,0)
 ; 
"RTN","XOBSCAV1",35,0)
 IF XOBSYS("ENV")="j2ee" DO
"RTN","XOBSCAV1",36,0)
 . DO SETUP^XUSRB(.XOBSTINF,"") ; use of SETUP^XUSRB: DBIA #4054
"RTN","XOBSCAV1",37,0)
 ELSE  DO  QUIT:$GET(DUZ)>0
"RTN","XOBSCAV1",38,0)
 . SET XWBVER=1.1 ; to allow VistaLink to contact client agent
"RTN","XOBSCAV1",39,0)
 . DO SETUP^XUSRB(.XOBSTINF,"") ; use of SETUP^XUSRB: DBIA #4054
"RTN","XOBSCAV1",40,0)
 . ; start of auto-signon support
"RTN","XOBSCAV1",41,0)
 . SET DUZ=$$AUTOXWB^XUS1B() IF DUZ<1 KILL DUZ ; use of $$AUTOXWB^XUS1B: DBIA #4060
"RTN","XOBSCAV1",42,0)
 . IF $GET(DUZ)>0 DO NOW^XUSRB SET XUMSG=$$POST^XUSRB(0) IF XUMSG>0 KILL DUZ ; XUSRB calls: DBIA #4061
"RTN","XOBSCAV1",43,0)
 . ; do autosignon and quit if DUZ is set
"RTN","XOBSCAV1",44,0)
 . IF $GET(DUZ)>0 DO  QUIT
"RTN","XOBSCAV1",45,0)
 . .USE XOBPORT ; restore current IO (the TCP port)
"RTN","XOBSCAV1",46,0)
 . .SET XOBRET(5)=0 DO LOGFIN
"RTN","XOBSCAV1",47,0)
 . .QUIT
"RTN","XOBSCAV1",48,0)
 . KILL XWBVER ; once auto-signon fails, don't need to contact client agent
"RTN","XOBSCAV1",49,0)
 . ; end of autosignon support
"RTN","XOBSCAV1",50,0)
 ;
"RTN","XOBSCAV1",51,0)
 ;if failed autosignon, continue w/intro text
"RTN","XOBSCAV1",52,0)
 ; ** use of USE command covered by blanket SAC Kernel exemption for Foundations
"RTN","XOBSCAV1",53,0)
 USE XOBPORT ; restore current IO (the TCP port)
"RTN","XOBSCAV1",54,0)
 ;
"RTN","XOBSCAV1",55,0)
 SET XOBMSG(1)="<SetupInfo serverName='"_$$CHARCHK^XOBVLIB(XOBSTINF(0))_"' volume='"
"RTN","XOBSCAV1",56,0)
 ; note: next line, "dtime" attribute value is not DTIME, but is the VistaLink heartbeat rate.
"RTN","XOBSCAV1",57,0)
 ;       this is used by the J2SE client code to time out the client dialogs.
"RTN","XOBSCAV1",58,0)
 ;       Value may be replaced w/a signon-specific site parameter later.
"RTN","XOBSCAV1",59,0)
 SET XOBMSG(1)=XOBMSG(1)_$$CHARCHK^XOBVLIB(XOBSTINF(1))_"' uci='"_$$CHARCHK^XOBVLIB(XOBSTINF(2))_"' device='"_$$CHARCHK^XOBVLIB(XOBSTINF(3))_"' numberAttempts='"_$$CHARCHK^XOBVLIB(XOBSTINF(4))_"' dtime='"_$$GETRATE^XOBVLIB()_"'/>"
"RTN","XOBSCAV1",60,0)
 ; add intro text
"RTN","XOBSCAV1",61,0)
 DO GETINTRO^XOBSCAV2("XOBMSG",2)
"RTN","XOBSCAV1",62,0)
 ;
"RTN","XOBSCAV1",63,0)
 DO SENDSEC^XOBSCAV(.XOBR,$PIECE($TEXT(RESTYPE^XOBSCAV),";;",2),$PIECE($TEXT(MSGSETUP^XOBSCAV),";;",2),.XOBMSG,$$SUCCESS^XOBSCAV(),$PIECE($TEXT(SCHSETUP^XOBSCAV),";;",2))
"RTN","XOBSCAV1",64,0)
 QUIT
"RTN","XOBSCAV1",65,0)
 ; ::AV.Logon.Request message processing
"RTN","XOBSCAV1",66,0)
LOGON ; process login request
"RTN","XOBSCAV1",67,0)
 NEW XOBAC,XOBVC,XOBRET,XOBRETDV
"RTN","XOBSCAV1",68,0)
 ;
"RTN","XOBSCAV1",69,0)
 IF $$LOGGEDON^XOBSCAV DO  QUIT
"RTN","XOBSCAV1",70,0)
 .DO ERROR^XOBSCAV(.XOBR,$PIECE($TEXT(FSERVER^XOBSCAV),";;",2),"Server Partition State",183003,$$CHARCHK^XOBVLIB($$EZBLD^DIALOG(183003)))
"RTN","XOBSCAV1",71,0)
 ;
"RTN","XOBSCAV1",72,0)
 KILL DUZ ; if DUZ is around, it shouldn't be.
"RTN","XOBSCAV1",73,0)
 USE XOBNULL ; protect against direct writes to socket
"RTN","XOBSCAV1",74,0)
 ; try to logon w/avcodes
"RTN","XOBSCAV1",75,0)
 DO VALIDAV^XUSRB(.XOBRET,XOBDATA("XOB SECAV","AVCODE")) ; use of VALIDAV^XUSRB: DBIA#4054
"RTN","XOBSCAV1",76,0)
 KILL XOBDATA("XOB SECAV","AVCODE")
"RTN","XOBSCAV1",77,0)
 USE XOBPORT ; restore current IO (the TCP port)
"RTN","XOBSCAV1",78,0)
 ;
"RTN","XOBSCAV1",79,0)
 ; if bad a/v code credentials
"RTN","XOBSCAV1",80,0)
 IF '+XOBRET(0),'+XOBRET(1),'+XOBRET(2) DO  QUIT
"RTN","XOBSCAV1",81,0)
 . ; look for particular error string which means IP is locked
"RTN","XOBSCAV1",82,0)
 . IF $GET(XOBRET(3))["Device/IP address is locked due" DO ERROR^XOBSCAV(.XOBR,$PIECE($TEXT(FSERVER^XOBSCAV),";;",2),"Logon Failed",182306,$$CHARCHK^XOBVLIB($$EZBLD^DIALOG(182306,$GET(XOBRET(3))))) QUIT
"RTN","XOBSCAV1",83,0)
 . IF XOBSYS("ENV")="j2ee" DO ERROR^XOBSCAV(.XOBR,$PIECE($TEXT(FSERVER^XOBSCAV),";;",2),"Connector Proxy User Error",183008,$$CHARCHK^XOBVLIB($$EZBLD^DIALOG(183008,$GET(XOBRET(3))))) QUIT
"RTN","XOBSCAV1",84,0)
 . ELSE  DO LOGBADCD
"RTN","XOBSCAV1",85,0)
 ;
"RTN","XOBSCAV1",86,0)
 ; if Kernel says user needs to change verify code
"RTN","XOBSCAV1",87,0)
 IF '+XOBRET(0),'+XOBRET(1),XOBRET(2) DO LOGCVC QUIT
"RTN","XOBSCAV1",88,0)
 ;
"RTN","XOBSCAV1",89,0)
 IF '+XOBRET(0) DO  QUIT  ; there was an error
"RTN","XOBSCAV1",90,0)
 .NEW XOBSPAR
"RTN","XOBSCAV1",91,0)
 .SET XOBSPAR(1)=$GET(XOBRET(3))
"RTN","XOBSCAV1",92,0)
 .; look for particular error string which means too many invalid signon attempts
"RTN","XOBSCAV1",93,0)
 .IF XOBSPAR(1)["too many invalid sign" DO ERROR^XOBSCAV(.XOBR,$PIECE($TEXT(FSERVER^XOBSCAV),";;",2),"Logon Failed",183005,$$CHARCHK^XOBVLIB($$EZBLD^DIALOG(183005,.XOBSPAR))) QUIT
"RTN","XOBSCAV1",94,0)
 .DO ERROR^XOBSCAV(.XOBR,$PIECE($TEXT(FSERVER^XOBSCAV),";;",2),"Logon Failed",183004,$$CHARCHK^XOBVLIB($$EZBLD^DIALOG(183004,.XOBSPAR)))
"RTN","XOBSCAV1",95,0)
 ;
"RTN","XOBSCAV1",96,0)
 ; if user requested to change verify code
"RTN","XOBSCAV1",97,0)
 IF XOBDATA("XOB SECAV","REQUESTCVC")="true" DO LOGCVC QUIT
"RTN","XOBSCAV1",98,0)
 ;
"RTN","XOBSCAV1",99,0)
 ; if j2ee, test for connector proxy user
"RTN","XOBSCAV1",100,0)
 IF XOBSYS("ENV")="j2ee" QUIT:'$$ISCPROXY()
"RTN","XOBSCAV1",101,0)
 ;
"RTN","XOBSCAV1",102,0)
 ; at this point login was successful
"RTN","XOBSCAV1",103,0)
 DO LOGFIN
"RTN","XOBSCAV1",104,0)
 QUIT
"RTN","XOBSCAV1",105,0)
LOGFIN ; check the divisions, finish login now
"RTN","XOBSCAV1",106,0)
 NEW XOBRETDV DO DIVGET^XUSRB2(.XOBRETDV,DUZ) ; use of DIVGET^XUSRB2: DBIA #4055
"RTN","XOBSCAV1",107,0)
 IF '+XOBRETDV(0) DO  QUIT
"RTN","XOBSCAV1",108,0)
 . DO LOGOK
"RTN","XOBSCAV1",109,0)
 . DO DUZSV^XOBVSYSI(.DUZ)
"RTN","XOBSCAV1",110,0)
 ; otherwise this is a multidivisional user
"RTN","XOBSCAV1",111,0)
 DO LOGSELDV(.XOBRETDV)
"RTN","XOBSCAV1",112,0)
 QUIT
"RTN","XOBSCAV1",113,0)
LOGBADCD ; response if bad a/v code pair
"RTN","XOBSCAV1",114,0)
 NEW XOBMSG
"RTN","XOBSCAV1",115,0)
 SET XOBMSG(1)="<"_$PIECE($TEXT(MSGTAG^XOBSCAV),";;",2)_">"_$$CHARCHK^XOBVLIB(XOBRET(3))_"</"_$PIECE($TEXT(MSGTAG^XOBSCAV),";;",2)_">"
"RTN","XOBSCAV1",116,0)
 DO SENDSEC^XOBSCAV(.XOBR,$PIECE($TEXT(RESTYPE^XOBSCAV),";;",2),$PIECE($TEXT(MSGLGON^XOBSCAV),";;",2),.XOBMSG,$$FAILURE^XOBSCAV(),$PIECE($TEXT(SCHSIMPL^XOBSCAV),";;",2))
"RTN","XOBSCAV1",117,0)
 QUIT
"RTN","XOBSCAV1",118,0)
LOGCVC ; response if need to change vc
"RTN","XOBSCAV1",119,0)
 NEW XOBMSG,XOBLINE
"RTN","XOBSCAV1",120,0)
 SET XOBLINE=$$POSTTXT^XOBSCAV(.XOBRET,.XOBMSG)
"RTN","XOBSCAV1",121,0)
 SET XOBMSG(XOBLINE+1)="<"_$PIECE($TEXT(PARTTAG^XOBSCAV),";;",2)_" changeVerify=""true"" cvcHelpText="""_$$CHARCHK^XOBVLIB($$AVHLPTXT^XUS2())_""" />" ; use of AVHLPTXT^XUS2: DBIA #4057
"RTN","XOBSCAV1",122,0)
 SET XOBMSG(XOBLINE+2)="<"_$PIECE($TEXT(MSGTAG^XOBSCAV),";;",2)_">"_$$CHARCHK^XOBVLIB(XOBRET(3))_"</"_$PIECE($TEXT(MSGTAG^XOBSCAV),";;",2)_">"
"RTN","XOBSCAV1",123,0)
 DO SENDSEC^XOBSCAV(.XOBR,$PIECE($TEXT(RESTYPE^XOBSCAV),";;",2),$PIECE($TEXT(MSGLGON^XOBSCAV),";;",2),.XOBMSG,$$PARTIAL^XOBSCAV(),$PIECE($TEXT(SCHPARTS^XOBSCAV),";;",2))
"RTN","XOBSCAV1",124,0)
 QUIT
"RTN","XOBSCAV1",125,0)
LOGSELDV(XOBDIVS) ; response if need to select division
"RTN","XOBSCAV1",126,0)
 ;XOBDIVS is in format of output from DIVGET^XUSRB2
"RTN","XOBSCAV1",127,0)
 NEW XOBMSG,XOBLINE
"RTN","XOBSCAV1",128,0)
 SET XOBLINE=$$POSTTXT^XOBSCAV(.XOBRET,.XOBMSG)
"RTN","XOBSCAV1",129,0)
 SET XOBLINE=$$ADDDIVS^XOBSCAV(.XOBDIVS,.XOBMSG)
"RTN","XOBSCAV1",130,0)
 DO SENDSEC^XOBSCAV(.XOBR,$PIECE($TEXT(RESTYPE^XOBSCAV),";;",2),$PIECE($TEXT(MSGLGON^XOBSCAV),";;",2),.XOBMSG,$$PARTIAL^XOBSCAV(),$PIECE($TEXT(SCHPARTS^XOBSCAV),";;",2))
"RTN","XOBSCAV1",131,0)
 QUIT
"RTN","XOBSCAV1",132,0)
LOGOK ; response if everything's looking good
"RTN","XOBSCAV1",133,0)
 NEW XOBMSG,XOBLINE
"RTN","XOBSCAV1",134,0)
 SET XOBLINE=$$POSTTXT^XOBSCAV(.XOBRET,.XOBMSG)
"RTN","XOBSCAV1",135,0)
 DO SENDSEC^XOBSCAV(.XOBR,$PIECE($TEXT(RESTYPE^XOBSCAV),";;",2),$PIECE($TEXT(MSGLGON^XOBSCAV),";;",2),.XOBMSG,$$SUCCESS^XOBSCAV(),$PIECE($TEXT(SCHLGON^XOBSCAV),";;",2))
"RTN","XOBSCAV1",136,0)
 QUIT
"RTN","XOBSCAV1",137,0)
 ; ::AV.Logout.Request message processing
"RTN","XOBSCAV1",138,0)
LOGOUT ; logout
"RTN","XOBSCAV1",139,0)
 USE XOBNULL ; protect against direct writes to socket
"RTN","XOBSCAV1",140,0)
 ; do the logout
"RTN","XOBSCAV1",141,0)
 DO CLEAN
"RTN","XOBSCAV1",142,0)
 USE XOBPORT ; restore current IO (the TCP port)
"RTN","XOBSCAV1",143,0)
 NEW XOBMSG
"RTN","XOBSCAV1",144,0)
 DO SENDSEC^XOBSCAV(.XOBR,$PIECE($TEXT(RESTYPE^XOBSCAV),";;",2),$PIECE($TEXT(MSGLGOUT^XOBSCAV),";;",2),.XOBMSG,$$SUCCESS^XOBSCAV(),$PIECE($TEXT(SCHSIMPL^XOBSCAV),";;",2))
"RTN","XOBSCAV1",145,0)
 QUIT
"RTN","XOBSCAV1",146,0)
 ; ::Logout to call if connection has timed out
"RTN","XOBSCAV1",147,0)
CLEAN ; logout
"RTN","XOBSCAV1",148,0)
 DO LOGOUT^XUSRB ; use of LOGOUT^XUSRB: DBIA #4054
"RTN","XOBSCAV1",149,0)
 QUIT
"RTN","XOBSCAV1",150,0)
 ; ::AV.SelectDivision.Request message processing
"RTN","XOBSCAV1",151,0)
DIVSLCT ; select division
"RTN","XOBSCAV1",152,0)
 NEW XOBRET
"RTN","XOBSCAV1",153,0)
 ;
"RTN","XOBSCAV1",154,0)
 IF '+DUZ DO DIVSLCT0("User did not complete the access/verify code login process.") QUIT  ; need DUZ
"RTN","XOBSCAV1",155,0)
 DO DIVSET^XUSRB2(.XOBRET,"`"_XOBDATA("XOB SECAV","SELECTEDDIVISION")) ; use of DIVSET^XUSRB2: DBIA #4055
"RTN","XOBSCAV1",156,0)
 IF +XOBRET DO  QUIT
"RTN","XOBSCAV1",157,0)
 . DO DIVSLCT1
"RTN","XOBSCAV1",158,0)
 . DO DUZSV^XOBVSYSI(.DUZ)
"RTN","XOBSCAV1",159,0)
 DO DIVSLCT0("division not found for this user.")
"RTN","XOBSCAV1",160,0)
 QUIT
"RTN","XOBSCAV1",161,0)
 ;
"RTN","XOBSCAV1",162,0)
DIVSLCT0(XOBTEXT) ; send 
"RTN","XOBSCAV1",163,0)
 NEW XOBMSG
"RTN","XOBSCAV1",164,0)
 SET XOBMSG(1)="<"_$PIECE($TEXT(MSGTAG^XOBSCAV),";;",2)_">"_$$CHARCHK^XOBVLIB(XOBTEXT)_"</"_$PIECE($TEXT(MSGTAG^XOBSCAV),";;",2)_">"
"RTN","XOBSCAV1",165,0)
 DO SENDSEC^XOBSCAV(.XOBR,$PIECE($TEXT(RESTYPE^XOBSCAV),";;",2),$PIECE($TEXT(MSGSELDV^XOBSCAV),";;",2),.XOBMSG,$$FAILURE^XOBSCAV(),$PIECE($TEXT(SCHSIMPL^XOBSCAV),";;",2))
"RTN","XOBSCAV1",166,0)
 QUIT
"RTN","XOBSCAV1",167,0)
 ;
"RTN","XOBSCAV1",168,0)
DIVSLCT1 ; success
"RTN","XOBSCAV1",169,0)
 NEW XOBMSG
"RTN","XOBSCAV1",170,0)
 DO SENDSEC^XOBSCAV(.XOBR,$PIECE($TEXT(RESTYPE^XOBSCAV),";;",2),$PIECE($TEXT(MSGSELDV^XOBSCAV),";;",2),.XOBMSG,$$SUCCESS^XOBSCAV(),$PIECE($TEXT(SCHSIMPL^XOBSCAV),";;",2))
"RTN","XOBSCAV1",171,0)
 QUIT
"RTN","XOBSCAV1",172,0)
 ;
"RTN","XOBSCAV1",173,0)
PRODMISM() ; returns 1 if production mismatch, 0 if not
"RTN","XOBSCAV1",174,0)
 IF XOBSYS("ENV")'="j2ee" QUIT 0 ; skip in c/s mode
"RTN","XOBSCAV1",175,0)
 SET XOBPROD=$SELECT($GET(XOBDATA("CLIENTISPRODUCTION"))="true":1,1:0)
"RTN","XOBSCAV1",176,0)
 IF '(XOBPROD=$$PROD^XUPROD(0)) QUIT 1
"RTN","XOBSCAV1",177,0)
 QUIT 0
"RTN","XOBSCAV1",178,0)
 ;
"RTN","XOBSCAV1",179,0)
STATMISM() ; return 1 if primary station mismatch, 0 if not
"RTN","XOBSCAV1",180,0)
 IF XOBSYS("ENV")'="j2ee" QUIT 0 ; no checking for c/s mode
"RTN","XOBSCAV1",181,0)
 NEW XOBSTAT
"RTN","XOBSCAV1",182,0)
 ; strip off suffix
"RTN","XOBSCAV1",183,0)
 SET XOBSTAT=$$STRPSUFF($GET(XOBDATA("CLIENTPRIMARYSTATION")))
"RTN","XOBSCAV1",184,0)
 ; compare w/KSP value
"RTN","XOBSCAV1",185,0)
 IF XOBSTAT'=XOBSYS("PRIMARY STATION#") QUIT 1 ;mismatch found
"RTN","XOBSCAV1",186,0)
 QUIT 0
"RTN","XOBSCAV1",187,0)
 ;
"RTN","XOBSCAV1",188,0)
STRPSUFF(XOBSTAT) ; strip alpha suffix from sta# e.g. AAC "200M"
"RTN","XOBSCAV1",189,0)
 SET XOBSTAT=$$TRUNCCH^XOBVSYSI(XOBSTAT)
"RTN","XOBSCAV1",190,0)
 ; nursing home, treat 9 as suffix
"RTN","XOBSCAV1",191,0)
 IF $LENGTH(XOBSTAT)=4,$E(XOBSTAT,4)=9 SET XOBSTAT=$E(XOBSTAT,1,3)
"RTN","XOBSCAV1",192,0)
 QUIT XOBSTAT
"RTN","XOBSCAV1",193,0)
 ;
"RTN","XOBSCAV1",194,0)
ISCPROXY() ; c/proxy check
"RTN","XOBSCAV1",195,0)
 ; returns 1 if c/proxy user, 0 if not
"RTN","XOBSCAV1",196,0)
 NEW XOBCPCHK,XOBOK
"RTN","XOBSCAV1",197,0)
 SET XOBOK=1
"RTN","XOBSCAV1",198,0)
 SET XOBCPCHK=$$CPCHK^XUSAP(+XOBRET(0))
"RTN","XOBSCAV1",199,0)
 IF 'XOBCPCHK DO  SET XOBOK=0
"RTN","XOBSCAV1",200,0)
 . DO ERROR^XOBSCAV(.XOBR,$PIECE($TEXT(FSERVER^XOBSCAV),";;",2),"Connector Proxy User Error",183008,$$CHARCHK^XOBVLIB($$EZBLD^DIALOG(183008,$PIECE($GET(XOBCPCHK),U,2))))
"RTN","XOBSCAV1",201,0)
 QUIT XOBOK
"RTN","XOBSCAV1",202,0)
 ;
"RTN","XOBSCAV2")
0^3^B64619205
"RTN","XOBSCAV2",1,0)
XOBSCAV2 ;; kec/oak - VistaLink Access/Verify Security ; 12/09/2002  17:00
"RTN","XOBSCAV2",2,0)
 ;;1.6;VistALink Security;;May 08, 2009;Build 15
"RTN","XOBSCAV2",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBSCAV2",4,0)
 QUIT
"RTN","XOBSCAV2",5,0)
 ;
"RTN","XOBSCAV2",6,0)
 ; --------------------------------------------------------------------
"RTN","XOBSCAV2",7,0)
 ;      Access/Verify Security: Security Message Request Handler
"RTN","XOBSCAV2",8,0)
 ;   (AV.GetUserDemographics req/resp pairs; XML parser callbacks)
"RTN","XOBSCAV2",9,0)
 ; --------------------------------------------------------------------
"RTN","XOBSCAV2",10,0)
 ;
"RTN","XOBSCAV2",11,0)
 ;==== AV.GetUserDemographics.Request message processing ====
"RTN","XOBSCAV2",12,0)
SENDDEM ; respond to user demographics request
"RTN","XOBSCAV2",13,0)
 IF '$$LOGGEDON^XOBSCAV() DO SENDDEM0("User not logged on.")
"RTN","XOBSCAV2",14,0)
 DO SENDDEM1
"RTN","XOBSCAV2",15,0)
 QUIT
"RTN","XOBSCAV2",16,0)
SENDDEM1 ; success
"RTN","XOBSCAV2",17,0)
 NEW XOBMSG,XOBI,XOBNC,XOBNC1,XOBDIV,XOBRET,XOBERR,XOBTXT
"RTN","XOBSCAV2",18,0)
 ; get ptr to Name Components file
"RTN","XOBSCAV2",19,0)
 DO GETS^DIQ(200,DUZ_",","10.1","I","XOBNC","XOBERR")
"RTN","XOBSCAV2",20,0)
 IF $DATA(XOBERR) DO  QUIT
"RTN","XOBSCAV2",21,0)
 .SET XOBI=0,XOBTXT="FileMan Error: "
"RTN","XOBSCAV2",22,0)
 .FOR  SET XOBI=$ORDER(XOBERR("DIERR",XOBI)) QUIT:'+XOBI  SET XOBTXT=XOBTXT_XOBERR("DIERR",XOBI)_" "_XOBERR("DIERR",XOBI,"TEXT",1)
"RTN","XOBSCAV2",23,0)
 .DO ERROR^XOBSCAV(.XOBR,$PIECE($TEXT(FSERVER^XOBSCAV),";;",2),"Demographics failure",183006,$$CHARCHK^XOBVLIB($$EZBLD^DIALOG(183006,.XOBTXT)))
"RTN","XOBSCAV2",24,0)
 SET XOBNC=XOBNC(200,DUZ_",",10.1,"I")
"RTN","XOBSCAV2",25,0)
 ; get name components -- read access to file 20: DBIA# 3041
"RTN","XOBSCAV2",26,0)
 DO GETS^DIQ(20,XOBNC_",","1:6","","XOBNC1","XOBERR")
"RTN","XOBSCAV2",27,0)
 IF $DATA(XOBERR) DO  QUIT
"RTN","XOBSCAV2",28,0)
 .SET XOBI=0,XOBTXT="FileMan Error: "
"RTN","XOBSCAV2",29,0)
 .FOR  SET XOBI=$ORDER(XOBERR("DIERR",XOBI)) QUIT:'+XOBI  SET XOBTXT=XOBTXT_XOBERR("DIERR",XOBI)_" "_XOBERR("DIERR",XOBI,"TEXT",1)
"RTN","XOBSCAV2",30,0)
 .DO ERROR^XOBSCAV(.XOBR,$PIECE($TEXT(FSERVER^XOBSCAV),";;",2),"Demographics failure",183006,$$CHARCHK^XOBVLIB($$EZBLD^DIALOG(183006,.XOBTXT)))
"RTN","XOBSCAV2",31,0)
 ; get more userinfo from Kernel
"RTN","XOBSCAV2",32,0)
 DO USERINFO^XUSRB2(.XOBRET) ; use of USERINFO^XUSRB2: DBIA #4055
"RTN","XOBSCAV2",33,0)
 ; strip any illegal xml chars from data
"RTN","XOBSCAV2",34,0)
 FOR XOBI=1:1:7 SET XOBRET(XOBI)=$$CHARCHK^XOBVLIB(XOBRET(XOBI))
"RTN","XOBSCAV2",35,0)
 FOR XOBI=1:1:6 SET XOBNC1(20,XOBNC_",",XOBI)=$$CHARCHK^XOBVLIB(XOBNC1(20,XOBNC_",",XOBI))
"RTN","XOBSCAV2",36,0)
 ; format return message
"RTN","XOBSCAV2",37,0)
 SET XOBMSG(1)="<NameInfo prefix='"_XOBNC1(20,XOBNC_",",4)_"' givenFirst='"_XOBNC1(20,XOBNC_",",2)_"' middle='"_XOBNC1(20,XOBNC_",",3)
"RTN","XOBSCAV2",38,0)
 SET XOBMSG(1)=XOBMSG(1)_"' familyLast='"_XOBNC1(20,XOBNC_",",1)_"' suffix='"_XOBNC1(20,XOBNC_",",5)
"RTN","XOBSCAV2",39,0)
 SET XOBMSG(1)=XOBMSG(1)_"' degree='"_XOBNC1(20,XOBNC_",",6)_"' newPerson01Name='"_XOBRET(1)_"' standardConcatenated='"_XOBRET(2)_"' />"
"RTN","XOBSCAV2",40,0)
 SET XOBMSG(2)="<UserInfo duz='"_DUZ_"' title='"_$$CHARCHK^XOBVLIB(XOBRET(4))_"' serviceSection='"_$$CHARCHK^XOBVLIB(XOBRET(5))_"' language='"_$$CHARCHK^XOBVLIB(XOBRET(6))_"' timeout='"_$$CHARCHK^XOBVLIB(XOBRET(7))
"RTN","XOBSCAV2",41,0)
 SET XOBMSG(2)=XOBMSG(2)_"' vpid='"_$$CHARCHK^XOBVLIB($G(XOBRET(8)))_"' />"
"RTN","XOBSCAV2",42,0)
 SET XOBMSG(3)="<Division ien='"_$$CHARCHK^XOBVLIB($PIECE(XOBRET(3),U))_"' divName='"_$$CHARCHK^XOBVLIB($PIECE(XOBRET(3),U,2))_"' divNumber='"_$$CHARCHK^XOBVLIB($PIECE(XOBRET(3),U,3))_"' />"
"RTN","XOBSCAV2",43,0)
 SET XOBMSG(4)="<SiteInfo domainName='"_$$KSP^XUPARAM("WHERE")_"'/>"
"RTN","XOBSCAV2",44,0)
 DO SENDSEC^XOBSCAV(.XOBR,$PIECE($TEXT(RESTYPE^XOBSCAV),";;",2),$PIECE($TEXT(MSGUSERD^XOBSCAV),";;",2),.XOBMSG,$$SUCCESS^XOBSCAV(),$PIECE($TEXT(SCHUSERD^XOBSCAV),";;",2))
"RTN","XOBSCAV2",45,0)
 QUIT
"RTN","XOBSCAV2",46,0)
SENDDEM0(XOBTEXT) ; failure
"RTN","XOBSCAV2",47,0)
 NEW XOBMSG
"RTN","XOBSCAV2",48,0)
 SET XOBMSG(1)="<"_$PIECE($TEXT(MSGTAG^XOBSCAV),";;",2)_">"_$$CHARCHK^XOBVLIB(XOBTEXT)_"</"_$PIECE($TEXT(MSGTAG^XOBSCAV),";;",2)_">"
"RTN","XOBSCAV2",49,0)
 DO SENDSEC^XOBSCAV(.XOBR,$PIECE($TEXT(RESTYPE^XOBSCAV),";;",2),$PIECE($TEXT(MSGUSERD^XOBSCAV),";;",2),.XOBMSG,$$FAILURE^XOBSCAV(),$PIECE($TEXT(SCHSIMPL^XOBSCAV),";;",2))
"RTN","XOBSCAV2",50,0)
 QUIT
"RTN","XOBSCAV2",51,0)
 ;
"RTN","XOBSCAV2",52,0)
 ; ==== SAX Parser Callbacks ====
"RTN","XOBSCAV2",53,0)
 ; 
"RTN","XOBSCAV2",54,0)
ELEST(ELE,ATR) ; -- element start event handler
"RTN","XOBSCAV2",55,0)
 ;
"RTN","XOBSCAV2",56,0)
 IF ELE="VistaLink" DO  QUIT
"RTN","XOBSCAV2",57,0)
 . SET XOBDATA("MODE")=$GET(ATR("mode"),"singleton")
"RTN","XOBSCAV2",58,0)
 . SET XOBDATA("XOB SECAV","SECURITYTYPE")=$GET(ATR("messageType"),"unknown")
"RTN","XOBSCAV2",59,0)
 ;
"RTN","XOBSCAV2",60,0)
 IF ELE="SecurityInfo" DO  QUIT
"RTN","XOBSCAV2",61,0)
 . SET XOBDATA("XOB SECAV","SECURITYVERSION")=$GET(ATR("version"),"unknown")
"RTN","XOBSCAV2",62,0)
 ;
"RTN","XOBSCAV2",63,0)
 IF ELE="Request" DO  QUIT
"RTN","XOBSCAV2",64,0)
 . SET XOBDATA("XOB SECAV","SECURITYACTION")=$GET(ATR("type"),"unknown")
"RTN","XOBSCAV2",65,0)
 . ; get ip from msg if provided
"RTN","XOBSCAV2",66,0)
 . IF "AV.SetupAndIntroText"=XOBDATA("XOB SECAV","SECURITYACTION") DO
"RTN","XOBSCAV2",67,0)
 . . SET XOBDATA("CLIENTIP")=$GET(ATR("clientIp"))
"RTN","XOBSCAV2",68,0)
 ;
"RTN","XOBSCAV2",69,0)
 IF XOBDATA("XOB SECAV","SECURITYTYPE")'=$$MSGTYP^XOBSCAV("request") DO  QUIT
"RTN","XOBSCAV2",70,0)
 .;if not a security request, shouldn't be here
"RTN","XOBSCAV2",71,0)
 .;
"RTN","XOBSCAV2",72,0)
 IF '$DATA(XOBDATA("XOB SECAV","SECURITYACTION")) DO  QUIT
"RTN","XOBSCAV2",73,0)
 .;if haven't processed the "action" yet, shouldn't be here
"RTN","XOBSCAV2",74,0)
 ;
"RTN","XOBSCAV2",75,0)
 IF XOBDATA("XOB SECAV","SECURITYACTION")="AV.SetupAndIntroText" DO  QUIT
"RTN","XOBSCAV2",76,0)
 . IF ELE="productionInfo" DO
"RTN","XOBSCAV2",77,0)
 . . SET XOBDATA("CLIENTISPRODUCTION")=$GET(ATR("clientIsProduction"))
"RTN","XOBSCAV2",78,0)
 . . SET XOBDATA("CLIENTPRIMARYSTATION")=$GET(ATR("clientPrimaryStation"))
"RTN","XOBSCAV2",79,0)
 ;
"RTN","XOBSCAV2",80,0)
 IF XOBDATA("XOB SECAV","SECURITYACTION")="AV.GetUserDemographics" DO  QUIT
"RTN","XOBSCAV2",81,0)
 .; nothing needed
"RTN","XOBSCAV2",82,0)
 .; 
"RTN","XOBSCAV2",83,0)
 IF XOBDATA("XOB SECAV","SECURITYACTION")="AV.Logon" DO  QUIT
"RTN","XOBSCAV2",84,0)
 .IF ELE="avCodes" SET XOBAVCOD=""
"RTN","XOBSCAV2",85,0)
 .SET XOBDATA("XOB SECAV","REQUESTCVC")=$GET(ATR("requestCvc"))
"RTN","XOBSCAV2",86,0)
 ;
"RTN","XOBSCAV2",87,0)
 IF XOBDATA("XOB SECAV","SECURITYACTION")="AV.Logout" DO  QUIT
"RTN","XOBSCAV2",88,0)
 .; nothing needed
"RTN","XOBSCAV2",89,0)
 ;
"RTN","XOBSCAV2",90,0)
 IF XOBDATA("XOB SECAV","SECURITYACTION")="AV.SelectDivision" DO  QUIT
"RTN","XOBSCAV2",91,0)
 .IF ELE="Division" SET XOBDATA("XOB SECAV","SELECTEDDIVISION")=$GET(ATR("ien"))
"RTN","XOBSCAV2",92,0)
 ;
"RTN","XOBSCAV2",93,0)
 IF XOBDATA("XOB SECAV","SECURITYACTION")="AV.UpdateVC" DO  QUIT
"RTN","XOBSCAV2",94,0)
 .IF ELE="oldVc" SET XOBVCOLD="" QUIT
"RTN","XOBSCAV2",95,0)
 .IF ELE="newVc" SET XOBVCNEW="" QUIT
"RTN","XOBSCAV2",96,0)
 .IF ELE="confirmedVc" SET XOBVCCHK="" QUIT
"RTN","XOBSCAV2",97,0)
 ;
"RTN","XOBSCAV2",98,0)
 ;If got here -- an unknown type, ignore.
"RTN","XOBSCAV2",99,0)
 ;
"RTN","XOBSCAV2",100,0)
 QUIT
"RTN","XOBSCAV2",101,0)
 ;
"RTN","XOBSCAV2",102,0)
ELEND(ELE) ; -- element end event handler
"RTN","XOBSCAV2",103,0)
 ;
"RTN","XOBSCAV2",104,0)
 IF ELE="VistaLink" KILL XOBAVCOD,XOBVCOLD,XOBVCNEW,XOBVCCHK QUIT
"RTN","XOBSCAV2",105,0)
 IF $GET(XOBDATA("XOB SECAV","SECURITYACTION"))="AV.Logon",ELE="avCodes" DO  QUIT
"RTN","XOBSCAV2",106,0)
 .SET XOBDATA("XOB SECAV","AVCODE")=XOBAVCOD KILL XOBAVCOD
"RTN","XOBSCAV2",107,0)
 IF $GET(XOBDATA("XOB SECAV","SECURITYACTION"))="AV.UpdateVC" DO  QUIT
"RTN","XOBSCAV2",108,0)
 .IF ELE="oldVc" SET XOBDATA("XOB SECAV","OLDVC")=XOBVCOLD KILL XOBVCOLD QUIT
"RTN","XOBSCAV2",109,0)
 .IF ELE="newVc" SET XOBDATA("XOB SECAV","NEWVC")=XOBVCNEW KILL XOBVCNEW QUIT
"RTN","XOBSCAV2",110,0)
 .IF ELE="confirmedVc" SET XOBDATA("XOB SECAV","NEWVCCHECK")=XOBVCCHK KILL XOBVCCHK QUIT
"RTN","XOBSCAV2",111,0)
 .;shouldn't get here.
"RTN","XOBSCAV2",112,0)
 QUIT
"RTN","XOBSCAV2",113,0)
 ;
"RTN","XOBSCAV2",114,0)
CHR(TEXT) ; -- character value event handler <tag>TEXT</tag)
"RTN","XOBSCAV2",115,0)
 ; -- need to concatenate because MXML parses on ENTITY characters (<>& etc.) and
"RTN","XOBSCAV2",116,0)
 ;    callback gets hit multiple times even though the tag text value is just one piece of data.
"RTN","XOBSCAV2",117,0)
 ;    (Yes, this seems kludgie!)
"RTN","XOBSCAV2",118,0)
 IF $DATA(XOBAVCOD) SET XOBAVCOD=XOBAVCOD_TEXT QUIT
"RTN","XOBSCAV2",119,0)
 IF $DATA(XOBVCOLD) SET XOBVCOLD=XOBVCOLD_TEXT QUIT
"RTN","XOBSCAV2",120,0)
 IF $DATA(XOBVCNEW) SET XOBVCNEW=XOBVCNEW_TEXT QUIT
"RTN","XOBSCAV2",121,0)
 IF $DATA(XOBVCCHK) SET XOBVCCHK=XOBVCCHK_TEXT QUIT
"RTN","XOBSCAV2",122,0)
 QUIT
"RTN","XOBSCAV2",123,0)
  ;==== AV.UpdateVC.Request message processing ====
"RTN","XOBSCAV2",124,0)
SENDNVC ; respond to "change verify code" request. Use of CVC^XUSRB per DBIA #4054
"RTN","XOBSCAV2",125,0)
 NEW XOBRET,XOBRETDV,XOBSDUZ
"RTN","XOBSCAV2",126,0)
 SET XOBSDUZ=DUZ ; save DUZ in case of failure - we need to restore
"RTN","XOBSCAV2",127,0)
 DO CVC^XUSRB(.XOBRET,XOBDATA("XOB SECAV","OLDVC")_U_XOBDATA("XOB SECAV","NEWVC")_U_XOBDATA("XOB SECAV","NEWVCCHECK"))
"RTN","XOBSCAV2",128,0)
 KILL XOBDATA("XOB SECAV","OLDVC"),XOBDATA("XOB SECAV","NEWVC"),XOBDATA("XOB SECAV","NEWVCCHECK")
"RTN","XOBSCAV2",129,0)
 IF +$GET(DUZ) DO  QUIT  ; success changing verify code
"RTN","XOBSCAV2",130,0)
 .; check the divisions now
"RTN","XOBSCAV2",131,0)
 .DO DIVGET^XUSRB2(.XOBRETDV,DUZ) ; use of DIVGET^XUSRB2: DBIA #4055
"RTN","XOBSCAV2",132,0)
 .IF '+XOBRETDV(0) DO SENDNVC1 QUIT
"RTN","XOBSCAV2",133,0)
 .; otherwise this is a multidivisional user
"RTN","XOBSCAV2",134,0)
 .DO SENDNVCD(.XOBRETDV)
"RTN","XOBSCAV2",135,0)
 ; cvc failed
"RTN","XOBSCAV2",136,0)
 SET DUZ=XOBSDUZ ; restore DUZ
"RTN","XOBSCAV2",137,0)
 DO SENDNVC0 ; failure
"RTN","XOBSCAV2",138,0)
 QUIT
"RTN","XOBSCAV2",139,0)
SENDNVC1 ; send verify code update success
"RTN","XOBSCAV2",140,0)
 ;update the vc/finish the logon
"RTN","XOBSCAV2",141,0)
 NEW XOBMSG
"RTN","XOBSCAV2",142,0)
 DO SENDSEC^XOBSCAV(.XOBR,$PIECE($TEXT(RESTYPE^XOBSCAV),";;",2),$PIECE($TEXT(MSGUPDVC^XOBSCAV),";;",2),.XOBMSG,$$SUCCESS^XOBSCAV(),$PIECE($TEXT(SCHSIMPL^XOBSCAV),";;",2))
"RTN","XOBSCAV2",143,0)
 QUIT
"RTN","XOBSCAV2",144,0)
SENDNVC0 ; send verify code update error
"RTN","XOBSCAV2",145,0)
 ;update the vc/finish the logon
"RTN","XOBSCAV2",146,0)
 NEW XOBMSG,XOBI
"RTN","XOBSCAV2",147,0)
 SET XOBMSG(1)="<"_$PIECE($TEXT(MSGTAG^XOBSCAV),";;",2)_">"_$$CHARCHK^XOBVLIB($GET(XOBRET(1)))_"</"_$PIECE($TEXT(MSGTAG^XOBSCAV),";;",2)_">"
"RTN","XOBSCAV2",148,0)
 DO SENDSEC^XOBSCAV(.XOBR,$PIECE($TEXT(RESTYPE^XOBSCAV),";;",2),$PIECE($TEXT(MSGUPDVC^XOBSCAV),";;",2),.XOBMSG,$$FAILURE^XOBSCAV(),$PIECE($TEXT(SCHSIMPL^XOBSCAV),";;",2))
"RTN","XOBSCAV2",149,0)
 QUIT
"RTN","XOBSCAV2",150,0)
SENDNVCD(XOBDIVS) ; send verify code partial success, need divisions
"RTN","XOBSCAV2",151,0)
 ;XOBDIVS is in format of output from DIVGET^XUSRB2
"RTN","XOBSCAV2",152,0)
 NEW XOBMSG,XOBI,XOBLINE
"RTN","XOBSCAV2",153,0)
 SET XOBLINE=$$ADDDIVS^XOBSCAV(.XOBDIVS,.XOBMSG)
"RTN","XOBSCAV2",154,0)
 DO SENDSEC^XOBSCAV(.XOBR,$PIECE($TEXT(RESTYPE^XOBSCAV),";;",2),$PIECE($TEXT(MSGUPDVC^XOBSCAV),";;",2),.XOBMSG,$$PARTIAL^XOBSCAV(),$PIECE($TEXT(SCHPARTS^XOBSCAV),";;",2))
"RTN","XOBSCAV2",155,0)
 QUIT
"RTN","XOBSCAV2",156,0)
 ;
"RTN","XOBSCAV2",157,0)
 ;==== utility functions ====
"RTN","XOBSCAV2",158,0)
 ;
"RTN","XOBSCAV2",159,0)
GETINTRO(XOBSREF,XOBSCNTR) ;
"RTN","XOBSCAV2",160,0)
 ; XOBSREF: variable in which to store intro text (at one level descendant)
"RTN","XOBSCAV2",161,0)
 ; XOBSCNT: integer subscript counter value at which to start storing text
"RTN","XOBSCAV2",162,0)
 ; returns: XOBSREF containing <IntroText> element text with intro text lines in CDATA section
"RTN","XOBSCAV2",163,0)
 ;          XOBSCNT incremented to last subscript at which text was stored (if passed as dot-arg)
"RTN","XOBSCAV2",164,0)
 ; 
"RTN","XOBSCAV2",165,0)
 NEW XOBCCMSK,XOBI,XOBITINF,XOBTMP1
"RTN","XOBSCAV2",166,0)
 ; get intro text
"RTN","XOBSCAV2",167,0)
 DO INTRO^XUSRB(.XOBITINF) ; use of INTRO^XUSRB: DBIA #4054
"RTN","XOBSCAV2",168,0)
 ; set up control character mask
"RTN","XOBSCAV2",169,0)
 SET XOBCCMSK="" FOR XOBI=0:1:8,11,12,14:1:31 SET XOBCCMSK=XOBCCMSK_$CHAR(XOBI)
"RTN","XOBSCAV2",170,0)
 ; populate/format return value
"RTN","XOBSCAV2",171,0)
 SET @XOBSREF@(XOBSCNTR)="<IntroText><![CDATA["
"RTN","XOBSCAV2",172,0)
 SET XOBTMP1=-1 FOR  SET XOBTMP1=$ORDER(XOBITINF(XOBTMP1)) QUIT:XOBTMP1']""  DO
"RTN","XOBSCAV2",173,0)
 .SET XOBSCNTR=XOBSCNTR+1,@XOBSREF@(XOBSCNTR)=$TRANSLATE(XOBITINF(XOBTMP1),XOBCCMSK,"")_"<BR>"
"RTN","XOBSCAV2",174,0)
 SET XOBSCNTR=XOBSCNTR+1,@XOBSREF@(XOBSCNTR)="]]></IntroText>"
"RTN","XOBSCAV2",175,0)
 QUIT
"RTN","XOBSCAV2",176,0)
 ;
"RTN","XOBSCI")
0^4^B583719
"RTN","XOBSCI",1,0)
XOBSCI ;; ld,mjk/alb - VistaLink Interface Implementation ; 07/27/2002  13:00
"RTN","XOBSCI",2,0)
 ;;1.6;VistALink Security;;May 08, 2009;Build 15
"RTN","XOBSCI",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBSCI",4,0)
 ;
"RTN","XOBSCI",5,0)
 ;Implements the VistaLink message framework for messages in the (XOBS) security module.
"RTN","XOBSCI",6,0)
 ;
"RTN","XOBSCI",7,0)
CALLBACK(CB) ; -- init callbacks implementation
"RTN","XOBSCI",8,0)
 SET CB("STARTELEMENT")="ELEST^XOBSCAV2"
"RTN","XOBSCI",9,0)
 SET CB("ENDELEMENT")="ELEND^XOBSCAV2"
"RTN","XOBSCI",10,0)
 SET CB("CHARACTERS")="CHR^XOBSCAV2"
"RTN","XOBSCI",11,0)
 QUIT
"RTN","XOBSCI",12,0)
 ;
"RTN","XOBSCI",13,0)
READER(XOBUF,XOBDATA) ; -- proprietary format reader implementation
"RTN","XOBSCI",14,0)
 QUIT
"RTN","XOBSCI",15,0)
 ;
"RTN","XOBSCI",16,0)
REQHDLR(XOBDATA) ; -- request handler implementation
"RTN","XOBSCI",17,0)
 DO EN^XOBSCAV(.XOBDATA)
"RTN","XOBSCI",18,0)
 QUIT
"RTN","XOBSCI",19,0)
 ;
"RTN","XOBSRA")
0^5^B61930744
"RTN","XOBSRA",1,0)
XOBSRA ;mjk,esd/alb - VistALink Reauthentication Code ; 05/22/2003  07:00
"RTN","XOBSRA",2,0)
 ;;1.6;VistALink Security;;May 08, 2009;Build 15
"RTN","XOBSRA",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBSRA",4,0)
 QUIT
"RTN","XOBSRA",5,0)
 ;
"RTN","XOBSRA",6,0)
 ; ------------------------------------------------------------------------
"RTN","XOBSRA",7,0)
 ;             RPC Server: Reauthentication based on VPID, DUZ, and AV
"RTN","XOBSRA",8,0)
 ; ------------------------------------------------------------------------
"RTN","XOBSRA",9,0)
 ;
"RTN","XOBSRA",10,0)
SETUPDUZ() ; -- get DUZ context and division
"RTN","XOBSRA",11,0)
 ;
"RTN","XOBSRA",12,0)
 NEW XOBERR,XOBID,XOBTYPE
"RTN","XOBSRA",13,0)
 SET (XOBERR,XOBID)=0
"RTN","XOBSRA",14,0)
 ;
"RTN","XOBSRA",15,0)
 ; -- if already authenticated quit
"RTN","XOBSRA",16,0)
 IF $GET(XOBDATA("XOB RPC","SECURITY","STATE"))="authenticated" GOTO SUDQ
"RTN","XOBSRA",17,0)
 ;
"RTN","XOBSRA",18,0)
 ; -- switch to null device
"RTN","XOBSRA",19,0)
 DO NULL
"RTN","XOBSRA",20,0)
 ; -- initialize partition
"RTN","XOBSRA",21,0)
 DO INIT
"RTN","XOBSRA",22,0)
 ;
"RTN","XOBSRA",23,0)
 ; -- check if logons are enabled
"RTN","XOBSRA",24,0)
 SET XOBERR=$$LOGINH()
"RTN","XOBSRA",25,0)
 IF XOBERR DO SOCKET GOTO SUDQ
"RTN","XOBSRA",26,0)
 ;
"RTN","XOBSRA",27,0)
 ; -- reauthenticate user based on type
"RTN","XOBSRA",28,0)
 SET XOBTYPE=$GET(XOBDATA("XOB RPC","SECURITY","TYPE")),XOBTYPE=$$UP^XLFSTR(XOBTYPE)
"RTN","XOBSRA",29,0)
 IF XOBTYPE="DUZ"!(XOBTYPE="AV")!(XOBTYPE="VPID")!(XOBTYPE="CCOW")!(XOBTYPE="APPPROXY") DO
"RTN","XOBSRA",30,0)
 . DO @(XOBTYPE_"(.XOBID,.XOBERR)")
"RTN","XOBSRA",31,0)
 ELSE  DO
"RTN","XOBSRA",32,0)
 . SET XOBERR=182301_U_XOBTYPE_U_"  [Erroneous reauthentication type]"
"RTN","XOBSRA",33,0)
 ;
"RTN","XOBSRA",34,0)
 ; -- check division
"RTN","XOBSRA",35,0)
 IF XOBID SET XOBERR=$$DUZENV(XOBID,XOBTYPE)
"RTN","XOBSRA",36,0)
 ;
"RTN","XOBSRA",37,0)
 ; -- switch back to socket device
"RTN","XOBSRA",38,0)
 DO SOCKET
"RTN","XOBSRA",39,0)
SUDQ ;
"RTN","XOBSRA",40,0)
 ;LOG:: Log error in trap or elsewhere if appropriate. May want to log 'no match' event for security reasons.
"RTN","XOBSRA",41,0)
 IF 'XOBERR DO FINAL
"RTN","XOBSRA",42,0)
 QUIT XOBERR
"RTN","XOBSRA",43,0)
 ;
"RTN","XOBSRA",44,0)
NULL ; switch to null device
"RTN","XOBSRA",45,0)
 USE XOBNULL
"RTN","XOBSRA",46,0)
 QUIT
"RTN","XOBSRA",47,0)
 ;
"RTN","XOBSRA",48,0)
SOCKET ; -- switch back to socket device
"RTN","XOBSRA",49,0)
 ; -- empty write buffer of null device
"RTN","XOBSRA",50,0)
 USE XOBNULL SET DX=0,DY=0 XECUTE ^%ZOSF("XY")
"RTN","XOBSRA",51,0)
 ; -- reset to use tcp port device to send results
"RTN","XOBSRA",52,0)
 USE XOBPORT
"RTN","XOBSRA",53,0)
 QUIT
"RTN","XOBSRA",54,0)
 ;
"RTN","XOBSRA",55,0)
AV(XOBID,XOBERR) ; -- AV (SSO/UC KAAJEE) reauth type
"RTN","XOBSRA",56,0)
 ;
"RTN","XOBSRA",57,0)
 ; More checks performed here; assume this would be called ONCE when user authenticates
"RTN","XOBSRA",58,0)
 ; to application via KAAJEE or FatKAAT
"RTN","XOBSRA",59,0)
 ;
"RTN","XOBSRA",60,0)
 DO AV^XOBSRAKJ(.XOBID,.XOBERR)
"RTN","XOBSRA",61,0)
 QUIT
"RTN","XOBSRA",62,0)
 ;
"RTN","XOBSRA",63,0)
DUZ(XOBID,XOBERR) ; -- DUZ reauth type
"RTN","XOBSRA",64,0)
 ;
"RTN","XOBSRA",65,0)
 NEW XOBCTYPE
"RTN","XOBSRA",66,0)
 SET XOBCTYPE="DUZ"
"RTN","XOBSRA",67,0)
 SET XOBID=$GET(XOBDATA("XOB RPC","SECURITY","TYPE","VALUE"))
"RTN","XOBSRA",68,0)
 ;
"RTN","XOBSRA",69,0)
 ; Active user status check performed here; assume heavier-duty checks done by application
"RTN","XOBSRA",70,0)
 ; when user authenticated to application via KAAJEE, FatKAAT or equivalent.
"RTN","XOBSRA",71,0)
 ;
"RTN","XOBSRA",72,0)
 DO ACTUSR(.XOBID,.XOBERR,XOBCTYPE)
"RTN","XOBSRA",73,0)
 QUIT
"RTN","XOBSRA",74,0)
 ;
"RTN","XOBSRA",75,0)
VPID(XOBID,XOBERR) ; -- VPID reauth type
"RTN","XOBSRA",76,0)
 NEW VPID,XOBCTYPE
"RTN","XOBSRA",77,0)
 SET XOBID=0
"RTN","XOBSRA",78,0)
 SET XOBCTYPE="VPID"
"RTN","XOBSRA",79,0)
 ;
"RTN","XOBSRA",80,0)
 SET VPID=$GET(XOBDATA("XOB RPC","SECURITY","TYPE","VALUE"))
"RTN","XOBSRA",81,0)
 IF VPID]"" SET XOBID=$$IEN^XUPS(VPID)
"RTN","XOBSRA",82,0)
 ;
"RTN","XOBSRA",83,0)
 IF '+XOBID DO  QUIT
"RTN","XOBSRA",84,0)
 . SET XOBERR=182301_U_XOBTYPE_U_"["_XOBCTYPE_" Value: '"_VPID_"']"
"RTN","XOBSRA",85,0)
 . SET XOBID=0
"RTN","XOBSRA",86,0)
 ;
"RTN","XOBSRA",87,0)
 ; Active user status check performed here; assume heavier-duty checks done by application
"RTN","XOBSRA",88,0)
 ; when user authenticated to application via KAAJEE, FatKAAT or equivalent.
"RTN","XOBSRA",89,0)
 ;
"RTN","XOBSRA",90,0)
 DO ACTUSR(.XOBID,.XOBERR,XOBCTYPE)
"RTN","XOBSRA",91,0)
 QUIT
"RTN","XOBSRA",92,0)
 ;
"RTN","XOBSRA",93,0)
APPPROXY(XOBID,XOBERR) ; -- application proxy reauth type
"RTN","XOBSRA",94,0)
 ;
"RTN","XOBSRA",95,0)
 NEW XOBANAME,XOBCTYPE,XOBAPFND
"RTN","XOBSRA",96,0)
 SET XOBID=0,XOBCTYPE="APPPROXY"
"RTN","XOBSRA",97,0)
 SET XOBANAME=$GET(XOBDATA("XOB RPC","SECURITY","TYPE","VALUE"))
"RTN","XOBSRA",98,0)
 ;
"RTN","XOBSRA",99,0)
 ; APFIND^XUSAP(name) -> returns ien^vpid, or (failure) -int^reason
"RTN","XOBSRA",100,0)
 IF XOBANAME]"" SET XOBAPFND=$$APFIND^XUSAP(XOBANAME),XOBID=$PIECE(XOBAPFND,U)
"RTN","XOBSRA",101,0)
 ; file #200 division mult checking not necessary for app proxy user
"RTN","XOBSRA",102,0)
 IF (+XOBID)<1 DO
"RTN","XOBSRA",103,0)
 . SET XOBERR=182307_U_XOBANAME_U_"["_$P(XOBAPFND,U,2)_"]",XOBID=0
"RTN","XOBSRA",104,0)
 QUIT
"RTN","XOBSRA",105,0)
 ;
"RTN","XOBSRA",106,0)
CCOW(XOBID,XOBERR) ; -- CCOW reauth type
"RTN","XOBSRA",107,0)
 ; 
"RTN","XOBSRA",108,0)
 ; Very few checks performed here; assume heavier duty checks done by application when originally
"RTN","XOBSRA",109,0)
 ; authenticated and created Kernel CCOW token. User would need to be reauthenticated (and perform
"RTN","XOBSRA",110,0)
 ; heavier-duty checks) upon Kernel CCOW token expiration.
"RTN","XOBSRA",111,0)
 ;
"RTN","XOBSRA",112,0)
 DO CCOW^XOBSRAKJ(.XOBID,.XOBERR)
"RTN","XOBSRA",113,0)
 QUIT
"RTN","XOBSRA",114,0)
 ;
"RTN","XOBSRA",115,0)
ACTUSR(XOBID,XOBERR,XOBCTYPE) ; -- user active status check & error processing
"RTN","XOBSRA",116,0)
 ;
"RTN","XOBSRA",117,0)
 NEW XOBACTIV
"RTN","XOBSRA",118,0)
 SET XOBACTIV=0
"RTN","XOBSRA",119,0)
 SET XOBID=$GET(XOBID),XOBCTYPE=$GET(XOBCTYPE)
"RTN","XOBSRA",120,0)
 ;
"RTN","XOBSRA",121,0)
 ;-- returns active status indicator of user
"RTN","XOBSRA",122,0)
 SET XOBACTIV=$$ACTIVE^XUSER(XOBID)
"RTN","XOBSRA",123,0)
 IF +XOBACTIV<1 DO
"RTN","XOBSRA",124,0)
 . ;
"RTN","XOBSRA",125,0)
 . ;-- get dialog entry for error
"RTN","XOBSRA",126,0)
 . SET XOBERR=$$GETERR(XOBACTIV,XOBID,XOBCTYPE)
"RTN","XOBSRA",127,0)
 . SET XOBID=0
"RTN","XOBSRA",128,0)
 QUIT
"RTN","XOBSRA",129,0)
 ;
"RTN","XOBSRA",130,0)
DUZENV(XOBDUZ,XOBTYPE) ; -- build DUZ and check division
"RTN","XOBSRA",131,0)
 ;
"RTN","XOBSRA",132,0)
 ; QUIT 0 if OK, DialogErrorNumber^DialogErrorParameter1^... if bad
"RTN","XOBSRA",133,0)
 ;
"RTN","XOBSRA",134,0)
 NEW XOBDVARY,XOBDIV,XOBDIVEX,XOBDIVRQ,XOBDUZSV,XOBERR,XOBI,XOBOK
"RTN","XOBSRA",135,0)
 SET XOBOK=0,(XOBERR,XOBDIVEX)=""
"RTN","XOBSRA",136,0)
 ;
"RTN","XOBSRA",137,0)
 ; -- preserve previous DUZ value, restore if needed
"RTN","XOBSRA",138,0)
 MERGE XOBDUZSV=DUZ KILL DUZ
"RTN","XOBSRA",139,0)
 ;
"RTN","XOBSRA",140,0)
 ; -- set up info on passed in user
"RTN","XOBSRA",141,0)
 SET DUZ=XOBDUZ
"RTN","XOBSRA",142,0)
 SET XOBDIVRQ("STATIONNUMBER")=$GET(XOBDATA("XOB RPC","SECURITY","DIV"))
"RTN","XOBSRA",143,0)
 ;
"RTN","XOBSRA",144,0)
 DO  ; checks
"RTN","XOBSRA",145,0)
 .;
"RTN","XOBSRA",146,0)
 .; -- if no division passed in
"RTN","XOBSRA",147,0)
 . IF XOBDIVRQ("STATIONNUMBER")']"" DO  QUIT
"RTN","XOBSRA",148,0)
 . . SET XOBERR=182308_U_"no division passed"_U_XOBTYPE_U_XOBDUZ_U_"null"
"RTN","XOBSRA",149,0)
 . ;
"RTN","XOBSRA",150,0)
 . ; -- is division supported at the site?
"RTN","XOBSRA",151,0)
 . SET XOBDIVRQ("IEN")=$$SITECHK(XOBDIVRQ("STATIONNUMBER"))
"RTN","XOBSRA",152,0)
 . IF '+XOBDIVRQ("IEN") DO  QUIT
"RTN","XOBSRA",153,0)
 . . SET XOBERR=182308_U_$P(XOBDIVRQ("IEN"),U,2)_U_XOBTYPE_U_XOBDUZ_U_XOBDIVRQ("STATIONNUMBER")
"RTN","XOBSRA",154,0)
 . . KILL XOBDIVRQ("IEN")
"RTN","XOBSRA",155,0)
 .;
"RTN","XOBSRA",156,0)
 .; -- build DUZ
"RTN","XOBSRA",157,0)
 . DO DUZ^XUP(DUZ)
"RTN","XOBSRA",158,0)
 .;
"RTN","XOBSRA",159,0)
 .; -- don't do user-based checks if reauth type is APPPROXY
"RTN","XOBSRA",160,0)
 .IF XOBTYPE="APPPROXY" SET XOBOK=1 QUIT
"RTN","XOBSRA",161,0)
 .;
"RTN","XOBSRA",162,0)
 .; -- do check for user-permitted divisions
"RTN","XOBSRA",163,0)
 . DO DIVGET^XUSRB2(.XOBDIV,DUZ)
"RTN","XOBSRA",164,0)
 .;
"RTN","XOBSRA",165,0)
 .; -- DIVGET^XUSRB2 return value: if no divisions or one (matching) division, it's good
"RTN","XOBSRA",166,0)
 . IF '$GET(XOBDIV(0)) DO  QUIT
"RTN","XOBSRA",167,0)
 .. IF $GET(DUZ(2))=XOBDIVRQ("IEN") SET XOBOK=1 QUIT  ; OK
"RTN","XOBSRA",168,0)
 ..;
"RTN","XOBSRA",169,0)
 ..; -- if got here, did not match division
"RTN","XOBSRA",170,0)
 .. SET XOBERR=182302_U_XOBTYPE_U_XOBDUZ_U_XOBDIVRQ("STATIONNUMBER")
"RTN","XOBSRA",171,0)
 .;
"RTN","XOBSRA",172,0)
 .; -- DIVGET^XUSRB2 return value: if >1 divisions to select, attempt to set DUZ(2) to div passed in
"RTN","XOBSRA",173,0)
 . DO DIVSET^XUSRB2(.XOBOK,"`"_XOBDIVRQ("IEN")) I 'XOBOK DO
"RTN","XOBSRA",174,0)
 .. SET XOBERR=182302_U_XOBTYPE_U_XOBDUZ_U_XOBDIVRQ("STATIONNUMBER")
"RTN","XOBSRA",175,0)
 ;
"RTN","XOBSRA",176,0)
 IF 'XOBOK DO  ; A check failed. Clean up partition.
"RTN","XOBSRA",177,0)
 .;
"RTN","XOBSRA",178,0)
 .; -- reset DUZ
"RTN","XOBSRA",179,0)
 . KILL DUZ
"RTN","XOBSRA",180,0)
 . MERGE DUZ=XOBDUZSV
"RTN","XOBSRA",181,0)
 ;
"RTN","XOBSRA",182,0)
 ; -- send back error
"RTN","XOBSRA",183,0)
 QUIT $SELECT(XOBOK:0,1:XOBERR)
"RTN","XOBSRA",184,0)
 ;
"RTN","XOBSRA",185,0)
LOGINH() ; -- Check if system is currently allowing logins
"RTN","XOBSRA",186,0)
 ; Return:
"RTN","XOBSRA",187,0)
 ;   181004 : if logins are disabled
"RTN","XOBSRA",188,0)
 ;        0 : if logins are allowed
"RTN","XOBSRA",189,0)
 ;
"RTN","XOBSRA",190,0)
 NEW XQVOL,XUCI,XUENV,XUVOL,X,Y
"RTN","XOBSRA",191,0)
 ;
"RTN","XOBSRA",192,0)
 ; -- Setup XUENV, XUCI,XQVOL,XUVOL
"RTN","XOBSRA",193,0)
 DO XUVOL^XUS
"RTN","XOBSRA",194,0)
 ;
"RTN","XOBSRA",195,0)
 ; -- Check whether logins are disabled
"RTN","XOBSRA",196,0)
 QUIT $SELECT($$INHIB1^XUSRB():181004,1:0)
"RTN","XOBSRA",197,0)
 ;
"RTN","XOBSRA",198,0)
NOACCESS(XOBID) ; -- Determine if user is allowed access via user active status & prohibited times checks
"RTN","XOBSRA",199,0)
 ;
"RTN","XOBSRA",200,0)
 NEW XOBERR,XOBNOACC,XOBRANGE
"RTN","XOBSRA",201,0)
 SET (XOBERR,XOBNOACC)=0
"RTN","XOBSRA",202,0)
 ;
"RTN","XOBSRA",203,0)
 ; -- user active status check & error processing
"RTN","XOBSRA",204,0)
 DO ACTUSR(.XOBID,.XOBERR)
"RTN","XOBSRA",205,0)
 ;
"RTN","XOBSRA",206,0)
 ; -- check if sign-on is attempted during prohibited times
"RTN","XOBSRA",207,0)
 IF 'XOBERR DO
"RTN","XOBSRA",208,0)
 . SET XOBRANGE=$$GET1^DIQ(200,XOBID,15)
"RTN","XOBSRA",209,0)
 . IF XOBRANGE DO
"RTN","XOBSRA",210,0)
 .. SET XOBNOACC=$$PROHIBIT^XUS1A($P($HOROLOG,",",2),XOBRANGE)
"RTN","XOBSRA",211,0)
 .. IF XOBNOACC SET XOBERR=182304_U_XOBID_U_"Prohibited time: "_$PIECE(XOBNOACC,U,2)
"RTN","XOBSRA",212,0)
 QUIT XOBERR
"RTN","XOBSRA",213,0)
 ;
"RTN","XOBSRA",214,0)
VCHG(XOBID) ; -- Check if verify code needs to be changed
"RTN","XOBSRA",215,0)
 ; Return:
"RTN","XOBSRA",216,0)
 ;   182303^XOBID : if verify code is undefined or expired
"RTN","XOBSRA",217,0)
 ;              0 : verify code is current
"RTN","XOBSRA",218,0)
 NEW DUZ,I,VCHG,XOPT
"RTN","XOBSRA",219,0)
 SET DUZ=+$GET(XOBID),VCHG=0
"RTN","XOBSRA",220,0)
 ;
"RTN","XOBSRA",221,0)
 ; -- set up XOPT
"RTN","XOBSRA",222,0)
 DO XOPT^XUS
"RTN","XOBSRA",223,0)
 ;
"RTN","XOBSRA",224,0)
 ; -- check if verify code is current
"RTN","XOBSRA",225,0)
 IF $$VCVALID^XUSRB() DO
"RTN","XOBSRA",226,0)
 . SET VCHG=182303_U_DUZ
"RTN","XOBSRA",227,0)
 QUIT VCHG
"RTN","XOBSRA",228,0)
 ;
"RTN","XOBSRA",229,0)
INIT ; -- VL-specific or general partition setup before reauthentication process starts
"RTN","XOBSRA",230,0)
 ;
"RTN","XOBSRA",231,0)
 LOCK
"RTN","XOBSRA",232,0)
 SET:$DATA(IO)[0 IO=$IO SET IO(0)=IO
"RTN","XOBSRA",233,0)
 KILL ^UTILITY($JOB),^TMP($JOB)
"RTN","XOBSRA",234,0)
 KILL ^XUTL("XQ",$JOB)
"RTN","XOBSRA",235,0)
 ; -- clean up partition's local symbol table
"RTN","XOBSRA",236,0)
 DO KILL^XOBSRA1
"RTN","XOBSRA",237,0)
 QUIT
"RTN","XOBSRA",238,0)
 ;
"RTN","XOBSRA",239,0)
FINAL ; -- Final setup needed after a re-authentication is performed successfully.
"RTN","XOBSRA",240,0)
 ; -- Save DUZ and IO variables in ^XUTL("XQ",$JOB)
"RTN","XOBSRA",241,0)
 DO SAVE^XUS1
"RTN","XOBSRA",242,0)
 ;
"RTN","XOBSRA",243,0)
 ; Change in XUSRB: calls POST2^XUSRB calls CLRFAC^XUS3 to clear Failed Signon Attempts
"RTN","XOBSRA",244,0)
 ; file of entry with given IP. Need IO("IP") obtained from ZIO^%ZIS4.
"RTN","XOBSRA",245,0)
 ; 
"RTN","XOBSRA",246,0)
 KILL XQY,XQYQ
"RTN","XOBSRA",247,0)
 QUIT
"RTN","XOBSRA",248,0)
 ;
"RTN","XOBSRA",249,0)
GETERR(XOBACT,XOBID,XOBCONN) ;-- Get appropriate DIALOG file error
"RTN","XOBSRA",250,0)
 ;
"RTN","XOBSRA",251,0)
 NEW XOBERR
"RTN","XOBSRA",252,0)
 SET XOBERR=0
"RTN","XOBSRA",253,0)
 SET XOBACT=$GET(XOBACT),XOBID=$GET(XOBID),XOBCONN=$GET(XOBCONN)
"RTN","XOBSRA",254,0)
 ;
"RTN","XOBSRA",255,0)
 ;- error indicates that user can't sign on, is DISUSER'd, or is TERMINATED
"RTN","XOBSRA",256,0)
 IF $PIECE(XOBACT,U)=0 SET XOBERR=182304_U_XOBID_U_$SELECT($PIECE(XOBACT,U,2)'="":$PIECE(XOBACT,U,2),1:"Unable to Sign On")
"RTN","XOBSRA",257,0)
 ;
"RTN","XOBSRA",258,0)
 ;- error indicates no user record found
"RTN","XOBSRA",259,0)
 IF $PIECE(XOBACT,U)="" DO
"RTN","XOBSRA",260,0)
 . SET:XOBCONN="" XOBCONN="Unknown Reauthentication Type"
"RTN","XOBSRA",261,0)
 . SET XOBERR=182301_U_XOBCONN_U_"  ["_XOBCONN_" reauthentication type, DUZ Value: '"_XOBID_"']"
"RTN","XOBSRA",262,0)
 QUIT XOBERR
"RTN","XOBSRA",263,0)
 ;
"RTN","XOBSRA",264,0)
SITECHK(XOBSTATN) ; check if valid division for this site
"RTN","XOBSRA",265,0)
 ; input: station#
"RTN","XOBSRA",266,0)
 ; output: IEN of station# in institution file (if valid for this site)
"RTN","XOBSRA",267,0)
 ;         0^error message (if not valid for this site)
"RTN","XOBSRA",268,0)
 N XOBSTIEN,XOBSTRIP
"RTN","XOBSRA",269,0)
 SET XOBSTRIP=$$STRPSUFF^XOBSCAV1(XOBSTATN)
"RTN","XOBSRA",270,0)
 ; note: AAC 200M truncated to 200 in both sides of comparison below
"RTN","XOBSRA",271,0)
 QUIT:(XOBSTRIP'=XOBSYS("PRIMARY STATION#")) "0^STATION '"_XOBSTATN_"' is not supported by this M system."
"RTN","XOBSRA",272,0)
 S XOBSTIEN=$$IEN^XUAF4(XOBSTATN)
"RTN","XOBSRA",273,0)
 QUIT:'+XOBSTIEN "0^STATION '"_XOBSTATN_"' is not a known station number."
"RTN","XOBSRA",274,0)
 QUIT:'$$ACTIVE^XUAF4(XOBSTIEN) "0^STATION '"_XOBSTATN_"' is not active on this M system."
"RTN","XOBSRA",275,0)
 QUIT XOBSTIEN
"RTN","XOBSRA1")
0^7^B2720328
"RTN","XOBSRA1",1,0)
XOBSRA1 ;mjk,esd/alb - VistALink Reauthentication Code ; 05/22/2003  07:00
"RTN","XOBSRA1",2,0)
 ;;1.6;VistALink Security;;May 08, 2009;Build 15
"RTN","XOBSRA1",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBSRA1",4,0)
 QUIT
"RTN","XOBSRA1",5,0)
 ;
"RTN","XOBSRA1",6,0)
KILL ; -- clean up partition's local symbol table ; called from INIT^XOBSRA
"RTN","XOBSRA1",7,0)
 ;SET AAXOB="before" DO ^%ZTER ; -- used to view symbol table 'before' state
"RTN","XOBSRA1",8,0)
 ;
"RTN","XOBSRA1",9,0)
 IF XOBOS["OpenM" DO
"RTN","XOBSRA1",10,0)
 . ; -- Stack: CACHEVMS^XOBVTCP
"RTN","XOBSRA1",11,0)
 . ;           SPAWN^XOBVLL
"RTN","XOBSRA1",12,0)
 . ;           NXTCALL^XOBVLL
"RTN","XOBSRA1",13,0)
 . ;           EN^XOBVRM
"RTN","XOBSRA1",14,0)
 . ;           EN^XOBVRPC()
"RTN","XOBSRA1",15,0)
 . ;           SETUPDUZ^XOBSRA()
"RTN","XOBSRA1",16,0)
 . ;           
"RTN","XOBSRA1",17,0)
 . ; -- NEW non-XOB variables created in above stack
"RTN","XOBSRA1",18,0)
 . NEW DIQUIET,DX,DY,RPC0,RPCNAME,RPCIEN,TAG,ROU,METHSIG,XRTN
"RTN","XOBSRA1",19,0)
 . DO CACHE("XOB")
"RTN","XOBSRA1",20,0)
 ELSE  DO
"RTN","XOBSRA1",21,0)
 . DO OTHER
"RTN","XOBSRA1",22,0)
 ;
"RTN","XOBSRA1",23,0)
 ;SET AAXOB="after" DO ^%ZTER ; -- used to view symbol table 'after' state
"RTN","XOBSRA1",24,0)
 QUIT
"RTN","XOBSRA1",25,0)
 ;
"RTN","XOBSRA1",26,0)
CACHE(%NS) ; -- KILL all 'L'ocal 'VAR'iables except for a 'N'ame'S'pace (%NS) and Kernel for Cache systems
"RTN","XOBSRA1",27,0)
 NEW %LVAR,%NSLEN
"RTN","XOBSRA1",28,0)
 SET %NSLEN=$LENGTH(%NS)
"RTN","XOBSRA1",29,0)
 SET %LVAR=%NS
"RTN","XOBSRA1",30,0)
 FOR  SET %LVAR=$ORDER(@%LVAR) QUIT:%LVAR=""!($EXTRACT(%LVAR,1,%NSLEN)'=%NS)  NEW @%LVAR
"RTN","XOBSRA1",31,0)
 ; -- NEW Kernel variables and do the big KILL
"RTN","XOBSRA1",32,0)
 DO KILL^XUSCLEAN
"RTN","XOBSRA1",33,0)
 QUIT
"RTN","XOBSRA1",34,0)
 ;
"RTN","XOBSRA1",35,0)
OTHER ; -- explicit NEW'ing for other for non-Cache M implementations
"RTN","XOBSRA1",36,0)
 ; -- The following are NEW'ed as part KILL^XOBVLL call:
"RTN","XOBSRA1",37,0)
 ;    XOBPORT,XOBSTOP,XOBNULL,XOBOS,XOBSYS,XOBHDLR,XOBOK
"RTN","XOBSRA1",38,0)
 ; -- additional NEW'ing needed to preserve for CACHEVMS^XOBVTCP
"RTN","XOBSRA1",39,0)
 NEW XOBEC
"RTN","XOBSRA1",40,0)
 ; -- additional NEW'ing needed to preserve for SPAWN^XOBVLL
"RTN","XOBSRA1",41,0)
 NEW XOBLASTR
"RTN","XOBSRA1",42,0)
 ; -- additional NEW'ing needed to preserve for NXTCALL^XOBVLL
"RTN","XOBSRA1",43,0)
 NEW XOBROOT,XOBREAD,XOBTO,XOBFIRST,XOBDATA,DIQUIET
"RTN","XOBSRA1",44,0)
 ; -- additional NEW'ing needed to preserve for EN^XOBVRM
"RTN","XOBSRA1",45,0)
 NEW XOBOPT
"RTN","XOBSRA1",46,0)
 ; -- additional NEW'ing needed to preserve for EN^XOBVRPC()
"RTN","XOBSRA1",47,0)
 NEW DX,DY,RPC0,RPCNAME,RPCIEN,TAG,ROU,METHSIG,XOBERR,XOBR,XOBSEC,XOBWRAP,XRTN,XOBRA,XOBVER,XOBPTYPE
"RTN","XOBSRA1",48,0)
 ; -- additional NEW'ing needed to preserve for SETUPDUZ^XOBSRA()
"RTN","XOBSRA1",49,0)
 NEW XOBERR,XOBID,XOBTYPE
"RTN","XOBSRA1",50,0)
 ; -- call KILL^XOBVLL to finish NEW'ing and execute Kernel call to kill
"RTN","XOBSRA1",51,0)
 DO KILL^XOBVLL
"RTN","XOBSRA1",52,0)
 QUIT
"RTN","XOBSRA1",53,0)
 ;
"RTN","XOBSRAKJ")
0^6^B10014384
"RTN","XOBSRAKJ",1,0)
XOBSRAKJ ;kc/oak - VistALink Reauthentication Code, SSO/UC KAAJEE ; 03/02/2004  07:00
"RTN","XOBSRAKJ",2,0)
 ;;1.6;VistALink Security;;May 08, 2009;Build 15
"RTN","XOBSRAKJ",3,0)
 ;Per VHA directive 2004-038, this routine should not be modified.
"RTN","XOBSRAKJ",4,0)
 QUIT
"RTN","XOBSRAKJ",5,0)
 ;
"RTN","XOBSRAKJ",6,0)
 ; ------------------------------------------------------------------------
"RTN","XOBSRAKJ",7,0)
 ;       RPC Server: Reauthentication subroutines for SSO/UC KAAJEE
"RTN","XOBSRAKJ",8,0)
 ; ------------------------------------------------------------------------
"RTN","XOBSRAKJ",9,0)
 ;
"RTN","XOBSRAKJ",10,0)
CCOW(XOBID,XOBERR) ; -- CCOW connection type
"RTN","XOBSRAKJ",11,0)
 NEW XOBOUT,T,HDL
"RTN","XOBSRAKJ",12,0)
 SET XOBID=0
"RTN","XOBSRAKJ",13,0)
 ;
"RTN","XOBSRAKJ",14,0)
 ;get DUZ using Kernel CCOW Token xref
"RTN","XOBSRAKJ",15,0)
 SET HDL=$GET(XOBDATA("XOB RPC","SECURITY","TYPE","CCOW"))
"RTN","XOBSRAKJ",16,0)
 SET HDL=$$DECRYP^XUSRB1(HDL)
"RTN","XOBSRAKJ",17,0)
 ;
"RTN","XOBSRAKJ",18,0)
 IF $EXTRACT(HDL,1,2)'="~2" DO  QUIT
"RTN","XOBSRAKJ",19,0)
 . SET XOBERR=182301_U_"CCOW"_U_"[token does not match CCOW handle format.]"
"RTN","XOBSRAKJ",20,0)
 . SET XOBID=0
"RTN","XOBSRAKJ",21,0)
 ;
"RTN","XOBSRAKJ",22,0)
 ; TODO: need IP address, then need to do $$IPLOCKED(IP)?
"RTN","XOBSRAKJ",23,0)
 ; 
"RTN","XOBSRAKJ",24,0)
 ; since bypassing CHKCCOW^XUSRB4, need to extract true handle, expiry here
"RTN","XOBSRAKJ",25,0)
 SET HDL=$$UP^XLFSTR($EXTRACT(HDL,3,99)),T=$PIECE($GET(^XTV(8989.3,1,30),5400),U)
"RTN","XOBSRAKJ",26,0)
 ; call Kernel to resolve CCOW handle into user ID
"RTN","XOBSRAKJ",27,0)
 SET XOBOUT=$$CHECK^XUSRB4(HDL,T)
"RTN","XOBSRAKJ",28,0)
 IF (+XOBOUT)<1 DO  QUIT
"RTN","XOBSRAKJ",29,0)
 . SET XOBERR=182301_U_"CCOW"_U_"["_$PIECE(XOBOUT,U,2)_"]"
"RTN","XOBSRAKJ",30,0)
 . SET XOBID=0
"RTN","XOBSRAKJ",31,0)
 ; 
"RTN","XOBSRAKJ",32,0)
 ; need to get set XOBID=DUZ, save off DUZ(2) and anything else held in the token for XOBSRA
"RTN","XOBSRAKJ",33,0)
 SET XOBID=+XOBOUT
"RTN","XOBSRAKJ",34,0)
 ;
"RTN","XOBSRAKJ",35,0)
 ; Save the division station# into $GET(XOBDATA("XOB RPC","SECURITY","DIV")) -- that
"RTN","XOBSRAKJ",36,0)
 ; is where the XOBSRA division check is looking for it
"RTN","XOBSRAKJ",37,0)
 SET:+DUZ(2) XOBDATA("XOB RPC","SECURITY","DIV")=$$STA^XUAF4(DUZ(2))
"RTN","XOBSRAKJ",38,0)
 ;
"RTN","XOBSRAKJ",39,0)
 IF XOBID<1 DO  QUIT
"RTN","XOBSRAKJ",40,0)
 . SET XOBERR=182305_U_"CCOW"
"RTN","XOBSRAKJ",41,0)
 . SET XOBID=0
"RTN","XOBSRAKJ",42,0)
 ;
"RTN","XOBSRAKJ",43,0)
 ; probably can run MORECHKS as is?
"RTN","XOBSRAKJ",44,0)
 ; SET XOBERR=$$MORECHKS(XOBID)
"RTN","XOBSRAKJ",45,0)
 ; 
"RTN","XOBSRAKJ",46,0)
 IF XOBERR SET XOBID=0 QUIT
"RTN","XOBSRAKJ",47,0)
 ;
"RTN","XOBSRAKJ",48,0)
 ; TODO: POST(IP)
"RTN","XOBSRAKJ",49,0)
 ;
"RTN","XOBSRAKJ",50,0)
 QUIT
"RTN","XOBSRAKJ",51,0)
 ;
"RTN","XOBSRAKJ",52,0)
AV(XOBID,XOBERR) ; -- AV connection type
"RTN","XOBSRAKJ",53,0)
 NEW AC,AVCODE,VC,X,XOBCLIP,XOBTYPE
"RTN","XOBSRAKJ",54,0)
 SET XOBID=0
"RTN","XOBSRAKJ",55,0)
 ;
"RTN","XOBSRAKJ",56,0)
 ; -- get DUZ using access and verify codes
"RTN","XOBSRAKJ",57,0)
 SET AVCODE=$GET(XOBDATA("XOB RPC","SECURITY","TYPE","AVCODE"))
"RTN","XOBSRAKJ",58,0)
 ;
"RTN","XOBSRAKJ",59,0)
 SET AVCODE=$$DECRYP^XUSRB1(AVCODE)
"RTN","XOBSRAKJ",60,0)
 SET AC=$PIECE(AVCODE,";",1),VC=$PIECE(AVCODE,";",2),XOBCLIP=$PIECE(AVCODE,";",3)
"RTN","XOBSRAKJ",61,0)
 ;
"RTN","XOBSRAKJ",62,0)
 ; -- convert AC, VC into hashed versions
"RTN","XOBSRAKJ",63,0)
 SET X=AC,AC=$$EN^XUSHSH($$UP^XLFSTR(X))
"RTN","XOBSRAKJ",64,0)
 SET X=VC,VC=$$EN^XUSHSH($$UP^XLFSTR(X))
"RTN","XOBSRAKJ",65,0)
 ;
"RTN","XOBSRAKJ",66,0)
 ; -- check if exceeded multiple signon attempts
"RTN","XOBSRAKJ",67,0)
 SET XOBERR=$$IPLOCKED(XOBCLIP) IF XOBERR SET XOBID=0 QUIT
"RTN","XOBSRAKJ",68,0)
 ;
"RTN","XOBSRAKJ",69,0)
 ; -- look up AC
"RTN","XOBSRAKJ",70,0)
 SET XOBID=+$ORDER(^VA(200,"A",AC,0))
"RTN","XOBSRAKJ",71,0)
 IF XOBID<1 DO  QUIT
"RTN","XOBSRAKJ",72,0)
 . SET XOBERR=182305_U_"AV"
"RTN","XOBSRAKJ",73,0)
 . SET XOBID=0
"RTN","XOBSRAKJ",74,0)
 ;
"RTN","XOBSRAKJ",75,0)
 ; -- check VC
"RTN","XOBSRAKJ",76,0)
 IF $PIECE($GET(^VA(200,XOBID,.1)),U,2)'=VC DO  QUIT
"RTN","XOBSRAKJ",77,0)
 . SET XOBERR=182305_U_"AV"
"RTN","XOBSRAKJ",78,0)
 . SET XOBID=0
"RTN","XOBSRAKJ",79,0)
 ;
"RTN","XOBSRAKJ",80,0)
 ; -- check user access and whether verify code needs changing
"RTN","XOBSRAKJ",81,0)
 SET XOBERR=$$MORECHKS(XOBID)
"RTN","XOBSRAKJ",82,0)
 IF XOBERR SET XOBID=0 QUIT
"RTN","XOBSRAKJ",83,0)
 ;
"RTN","XOBSRAKJ",84,0)
 ; login succeeded
"RTN","XOBSRAKJ",85,0)
 DO POST(XOBCLIP)
"RTN","XOBSRAKJ",86,0)
 ;
"RTN","XOBSRAKJ",87,0)
 ; NOTE: AV doesn't need to check $$PERSON for AV because our source was file 200, not a separate index
"RTN","XOBSRAKJ",88,0)
 ;
"RTN","XOBSRAKJ",89,0)
 QUIT
"RTN","XOBSRAKJ",90,0)
 ;
"RTN","XOBSRAKJ",91,0)
MORECHKS(XOBID) ; -- More separate checks
"RTN","XOBSRAKJ",92,0)
 NEW XOBERR
"RTN","XOBSRAKJ",93,0)
 SET XOBERR=0
"RTN","XOBSRAKJ",94,0)
 ;
"RTN","XOBSRAKJ",95,0)
 ; -- check user access
"RTN","XOBSRAKJ",96,0)
 SET XOBERR=$$NOACCESS^XOBSRA(XOBID)
"RTN","XOBSRAKJ",97,0)
 IF XOBERR SET XOBID=0 QUIT XOBERR
"RTN","XOBSRAKJ",98,0)
 ;
"RTN","XOBSRAKJ",99,0)
 ; -- check if verify code needs changing
"RTN","XOBSRAKJ",100,0)
 SET XOBERR=$$VCHG^XOBSRA(XOBID)
"RTN","XOBSRAKJ",101,0)
 IF XOBERR SET XOBID=0 QUIT XOBERR
"RTN","XOBSRAKJ",102,0)
 ;
"RTN","XOBSRAKJ",103,0)
 QUIT XOBERR
"RTN","XOBSRAKJ",104,0)
 ;
"RTN","XOBSRAKJ",105,0)
IPLOCKED(XOBCLIP) ; -- check if IP address is locked, increment if not
"RTN","XOBSRAKJ",106,0)
 ;
"RTN","XOBSRAKJ",107,0)
 ; Implements the script-inhibiting lock-by-IP-address Kernel function.
"RTN","XOBSRAKJ",108,0)
 ; Does not lock user out for long, but does slow down scripts.
"RTN","XOBSRAKJ",109,0)
 ; 
"RTN","XOBSRAKJ",110,0)
 ; Return:
"RTN","XOBSRAKJ",111,0)
 ;   182306^XOBID : if too many invalid login attempts
"RTN","XOBSRAKJ",112,0)
 ;   0 : not too many login attempts
"RTN","XOBSRAKJ",113,0)
 ;
"RTN","XOBSRAKJ",114,0)
 IF $$LKCHECK^XUSTZIP(XOBCLIP) DO  QUIT XOBERR
"RTN","XOBSRAKJ",115,0)
 . SET XOBERR="182306^Too many invalid signon attempts."
"RTN","XOBSRAKJ",116,0)
 ;
"RTN","XOBSRAKJ",117,0)
 NEW XOBERR,XUFAC SET XOBERR=0
"RTN","XOBSRAKJ",118,0)
 ;
"RTN","XOBSRAKJ",119,0)
 IF $$FAIL^XUS3(XOBCLIP) SET XOBERR="182306^"_$$RA^XUSTZ(XOBCLIP)
"RTN","XOBSRAKJ",120,0)
 QUIT XOBERR
"RTN","XOBSRAKJ",121,0)
 ;
"RTN","XOBSRAKJ",122,0)
POST(XOBCLIP) ; post-successful tasks
"RTN","XOBSRAKJ",123,0)
 DO CLRFAC^XUS3(XOBCLIP)
"RTN","XOBSRAKJ",124,0)
 QUIT
"VER")
8.0^22.0
**END**
**END**
