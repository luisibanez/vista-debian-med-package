Released ROR*1.5*15 SEQ #16
Extracted from mail message
**KIDS**:ROR*1.5*15^

**INSTALL NAME**
ROR*1.5*15
"BLD",7618,0)
ROR*1.5*15^CLINICAL CASE REGISTRIES^0^3110908^y
"BLD",7618,4,0)
^9.64PA^799.6^4
"BLD",7618,4,799.1,0)
799.1
"BLD",7618,4,799.1,222)
n^n^f^^n^^y^m^n
"BLD",7618,4,799.1,224)
I $P(^(0),U)="eGFR by CKD-EPI"
"BLD",7618,4,799.31,0)
799.31
"BLD",7618,4,799.31,222)
n^n^f^^n^ROR XML^y^m^n
"BLD",7618,4,799.51,0)
799.51
"BLD",7618,4,799.51,222)
n^n^f^^y^ROR 15^y^o^n
"BLD",7618,4,799.6,0)
799.6
"BLD",7618,4,799.6,222)
n^n^f^^n^^y^m^n
"BLD",7618,4,799.6,223)

"BLD",7618,4,799.6,224)
I $P(^(0),U)="NON-VA MEDS"
"BLD",7618,4,"B",799.1,799.1)

"BLD",7618,4,"B",799.31,799.31)

"BLD",7618,4,"B",799.51,799.51)

"BLD",7618,4,"B",799.6,799.6)

"BLD",7618,6.3)
27
"BLD",7618,"ABPKG")
n
"BLD",7618,"INI")
PRE^RORP015
"BLD",7618,"INID")
^n^n
"BLD",7618,"INIT")
POST^RORP015
"BLD",7618,"KRN",0)
^9.67PA^779.2^20
"BLD",7618,"KRN",.4,0)
.4
"BLD",7618,"KRN",.401,0)
.401
"BLD",7618,"KRN",.402,0)
.402
"BLD",7618,"KRN",.403,0)
.403
"BLD",7618,"KRN",.5,0)
.5
"BLD",7618,"KRN",.84,0)
.84
"BLD",7618,"KRN",.84,"NM",0)
^9.68A^4^3
"BLD",7618,"KRN",.84,"NM",2,0)
7981020.001^^0
"BLD",7618,"KRN",.84,"NM",3,0)
7981020.002^^0
"BLD",7618,"KRN",.84,"NM",4,0)
7981999.001^^0
"BLD",7618,"KRN",.84,"NM","B",7981020.001,2)

"BLD",7618,"KRN",.84,"NM","B",7981020.002,3)

"BLD",7618,"KRN",.84,"NM","B",7981999.001,4)

"BLD",7618,"KRN",3.6,0)
3.6
"BLD",7618,"KRN",3.8,0)
3.8
"BLD",7618,"KRN",9.2,0)
9.2
"BLD",7618,"KRN",9.8,0)
9.8
"BLD",7618,"KRN",9.8,"NM",0)
^9.68A^10^9
"BLD",7618,"KRN",9.8,"NM",1,0)
RORX020^^0^B68556557
"BLD",7618,"KRN",9.8,"NM",2,0)
RORX020A^^0^B53998936
"BLD",7618,"KRN",9.8,"NM",3,0)
RORXU005^^0^B19990482
"BLD",7618,"KRN",9.8,"NM",4,0)
RORXU002^^0^B116207704
"BLD",7618,"KRN",9.8,"NM",5,0)
RORRP015^^0^B22836599
"BLD",7618,"KRN",9.8,"NM",6,0)
RORUTL11^^0^B3286551
"BLD",7618,"KRN",9.8,"NM",8,0)
RORX019^^0^B164858937
"BLD",7618,"KRN",9.8,"NM",9,0)
RORP015^^0^B962707
"BLD",7618,"KRN",9.8,"NM",10,0)
RORX020B^^0^B63829872
"BLD",7618,"KRN",9.8,"NM","B","RORP015",9)

"BLD",7618,"KRN",9.8,"NM","B","RORRP015",5)

"BLD",7618,"KRN",9.8,"NM","B","RORUTL11",6)

"BLD",7618,"KRN",9.8,"NM","B","RORX019",8)

"BLD",7618,"KRN",9.8,"NM","B","RORX020",1)

"BLD",7618,"KRN",9.8,"NM","B","RORX020A",2)

"BLD",7618,"KRN",9.8,"NM","B","RORX020B",10)

"BLD",7618,"KRN",9.8,"NM","B","RORXU002",4)

"BLD",7618,"KRN",9.8,"NM","B","RORXU005",3)

"BLD",7618,"KRN",19,0)
19
"BLD",7618,"KRN",19.1,0)
19.1
"BLD",7618,"KRN",19.1,"NM",0)
^9.68A^^0
"BLD",7618,"KRN",101,0)
101
"BLD",7618,"KRN",409.61,0)
409.61
"BLD",7618,"KRN",771,0)
771
"BLD",7618,"KRN",779.2,0)
779.2
"BLD",7618,"KRN",870,0)
870
"BLD",7618,"KRN",8989.51,0)
8989.51
"BLD",7618,"KRN",8989.52,0)
8989.52
"BLD",7618,"KRN",8994,0)
8994
"BLD",7618,"KRN","B",.4,.4)

"BLD",7618,"KRN","B",.401,.401)

"BLD",7618,"KRN","B",.402,.402)

"BLD",7618,"KRN","B",.403,.403)

"BLD",7618,"KRN","B",.5,.5)

"BLD",7618,"KRN","B",.84,.84)

"BLD",7618,"KRN","B",3.6,3.6)

"BLD",7618,"KRN","B",3.8,3.8)

"BLD",7618,"KRN","B",9.2,9.2)

"BLD",7618,"KRN","B",9.8,9.8)

"BLD",7618,"KRN","B",19,19)

"BLD",7618,"KRN","B",19.1,19.1)

"BLD",7618,"KRN","B",101,101)

"BLD",7618,"KRN","B",409.61,409.61)

"BLD",7618,"KRN","B",771,771)

"BLD",7618,"KRN","B",779.2,779.2)

"BLD",7618,"KRN","B",870,870)

"BLD",7618,"KRN","B",8989.51,8989.51)

"BLD",7618,"KRN","B",8989.52,8989.52)

"BLD",7618,"KRN","B",8994,8994)

"BLD",7618,"PRET")

"BLD",7618,"QUES",0)
^9.62^^
"BLD",7618,"REQB",0)
^9.611^2^2
"BLD",7618,"REQB",1,0)
PSN*4.0*284^1
"BLD",7618,"REQB",2,0)
ROR*1.5*14^1
"BLD",7618,"REQB","B","PSN*4.0*284",1)

"BLD",7618,"REQB","B","ROR*1.5*14",2)

"DATA",799.1,43,0)
eGFR by CKD-EPI^7^1^3^
"DATA",799.1,44,0)
eGFR by CKD-EPI^7^2^3
"DATA",799.31,269,0)
HIV_DX
"DATA",799.31,270,0)
MDRD
"DATA",799.31,271,0)
CKD
"DATA",799.31,272,0)
NPMDRD
"DATA",799.31,273,0)
NPCKD
"DATA",799.51,38,0)
TELAPREVIR^1^28^4637^^^^^1
"DATA",799.51,39,0)
BOCEPREVIR^1^28^4636^^^^^1
"DATA",799.51,40,0)
RILPIVIRINE^2^20^4638^^^^^1
"DATA",799.6,12,0)
NON-VA MEDS^1^2850101^^^5^^^1
"DATA",799.6,12,1,0)
^799.61P^2^1
"DATA",799.6,12,1,2,0)
19
"DATA",799.6,12,3,0)
^799.63^3^2
"DATA",799.6,12,3,2,0)
VA HEPC^
"DATA",799.6,12,3,3,0)
VA HIV^
"FIA",799.1)
ROR LIST ITEM
"FIA",799.1,0)
^ROR(799.1,
"FIA",799.1,0,0)
799.1
"FIA",799.1,0,1)
n^n^f^^n^^y^m^n
"FIA",799.1,0,10)

"FIA",799.1,0,11)
I $P(^(0),U)="eGFR by CKD-EPI"
"FIA",799.1,0,"RLRO")

"FIA",799.1,0,"VR")
1.5^ROR
"FIA",799.1,799.1)
0
"FIA",799.31)
ROR XML ITEM
"FIA",799.31,0)
^ROR(799.31,
"FIA",799.31,0,0)
799.31
"FIA",799.31,0,1)
n^n^f^^n^ROR XML^y^m^n
"FIA",799.31,0,10)

"FIA",799.31,0,11)

"FIA",799.31,0,"RLRO")
^DIBT(449577,1)
"FIA",799.31,0,"VR")
1.5^ROR
"FIA",799.31,799.31)
0
"FIA",799.51)
ROR GENERIC DRUG
"FIA",799.51,0)
^ROR(799.51,
"FIA",799.51,0,0)
799.51
"FIA",799.51,0,1)
n^n^f^^y^ROR 15^y^o^n
"FIA",799.51,0,10)

"FIA",799.51,0,11)

"FIA",799.51,0,"RLRO")
^DIBT(449580,1)
"FIA",799.51,0,"VR")
1.5^ROR
"FIA",799.51,799.51)
0
"FIA",799.6)
ROR HISTORICAL DATA EXTRACTION
"FIA",799.6,0)
^RORDATA(799.6,
"FIA",799.6,0,0)
799.6
"FIA",799.6,0,1)
n^n^f^^n^^y^m^n
"FIA",799.6,0,10)

"FIA",799.6,0,11)
I $P(^(0),U)="NON-VA MEDS"
"FIA",799.6,0,"RLRO")

"FIA",799.6,0,"VR")
1.5^ROR
"FIA",799.6,799.6)
0
"FIA",799.6,799.61)
0
"FIA",799.6,799.63)
0
"FIA",799.6,799.64)
0
"FIA",799.6,799.641)
0
"FRV1",799.51,"38,0",2)
VA HEPC
"FRV1",799.51,"38,0",2,"F")
;ROR(798.1,
"FRV1",799.51,"38,0",3)
Default (HepC)
"FRV1",799.51,"38,0",3,"F")
;ROR(799.1,
"FRV1",799.51,"38,0",4)
TELAPREVIR
"FRV1",799.51,"38,0",4,"F")
;PSNDF(50.6,
"FRV1",799.51,"39,0",2)
VA HEPC
"FRV1",799.51,"39,0",2,"F")
;ROR(798.1,
"FRV1",799.51,"39,0",3)
Default (HepC)
"FRV1",799.51,"39,0",3,"F")
;ROR(799.1,
"FRV1",799.51,"39,0",4)
BOCEPREVIR
"FRV1",799.51,"39,0",4,"F")
;PSNDF(50.6,
"FRV1",799.51,"40,0",2)
VA HIV
"FRV1",799.51,"40,0",2,"F")
;ROR(798.1,
"FRV1",799.51,"40,0",3)
Default (HIV)
"FRV1",799.51,"40,0",3,"F")
;ROR(799.1,
"FRV1",799.51,"40,0",4)
RILPIVIRINE
"FRV1",799.51,"40,0",4,"F")
;PSNDF(50.6,
"FRV1K",799.51,"38,0",3)
KEY
"FRV1K",799.51,"38,0",3,1)
Drug Group
"FRV1K",799.51,"38,0",3,2)
VA HEPC
"FRV1K",799.51,"38,0",3,3)
99
"FRV1K",799.51,"39,0",3)
KEY
"FRV1K",799.51,"39,0",3,1)
Drug Group
"FRV1K",799.51,"39,0",3,2)
VA HEPC
"FRV1K",799.51,"39,0",3,3)
99
"FRV1K",799.51,"40,0",3)
KEY
"FRV1K",799.51,"40,0",3,1)
Drug Group
"FRV1K",799.51,"40,0",3,2)
VA HIV
"FRV1K",799.51,"40,0",3,3)
99
"INI")
PRE^RORP015
"INIT")
POST^RORP015
"IX",799.1,799.1,"KEY",0)
799.1^KEY^Uniqueness Index for the "A" Key of File #799.1^R^^R^IR^I^799.1^^^^^LS
"IX",799.1,799.1,"KEY",1)
S ^ROR(799.1,"KEY",X(1),X(2),X(3),DA)=""
"IX",799.1,799.1,"KEY",2)
K ^ROR(799.1,"KEY",X(1),X(2),X(3),DA)
"IX",799.1,799.1,"KEY",2.5)
K ^ROR(799.1,"KEY")
"IX",799.1,799.1,"KEY",11.1,0)
^.114IA^3^3
"IX",799.1,799.1,"KEY",11.1,1,0)
1^F^799.1^.02^^1
"IX",799.1,799.1,"KEY",11.1,2,0)
2^F^799.1^.03^^2
"IX",799.1,799.1,"KEY",11.1,3,0)
3^F^799.1^.04^^3
"IX",799.31,799.31,"B",0)
799.31^B^Uniqueness Index for Key 'A' of File #799.31^R^^F^IR^I^799.31^^^^^LS
"IX",799.31,799.31,"B",1)
S ^ROR(799.31,"B",X,DA)=""
"IX",799.31,799.31,"B",2)
K ^ROR(799.31,"B",X,DA)
"IX",799.31,799.31,"B",2.5)
K ^ROR(799.31,"B")
"IX",799.31,799.31,"B",11.1,0)
^.114IA^1^1
"IX",799.31,799.31,"B",11.1,1,0)
1^F^799.31^.01^^1
"IX",799.51,799.51,"ARDG",0)
799.51^ARDG^Registry & Drug Group^R^^R^IR^I^799.51^^^^^S
"IX",799.51,799.51,"ARDG",1)
S ^ROR(799.51,"ARDG",X(2),X(3),DA)=""
"IX",799.51,799.51,"ARDG",2)
K ^ROR(799.51,"ARDG",X(2),X(3),DA)
"IX",799.51,799.51,"ARDG",2.5)
K ^ROR(799.51,"ARDG")
"IX",799.51,799.51,"ARDG",11.1,0)
^.114IA^3^3
"IX",799.51,799.51,"ARDG",11.1,1,0)
1^F^799.51^.02^^^F
"IX",799.51,799.51,"ARDG",11.1,2,0)
3^F^799.51^.04^^2^F
"IX",799.51,799.51,"ARDG",11.1,3,0)
2^C^^^^1
"IX",799.51,799.51,"ARDG",11.1,3,1.5)
S X=$S(X(1)'="":X(1)_"#",1:"")
"IX",799.51,799.51,"KEY",0)
799.51^KEY^Registry, Drug Group, Generic Drug^R^^R^IR^I^799.51^^^^^LS
"IX",799.51,799.51,"KEY",1)
S ^ROR(799.51,"KEY",X(1),X(2),X(3),DA)=""
"IX",799.51,799.51,"KEY",2)
K ^ROR(799.51,"KEY",X(1),X(2),X(3),DA)
"IX",799.51,799.51,"KEY",2.5)
K ^ROR(799.51,"KEY")
"IX",799.51,799.51,"KEY",11.1,0)
^.114IA^3^3
"IX",799.51,799.51,"KEY",11.1,1,0)
1^F^799.51^.02^^1
"IX",799.51,799.51,"KEY",11.1,2,0)
2^F^799.51^.03^^2
"IX",799.51,799.51,"KEY",11.1,3,0)
3^F^799.51^.04^^3
"IX",799.6,799.6,"ADNAUTO",0)
799.6^ADNAUTO^Activation Date & Name for automatic backpulls.^R^^R^IR^I^799.6^^^^^S
"IX",799.6,799.6,"ADNAUTO",.1,0)
^^6^6^3051031^
"IX",799.6,799.6,"ADNAUTO",.1,1,0)
This index references parameters of those
"IX",799.6,799.6,"ADNAUTO",.1,2,0)
automatic historical data extractions (TYPE =
"IX",799.6,799.6,"ADNAUTO",.1,3,0)
"Auto (HL7 messages)") that are active (ACTIVATION
"IX",799.6,799.6,"ADNAUTO",.1,4,0)
DATE > 0) but have not been completed yet (some
"IX",799.6,799.6,"ADNAUTO",.1,5,0)
records of the REGISTRY NAME multiple have no
"IX",799.6,799.6,"ADNAUTO",.1,6,0)
value in the COMPLETION DATE/TIME field).
"IX",799.6,799.6,"ADNAUTO",1)
S ^RORDATA(799.6,"ADNAUTO",X(1),$E(X(2),1,30),DA)=""
"IX",799.6,799.6,"ADNAUTO",1.4)
S X=(X(3)=1)&(X(4)>0)&($D(^RORDATA(799.6,DA,3,"ANC"))>1)
"IX",799.6,799.6,"ADNAUTO",2)
K ^RORDATA(799.6,"ADNAUTO",X(1),$E(X(2),1,30),DA)
"IX",799.6,799.6,"ADNAUTO",2.5)
K ^RORDATA(799.6,"ADNAUTO")
"IX",799.6,799.6,"ADNAUTO",11.1,0)
^.114IA^4^4
"IX",799.6,799.6,"ADNAUTO",11.1,1,0)
1^F^799.6^.07^^1^F
"IX",799.6,799.6,"ADNAUTO",11.1,2,0)
2^F^799.6^.01^30^2^F
"IX",799.6,799.6,"ADNAUTO",11.1,3,0)
3^F^799.6^.02^^^F
"IX",799.6,799.6,"ADNAUTO",11.1,4,0)
4^F^799.6^.07^^^F
"IX",799.6,799.6,"B",0)
799.6^B^Uniqueness Index for Key 'A' of File #799.6^R^^F^IR^I^799.6^^^^^LS
"IX",799.6,799.6,"B",1)
S ^RORDATA(799.6,"B",X,DA)=""
"IX",799.6,799.6,"B",2)
K ^RORDATA(799.6,"B",X,DA)
"IX",799.6,799.6,"B",2.5)
K ^RORDATA(799.6,"B")
"IX",799.6,799.6,"B",11.1,0)
^.114IA^1^1
"IX",799.6,799.6,"B",11.1,1,0)
1^F^799.6^.01^^1
"IX",799.6,799.61,"B",0)
799.61^B^Uniqueness Index for Key 'A' of Subfile #799.61^R^^F^IR^I^799.61^^^^^LS
"IX",799.6,799.61,"B",1)
S ^RORDATA(799.6,DA(1),1,"B",X,DA)=""
"IX",799.6,799.61,"B",2)
K ^RORDATA(799.6,DA(1),1,"B",X,DA)
"IX",799.6,799.61,"B",2.5)
K ^RORDATA(799.6,DA(1),1,"B")
"IX",799.6,799.61,"B",11.1,0)
^.114IA^1^1
"IX",799.6,799.61,"B",11.1,1,0)
1^F^799.61^.01^^1
"IX",799.6,799.63,"ANC",0)
799.63^ANC^Not completed registries^MU^^R^IR^I^799.63^^^^^S
"IX",799.6,799.63,"ANC",1)
D ANC7996^RORDD01(.DA,X(1),1)
"IX",799.6,799.63,"ANC",1.4)
S X=(X(2)'>0)
"IX",799.6,799.63,"ANC",2)
D ANC7996^RORDD01(.DA,X(1),0)
"IX",799.6,799.63,"ANC",2.5)
K ^RORDATA(799.6,DA(1),3,"ANC")
"IX",799.6,799.63,"ANC",11.1,0)
^.114IA^2^2
"IX",799.6,799.63,"ANC",11.1,1,0)
1^F^799.63^.01^30^1^F
"IX",799.6,799.63,"ANC",11.1,2,0)
2^F^799.63^.02^^^F
"IX",799.6,799.63,"B",0)
799.63^B^Uniqueness Index for Key 'A' of Subfile #799.63^R^^F^IR^I^799.63^^^^^LS
"IX",799.6,799.63,"B",1)
S ^RORDATA(799.6,DA(1),3,"B",X,DA)=""
"IX",799.6,799.63,"B",2)
K ^RORDATA(799.6,DA(1),3,"B",X,DA)
"IX",799.6,799.63,"B",2.5)
K ^RORDATA(799.6,DA(1),3,"B")
"IX",799.6,799.63,"B",11.1,0)
^.114IA^1^1
"IX",799.6,799.63,"B",11.1,1,0)
1^F^799.63^.01^^1
"IX",799.6,799.64,"ANC",0)
799.64^ANC^Not completed tasks^R^^R^IR^I^799.64^^^^^S
"IX",799.6,799.64,"ANC",1)
S ^RORDATA(799.6,DA(1),4,"ANC",X(1),DA)=""
"IX",799.6,799.64,"ANC",1.4)
S X=(X(2)'=3)
"IX",799.6,799.64,"ANC",2)
K ^RORDATA(799.6,DA(1),4,"ANC",X(1),DA)
"IX",799.6,799.64,"ANC",2.5)
K ^RORDATA(799.6,DA(1),4,"ANC")
"IX",799.6,799.64,"ANC",11.1,0)
^.114IA^2^2
"IX",799.6,799.64,"ANC",11.1,1,0)
1^F^799.64^.01^^1^F
"IX",799.6,799.64,"ANC",11.1,1,3)

"IX",799.6,799.64,"ANC",11.1,2,0)
2^F^799.64^.03^^^F
"IX",799.6,799.64,"ANC",11.1,2,3)

"IX",799.6,799.64,"B",0)
799.64^B^Uniqueness Index for Key 'A' of Subfile #799.64^R^^F^IR^I^799.64^^^^^LS
"IX",799.6,799.64,"B",1)
S ^RORDATA(799.6,DA(1),4,"B",X,DA)=""
"IX",799.6,799.64,"B",2)
K ^RORDATA(799.6,DA(1),4,"B",X,DA)
"IX",799.6,799.64,"B",2.5)
K ^RORDATA(799.6,DA(1),4,"B")
"IX",799.6,799.64,"B",11.1,0)
^.114IA^1^1
"IX",799.6,799.64,"B",11.1,1,0)
1^F^799.64^.01^^1
"KEY",799.1,799.1,"A",0)
799.1^A^P^150
"KEY",799.1,799.1,"A",2,0)
^.312IA^3^3
"KEY",799.1,799.1,"A",2,1,0)
.02^799.1^1
"KEY",799.1,799.1,"A",2,2,0)
.03^799.1^2
"KEY",799.1,799.1,"A",2,3,0)
.04^799.1^3
"KEY",799.31,799.31,"A",0)
799.31^A^S^198
"KEY",799.31,799.31,"A",2,0)
^.312IA^1^1
"KEY",799.31,799.31,"A",2,1,0)
.01^799.31^1
"KEY",799.51,799.51,"A",0)
799.51^A^S^694
"KEY",799.51,799.51,"A",2,0)
^.312IA^3^3
"KEY",799.51,799.51,"A",2,1,0)
.02^799.51^1
"KEY",799.51,799.51,"A",2,2,0)
.03^799.51^2
"KEY",799.51,799.51,"A",2,3,0)
.04^799.51^3
"KEY",799.6,799.6,"A",0)
799.6^A^S^697
"KEY",799.6,799.6,"A",2,0)
^.312IA^1^1
"KEY",799.6,799.6,"A",2,1,0)
.01^799.6^1
"KEY",799.6,799.61,"A",0)
799.61^A^S^698
"KEY",799.6,799.61,"A",2,0)
^.312IA^1^1
"KEY",799.6,799.61,"A",2,1,0)
.01^799.61^1
"KEY",799.6,799.63,"A",0)
799.63^A^S^700
"KEY",799.6,799.63,"A",2,0)
^.312IA^1^1
"KEY",799.6,799.63,"A",2,1,0)
.01^799.63^1
"KEY",799.6,799.64,"A",0)
799.64^A^S^702
"KEY",799.6,799.64,"A",2,0)
^.312IA^1^1
"KEY",799.6,799.64,"A",2,1,0)
.01^799.64^1
"KEYPTR",799.1,799.1,"A")
799.1^KEY
"KEYPTR",799.31,799.31,"A")
799.31^B
"KEYPTR",799.51,799.51,"A")
799.51^KEY
"KEYPTR",799.6,799.6,"A")
799.6^B
"KEYPTR",799.6,799.61,"A")
799.61^B
"KEYPTR",799.6,799.63,"A")
799.63^B
"KEYPTR",799.6,799.64,"A")
799.64^B
"KRN",.84,7981020.001,-1)
0^2
"KRN",.84,7981020.001,0)
7981020.001^2^^CLINICAL CASE REGISTRIES^Renal Function by Range (HTML)
"KRN",.84,7981020.001,2,0)
^.844^261^261^3110823^^
"KRN",.84,7981020.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981020.001,2,2,0)
 
"KRN",.84,7981020.001,2,3,0)
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
"KRN",.84,7981020.001,2,4,0)
version="1.0">
"KRN",.84,7981020.001,2,5,0)
 
"KRN",.84,7981020.001,2,6,0)
<xsl:import  href="template://report/998/1"/>  <!-- Styles   -->
"KRN",.84,7981020.001,2,7,0)
<xsl:import  href="template://report/999/1"/>  <!-- Common   -->
"KRN",.84,7981020.001,2,8,0)
<xsl:include href="template://report/997/1"/>  <!-- Patients -->
"KRN",.84,7981020.001,2,9,0)
 
"KRN",.84,7981020.001,2,10,0)
<xsl:variable name="ckdcnt" 
"KRN",.84,7981020.001,2,11,0)
select="count(/REPORT/HEADER/TBLDEF[@NAME='PATIENTS']/COLUMN[@NAME='CKD'])
"KRN",.84,7981020.001,2,12,0)
"/> 
"KRN",.84,7981020.001,2,13,0)
<xsl:variable name="mdrdcnt" 
"KRN",.84,7981020.001,2,14,0)
select="count(/REPORT/HEADER/TBLDEF[@NAME='PATIENTS']/COLUMN[@NAME='MDRD']
"KRN",.84,7981020.001,2,15,0)
)"/> 
"KRN",.84,7981020.001,2,16,0)
 
"KRN",.84,7981020.001,2,17,0)
<xsl:template match="/">
"KRN",.84,7981020.001,2,18,0)
 <html>
"KRN",.84,7981020.001,2,19,0)
  <head>
"KRN",.84,7981020.001,2,20,0)
   <title>Renal Function by Range</title>
"KRN",.84,7981020.001,2,21,0)
   <xsl:call-template name="StyleSheet"/>
"KRN",.84,7981020.001,2,22,0)
  </head>
"KRN",.84,7981020.001,2,23,0)
  <body>
"KRN",.84,7981020.001,2,24,0)
   <h1>Renal Function by Range</h1>
"KRN",.84,7981020.001,2,25,0)
   <xsl:call-template name="ReportHeader"/>
"KRN",.84,7981020.001,2,26,0)
   <xsl:if test="count(/REPORT/PATIENTS/*) > 0">
"KRN",.84,7981020.001,2,27,0)
    <div style="margin:10; color: red; font-weight: bold">
"KRN",.84,7981020.001,2,28,0)
       Lab tests used in calculations are identified by LOINC code. 
"KRN",.84,7981020.001,2,29,0)
       Your local lab ADPAC should be contacted regarding errors in LOINC 
"KRN",.84,7981020.001,2,30,0)
codes.  The LOINC codes that are used are:<br/>
"KRN",.84,7981020.001,2,31,0)
       <br/>
"KRN",.84,7981020.001,2,32,0)
       <xsl:call-template name="ShowLOINCCodes"/>
"KRN",.84,7981020.001,2,33,0)
    </div>
"KRN",.84,7981020.001,2,34,0)
    <div style="margin:10; color: red; font-weight: bold">
"KRN",.84,7981020.001,2,35,0)
       *For this report, creatinine values &gt;12 mg/dL are assumed to be 
"KRN",.84,7981020.001,2,36,0)
erroneous and are ignored.  Height values on the CrCL report that are
"KRN",.84,7981020.001,2,37,0)
&lt;36 inches or &gt;96 inches are also assumed to be erroneous and are
"KRN",.84,7981020.001,2,38,0)
ignored.
"KRN",.84,7981020.001,2,39,0)
    </div>
"KRN",.84,7981020.001,2,40,0)
   </xsl:if>
"KRN",.84,7981020.001,2,41,0)
    <xsl:if test="$ckdcnt &gt; 0 or $mdrdcnt &gt; 0">
"KRN",.84,7981020.001,2,42,0)
     <xsl:call-template name="RenalReportSummary"/>
"KRN",.84,7981020.001,2,43,0)
    </xsl:if>
"KRN",.84,7981020.001,2,44,0)
   <xsl:if test="count(/REPORT/PATIENTS/*) > 0">
"KRN",.84,7981020.001,2,45,0)
     <br />
"KRN",.84,7981020.001,2,46,0)
     <!-- The following line added to fix page break issue in IE 7 -->
"KRN",.84,7981020.001,2,47,0)
     <div style="page-break-after:always; font-size:1; margin:0; 
"KRN",.84,7981020.001,2,48,0)
border:0"><span style="visibility: hidden">-</span></div>
"KRN",.84,7981020.001,2,49,0)
     <div>
"KRN",.84,7981020.001,2,50,0)
       <xsl:call-template name="MakeScrollable">
"KRN",.84,7981020.001,2,51,0)
         <xsl:with-param name="condition" select="*[31]"/>
"KRN",.84,7981020.001,2,52,0)
       </xsl:call-template>
"KRN",.84,7981020.001,2,53,0)
       <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981020.001,2,54,0)
     </div>
"KRN",.84,7981020.001,2,55,0)
     <xsl:call-template name="ExplainFormula"/>
"KRN",.84,7981020.001,2,56,0)
   </xsl:if>
"KRN",.84,7981020.001,2,57,0)
  </body>
"KRN",.84,7981020.001,2,58,0)
 </html>
"KRN",.84,7981020.001,2,59,0)
</xsl:template>
"KRN",.84,7981020.001,2,60,0)
 
"KRN",.84,7981020.001,2,61,0)
<xsl:template name="ShowLOINCCodes">
"KRN",.84,7981020.001,2,62,0)
 <xsl:param name="summary" select="/REPORT/LOINC_CODES"/>
"KRN",.84,7981020.001,2,63,0)
 <table cellpadding="5" cellspacing="0">
"KRN",.84,7981020.001,2,64,0)
  <thead>
"KRN",.84,7981020.001,2,65,0)
   <tr>
"KRN",.84,7981020.001,2,66,0)
    <th>LOINC Codes</th>
"KRN",.84,7981020.001,2,67,0)
   </tr>
"KRN",.84,7981020.001,2,68,0)
  </thead>
"KRN",.84,7981020.001,2,69,0)
  <tbody>
"KRN",.84,7981020.001,2,70,0)
    <xsl:for-each select="/REPORT/LOINC_CODES/CODE">
"KRN",.84,7981020.001,2,71,0)
    <tr>
"KRN",.84,7981020.001,2,72,0)
      <td class="aLeft"><xsl:value-of select="@CODE"/></td>
"KRN",.84,7981020.001,2,73,0)
    </tr>
"KRN",.84,7981020.001,2,74,0)
   </xsl:for-each>
"KRN",.84,7981020.001,2,75,0)
  </tbody>
"KRN",.84,7981020.001,2,76,0)
 </table>
"KRN",.84,7981020.001,2,77,0)
</xsl:template>
"KRN",.84,7981020.001,2,78,0)
 
"KRN",.84,7981020.001,2,79,0)
<xsl:template name="RenalReportSummary">
"KRN",.84,7981020.001,2,80,0)
 <xsl:param name="summary" select="/REPORT/SUMMARY"/>
"KRN",.84,7981020.001,2,81,0)
 <table cellpadding="5" cellspacing="0">
"KRN",.84,7981020.001,2,82,0)
  <thead>
"KRN",.84,7981020.001,2,83,0)
   <tr>
"KRN",.84,7981020.001,2,84,0)
    <th>Chronic Kidney Disease Stages</th>
"KRN",.84,7981020.001,2,85,0)
    <th>GFR</th>
"KRN",.84,7981020.001,2,86,0)
    <xsl:if test="$mdrdcnt &gt; 0">
"KRN",.84,7981020.001,2,87,0)
      <th>Number of Patients<br/>by MDRD</th>
"KRN",.84,7981020.001,2,88,0)
    </xsl:if>
"KRN",.84,7981020.001,2,89,0)
    <xsl:if test="$ckdcnt &gt; 0">
"KRN",.84,7981020.001,2,90,0)
      <th>Number of Patients<br/>by CKD-EPI</th>
"KRN",.84,7981020.001,2,91,0)
    </xsl:if>
"KRN",.84,7981020.001,2,92,0)
   </tr>
"KRN",.84,7981020.001,2,93,0)
  </thead>
"KRN",.84,7981020.001,2,94,0)
  <tbody>
"KRN",.84,7981020.001,2,95,0)
    <xsl:for-each select="/REPORT/SUMMARY/DATA">
"KRN",.84,7981020.001,2,96,0)
    <tr>
"KRN",.84,7981020.001,2,97,0)
      <td class="aLeft"><xsl:value-of select="./DESC"/></td>
"KRN",.84,7981020.001,2,98,0)
      <td><xsl:value-of select="./VALUES"/><sup>2</sup></td>
"KRN",.84,7981020.001,2,99,0)
      <xsl:if test="$mdrdcnt &gt; 0">
"KRN",.84,7981020.001,2,100,0)
        <td><xsl:value-of select="./NPMDRD"/></td>
"KRN",.84,7981020.001,2,101,0)
      </xsl:if>
"KRN",.84,7981020.001,2,102,0)
      <xsl:if test="$ckdcnt &gt; 0">
"KRN",.84,7981020.001,2,103,0)
        <td><xsl:value-of select="./NPCKD"/></td>
"KRN",.84,7981020.001,2,104,0)
      </xsl:if>
"KRN",.84,7981020.001,2,105,0)
    </tr>
"KRN",.84,7981020.001,2,106,0)
   </xsl:for-each>
"KRN",.84,7981020.001,2,107,0)
  </tbody>
"KRN",.84,7981020.001,2,108,0)
 </table>
"KRN",.84,7981020.001,2,109,0)
</xsl:template>
"KRN",.84,7981020.001,2,110,0)
 
"KRN",.84,7981020.001,2,111,0)
<xsl:template name="ExplainFormula">
"KRN",.84,7981020.001,2,112,0)
 <br/>
"KRN",.84,7981020.001,2,113,0)
 <div class="reportSummary">
"KRN",.84,7981020.001,2,114,0)
  <div style="float:left; width:80%">
"KRN",.84,7981020.001,2,115,0)
   <table cellpadding="3" cellspacing="0">
"KRN",.84,7981020.001,2,116,0)
    <caption>Calculation Formulas</caption>
"KRN",.84,7981020.001,2,117,0)
    <thead>
"KRN",.84,7981020.001,2,118,0)
     <tr>
"KRN",.84,7981020.001,2,119,0)
      <th width="60">Description</th>
"KRN",.84,7981020.001,2,120,0)
      <th>Formula</th>
"KRN",.84,7981020.001,2,121,0)
     </tr>
"KRN",.84,7981020.001,2,122,0)
    </thead>
"KRN",.84,7981020.001,2,123,0)
    <tbody>
"KRN",.84,7981020.001,2,124,0)
     <xsl:if 
"KRN",.84,7981020.001,2,125,0)
test="count(/REPORT/HEADER/TBLDEF[@NAME='PATIENTS']/COLUMN[@NAME='CRCL']) 
"KRN",.84,7981020.001,2,126,0)
> 0">
"KRN",.84,7981020.001,2,127,0)
     <tr>
"KRN",.84,7981020.001,2,128,0)
      <td align="center">Cockcroft-Gault</td>
"KRN",.84,7981020.001,2,129,0)
      <td class="aLeft"> (140-age) * ideal weight in kg (*.85 if 
"KRN",.84,7981020.001,2,130,0)
female)/(Cr*72)<br/><br/>
"KRN",.84,7981020.001,2,131,0)
       Ideal weight in kg calculated as:<br />
"KRN",.84,7981020.001,2,132,0)
       male = 51.65+(1.85*(height-60))<br/>
"KRN",.84,7981020.001,2,133,0)
       female = 48.67+(1.65*(height-60))
"KRN",.84,7981020.001,2,134,0)
      </td>
"KRN",.84,7981020.001,2,135,0)
     </tr>
"KRN",.84,7981020.001,2,136,0)
     </xsl:if>
"KRN",.84,7981020.001,2,137,0)
     <xsl:if test="$mdrdcnt &gt; 0">
"KRN",.84,7981020.001,2,138,0)
      <tr>
"KRN",.84,7981020.001,2,139,0)
       <td align="center">eGFR by MDRD</td>
"KRN",.84,7981020.001,2,140,0)
       <td class="aLeft"> 175 * (Cr<sup>-1.154</sup>) * 
"KRN",.84,7981020.001,2,141,0)
(age<sup>-.203</sup>) *1.212 (if Black) * .742 (if female)</td>
"KRN",.84,7981020.001,2,142,0)
      </tr>
"KRN",.84,7981020.001,2,143,0)
     </xsl:if>
"KRN",.84,7981020.001,2,144,0)
     <xsl:if test="$ckdcnt &gt; 0">
"KRN",.84,7981020.001,2,145,0)
      <tr>
"KRN",.84,7981020.001,2,146,0)
       <td align="center">eGFR by CKD-EPI</td>
"KRN",.84,7981020.001,2,147,0)
       <td class="aLeft"> 141 * min(Scr/k, 1)<sup>a</sup> * max(Scr/k, 
"KRN",.84,7981020.001,2,148,0)
1)<sup>-1.209</sup> * 0.993<sup>Age</sup> * 1.159 (if black) * 1.018 (if 
"KRN",.84,7981020.001,2,149,0)
female)</td>
"KRN",.84,7981020.001,2,150,0)
      </tr>
"KRN",.84,7981020.001,2,151,0)
     </xsl:if>
"KRN",.84,7981020.001,2,152,0)
    </tbody>
"KRN",.84,7981020.001,2,153,0)
   </table>
"KRN",.84,7981020.001,2,154,0)
  </div>
"KRN",.84,7981020.001,2,155,0)
 </div>
"KRN",.84,7981020.001,2,156,0)
</xsl:template>
"KRN",.84,7981020.001,2,157,0)
 
"KRN",.84,7981020.001,2,158,0)
<!--[ TABLE HEADERS ]-->
"KRN",.84,7981020.001,2,159,0)
 
"KRN",.84,7981020.001,2,160,0)
<xsl:template match="COLUMN[@NAME='TEST']">
"KRN",.84,7981020.001,2,161,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981020.001,2,162,0)
  <xsl:with-param name="title" select="'Test'"/>
"KRN",.84,7981020.001,2,163,0)
  <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981020.001,2,164,0)
  <xsl:with-param name="width" select="'6%'"/>
"KRN",.84,7981020.001,2,165,0)
 </xsl:call-template>
"KRN",.84,7981020.001,2,166,0)
</xsl:template>
"KRN",.84,7981020.001,2,167,0)
 
"KRN",.84,7981020.001,2,168,0)
<xsl:template match="COLUMN[@NAME='DATE']">
"KRN",.84,7981020.001,2,169,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981020.001,2,170,0)
  <xsl:with-param name="title" select="'Date'"/>
"KRN",.84,7981020.001,2,171,0)
  <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981020.001,2,172,0)
  <xsl:with-param name="width" select="'8%'"/>
"KRN",.84,7981020.001,2,173,0)
 </xsl:call-template>
"KRN",.84,7981020.001,2,174,0)
</xsl:template>
"KRN",.84,7981020.001,2,175,0)
 
"KRN",.84,7981020.001,2,176,0)
<xsl:template match="COLUMN[@NAME='RESULT']">
"KRN",.84,7981020.001,2,177,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981020.001,2,178,0)
  <xsl:with-param name="title" select="'Result'"/>
"KRN",.84,7981020.001,2,179,0)
  <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981020.001,2,180,0)
  <xsl:with-param name="width" select="'4%'"/>
"KRN",.84,7981020.001,2,181,0)
 </xsl:call-template>
"KRN",.84,7981020.001,2,182,0)
</xsl:template>
"KRN",.84,7981020.001,2,183,0)
 
"KRN",.84,7981020.001,2,184,0)
<xsl:template match="COLUMN[@NAME='CRCL']">
"KRN",.84,7981020.001,2,185,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981020.001,2,186,0)
  <xsl:with-param name="title" select="'CrCL'"/>
"KRN",.84,7981020.001,2,187,0)
  <xsl:with-param name="sort" select="'PATIENTS=CRCL'"/>
"KRN",.84,7981020.001,2,188,0)
  <xsl:with-param name="width" select="'6%'"/>
"KRN",.84,7981020.001,2,189,0)
 </xsl:call-template>
"KRN",.84,7981020.001,2,190,0)
</xsl:template>
"KRN",.84,7981020.001,2,191,0)
 
"KRN",.84,7981020.001,2,192,0)
<xsl:template match="COLUMN[@NAME='MDRD']">
"KRN",.84,7981020.001,2,193,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981020.001,2,194,0)
  <xsl:with-param name="title" select="'MDRD'"/>
"KRN",.84,7981020.001,2,195,0)
  <xsl:with-param name="sort" select="'PATIENTS=MDRD'"/>
"KRN",.84,7981020.001,2,196,0)
  <xsl:with-param name="width" select="'6%'"/>
"KRN",.84,7981020.001,2,197,0)
 </xsl:call-template>
"KRN",.84,7981020.001,2,198,0)
</xsl:template>
"KRN",.84,7981020.001,2,199,0)
 
"KRN",.84,7981020.001,2,200,0)
<xsl:template match="COLUMN[@NAME='CKD']">
"KRN",.84,7981020.001,2,201,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981020.001,2,202,0)
  <xsl:with-param name="title" select="'CKD-EPI'"/>
"KRN",.84,7981020.001,2,203,0)
  <xsl:with-param name="sort" select="'PATIENTS=CKD'"/>
"KRN",.84,7981020.001,2,204,0)
  <xsl:with-param name="width" select="'6%'"/>
"KRN",.84,7981020.001,2,205,0)
 </xsl:call-template>
"KRN",.84,7981020.001,2,206,0)
</xsl:template>
"KRN",.84,7981020.001,2,207,0)
 
"KRN",.84,7981020.001,2,208,0)
 <!--[ TABLE CELLS ]-->
"KRN",.84,7981020.001,2,209,0)
 
"KRN",.84,7981020.001,2,210,0)
<xsl:template match="PATIENT/CRCL">
"KRN",.84,7981020.001,2,211,0)
  <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981020.001,2,212,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981020.001,2,213,0)
    <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981020.001,2,214,0)
  </xsl:call-template>
"KRN",.84,7981020.001,2,215,0)
</xsl:template>
"KRN",.84,7981020.001,2,216,0)
 
"KRN",.84,7981020.001,2,217,0)
<xsl:template match="PATIENT/EGFR">
"KRN",.84,7981020.001,2,218,0)
  <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981020.001,2,219,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981020.001,2,220,0)
    <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981020.001,2,221,0)
  </xsl:call-template>
"KRN",.84,7981020.001,2,222,0)
</xsl:template>
"KRN",.84,7981020.001,2,223,0)
 
"KRN",.84,7981020.001,2,224,0)
<xsl:template match="PATIENT/RNLDATA">
"KRN",.84,7981020.001,2,225,0)
 <xsl:variable name="CRCL" 
"KRN",.84,7981020.001,2,226,0)
select="count(/REPORT/HEADER/TBLDEF[@NAME='PATIENTS']/COLUMN[@NAME='CRCL']
"KRN",.84,7981020.001,2,227,0)
)"/>
"KRN",.84,7981020.001,2,228,0)
 <td class="aLeft">
"KRN",.84,7981020.001,2,229,0)
   <xsl:text>Cr</xsl:text>
"KRN",.84,7981020.001,2,230,0)
   <xsl:if test="$CRCL>0">
"KRN",.84,7981020.001,2,231,0)
    <br/><xsl:text>Height</xsl:text>
"KRN",.84,7981020.001,2,232,0)
   </xsl:if>
"KRN",.84,7981020.001,2,233,0)
 </td>
"KRN",.84,7981020.001,2,234,0)
 <td>
"KRN",.84,7981020.001,2,235,0)
   <xsl:call-template name="CellValue">
"KRN",.84,7981020.001,2,236,0)
     <xsl:with-param name="value" select="TEST/DATE"/>
"KRN",.84,7981020.001,2,237,0)
     <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981020.001,2,238,0)
   </xsl:call-template>
"KRN",.84,7981020.001,2,239,0)
   <xsl:if test="$CRCL>0">
"KRN",.84,7981020.001,2,240,0)
     <br/>
"KRN",.84,7981020.001,2,241,0)
     <xsl:call-template name="CellValue">
"KRN",.84,7981020.001,2,242,0)
       <xsl:with-param name="value" select="HEIGHT/DATE"/>
"KRN",.84,7981020.001,2,243,0)
       <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981020.001,2,244,0)
     </xsl:call-template>
"KRN",.84,7981020.001,2,245,0)
   </xsl:if>
"KRN",.84,7981020.001,2,246,0)
 </td>
"KRN",.84,7981020.001,2,247,0)
 <td class="aRight">
"KRN",.84,7981020.001,2,248,0)
   <xsl:call-template name="CellValue">
"KRN",.84,7981020.001,2,249,0)
     <xsl:with-param name="value" select="TEST/RESULT"/>
"KRN",.84,7981020.001,2,250,0)
   </xsl:call-template>
"KRN",.84,7981020.001,2,251,0)
   <xsl:if test="$CRCL>0">
"KRN",.84,7981020.001,2,252,0)
     <br/>
"KRN",.84,7981020.001,2,253,0)
     <xsl:call-template name="CellValue">
"KRN",.84,7981020.001,2,254,0)
       <xsl:with-param name="value" select="HEIGHT/RESULT"/>
"KRN",.84,7981020.001,2,255,0)
     </xsl:call-template>
"KRN",.84,7981020.001,2,256,0)
   </xsl:if>
"KRN",.84,7981020.001,2,257,0)
 </td>
"KRN",.84,7981020.001,2,258,0)
 
"KRN",.84,7981020.001,2,259,0)
</xsl:template>
"KRN",.84,7981020.001,2,260,0)
 
"KRN",.84,7981020.001,2,261,0)
</xsl:stylesheet>
"KRN",.84,7981020.001,3,0)
^.845
"KRN",.84,7981020.002,-1)
0^3
"KRN",.84,7981020.002,0)
7981020.002^2^^CLINICAL CASE REGISTRIES^Renal Function by Range (CSV)
"KRN",.84,7981020.002,2,0)
^^142^142^3110518^
"KRN",.84,7981020.002,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981020.002,2,2,0)
 <xsl:stylesheet version="1.0"
"KRN",.84,7981020.002,2,3,0)
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
"KRN",.84,7981020.002,2,4,0)
 
"KRN",.84,7981020.002,2,5,0)
<xsl:import href="template://report/999/2"/>  <!-- Common   -->
"KRN",.84,7981020.002,2,6,0)
 
"KRN",.84,7981020.002,2,7,0)
<xsl:variable name="CRCLUSED" 
"KRN",.84,7981020.002,2,8,0)
select="count(/REPORT/HEADER/TBLDEF[@NAME='PATIENTS']/COLUMN[@NAME='CRCL']
"KRN",.84,7981020.002,2,9,0)
)"/>
"KRN",.84,7981020.002,2,10,0)
<xsl:variable name="CKDUSED" 
"KRN",.84,7981020.002,2,11,0)
select="count(/REPORT/HEADER/TBLDEF[@NAME='PATIENTS']/COLUMN[@NAME='CKD'])
"KRN",.84,7981020.002,2,12,0)
"/>
"KRN",.84,7981020.002,2,13,0)
<xsl:variable name="MDRDUSED" 
"KRN",.84,7981020.002,2,14,0)
select="count(/REPORT/HEADER/TBLDEF[@NAME='PATIENTS']/COLUMN[@NAME='MDRD']
"KRN",.84,7981020.002,2,15,0)
)"/>
"KRN",.84,7981020.002,2,16,0)
 
"KRN",.84,7981020.002,2,17,0)
<xsl:template match="/">
"KRN",.84,7981020.002,2,18,0)
  <xsl:if test="$CKDUSED &gt; 0 or $MDRDUSED &gt; 0">
"KRN",.84,7981020.002,2,19,0)
    <xsl:call-template name="RenalReportSummary"/>
"KRN",.84,7981020.002,2,20,0)
  </xsl:if>
"KRN",.84,7981020.002,2,21,0)
  <xsl:text>Renal Function by Range</xsl:text>
"KRN",.84,7981020.002,2,22,0)
  <xsl:apply-templates select="/REPORT/PATIENTS"/>
"KRN",.84,7981020.002,2,23,0)
</xsl:template>
"KRN",.84,7981020.002,2,24,0)
 
"KRN",.84,7981020.002,2,25,0)
<xsl:template name="RenalReportSummary">
"KRN",.84,7981020.002,2,26,0)
 <xsl:param name="summary" select="/REPORT/SUMMARY"/>
"KRN",.84,7981020.002,2,27,0)
 <xsl:text>Renal Function by Range (Summary)</xsl:text>
"KRN",.84,7981020.002,2,28,0)
 <xsl:value-of select="$CRLF"/>
"KRN",.84,7981020.002,2,29,0)
 <xsl:text>Chronic Kidney Disease Stages</xsl:text>
"KRN",.84,7981020.002,2,30,0)
 <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981020.002,2,31,0)
 <xsl:text>GFR</xsl:text>
"KRN",.84,7981020.002,2,32,0)
 <xsl:if test="$MDRDUSED &gt; 0">
"KRN",.84,7981020.002,2,33,0)
   <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981020.002,2,34,0)
   <xsl:text>Number of Patients by MDRD</xsl:text>
"KRN",.84,7981020.002,2,35,0)
 </xsl:if>
"KRN",.84,7981020.002,2,36,0)
<xsl:if test="$CKDUSED &gt; 0">
"KRN",.84,7981020.002,2,37,0)
   <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981020.002,2,38,0)
   <xsl:text>Number of Patients by CKD-EPI</xsl:text>
"KRN",.84,7981020.002,2,39,0)
 </xsl:if>
"KRN",.84,7981020.002,2,40,0)
 <xsl:value-of select="$CRLF"/>
"KRN",.84,7981020.002,2,41,0)
 <xsl:for-each select="/REPORT/SUMMARY/DATA">
"KRN",.84,7981020.002,2,42,0)
   <xsl:value-of select="./DESC"/>
"KRN",.84,7981020.002,2,43,0)
   <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981020.002,2,44,0)
   <xsl:value-of select="./VALUES"/>
"KRN",.84,7981020.002,2,45,0)
   <xsl:text> sq</xsl:text>
"KRN",.84,7981020.002,2,46,0)
   <xsl:if test="$MDRDUSED &gt; 0">
"KRN",.84,7981020.002,2,47,0)
     <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981020.002,2,48,0)
     <xsl:value-of select="./NPMDRD"/>
"KRN",.84,7981020.002,2,49,0)
   </xsl:if>
"KRN",.84,7981020.002,2,50,0)
   <xsl:if test="$CKDUSED &gt; 0">
"KRN",.84,7981020.002,2,51,0)
     <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981020.002,2,52,0)
     <xsl:value-of select="./NPCKD"/>
"KRN",.84,7981020.002,2,53,0)
   </xsl:if>
"KRN",.84,7981020.002,2,54,0)
   <xsl:value-of select="$CRLF"/>
"KRN",.84,7981020.002,2,55,0)
 </xsl:for-each>
"KRN",.84,7981020.002,2,56,0)
 <xsl:value-of select="$FILESWITCH"/>
"KRN",.84,7981020.002,2,57,0)
</xsl:template>
"KRN",.84,7981020.002,2,58,0)
 
"KRN",.84,7981020.002,2,59,0)
 <xsl:template match="COLUMN[@NAME='TEST']">
"KRN",.84,7981020.002,2,60,0)
  <xsl:value-of select="''"/>
"KRN",.84,7981020.002,2,61,0)
 </xsl:template>
"KRN",.84,7981020.002,2,62,0)
 
"KRN",.84,7981020.002,2,63,0)
 <xsl:template match="COLUMN[@NAME='DATE']">
"KRN",.84,7981020.002,2,64,0)
  <xsl:value-of select="'Cr Date'"/>
"KRN",.84,7981020.002,2,65,0)
  <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981020.002,2,66,0)
  <xsl:value-of select="'Cr'"/>
"KRN",.84,7981020.002,2,67,0)
  <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981020.002,2,68,0)
 </xsl:template>
"KRN",.84,7981020.002,2,69,0)
 
"KRN",.84,7981020.002,2,70,0)
 <xsl:template match="COLUMN[@NAME='RESULT']">
"KRN",.84,7981020.002,2,71,0)
  <xsl:if test="$CRCLUSED > 0">
"KRN",.84,7981020.002,2,72,0)
    <xsl:value-of select="'Height Date'"/>
"KRN",.84,7981020.002,2,73,0)
    <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981020.002,2,74,0)
    <xsl:value-of select="'Height'"/>
"KRN",.84,7981020.002,2,75,0)
    <xsl:value-of select="$DELIMITER"/>
"KRN",.84,7981020.002,2,76,0)
  </xsl:if>
"KRN",.84,7981020.002,2,77,0)
 </xsl:template>
"KRN",.84,7981020.002,2,78,0)
 
"KRN",.84,7981020.002,2,79,0)
<xsl:template match="COLUMN[@NAME='CRCL']">
"KRN",.84,7981020.002,2,80,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981020.002,2,81,0)
  <xsl:with-param name="title" select="'CrCL'"/>
"KRN",.84,7981020.002,2,82,0)
 </xsl:call-template>
"KRN",.84,7981020.002,2,83,0)
</xsl:template>
"KRN",.84,7981020.002,2,84,0)
 
"KRN",.84,7981020.002,2,85,0)
<xsl:template match="COLUMN[@NAME='MDRD']">
"KRN",.84,7981020.002,2,86,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981020.002,2,87,0)
  <xsl:with-param name="title" select="'MDRD'"/>
"KRN",.84,7981020.002,2,88,0)
 </xsl:call-template>
"KRN",.84,7981020.002,2,89,0)
</xsl:template>
"KRN",.84,7981020.002,2,90,0)
 
"KRN",.84,7981020.002,2,91,0)
<xsl:template match="COLUMN[@NAME='CKD']">
"KRN",.84,7981020.002,2,92,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981020.002,2,93,0)
  <xsl:with-param name="title" select="'CKD-EPI'"/>
"KRN",.84,7981020.002,2,94,0)
 </xsl:call-template>
"KRN",.84,7981020.002,2,95,0)
</xsl:template>
"KRN",.84,7981020.002,2,96,0)
 
"KRN",.84,7981020.002,2,97,0)
<xsl:template match="PATIENTS/PATIENT">
"KRN",.84,7981020.002,2,98,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981020.002,2,99,0)
   <xsl:with-param name="value" select="NAME"/>
"KRN",.84,7981020.002,2,100,0)
  </xsl:call-template>
"KRN",.84,7981020.002,2,101,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981020.002,2,102,0)
   <xsl:with-param name="value" select="LAST4"/>
"KRN",.84,7981020.002,2,103,0)
  </xsl:call-template>
"KRN",.84,7981020.002,2,104,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981020.002,2,105,0)
   <xsl:with-param name="value" select="DOD"/>
"KRN",.84,7981020.002,2,106,0)
   <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981020.002,2,107,0)
  </xsl:call-template>
"KRN",.84,7981020.002,2,108,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981020.002,2,109,0)
   <xsl:with-param name="value" select="RNLDATA/TEST/DATE"/>
"KRN",.84,7981020.002,2,110,0)
   <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981020.002,2,111,0)
  </xsl:call-template>
"KRN",.84,7981020.002,2,112,0)
  <xsl:call-template name="TableCell">
"KRN",.84,7981020.002,2,113,0)
    <xsl:with-param name="value" select="RNLDATA/TEST/RESULT"/>
"KRN",.84,7981020.002,2,114,0)
  </xsl:call-template>
"KRN",.84,7981020.002,2,115,0)
  <xsl:if test="$CRCLUSED > 0">
"KRN",.84,7981020.002,2,116,0)
   <xsl:call-template name="TableCell">
"KRN",.84,7981020.002,2,117,0)
     <xsl:with-param name="value" select="RNLDATA/HEIGHT/DATE"/>
"KRN",.84,7981020.002,2,118,0)
     <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981020.002,2,119,0)
   </xsl:call-template>
"KRN",.84,7981020.002,2,120,0)
   <xsl:call-template name="TableCell">
"KRN",.84,7981020.002,2,121,0)
     <xsl:with-param name="value" select="RNLDATA/HEIGHT/RESULT"/>
"KRN",.84,7981020.002,2,122,0)
   </xsl:call-template>
"KRN",.84,7981020.002,2,123,0)
  </xsl:if>
"KRN",.84,7981020.002,2,124,0)
  <xsl:if test="$CRCLUSED > 0">
"KRN",.84,7981020.002,2,125,0)
   <xsl:call-template name="TableCell">
"KRN",.84,7981020.002,2,126,0)
     <xsl:with-param name="value" select="CRCL"/>
"KRN",.84,7981020.002,2,127,0)
    </xsl:call-template>
"KRN",.84,7981020.002,2,128,0)
  </xsl:if>
"KRN",.84,7981020.002,2,129,0)
  <xsl:if test="$MDRDUSED > 0">
"KRN",.84,7981020.002,2,130,0)
   <xsl:call-template name="TableCell">
"KRN",.84,7981020.002,2,131,0)
     <xsl:with-param name="value" select="MDRD"/>
"KRN",.84,7981020.002,2,132,0)
    </xsl:call-template>
"KRN",.84,7981020.002,2,133,0)
  </xsl:if>
"KRN",.84,7981020.002,2,134,0)
  <xsl:if test="$CKDUSED > 0">
"KRN",.84,7981020.002,2,135,0)
   <xsl:call-template name="TableCell">
"KRN",.84,7981020.002,2,136,0)
     <xsl:with-param name="value" select="CKD"/>
"KRN",.84,7981020.002,2,137,0)
    </xsl:call-template>
"KRN",.84,7981020.002,2,138,0)
  </xsl:if>
"KRN",.84,7981020.002,2,139,0)
  <xsl:value-of select="$CRLF"/>
"KRN",.84,7981020.002,2,140,0)
 </xsl:template>
"KRN",.84,7981020.002,2,141,0)
 
"KRN",.84,7981020.002,2,142,0)
</xsl:stylesheet>
"KRN",.84,7981999.001,-1)
0^4
"KRN",.84,7981999.001,0)
7981999.001^2^^CLINICAL CASE REGISTRIES^Common XSL templates (HTML)
"KRN",.84,7981999.001,2,0)
^^817^817^3110503^
"KRN",.84,7981999.001,2,1,0)
<?xml version="1.0"?>
"KRN",.84,7981999.001,2,2,0)
<xsl:stylesheet version="1.0"
"KRN",.84,7981999.001,2,3,0)
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
"KRN",.84,7981999.001,2,4,0)
 
"KRN",.84,7981999.001,2,5,0)
<xsl:param name="REMOVE_URLS"/>
"KRN",.84,7981999.001,2,6,0)
 
"KRN",.84,7981999.001,2,7,0)
<xsl:output method="html" indent="yes" encoding="iso-8859-1"/>
"KRN",.84,7981999.001,2,8,0)
<xsl:strip-space elements="*"/>
"KRN",.84,7981999.001,2,9,0)
 
"KRN",.84,7981999.001,2,10,0)
<xsl:template match="REPORT/HEADER//*"></xsl:template>
"KRN",.84,7981999.001,2,11,0)
<xsl:template match="REPORT/PARAMETERS//*"></xsl:template>
"KRN",.84,7981999.001,2,12,0)
 
"KRN",.84,7981999.001,2,13,0)
<xsl:key name="TableDefs" match="/REPORT/HEADER/TBLDEF" use="@NAME"/>
"KRN",.84,7981999.001,2,14,0)
 
"KRN",.84,7981999.001,2,15,0)
<!--
"KRN",.84,7981999.001,2,16,0)
=========================================================================
"KRN",.84,7981999.001,2,17,0)
                                UTILITIES
"KRN",.84,7981999.001,2,18,0)
=========================================================================
"KRN",.84,7981999.001,2,19,0)
-->
"KRN",.84,7981999.001,2,20,0)
 
"KRN",.84,7981999.001,2,21,0)
<!-- Formats the value of table cell -->
"KRN",.84,7981999.001,2,22,0)
 
"KRN",.84,7981999.001,2,23,0)
<xsl:template name="CellValue">
"KRN",.84,7981999.001,2,24,0)
 <xsl:param name="fmdt" select="0"/>
"KRN",.84,7981999.001,2,25,0)
 <xsl:param name="value" select="."/>
"KRN",.84,7981999.001,2,26,0)
 <xsl:param name="yesno" select="0"/>
"KRN",.84,7981999.001,2,27,0)
 <xsl:choose>
"KRN",.84,7981999.001,2,28,0)
  <xsl:when test="string($value)=''">&#160;</xsl:when>
"KRN",.84,7981999.001,2,29,0)
  <xsl:when test="boolean($fmdt)">
"KRN",.84,7981999.001,2,30,0)
   <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,31,0)
    <xsl:with-param name="dt" select="$value"/>
"KRN",.84,7981999.001,2,32,0)
   </xsl:call-template>
"KRN",.84,7981999.001,2,33,0)
  </xsl:when>
"KRN",.84,7981999.001,2,34,0)
  <xsl:when test="boolean($yesno)">
"KRN",.84,7981999.001,2,35,0)
   <xsl:choose>
"KRN",.84,7981999.001,2,36,0)
    <xsl:when test="$value!=0">Yes</xsl:when>
"KRN",.84,7981999.001,2,37,0)
    <xsl:otherwise>No</xsl:otherwise>
"KRN",.84,7981999.001,2,38,0)
   </xsl:choose>
"KRN",.84,7981999.001,2,39,0)
  </xsl:when>
"KRN",.84,7981999.001,2,40,0)
  <xsl:otherwise><xsl:value-of select="$value"/></xsl:otherwise>
"KRN",.84,7981999.001,2,41,0)
 </xsl:choose>
"KRN",.84,7981999.001,2,42,0)
</xsl:template>
"KRN",.84,7981999.001,2,43,0)
 
"KRN",.84,7981999.001,2,44,0)
<!-- Converts the FileMan date/time in printable format -->
"KRN",.84,7981999.001,2,45,0)
 
"KRN",.84,7981999.001,2,46,0)
<xsl:template name="DateTime">
"KRN",.84,7981999.001,2,47,0)
 <xsl:param name="dt" select="."/>
"KRN",.84,7981999.001,2,48,0)
 <!--
"KRN",.84,7981999.001,2,49,0)
     Date (YYYMMDD)
"KRN",.84,7981999.001,2,50,0)
 -->
"KRN",.84,7981999.001,2,51,0)
 <xsl:variable name="date"
"KRN",.84,7981999.001,2,52,0)
               select="substring-before(concat($dt,'.'),'.')"/>
"KRN",.84,7981999.001,2,53,0)
 <xsl:if test="$date!=''">
"KRN",.84,7981999.001,2,54,0)
  <xsl:choose>
"KRN",.84,7981999.001,2,55,0)
   <xsl:when test="string-length($date)=7">
"KRN",.84,7981999.001,2,56,0)
    <xsl:variable name="year"
"KRN",.84,7981999.001,2,57,0)
                  select="string(number(substring($date,1,3))+1700)"/>
"KRN",.84,7981999.001,2,58,0)
    <xsl:variable name="month" select="substring($date,4,2)"/>
"KRN",.84,7981999.001,2,59,0)
    <xsl:variable name="day" select="substring($date,6,2)"/>
"KRN",.84,7981999.001,2,60,0)
    <xsl:choose>
"KRN",.84,7981999.001,2,61,0)
     <xsl:when test="$day!='00'">
"KRN",.84,7981999.001,2,62,0)
      <xsl:value-of select="concat($month,'/',$day,'/',$year)"/>
"KRN",.84,7981999.001,2,63,0)
     </xsl:when>
"KRN",.84,7981999.001,2,64,0)
     <xsl:when test="$month!='00'">
"KRN",.84,7981999.001,2,65,0)
      <xsl:value-of select="concat($month,'/',$year)"/>
"KRN",.84,7981999.001,2,66,0)
     </xsl:when>
"KRN",.84,7981999.001,2,67,0)
     <xsl:otherwise><xsl:value-of select="$year"/></xsl:otherwise>
"KRN",.84,7981999.001,2,68,0)
    </xsl:choose>
"KRN",.84,7981999.001,2,69,0)
   </xsl:when>
"KRN",.84,7981999.001,2,70,0)
   <xsl:otherwise>{error}</xsl:otherwise>
"KRN",.84,7981999.001,2,71,0)
  </xsl:choose>
"KRN",.84,7981999.001,2,72,0)
  <!--
"KRN",.84,7981999.001,2,73,0)
      Time (HHMMSS)
"KRN",.84,7981999.001,2,74,0)
  -->
"KRN",.84,7981999.001,2,75,0)
  <xsl:variable name="time"
"KRN",.84,7981999.001,2,76,0)
                select="concat(substring-after($dt,'.'),'000000')"/>
"KRN",.84,7981999.001,2,77,0)
  <xsl:if test="number($time)>0">
"KRN",.84,7981999.001,2,78,0)
   <xsl:text>@</xsl:text>
"KRN",.84,7981999.001,2,79,0)
   <xsl:value-of select="substring($time,1,2)"/>
"KRN",.84,7981999.001,2,80,0)
   <xsl:text>:</xsl:text>
"KRN",.84,7981999.001,2,81,0)
   <xsl:value-of select="substring($time,3,2)"/>
"KRN",.84,7981999.001,2,82,0)
  </xsl:if>
"KRN",.84,7981999.001,2,83,0)
 </xsl:if>
"KRN",.84,7981999.001,2,84,0)
</xsl:template>
"KRN",.84,7981999.001,2,85,0)
 
"KRN",.84,7981999.001,2,86,0)
<xsl:template name="HUPatientsHeader">
"KRN",.84,7981999.001,2,87,0)
 <xsl:value-of select="/REPORT/PARAMETERS/MAXUTNUM"/>
"KRN",.84,7981999.001,2,88,0)
 <xsl:text> patient(s) with highest utilization</xsl:text>
"KRN",.84,7981999.001,2,89,0)
</xsl:template>
"KRN",.84,7981999.001,2,90,0)
 
"KRN",.84,7981999.001,2,91,0)
<!-- Conditional hyperlink -->
"KRN",.84,7981999.001,2,92,0)
 
"KRN",.84,7981999.001,2,93,0)
<xsl:template name="HyperLink">
"KRN",.84,7981999.001,2,94,0)
 <xsl:param name="href" select="''"/>
"KRN",.84,7981999.001,2,95,0)
 <xsl:param name="keep" select="0"/>
"KRN",.84,7981999.001,2,96,0)
 <xsl:param name="name" select="''"/>
"KRN",.84,7981999.001,2,97,0)
 <xsl:param name="text" select="."/>
"KRN",.84,7981999.001,2,98,0)
 <xsl:choose>
"KRN",.84,7981999.001,2,99,0)
  <xsl:when test="$text=''"><xsl:text>&#160;</xsl:text></xsl:when>
"KRN",.84,7981999.001,2,100,0)
  <xsl:when test="boolean($keep) or not($REMOVE_URLS)">
"KRN",.84,7981999.001,2,101,0)
   <a>
"KRN",.84,7981999.001,2,102,0)
    <xsl:if test="$name!=''">
"KRN",.84,7981999.001,2,103,0)
     <xsl:attribute name="name">
"KRN",.84,7981999.001,2,104,0)
      <xsl:value-of select="$name"/>
"KRN",.84,7981999.001,2,105,0)
     </xsl:attribute>
"KRN",.84,7981999.001,2,106,0)
    </xsl:if>
"KRN",.84,7981999.001,2,107,0)
    <xsl:if test="$href!=''">
"KRN",.84,7981999.001,2,108,0)
     <xsl:attribute name="href">
"KRN",.84,7981999.001,2,109,0)
      <xsl:value-of select="$href"/>
"KRN",.84,7981999.001,2,110,0)
     </xsl:attribute>
"KRN",.84,7981999.001,2,111,0)
    </xsl:if>
"KRN",.84,7981999.001,2,112,0)
    <xsl:value-of select="$text"/>
"KRN",.84,7981999.001,2,113,0)
   </a>
"KRN",.84,7981999.001,2,114,0)
  </xsl:when>
"KRN",.84,7981999.001,2,115,0)
  <xsl:otherwise><xsl:value-of select="$text"/></xsl:otherwise>
"KRN",.84,7981999.001,2,116,0)
 </xsl:choose>
"KRN",.84,7981999.001,2,117,0)
</xsl:template>
"KRN",.84,7981999.001,2,118,0)
 
"KRN",.84,7981999.001,2,119,0)
<!-- Makes the parent container scrollable -->
"KRN",.84,7981999.001,2,120,0)
 
"KRN",.84,7981999.001,2,121,0)
<xsl:template name="MakeScrollable">
"KRN",.84,7981999.001,2,122,0)
 <xsl:param name="condition" select="0"/>
"KRN",.84,7981999.001,2,123,0)
 <xsl:choose>
"KRN",.84,7981999.001,2,124,0)
  <xsl:when test="$condition">
"KRN",.84,7981999.001,2,125,0)
   <xsl:attribute name="class">scrollableContainer</xsl:attribute>
"KRN",.84,7981999.001,2,126,0)
  </xsl:when>
"KRN",.84,7981999.001,2,127,0)
  <xsl:otherwise>
"KRN",.84,7981999.001,2,128,0)
   <xsl:attribute name="class">simpleContainer</xsl:attribute>
"KRN",.84,7981999.001,2,129,0)
  </xsl:otherwise>
"KRN",.84,7981999.001,2,130,0)
 </xsl:choose>
"KRN",.84,7981999.001,2,131,0)
</xsl:template>
"KRN",.84,7981999.001,2,132,0)
 
"KRN",.84,7981999.001,2,133,0)
<!-- Outputs content of the multivalued report parameter -->
"KRN",.84,7981999.001,2,134,0)
 
"KRN",.84,7981999.001,2,135,0)
<xsl:template name="ParamsList">
"KRN",.84,7981999.001,2,136,0)
 <xsl:param name="heading"/>
"KRN",.84,7981999.001,2,137,0)
 <xsl:param name="list" select="."/>
"KRN",.84,7981999.001,2,138,0)
 <tr>
"KRN",.84,7981999.001,2,139,0)
  <th scope="row">
"KRN",.84,7981999.001,2,140,0)
   <xsl:value-of select="concat($heading,':&#160;')"/>
"KRN",.84,7981999.001,2,141,0)
  </th>
"KRN",.84,7981999.001,2,142,0)
  <td>
"KRN",.84,7981999.001,2,143,0)
   <xsl:if test="$list/@DESCR">
"KRN",.84,7981999.001,2,144,0)
    <xsl:value-of select="$list/@DESCR"/><br/>
"KRN",.84,7981999.001,2,145,0)
   </xsl:if>
"KRN",.84,7981999.001,2,146,0)
   <xsl:if test="$list='ALL'">ALL</xsl:if>
"KRN",.84,7981999.001,2,147,0)
   <xsl:for-each select="$list/*">
"KRN",.84,7981999.001,2,148,0)
    <xsl:sort select="."/>
"KRN",.84,7981999.001,2,149,0)
    <xsl:if test="position()>1"><xsl:text>; </xsl:text></xsl:if>
"KRN",.84,7981999.001,2,150,0)
    <xsl:value-of select="."/>
"KRN",.84,7981999.001,2,151,0)
   </xsl:for-each>
"KRN",.84,7981999.001,2,152,0)
  </td>
"KRN",.84,7981999.001,2,153,0)
 </tr>
"KRN",.84,7981999.001,2,154,0)
</xsl:template>
"KRN",.84,7981999.001,2,155,0)
 
"KRN",.84,7981999.001,2,156,0)
<!--
"KRN",.84,7981999.001,2,157,0)
Special processing for multivalued local fields to handle 
"KRN",.84,7981999.001,2,158,0)
pseudo local field  in the HIV_DX tag.
"KRN",.84,7981999.001,2,159,0)
-->
"KRN",.84,7981999.001,2,160,0)
 
"KRN",.84,7981999.001,2,161,0)
<xsl:template name="LocalList">
"KRN",.84,7981999.001,2,162,0)
 <xsl:param name="firstitem"/>
"KRN",.84,7981999.001,2,163,0)
 <xsl:param name="list" select="."/>
"KRN",.84,7981999.001,2,164,0)
 <tr>
"KRN",.84,7981999.001,2,165,0)
  <th scope="row">
"KRN",.84,7981999.001,2,166,0)
   <xsl:text>Local Fields:&#160;</xsl:text>
"KRN",.84,7981999.001,2,167,0)
  </th>
"KRN",.84,7981999.001,2,168,0)
  <td>
"KRN",.84,7981999.001,2,169,0)
   <xsl:if test="$firstitem!=''">
"KRN",.84,7981999.001,2,170,0)
    <xsl:text>Diagnosed at this VA (</xsl:text>
"KRN",.84,7981999.001,2,171,0)
    <xsl:value-of select="$firstitem"/>
"KRN",.84,7981999.001,2,172,0)
    <xsl:text>); </xsl:text>
"KRN",.84,7981999.001,2,173,0)
   </xsl:if>
"KRN",.84,7981999.001,2,174,0)
   <xsl:for-each select="$list/*">
"KRN",.84,7981999.001,2,175,0)
    <xsl:sort select="."/>
"KRN",.84,7981999.001,2,176,0)
    <xsl:if test="position()>1"><xsl:text>; </xsl:text></xsl:if>
"KRN",.84,7981999.001,2,177,0)
    <xsl:value-of select="."/>
"KRN",.84,7981999.001,2,178,0)
   </xsl:for-each>
"KRN",.84,7981999.001,2,179,0)
  </td>
"KRN",.84,7981999.001,2,180,0)
 </tr>
"KRN",.84,7981999.001,2,181,0)
</xsl:template>
"KRN",.84,7981999.001,2,182,0)
 
"KRN",.84,7981999.001,2,183,0)
 
"KRN",.84,7981999.001,2,184,0)
<!-- Outputs singular or plural form of the word -->
"KRN",.84,7981999.001,2,185,0)
 
"KRN",.84,7981999.001,2,186,0)
<xsl:template name="Plural">
"KRN",.84,7981999.001,2,187,0)
 <xsl:param name="qnty" select="0"/>
"KRN",.84,7981999.001,2,188,0)
 <xsl:param name="sq" select="0"/>
"KRN",.84,7981999.001,2,189,0)
 <xsl:param name="word" select="."/>
"KRN",.84,7981999.001,2,190,0)
 <xsl:if test="$sq=0">
"KRN",.84,7981999.001,2,191,0)
  <xsl:value-of select="$qnty"/><xsl:text>&#160;</xsl:text>
"KRN",.84,7981999.001,2,192,0)
 </xsl:if>
"KRN",.84,7981999.001,2,193,0)
 <xsl:choose>
"KRN",.84,7981999.001,2,194,0)
  <xsl:when test="$qnty=1">
"KRN",.84,7981999.001,2,195,0)
   <xsl:value-of select="substring-before($word,'^')"/>
"KRN",.84,7981999.001,2,196,0)
  </xsl:when>
"KRN",.84,7981999.001,2,197,0)
  <xsl:otherwise>
"KRN",.84,7981999.001,2,198,0)
   <xsl:value-of select="substring-after($word,'^')"/>
"KRN",.84,7981999.001,2,199,0)
  </xsl:otherwise>
"KRN",.84,7981999.001,2,200,0)
 </xsl:choose>
"KRN",.84,7981999.001,2,201,0)
</xsl:template>
"KRN",.84,7981999.001,2,202,0)
 
"KRN",.84,7981999.001,2,203,0)
<!-- Formats basic information about the report -->
"KRN",.84,7981999.001,2,204,0)
 
"KRN",.84,7981999.001,2,205,0)
<xsl:template name="ReportInfo">
"KRN",.84,7981999.001,2,206,0)
 <xsl:variable name="HDR" select="/REPORT/HEADER"/>
"KRN",.84,7981999.001,2,207,0)
 <table cellpadding="0" cellspacing="0">
"KRN",.84,7981999.001,2,208,0)
  <tr>
"KRN",.84,7981999.001,2,209,0)
   <th scope="row">Report&#160;Created:&#160;</th>
"KRN",.84,7981999.001,2,210,0)
   <td>
"KRN",.84,7981999.001,2,211,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,212,0)
     <xsl:with-param name="dt" select="$HDR/DATE"/>
"KRN",.84,7981999.001,2,213,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,214,0)
   </td>
"KRN",.84,7981999.001,2,215,0)
  </tr>
"KRN",.84,7981999.001,2,216,0)
  <tr>
"KRN",.84,7981999.001,2,217,0)
   <th scope="row">Task&#160;Number:&#160;</th>
"KRN",.84,7981999.001,2,218,0)
   <td>
"KRN",.84,7981999.001,2,219,0)
    <xsl:call-template name="CellValue">
"KRN",.84,7981999.001,2,220,0)
     <xsl:with-param name="value" select="$HDR/TASK_NUMBER"/>
"KRN",.84,7981999.001,2,221,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,222,0)
   </td>
"KRN",.84,7981999.001,2,223,0)
  </tr>
"KRN",.84,7981999.001,2,224,0)
  <tr>
"KRN",.84,7981999.001,2,225,0)
   <th scope="row">Last&#160;Registry&#160;Update:&#160;</th>
"KRN",.84,7981999.001,2,226,0)
   <td>
"KRN",.84,7981999.001,2,227,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,228,0)
     <xsl:with-param name="dt" select="$HDR/UPDATED_UNTIL"/>
"KRN",.84,7981999.001,2,229,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,230,0)
   </td>
"KRN",.84,7981999.001,2,231,0)
  </tr>
"KRN",.84,7981999.001,2,232,0)
  <tr>
"KRN",.84,7981999.001,2,233,0)
   <th scope="row">Last&#160;Data&#160;Extraction:&#160;</th>
"KRN",.84,7981999.001,2,234,0)
   <td>
"KRN",.84,7981999.001,2,235,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,236,0)
     <xsl:with-param name="dt" select="$HDR/EXTRACTED_UNTIL"/>
"KRN",.84,7981999.001,2,237,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,238,0)
   </td>
"KRN",.84,7981999.001,2,239,0)
  </tr>
"KRN",.84,7981999.001,2,240,0)
 </table>
"KRN",.84,7981999.001,2,241,0)
</xsl:template>
"KRN",.84,7981999.001,2,242,0)
 
"KRN",.84,7981999.001,2,243,0)
<!-- Default report summary -->
"KRN",.84,7981999.001,2,244,0)
 
"KRN",.84,7981999.001,2,245,0)
<xsl:template name="ReportSummary">
"KRN",.84,7981999.001,2,246,0)
 <xsl:variable name="SUMMARY" select="/REPORT/SUMMARY"/>
"KRN",.84,7981999.001,2,247,0)
 <xsl:if test="$SUMMARY/*[1]">
"KRN",.84,7981999.001,2,248,0)
  <div class="reportSummary">
"KRN",.84,7981999.001,2,249,0)
   <xsl:apply-templates select="$SUMMARY"/>
"KRN",.84,7981999.001,2,250,0)
  </div>
"KRN",.84,7981999.001,2,251,0)
 </xsl:if>
"KRN",.84,7981999.001,2,252,0)
</xsl:template>
"KRN",.84,7981999.001,2,253,0)
 
"KRN",.84,7981999.001,2,254,0)
<!-- Indicator of an empty table -->
"KRN",.84,7981999.001,2,255,0)
 
"KRN",.84,7981999.001,2,256,0)
<xsl:template name="TableNoData">
"KRN",.84,7981999.001,2,257,0)
 <table width="100%" cellpadding="5" cellspacing="0">
"KRN",.84,7981999.001,2,258,0)
   <tr><td>No data has been found.</td></tr>
"KRN",.84,7981999.001,2,259,0)
 </table>
"KRN",.84,7981999.001,2,260,0)
</xsl:template>
"KRN",.84,7981999.001,2,261,0)
 
"KRN",.84,7981999.001,2,262,0)
<!--
"KRN",.84,7981999.001,2,263,0)
=========================================================================
"KRN",.84,7981999.001,2,264,0)
                              REPORT HEADER
"KRN",.84,7981999.001,2,265,0)
=========================================================================
"KRN",.84,7981999.001,2,266,0)
-->
"KRN",.84,7981999.001,2,267,0)
 
"KRN",.84,7981999.001,2,268,0)
<xsl:template name="ReportHeader">
"KRN",.84,7981999.001,2,269,0)
 <xsl:variable name="mvplist" select="/REPORT/PARAMETERS/*[*[1]]"/>
"KRN",.84,7981999.001,2,270,0)
 <xsl:variable name="notecnt" select="count(/REPORT/HEADER/NOTES/*)"/>
"KRN",.84,7981999.001,2,271,0)
 <div class="reportHeader">
"KRN",.84,7981999.001,2,272,0)
  <table width="100%" cellpadding="0" cellspacing="0">
"KRN",.84,7981999.001,2,273,0)
   <tr>
"KRN",.84,7981999.001,2,274,0)
    <td style="text-align:left">
"KRN",.84,7981999.001,2,275,0)
     <table cellpadding="0" cellspacing="0">
"KRN",.84,7981999.001,2,276,0)
      <xsl:apply-templates select="/REPORT/PARAMETERS/*[not(*[1])]"/>
"KRN",.84,7981999.001,2,277,0)
     </table>
"KRN",.84,7981999.001,2,278,0)
    </td>
"KRN",.84,7981999.001,2,279,0)
    <td style="text-align:right; padding-left:3%; width:10%">
"KRN",.84,7981999.001,2,280,0)
     <xsl:call-template name="ReportInfo"/>
"KRN",.84,7981999.001,2,281,0)
    </td>
"KRN",.84,7981999.001,2,282,0)
   </tr>
"KRN",.84,7981999.001,2,283,0)
  </table>
"KRN",.84,7981999.001,2,284,0)
  <xsl:if test="$mvplist[1]">
"KRN",.84,7981999.001,2,285,0)
   <table style="width:100%; margin-top:1%" cellpadding="0" cellspacing="0">
"KRN",.84,7981999.001,2,286,0)
    <xsl:apply-templates select="$mvplist"/>
"KRN",.84,7981999.001,2,287,0)
   </table>
"KRN",.84,7981999.001,2,288,0)
  </xsl:if>
"KRN",.84,7981999.001,2,289,0)
  <xsl:if test="/REPORT//PATIENT[1]">
"KRN",.84,7981999.001,2,290,0)
   <div style="margin:10; color: red; font-weight: bold">
"KRN",.84,7981999.001,2,291,0)
    This report contains confidential patient information and must be
"KRN",.84,7981999.001,2,292,0)
    handled in accordance with established policies.
"KRN",.84,7981999.001,2,293,0)
   </div>
"KRN",.84,7981999.001,2,294,0)
  </xsl:if>
"KRN",.84,7981999.001,2,295,0)
  <xsl:if test="$notecnt>0">
"KRN",.84,7981999.001,2,296,0)
   <dl style="text-align:left">
"KRN",.84,7981999.001,2,297,0)
    <xsl:choose>
"KRN",.84,7981999.001,2,298,0)
     <xsl:when test="$notecnt>1">
"KRN",.84,7981999.001,2,299,0)
      <xsl:for-each select="/REPORT/HEADER/NOTES/*">
"KRN",.84,7981999.001,2,300,0)
       <dt>Note #<xsl:value-of select="position()"/>:</dt>
"KRN",.84,7981999.001,2,301,0)
       <dd><xsl:apply-templates select="."/></dd>
"KRN",.84,7981999.001,2,302,0)
      </xsl:for-each>
"KRN",.84,7981999.001,2,303,0)
     </xsl:when>
"KRN",.84,7981999.001,2,304,0)
     <xsl:otherwise>
"KRN",.84,7981999.001,2,305,0)
      <dt>Note:</dt>
"KRN",.84,7981999.001,2,306,0)
      <dd><xsl:apply-templates select="/REPORT/HEADER/NOTES/*"/></dd>
"KRN",.84,7981999.001,2,307,0)
     </xsl:otherwise>
"KRN",.84,7981999.001,2,308,0)
    </xsl:choose>
"KRN",.84,7981999.001,2,309,0)
   </dl>
"KRN",.84,7981999.001,2,310,0)
  </xsl:if>
"KRN",.84,7981999.001,2,311,0)
 </div>
"KRN",.84,7981999.001,2,312,0)
</xsl:template>
"KRN",.84,7981999.001,2,313,0)
 
"KRN",.84,7981999.001,2,314,0)
<xsl:template match="HEADER/NOTES/AGE">
"KRN",.84,7981999.001,2,315,0)
 Age of patients is calculated as of the date when the report is run
"KRN",.84,7981999.001,2,316,0)
 (<xsl:call-template name="DateTime"/>). If a patient died then the
"KRN",.84,7981999.001,2,317,0)
 age is calculated as of date of death.
"KRN",.84,7981999.001,2,318,0)
</xsl:template>
"KRN",.84,7981999.001,2,319,0)
 
"KRN",.84,7981999.001,2,320,0)
<xsl:template match="HEADER/NOTES/AGE_BASE_DATE">
"KRN",.84,7981999.001,2,321,0)
 Age of patients is calculated as of <xsl:call-template name="DateTime"/>,
"KRN",.84,7981999.001,2,322,0)
 which is the middle of the report date range. If a patient was born after
"KRN",.84,7981999.001,2,323,0)
 this date then the field will be empty. If a patient died before this
"KRN",.84,7981999.001,2,324,0)
 date then the age is calculated as of date of death.
"KRN",.84,7981999.001,2,325,0)
</xsl:template>
"KRN",.84,7981999.001,2,326,0)
 
"KRN",.84,7981999.001,2,327,0)
<xsl:template match="PARAMETERS/CLINICS">
"KRN",.84,7981999.001,2,328,0)
 <xsl:call-template name="ParamsList">
"KRN",.84,7981999.001,2,329,0)
  <xsl:with-param name="heading" select="'Clinics'"/>
"KRN",.84,7981999.001,2,330,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,331,0)
</xsl:template>
"KRN",.84,7981999.001,2,332,0)
 
"KRN",.84,7981999.001,2,333,0)
<xsl:template match="PARAMETERS/CPTLST">
"KRN",.84,7981999.001,2,334,0)
 <xsl:call-template name="ParamsList">
"KRN",.84,7981999.001,2,335,0)
  <xsl:with-param name="heading" select="'CPT'"/>
"KRN",.84,7981999.001,2,336,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,337,0)
</xsl:template>
"KRN",.84,7981999.001,2,338,0)
 
"KRN",.84,7981999.001,2,339,0)
<xsl:template name="DateRange" match="PARAMETERS/DATE_RANGE">
"KRN",.84,7981999.001,2,340,0)
 <xsl:param name="dtr" select="."/>
"KRN",.84,7981999.001,2,341,0)
 <xsl:param name="title" select="''"/>
"KRN",.84,7981999.001,2,342,0)
 <xsl:if test="($dtr/@START!='') and ($dtr/@END!='')">
"KRN",.84,7981999.001,2,343,0)
  <tr>
"KRN",.84,7981999.001,2,344,0)
   <th scope="row">
"KRN",.84,7981999.001,2,345,0)
    <xsl:if test="$title!=''">
"KRN",.84,7981999.001,2,346,0)
     <xsl:value-of select="concat($title,'&#160;')"/>
"KRN",.84,7981999.001,2,347,0)
    </xsl:if>
"KRN",.84,7981999.001,2,348,0)
    <xsl:text>Date&#160;Range:&#160;</xsl:text>
"KRN",.84,7981999.001,2,349,0)
   </th>
"KRN",.84,7981999.001,2,350,0)
   <td style="vertical-align:text-bottom">
"KRN",.84,7981999.001,2,351,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,352,0)
     <xsl:with-param name="dt" select="$dtr/@START"/>
"KRN",.84,7981999.001,2,353,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,354,0)
    <xsl:text>&#160;-&#160;</xsl:text>
"KRN",.84,7981999.001,2,355,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,356,0)
     <xsl:with-param name="dt" select="$dtr/@END"/>  
"KRN",.84,7981999.001,2,357,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,358,0)
   </td>
"KRN",.84,7981999.001,2,359,0)
  </tr>
"KRN",.84,7981999.001,2,360,0)
 </xsl:if>
"KRN",.84,7981999.001,2,361,0)
</xsl:template>
"KRN",.84,7981999.001,2,362,0)
 
"KRN",.84,7981999.001,2,363,0)
<!-- 
"KRN",.84,7981999.001,2,364,0)
<xsl:template name="DateRange" match="PARAMETERS/DATE_RANGE">
"KRN",.84,7981999.001,2,365,0)
 <xsl:param name="dtr" select="."/>
"KRN",.84,7981999.001,2,366,0)
 <xsl:param name="title" select="''"/>
"KRN",.84,7981999.001,2,367,0)
 <xsl:if test="$dtr/@START!=''">
"KRN",.84,7981999.001,2,368,0)
  <tr>
"KRN",.84,7981999.001,2,369,0)
   <th scope="row"><xsl:value-of select="$title"/> Start&#160;Date:&#160;</th>
"KRN",.84,7981999.001,2,370,0)
   <td style="vertical-align:text-bottom">
"KRN",.84,7981999.001,2,371,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,372,0)
     <xsl:with-param name="dt" select="$dtr/@START"/>
"KRN",.84,7981999.001,2,373,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,374,0)
   </td>
"KRN",.84,7981999.001,2,375,0)
  </tr>
"KRN",.84,7981999.001,2,376,0)
 </xsl:if>
"KRN",.84,7981999.001,2,377,0)
 <xsl:if test="$dtr/@END!=''">
"KRN",.84,7981999.001,2,378,0)
  <tr>
"KRN",.84,7981999.001,2,379,0)
   <th scope="row"><xsl:value-of select="$title"/> End&#160;Date:&#160;</th>
"KRN",.84,7981999.001,2,380,0)
   <td style="vertical-align:text-bottom">
"KRN",.84,7981999.001,2,381,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,382,0)
     <xsl:with-param name="dt" select="$dtr/@END"/>
"KRN",.84,7981999.001,2,383,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,384,0)
   </td>
"KRN",.84,7981999.001,2,385,0)
  </tr>
"KRN",.84,7981999.001,2,386,0)
 </xsl:if>
"KRN",.84,7981999.001,2,387,0)
</xsl:template>
"KRN",.84,7981999.001,2,388,0)
-->
"KRN",.84,7981999.001,2,389,0)
 
"KRN",.84,7981999.001,2,390,0)
<xsl:template match="PARAMETERS/DIVISIONS">
"KRN",.84,7981999.001,2,391,0)
 <xsl:call-template name="ParamsList">
"KRN",.84,7981999.001,2,392,0)
  <xsl:with-param name="heading" select="'Divisions'"/>
"KRN",.84,7981999.001,2,393,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,394,0)
</xsl:template>
"KRN",.84,7981999.001,2,395,0)
 
"KRN",.84,7981999.001,2,396,0)
<xsl:template match="PARAMETERS/ICD9LST">
"KRN",.84,7981999.001,2,397,0)
 <tr>
"KRN",.84,7981999.001,2,398,0)
  <th scope="row">ICD-9:&#160;</th>
"KRN",.84,7981999.001,2,399,0)
  <td>
"KRN",.84,7981999.001,2,400,0)
   <dl>
"KRN",.84,7981999.001,2,401,0)
    <xsl:if test="@DESCR!=''">
"KRN",.84,7981999.001,2,402,0)
     <dt><xsl:value-of select="@DESCR"/></dt>
"KRN",.84,7981999.001,2,403,0)
    </xsl:if>
"KRN",.84,7981999.001,2,404,0)
    <xsl:if test=".='ALL'"><dt>ALL</dt></xsl:if>
"KRN",.84,7981999.001,2,405,0)
    <xsl:apply-templates select="GROUP"/>
"KRN",.84,7981999.001,2,406,0)
   </dl>
"KRN",.84,7981999.001,2,407,0)
  </td>
"KRN",.84,7981999.001,2,408,0)
 </tr>
"KRN",.84,7981999.001,2,409,0)
</xsl:template>
"KRN",.84,7981999.001,2,410,0)
 
"KRN",.84,7981999.001,2,411,0)
<xsl:template match="PARAMETERS/ICD9LST/GROUP">
"KRN",.84,7981999.001,2,412,0)
 <dt><b><xsl:value-of select="@NAME"/></b></dt>
"KRN",.84,7981999.001,2,413,0)
 <dd><dl>
"KRN",.84,7981999.001,2,414,0)
  <xsl:if test="@DESCR!=''">
"KRN",.84,7981999.001,2,415,0)
   <dt><xsl:value-of select="@DESCR"/></dt>
"KRN",.84,7981999.001,2,416,0)
  </xsl:if>
"KRN",.84,7981999.001,2,417,0)
  <xsl:for-each select="ICD9">
"KRN",.84,7981999.001,2,418,0)
   <xsl:sort select="."/>
"KRN",.84,7981999.001,2,419,0)
   <xsl:if test="position()>1"><xsl:text>; </xsl:text></xsl:if>
"KRN",.84,7981999.001,2,420,0)
   <xsl:value-of select="."/>
"KRN",.84,7981999.001,2,421,0)
  </xsl:for-each>
"KRN",.84,7981999.001,2,422,0)
 </dl></dd>
"KRN",.84,7981999.001,2,423,0)
</xsl:template>
"KRN",.84,7981999.001,2,424,0)
 
"KRN",.84,7981999.001,2,425,0)
<xsl:template match="PARAMETERS/ICD9FILT">
"KRN",.84,7981999.001,2,426,0)
 <tr>
"KRN",.84,7981999.001,2,427,0)
  <th scope="row">Other Diagnoses:&#160;</th>
"KRN",.84,7981999.001,2,428,0)
  <td>
"KRN",.84,7981999.001,2,429,0)
   <dl>
"KRN",.84,7981999.001,2,430,0)
    <xsl:if test="@FILTER!=''">
"KRN",.84,7981999.001,2,431,0)
      <xsl:choose>
"KRN",.84,7981999.001,2,432,0)
        <xsl:when test="@FILTER='EXCLUDE'">
"KRN",.84,7981999.001,2,433,0)
          <dt><xsl:text>Exclude</xsl:text></dt>
"KRN",.84,7981999.001,2,434,0)
          <xsl:apply-templates select="GROUP"/>
"KRN",.84,7981999.001,2,435,0)
        </xsl:when>
"KRN",.84,7981999.001,2,436,0)
        <xsl:when test="@FILTER='INCLUDE'">
"KRN",.84,7981999.001,2,437,0)
          <dt><xsl:text>Include</xsl:text></dt>
"KRN",.84,7981999.001,2,438,0)
          <xsl:apply-templates select="GROUP"/>
"KRN",.84,7981999.001,2,439,0)
        </xsl:when>
"KRN",.84,7981999.001,2,440,0)
        <xsl:otherwise>
"KRN",.84,7981999.001,2,441,0)
          <dt><xsl:text>All</xsl:text></dt>
"KRN",.84,7981999.001,2,442,0)
        </xsl:otherwise>
"KRN",.84,7981999.001,2,443,0)
      </xsl:choose>
"KRN",.84,7981999.001,2,444,0)
    </xsl:if>
"KRN",.84,7981999.001,2,445,0)
   </dl>
"KRN",.84,7981999.001,2,446,0)
  </td>
"KRN",.84,7981999.001,2,447,0)
 </tr>
"KRN",.84,7981999.001,2,448,0)
</xsl:template>
"KRN",.84,7981999.001,2,449,0)
 
"KRN",.84,7981999.001,2,450,0)
<xsl:template match="PARAMETERS/ICD9FILT/GROUP">
"KRN",.84,7981999.001,2,451,0)
 <dt><b><xsl:value-of select="@ID"/></b></dt>
"KRN",.84,7981999.001,2,452,0)
 <dd><dl>
"KRN",.84,7981999.001,2,453,0)
  <xsl:for-each select="ICD9">
"KRN",.84,7981999.001,2,454,0)
   <xsl:sort select="@ID"/>
"KRN",.84,7981999.001,2,455,0)
   <xsl:if test="position()>1"><xsl:text>; </xsl:text></xsl:if>
"KRN",.84,7981999.001,2,456,0)
   <xsl:value-of select="@ID"/>
"KRN",.84,7981999.001,2,457,0)
  </xsl:for-each>
"KRN",.84,7981999.001,2,458,0)
 </dl></dd>
"KRN",.84,7981999.001,2,459,0)
</xsl:template> 
"KRN",.84,7981999.001,2,460,0)
 
"KRN",.84,7981999.001,2,461,0)
<xsl:template match="PARAMETERS/LOCAL_FIELDS">
"KRN",.84,7981999.001,2,462,0)
 <xsl:variable name="pseudo" select="/REPORT/PARAMETERS/HIV_DX" />
"KRN",.84,7981999.001,2,463,0)
 <xsl:call-template name="LocalList">
"KRN",.84,7981999.001,2,464,0)
  <xsl:with-param name="firstitem" select="$pseudo"/>
"KRN",.84,7981999.001,2,465,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,466,0)
</xsl:template>
"KRN",.84,7981999.001,2,467,0)
 
"KRN",.84,7981999.001,2,468,0)
<!-- Process the pseudo local field -->
"KRN",.84,7981999.001,2,469,0)
<xsl:template match="PARAMETERS/HIV_DX">
"KRN",.84,7981999.001,2,470,0)
 <xsl:if test="count(/REPORT/PARAMETERS/LOCAL_FIELDS/*) &lt; 1">
"KRN",.84,7981999.001,2,471,0)
  <tr>
"KRN",.84,7981999.001,2,472,0)
   <th scope="row">
"KRN",.84,7981999.001,2,473,0)
    <xsl:text>Local Fields:&#160;</xsl:text>
"KRN",.84,7981999.001,2,474,0)
   </th>
"KRN",.84,7981999.001,2,475,0)
   <td>
"KRN",.84,7981999.001,2,476,0)
    <xsl:text>Diagnosed at this VA (</xsl:text>
"KRN",.84,7981999.001,2,477,0)
    <xsl:value-of select="."/>
"KRN",.84,7981999.001,2,478,0)
    <xsl:text>)</xsl:text>
"KRN",.84,7981999.001,2,479,0)
   </td>
"KRN",.84,7981999.001,2,480,0)
  </tr>
"KRN",.84,7981999.001,2,481,0)
 </xsl:if>
"KRN",.84,7981999.001,2,482,0)
</xsl:template> 
"KRN",.84,7981999.001,2,483,0)
 
"KRN",.84,7981999.001,2,484,0)
<xsl:template match="PARAMETERS/OPTIONS">
"KRN",.84,7981999.001,2,485,0)
 <tr>
"KRN",.84,7981999.001,2,486,0)
  <th scope="row">Options:&#160;</th>
"KRN",.84,7981999.001,2,487,0)
  <td>
"KRN",.84,7981999.001,2,488,0)
    <xsl:if test="@ALL_FILLS='1'"><xsl:text>All fills</xsl:text></xsl:if>
"KRN",.84,7981999.001,2,489,0)
    <xsl:if test="@RECENT_FILLS='1'"><xsl:text>Most recent fill in time 
"KRN",.84,7981999.001,2,490,0)
period</xsl:text></xsl:if>
"KRN",.84,7981999.001,2,491,0)
    <xsl:if test="@RECENT_FILLS!='1' and @ALL_FILLS!='1'"><xsl:value-of 
"KRN",.84,7981999.001,2,492,0)
select="."/></xsl:if>
"KRN",.84,7981999.001,2,493,0)
  </td>
"KRN",.84,7981999.001,2,494,0)
 </tr>
"KRN",.84,7981999.001,2,495,0)
 <xsl:if test="@MOST_RECENT='1'">
"KRN",.84,7981999.001,2,496,0)
  <tr>
"KRN",.84,7981999.001,2,497,0)
   <th scope="row">Lab Test Date:&#160;</th>
"KRN",.84,7981999.001,2,498,0)
   <td><xsl:text>Most Recent</xsl:text></td>
"KRN",.84,7981999.001,2,499,0)
  </tr>
"KRN",.84,7981999.001,2,500,0)
 </xsl:if>
"KRN",.84,7981999.001,2,501,0)
 <xsl:if test="@MAX_DATE='1'">
"KRN",.84,7981999.001,2,502,0)
  <tr>
"KRN",.84,7981999.001,2,503,0)
   <th scope="row">Lab Test Date:&#160;</th>
"KRN",.84,7981999.001,2,504,0)
   <td>
"KRN",.84,7981999.001,2,505,0)
    <xsl:text>As of </xsl:text>
"KRN",.84,7981999.001,2,506,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,507,0)
     <xsl:with-param name="dt" select="../MAX_DATE"/>
"KRN",.84,7981999.001,2,508,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,509,0)
   </td>
"KRN",.84,7981999.001,2,510,0)
  </tr>
"KRN",.84,7981999.001,2,511,0)
 </xsl:if>
"KRN",.84,7981999.001,2,512,0)
</xsl:template>
"KRN",.84,7981999.001,2,513,0)
 
"KRN",.84,7981999.001,2,514,0)
<xsl:template match="PARAMETERS/OTHER_REGISTRIES">
"KRN",.84,7981999.001,2,515,0)
 <xsl:call-template name="ParamsList">
"KRN",.84,7981999.001,2,516,0)
  <xsl:with-param name="heading" select="'Other Registries'"/>
"KRN",.84,7981999.001,2,517,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,518,0)
</xsl:template>
"KRN",.84,7981999.001,2,519,0)
 
"KRN",.84,7981999.001,2,520,0)
<xsl:template match="PARAMETERS/PATIENTS">
"KRN",.84,7981999.001,2,521,0)
 <tr>
"KRN",.84,7981999.001,2,522,0)
  <th scope="row">Patients:&#160;</th>
"KRN",.84,7981999.001,2,523,0)
  <td><xsl:value-of select="."/></td>
"KRN",.84,7981999.001,2,524,0)
 </tr>
"KRN",.84,7981999.001,2,525,0)
</xsl:template>
"KRN",.84,7981999.001,2,526,0)
 
"KRN",.84,7981999.001,2,527,0)
<xsl:template match="PARAMETERS/REGNAME">
"KRN",.84,7981999.001,2,528,0)
 <tr>
"KRN",.84,7981999.001,2,529,0)
  <th scope="row">Registry:&#160;</th>
"KRN",.84,7981999.001,2,530,0)
  <td><xsl:value-of select="."/></td>
"KRN",.84,7981999.001,2,531,0)
 </tr>
"KRN",.84,7981999.001,2,532,0)
</xsl:template>
"KRN",.84,7981999.001,2,533,0)
 
"KRN",.84,7981999.001,2,534,0)
<xsl:template match="PARAMETERS/TASK_COMMENT">
"KRN",.84,7981999.001,2,535,0)
 <tr>
"KRN",.84,7981999.001,2,536,0)
  <th scope="row">Comment:&#160;</th>
"KRN",.84,7981999.001,2,537,0)
  <td><xsl:value-of select="."/></td>
"KRN",.84,7981999.001,2,538,0)
 </tr>
"KRN",.84,7981999.001,2,539,0)
</xsl:template>
"KRN",.84,7981999.001,2,540,0)
 
"KRN",.84,7981999.001,2,541,0)
<xsl:template match="PARAMETERS/UTIL_TYPES">
"KRN",.84,7981999.001,2,542,0)
 <tr>
"KRN",.84,7981999.001,2,543,0)
  <th scope="row">Utilization:&#160;</th>
"KRN",.84,7981999.001,2,544,0)
  <td><xsl:value-of select="."/></td>
"KRN",.84,7981999.001,2,545,0)
 </tr>
"KRN",.84,7981999.001,2,546,0)
</xsl:template>
"KRN",.84,7981999.001,2,547,0)
 
"KRN",.84,7981999.001,2,548,0)
<xsl:template match="PARAMETERS/LRGRANGES">
"KRN",.84,7981999.001,2,549,0)
 <tr>
"KRN",.84,7981999.001,2,550,0)
  <th scope="row">Results:&#160;</th>
"KRN",.84,7981999.001,2,551,0)
  <td>
"KRN",.84,7981999.001,2,552,0)
   <xsl:for-each select="LRGRANGE">
"KRN",.84,7981999.001,2,553,0)
    <xsl:value-of select="."/><br/>
"KRN",.84,7981999.001,2,554,0)
   </xsl:for-each>
"KRN",.84,7981999.001,2,555,0)
  </td>
"KRN",.84,7981999.001,2,556,0)
 </tr>
"KRN",.84,7981999.001,2,557,0)
</xsl:template>
"KRN",.84,7981999.001,2,558,0)
 
"KRN",.84,7981999.001,2,559,0)
<xsl:template match="PARAMETERS/DATE_RANGE_3">
"KRN",.84,7981999.001,2,560,0)
 <xsl:call-template name="DateRange">
"KRN",.84,7981999.001,2,561,0)
  <xsl:with-param name="title" select="'Utilization'"/>
"KRN",.84,7981999.001,2,562,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,563,0)
</xsl:template>
"KRN",.84,7981999.001,2,564,0)
 
"KRN",.84,7981999.001,2,565,0)
 
"KRN",.84,7981999.001,2,566,0)
<!--
"KRN",.84,7981999.001,2,567,0)
=========================================================================
"KRN",.84,7981999.001,2,568,0)
                       DEFAULT DATA GRID TEMPLATES
"KRN",.84,7981999.001,2,569,0)
=========================================================================
"KRN",.84,7981999.001,2,570,0)
-->
"KRN",.84,7981999.001,2,571,0)
 
"KRN",.84,7981999.001,2,572,0)
<xsl:template name="DataGrid" match="*[@TABLE!='']">
"KRN",.84,7981999.001,2,573,0)
 <xsl:param name="divstyle" select="''"/>
"KRN",.84,7981999.001,2,574,0)
 <xsl:param name="scroll" select="*[31]"/>
"KRN",.84,7981999.001,2,575,0)
 <xsl:variable name="tbldef" select="key('TableDefs',@TABLE)"/>
"KRN",.84,7981999.001,2,576,0)
 <xsl:choose>
"KRN",.84,7981999.001,2,577,0)
  <xsl:when test="*[1]">
"KRN",.84,7981999.001,2,578,0)
   <div>
"KRN",.84,7981999.001,2,579,0)
    <xsl:if test="$divstyle!=''">
"KRN",.84,7981999.001,2,580,0)
     <xsl:attribute name="style">
"KRN",.84,7981999.001,2,581,0)
      <xsl:value-of select="$divstyle"/>
"KRN",.84,7981999.001,2,582,0)
     </xsl:attribute>
"KRN",.84,7981999.001,2,583,0)
    </xsl:if>
"KRN",.84,7981999.001,2,584,0)
    <xsl:call-template name="MakeScrollable">
"KRN",.84,7981999.001,2,585,0)
     <xsl:with-param name="condition" select="$scroll"/>
"KRN",.84,7981999.001,2,586,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,587,0)
    <table class="dataGrid" cellpadding="5" cellspacing="0">
"KRN",.84,7981999.001,2,588,0)
     <xsl:apply-templates select="$tbldef/@HEADER"/>
"KRN",.84,7981999.001,2,589,0)
     <xsl:apply-templates select="$tbldef/@FOOTER"/>
"KRN",.84,7981999.001,2,590,0)
     <tbody>
"KRN",.84,7981999.001,2,591,0)
      <xsl:apply-templates select="*">
"KRN",.84,7981999.001,2,592,0)
       <xsl:with-param name="seqnum"
"KRN",.84,7981999.001,2,593,0)
            select="count($tbldef/COLUMN[@NAME='#'])"/>
"KRN",.84,7981999.001,2,594,0)
      </xsl:apply-templates>
"KRN",.84,7981999.001,2,595,0)
     </tbody>
"KRN",.84,7981999.001,2,596,0)
    </table>
"KRN",.84,7981999.001,2,597,0)
   </div>
"KRN",.84,7981999.001,2,598,0)
  </xsl:when>
"KRN",.84,7981999.001,2,599,0)
  <xsl:otherwise>
"KRN",.84,7981999.001,2,600,0)
   <xsl:call-template name="TableNoData"/>
"KRN",.84,7981999.001,2,601,0)
  </xsl:otherwise>
"KRN",.84,7981999.001,2,602,0)
 </xsl:choose>
"KRN",.84,7981999.001,2,603,0)
</xsl:template>
"KRN",.84,7981999.001,2,604,0)
 
"KRN",.84,7981999.001,2,605,0)
<!-- Default data grid header -->
"KRN",.84,7981999.001,2,606,0)
 
"KRN",.84,7981999.001,2,607,0)
<xsl:template match="HEADER/TBLDEF/@HEADER">
"KRN",.84,7981999.001,2,608,0)
 <thead>
"KRN",.84,7981999.001,2,609,0)
  <tr><xsl:apply-templates select="../COLUMN"/></tr>
"KRN",.84,7981999.001,2,610,0)
 </thead>
"KRN",.84,7981999.001,2,611,0)
</xsl:template>
"KRN",.84,7981999.001,2,612,0)
 
"KRN",.84,7981999.001,2,613,0)
<!-- Default column heading cell -->
"KRN",.84,7981999.001,2,614,0)
 
"KRN",.84,7981999.001,2,615,0)
<xsl:template name="ColumnHeader" match="HEADER/TBLDEF/COLUMN">
"KRN",.84,7981999.001,2,616,0)
 <xsl:param name="column" select="."/>
"KRN",.84,7981999.001,2,617,0)
 <xsl:param name="colname" select="$column/@NAME"/>
"KRN",.84,7981999.001,2,618,0)
 <xsl:param name="sortmode"/>
"KRN",.84,7981999.001,2,619,0)
 <xsl:param name="sort" 
"KRN",.84,7981999.001,2,620,0)
      select="concat($column/../@NAME,'=',$colname,$sortmode)"/>
"KRN",.84,7981999.001,2,621,0)
 <xsl:param name="title" select="$colname"/>
"KRN",.84,7981999.001,2,622,0)
 <xsl:param name="colspan" select="0"/>
"KRN",.84,7981999.001,2,623,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,624,0)
 <xsl:param name="style"/>
"KRN",.84,7981999.001,2,625,0)
 <xsl:param name="width"/>
"KRN",.84,7981999.001,2,626,0)
 <th scope="col">
"KRN",.84,7981999.001,2,627,0)
  <xsl:if test="$colspan>1">
"KRN",.84,7981999.001,2,628,0)
   <xsl:attribute name="colspan">
"KRN",.84,7981999.001,2,629,0)
    <xsl:value-of select="$colspan"/>
"KRN",.84,7981999.001,2,630,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,631,0)
  </xsl:if>
"KRN",.84,7981999.001,2,632,0)
  <xsl:if test="$rowspan>1">
"KRN",.84,7981999.001,2,633,0)
   <xsl:attribute name="rowspan">
"KRN",.84,7981999.001,2,634,0)
    <xsl:value-of select="$rowspan"/>
"KRN",.84,7981999.001,2,635,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,636,0)
  </xsl:if>
"KRN",.84,7981999.001,2,637,0)
  <xsl:if test="string($style)!=''">
"KRN",.84,7981999.001,2,638,0)
   <xsl:attribute name="style">
"KRN",.84,7981999.001,2,639,0)
    <xsl:value-of select="$style"/>
"KRN",.84,7981999.001,2,640,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,641,0)
  </xsl:if>
"KRN",.84,7981999.001,2,642,0)
  <xsl:if test="string($width)!=''">
"KRN",.84,7981999.001,2,643,0)
   <xsl:attribute name="width">
"KRN",.84,7981999.001,2,644,0)
    <xsl:value-of select="$width"/>
"KRN",.84,7981999.001,2,645,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,646,0)
  </xsl:if>
"KRN",.84,7981999.001,2,647,0)
  <xsl:choose>
"KRN",.84,7981999.001,2,648,0)
   <xsl:when test="$title=''">&#160;</xsl:when>
"KRN",.84,7981999.001,2,649,0)
   <xsl:when test="($sort!='') and not($REMOVE_URLS)">
"KRN",.84,7981999.001,2,650,0)
    <xsl:element name="a">
"KRN",.84,7981999.001,2,651,0)
     <xsl:attribute name="href">
"KRN",.84,7981999.001,2,652,0)
      <xsl:text>http://vista/report/sort?</xsl:text>
"KRN",.84,7981999.001,2,653,0)
      <xsl:value-of select="$sort"/>
"KRN",.84,7981999.001,2,654,0)
     </xsl:attribute>
"KRN",.84,7981999.001,2,655,0)
     <xsl:value-of select="$title"/>
"KRN",.84,7981999.001,2,656,0)
    </xsl:element>
"KRN",.84,7981999.001,2,657,0)
   </xsl:when>
"KRN",.84,7981999.001,2,658,0)
   <xsl:otherwise><xsl:value-of select="$title"/></xsl:otherwise>
"KRN",.84,7981999.001,2,659,0)
  </xsl:choose>
"KRN",.84,7981999.001,2,660,0)
 </th>
"KRN",.84,7981999.001,2,661,0)
</xsl:template>
"KRN",.84,7981999.001,2,662,0)
 
"KRN",.84,7981999.001,2,663,0)
<!-- Default Footer -->
"KRN",.84,7981999.001,2,664,0)
 
"KRN",.84,7981999.001,2,665,0)
<xsl:template name="DataGridFooter" match="TBLDEF/@FOOTER">
"KRN",.84,7981999.001,2,666,0)
 <xsl:param name="colspan"
"KRN",.84,7981999.001,2,667,0)
      select="count(..//COLUMN[not(child::COLUMN[1])])"/>
"KRN",.84,7981999.001,2,668,0)
 <tfoot><tr><td>
"KRN",.84,7981999.001,2,669,0)
  <xsl:if test="$colspan>1">
"KRN",.84,7981999.001,2,670,0)
   <xsl:attribute name="colspan">
"KRN",.84,7981999.001,2,671,0)
    <xsl:value-of select="$colspan"/>
"KRN",.84,7981999.001,2,672,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,673,0)
  </xsl:if>
"KRN",.84,7981999.001,2,674,0)
  <xsl:text>&#160;</xsl:text>
"KRN",.84,7981999.001,2,675,0)
 </td></tr></tfoot>
"KRN",.84,7981999.001,2,676,0)
</xsl:template>
"KRN",.84,7981999.001,2,677,0)
 
"KRN",.84,7981999.001,2,678,0)
<!-- Default data grid row -->
"KRN",.84,7981999.001,2,679,0)
 
"KRN",.84,7981999.001,2,680,0)
<xsl:template match="*[@TABLE!='']/*">
"KRN",.84,7981999.001,2,681,0)
 <xsl:param name="seqnum" select="0"/>
"KRN",.84,7981999.001,2,682,0)
 <tr>
"KRN",.84,7981999.001,2,683,0)
  <xsl:if test="$seqnum">
"KRN",.84,7981999.001,2,684,0)
   <td><xsl:value-of select="position()"/></td>
"KRN",.84,7981999.001,2,685,0)
  </xsl:if>
"KRN",.84,7981999.001,2,686,0)
  <xsl:apply-templates select="child::*"/>
"KRN",.84,7981999.001,2,687,0)
 </tr>
"KRN",.84,7981999.001,2,688,0)
</xsl:template>
"KRN",.84,7981999.001,2,689,0)
 
"KRN",.84,7981999.001,2,690,0)
<!-- Data grid cell -->
"KRN",.84,7981999.001,2,691,0)
 
"KRN",.84,7981999.001,2,692,0)
<xsl:template name="TableCell" match="*[@TABLE!='']/*/*">
"KRN",.84,7981999.001,2,693,0)
 <xsl:param name="class"/>
"KRN",.84,7981999.001,2,694,0)
 <xsl:param name="colspan" select="0"/>
"KRN",.84,7981999.001,2,695,0)
 <xsl:param name="fmdt" select="0"/>
"KRN",.84,7981999.001,2,696,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,697,0)
 <xsl:param name="style"/>
"KRN",.84,7981999.001,2,698,0)
 <xsl:param name="value" select="."/>
"KRN",.84,7981999.001,2,699,0)
 <xsl:param name="width"/>
"KRN",.84,7981999.001,2,700,0)
 <xsl:param name="yesno" select="0"/>
"KRN",.84,7981999.001,2,701,0)
 <td>
"KRN",.84,7981999.001,2,702,0)
  <xsl:if test="string($class)!=''">
"KRN",.84,7981999.001,2,703,0)
   <xsl:attribute name="class">
"KRN",.84,7981999.001,2,704,0)
    <xsl:value-of select="$class"/>
"KRN",.84,7981999.001,2,705,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,706,0)
  </xsl:if>
"KRN",.84,7981999.001,2,707,0)
  <xsl:if test="$colspan>1">
"KRN",.84,7981999.001,2,708,0)
   <xsl:attribute name="colspan">
"KRN",.84,7981999.001,2,709,0)
    <xsl:value-of select="$colspan"/>
"KRN",.84,7981999.001,2,710,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,711,0)
  </xsl:if>
"KRN",.84,7981999.001,2,712,0)
  <xsl:if test="$rowspan>1">
"KRN",.84,7981999.001,2,713,0)
   <xsl:attribute name="rowspan">
"KRN",.84,7981999.001,2,714,0)
    <xsl:value-of select="$rowspan"/>
"KRN",.84,7981999.001,2,715,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,716,0)
  </xsl:if>
"KRN",.84,7981999.001,2,717,0)
  <xsl:if test="string($style)!=''">
"KRN",.84,7981999.001,2,718,0)
   <xsl:attribute name="style">
"KRN",.84,7981999.001,2,719,0)
    <xsl:value-of select="$style"/>
"KRN",.84,7981999.001,2,720,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,721,0)
  </xsl:if>
"KRN",.84,7981999.001,2,722,0)
  <xsl:if test="string($width)!=''">
"KRN",.84,7981999.001,2,723,0)
   <xsl:attribute name="width">
"KRN",.84,7981999.001,2,724,0)
    <xsl:value-of select="$width"/>
"KRN",.84,7981999.001,2,725,0)
   </xsl:attribute>
"KRN",.84,7981999.001,2,726,0)
  </xsl:if>
"KRN",.84,7981999.001,2,727,0)
  <xsl:choose>
"KRN",.84,7981999.001,2,728,0)
   <xsl:when test="string($value)=''">&#160;</xsl:when>
"KRN",.84,7981999.001,2,729,0)
   <xsl:when test="boolean($fmdt)">
"KRN",.84,7981999.001,2,730,0)
    <xsl:call-template name="DateTime">
"KRN",.84,7981999.001,2,731,0)
     <xsl:with-param name="dt" select="$value"/>
"KRN",.84,7981999.001,2,732,0)
    </xsl:call-template>
"KRN",.84,7981999.001,2,733,0)
   </xsl:when>
"KRN",.84,7981999.001,2,734,0)
   <xsl:when test="boolean($yesno)">
"KRN",.84,7981999.001,2,735,0)
    <xsl:choose>
"KRN",.84,7981999.001,2,736,0)
     <xsl:when test="$value!=0">Yes</xsl:when>
"KRN",.84,7981999.001,2,737,0)
     <xsl:otherwise>No</xsl:otherwise>
"KRN",.84,7981999.001,2,738,0)
    </xsl:choose>
"KRN",.84,7981999.001,2,739,0)
   </xsl:when>
"KRN",.84,7981999.001,2,740,0)
   <xsl:otherwise><xsl:value-of select="$value"/></xsl:otherwise>
"KRN",.84,7981999.001,2,741,0)
  </xsl:choose>
"KRN",.84,7981999.001,2,742,0)
 </td>
"KRN",.84,7981999.001,2,743,0)
</xsl:template>
"KRN",.84,7981999.001,2,744,0)
 
"KRN",.84,7981999.001,2,745,0)
<!-- Default column headings -->
"KRN",.84,7981999.001,2,746,0)
 
"KRN",.84,7981999.001,2,747,0)
<xsl:template match="TBLDEF/COLUMN[@NAME='#']">
"KRN",.84,7981999.001,2,748,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,749,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.001,2,750,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,751,0)
  <xsl:with-param name="sort" select="''"/>
"KRN",.84,7981999.001,2,752,0)
  <xsl:with-param name="width" select="'4%'"/>
"KRN",.84,7981999.001,2,753,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,754,0)
</xsl:template>
"KRN",.84,7981999.001,2,755,0)
 
"KRN",.84,7981999.001,2,756,0)
<xsl:template match="COLUMN[@NAME='DATE']">                                    
"KRN",.84,7981999.001,2,757,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,758,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.001,2,759,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,760,0)
  <xsl:with-param name="title" select="'Date'"/>                               
"KRN",.84,7981999.001,2,761,0)
  <xsl:with-param name="width" select="'15%'"/>
"KRN",.84,7981999.001,2,762,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,763,0)
</xsl:template>
"KRN",.84,7981999.001,2,764,0)
 
"KRN",.84,7981999.001,2,765,0)
<xsl:template match="COLUMN[@NAME='DOD']">
"KRN",.84,7981999.001,2,766,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,767,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.001,2,768,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,769,0)
  <xsl:with-param name="title" select="'Date of Death'"/>
"KRN",.84,7981999.001,2,770,0)
  <xsl:with-param name="width" select="'7%'"/>
"KRN",.84,7981999.001,2,771,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,772,0)
</xsl:template>
"KRN",.84,7981999.001,2,773,0)
 
"KRN",.84,7981999.001,2,774,0)
<xsl:template match="COLUMN[@NAME='LAST4']">
"KRN",.84,7981999.001,2,775,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,776,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.001,2,777,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,778,0)
  <xsl:with-param name="title" select="'SSN'"/>
"KRN",.84,7981999.001,2,779,0)
  <xsl:with-param name="width" select="'7%'"/>
"KRN",.84,7981999.001,2,780,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,781,0)
</xsl:template>
"KRN",.84,7981999.001,2,782,0)
 
"KRN",.84,7981999.001,2,783,0)
<xsl:template match="COLUMN[@NAME='NAME']">
"KRN",.84,7981999.001,2,784,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,785,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.001,2,786,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,787,0)
  <xsl:with-param name="title" select="'Name'"/>
"KRN",.84,7981999.001,2,788,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,789,0)
</xsl:template>
"KRN",.84,7981999.001,2,790,0)
 
"KRN",.84,7981999.001,2,791,0)
<xsl:template match="TBLDEF[@NAME='PATIENTS']/COLUMN[@NAME='NAME']">
"KRN",.84,7981999.001,2,792,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,793,0)
 <xsl:call-template name="ColumnHeader">
"KRN",.84,7981999.001,2,794,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,795,0)
  <xsl:with-param name="title" select="'Patient Name'"/>
"KRN",.84,7981999.001,2,796,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,797,0)
</xsl:template>
"KRN",.84,7981999.001,2,798,0)
 
"KRN",.84,7981999.001,2,799,0)
<!-- Default cells -->
"KRN",.84,7981999.001,2,800,0)
 
"KRN",.84,7981999.001,2,801,0)
<xsl:template match="PATIENT/DOD">
"KRN",.84,7981999.001,2,802,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,803,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981999.001,2,804,0)
  <xsl:with-param name="fmdt" select="1"/>
"KRN",.84,7981999.001,2,805,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,806,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,807,0)
</xsl:template>
"KRN",.84,7981999.001,2,808,0)
 
"KRN",.84,7981999.001,2,809,0)
<xsl:template match="*[@TABLE!='']/*/NAME">
"KRN",.84,7981999.001,2,810,0)
 <xsl:param name="rowspan" select="0"/>
"KRN",.84,7981999.001,2,811,0)
 <xsl:call-template name="TableCell">
"KRN",.84,7981999.001,2,812,0)
  <xsl:with-param name="class" select="'aLeft'"/>
"KRN",.84,7981999.001,2,813,0)
  <xsl:with-param name="rowspan" select="$rowspan"/>
"KRN",.84,7981999.001,2,814,0)
 </xsl:call-template>
"KRN",.84,7981999.001,2,815,0)
</xsl:template>
"KRN",.84,7981999.001,2,816,0)
 
"KRN",.84,7981999.001,2,817,0)
</xsl:stylesheet>
"KRN",.84,7981999.001,3,0)
^.845
"MBREQ")
0
"ORD",9,.84)
.84;9;;;EDEOUT^DIFROMSO(.84,DA,"",XPDA);FPRE^DIFROMSI(.84,"",XPDA);EPRE^DIFROMSI(.84,DA,"",XPDA,"",OLDA);;EPOST^DIFROMSI(.84,DA,"",XPDA);DEL^DIFROMSK(.84,"",%)
"ORD",9,.84,0)
DIALOG
"PGL",799.51,0,2,.02)
REGISTRY^RP798.1'X^ROR(798.1,^0;2^Q:$$VAEDT^RORDD(799.51,$G(DA))
"PGL",799.51,0,3,.03)
DRUG GROUP^R*P799.1'X^ROR(799.1,^0;3^Q:$$VAEDT^RORDD(799.51,$G(DA))  S Y=$P($G(^ROR(799.51,DA,0)),U,2),DIC("S")="S D=$G(^(0)) I $P(D,U,2)=4"_$S(Y>0:",$P(D,U,3)="_Y,1:"") D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"PGL",799.51,0,4,.04)
VA GENERIC^RP50.6'X^PSNDF(50.6,^0;4^Q:$$VAEDT^RORDD(799.51,$G(DA))
"PKG",618,-1)
1^1
"PKG",618,0)
CLINICAL CASE REGISTRIES^ROR^CLINICAL REGISTRIES
"PKG",618,20,0)
^9.402P^^
"PKG",618,22,0)
^9.49I^1^1
"PKG",618,22,1,0)
1.5^3060208^3060419^568
"PKG",618,22,1,"PAH",1,0)
15^3110908
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
9
"RTN","RORP015")
0^9^B962707^n/a
"RTN","RORP015",1,0)
RORP015 ;BP/ACS CCR PRE/POST-INIT PATCH 15 ; 6/23/11 10:57am
"RTN","RORP015",2,0)
 ;;1.5;CLINICAL CASE REGISTRIES;**15**;Feb 17, 2006;Build 27
"RTN","RORP015",3,0)
 ;
"RTN","RORP015",4,0)
 ; This routine uses the following IAs:
"RTN","RORP015",5,0)
 ;
"RTN","RORP015",6,0)
 ; #2053    UPDATE^DIE (supported)
"RTN","RORP015",7,0)
 ; #10075   OPTION file r/w
"RTN","RORP015",8,0)
 N RORPARM S RORPARM("DEVELOPER")=1
"RTN","RORP015",9,0)
 ;
"RTN","RORP015",10,0)
 ;********************************************************************
"RTN","RORP015",11,0)
 ;Remove erroneous NON-VA MEDS entry from the ROR HISTORICAL DATA
"RTN","RORP015",12,0)
 ;EXTRACT file.  Entry will be re-added during installation.
"RTN","RORP015",13,0)
 ;********************************************************************
"RTN","RORP015",14,0)
PRE ;
"RTN","RORP015",15,0)
 N RORIEN,X,DIK S RORIEN=$O(^RORDATA(799.6,"B","NON-VA MEDS",0))
"RTN","RORP015",16,0)
 I $G(RORIEN) D
"RTN","RORP015",17,0)
 . N DIK,DA
"RTN","RORP015",18,0)
 . S DIK="^RORDATA(799.6,",DA=RORIEN D ^DIK
"RTN","RORP015",19,0)
 Q
"RTN","RORP015",20,0)
POST ;
"RTN","RORP015",21,0)
 ;
"RTN","RORP015",22,0)
 ;*******************************************************************
"RTN","RORP015",23,0)
 ;
"RTN","RORP015",24,0)
 ;Delete entries in ROR GENERIC DRUG with unresolved pointers
"RTN","RORP015",25,0)
 ;
"RTN","RORP015",26,0)
 ;********************************************************************
"RTN","RORP015",27,0)
 ;clean up 799.51 if pointers are bad
"RTN","RORP015",28,0)
 N DIC,X,DIK,DA,RORNAME,Y
"RTN","RORP015",29,0)
 S DIC=799.51,DIC(0)="MNZ"
"RTN","RORP015",30,0)
 F RORNAME="TELAPREVIR","BOCEPREVIR","RILPIVIRINE" D
"RTN","RORP015",31,0)
 .S X=RORNAME D ^DIC Q:+Y<0
"RTN","RORP015",32,0)
 .Q:+$P(Y(0),U,4)>0
"RTN","RORP015",33,0)
 .S DA=+Y,DIK="^ROR(799.51," D ^DIK
"RTN","RORP015",34,0)
 Q
"RTN","RORRP015")
0^5^B22836599^B22232247
"RTN","RORRP015",1,0)
RORRP015 ;HCIOFO/SG - RPC: DIVISIONS AND HOSPITAL LOCATIONS ; 5/25/11 11:49am
"RTN","RORRP015",2,0)
 ;;1.5;CLINICAL CASE REGISTRIES;**1,15**;Feb 17, 2006;Build 27
"RTN","RORRP015",3,0)
 ;
"RTN","RORRP015",4,0)
 ; This routine uses the following IAs:
"RTN","RORRP015",5,0)
 ;
"RTN","RORRP015",6,0)
 ; #1246         WIN^DGPMDDCF (supported)
"RTN","RORRP015",7,0)
 ; #417          Access to the file #40.8 (controlled)
"RTN","RORRP015",8,0)
 ; #10040        Access to the HOSPITAL LOCATION file (supported)
"RTN","RORRP015",9,0)
 ;
"RTN","RORRP015",10,0)
 Q
"RTN","RORRP015",11,0)
 ;
"RTN","RORRP015",12,0)
 ;***** CHECKS IF THE HOSPITAL LOCATION IS ACTIVE
"RTN","RORRP015",13,0)
 ;
"RTN","RORRP015",14,0)
 ; LOCIEN        IEN of the hospital location
"RTN","RORRP015",15,0)
 ;
"RTN","RORRP015",16,0)
ACTLOC(LOCIEN) ;
"RTN","RORRP015",17,0)
 N D0,DGPMOS,RDT,X
"RTN","RORRP015",18,0)
 Q:$G(^SC(LOCIEN,"OOS")) 0              ; An OOS entry
"RTN","RORRP015",19,0)
 S D0=+$G(^SC(LOCIEN,42))
"RTN","RORRP015",20,0)
 I D0>0  D WIN^DGPMDDCF  Q 'X           ; Check if ward is inactive
"RTN","RORRP015",21,0)
 S X=$G(^SC(LOCIEN,"I"))  Q:'$P(X,U) 1  ; No inactivation date
"RTN","RORRP015",22,0)
 S RDT=+$P(X,U,2)
"RTN","RORRP015",23,0)
 I DT>$P(X,U)  Q:'RDT!(DT<RDT) 0        ; Check reactivation date
"RTN","RORRP015",24,0)
 Q 1
"RTN","RORRP015",25,0)
 ;
"RTN","RORRP015",26,0)
 ;***** RETURNS THE LIST OF DIVISIONS
"RTN","RORRP015",27,0)
 ; RPC: [ROR LIST DIVISIONS]
"RTN","RORRP015",28,0)
 ;
"RTN","RORRP015",29,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP015",30,0)
 ;               are returned to.
"RTN","RORRP015",31,0)
 ;
"RTN","RORRP015",32,0)
 ; [PART]        The partial match restriction.
"RTN","RORRP015",33,0)
 ;
"RTN","RORRP015",34,0)
 ; [FLAGS]       Flags that control the execution (can be combined)
"RTN","RORRP015",35,0)
 ;                 B  Backwards. Traverses the index in the opposite
"RTN","RORRP015",36,0)
 ;                    direction of normal traversal.
"RTN","RORRP015",37,0)
 ;
"RTN","RORRP015",38,0)
 ; [NUMBER]      Maximum number of entries to return. A value of "*"
"RTN","RORRP015",39,0)
 ;               or no value in this parameter designates all entries.
"RTN","RORRP015",40,0)
 ;
"RTN","RORRP015",41,0)
 ; [FROM]        The index entry(s) from which to begin the list
"RTN","RORRP015",42,0)
 ;                 ^01: FromName
"RTN","RORRP015",43,0)
 ;                 ^02: FromIEN
"RTN","RORRP015",44,0)
 ;
"RTN","RORRP015",45,0)
 ;               For example, a FROM value of "VA" would list entries
"RTN","RORRP015",46,0)
 ;               following VA. You can use the 2-nd and 3-rd "^"-
"RTN","RORRP015",47,0)
 ;               pieces of the @RESULTS@(0) node to continue the
"RTN","RORRP015",48,0)
 ;               listing in the subsequent procedure calls.
"RTN","RORRP015",49,0)
 ;
"RTN","RORRP015",50,0)
 ;               NOTE: The FROM value itself is not included in
"RTN","RORRP015",51,0)
 ;                     the resulting list.
"RTN","RORRP015",52,0)
 ;
"RTN","RORRP015",53,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP015",54,0)
 ;
"RTN","RORRP015",55,0)
 ; See description of the LIST^DIC for more details about the
"RTN","RORRP015",56,0)
 ; PART, NUMBER and FROM parameters.
"RTN","RORRP015",57,0)
 ;
"RTN","RORRP015",58,0)
 ; Return Values:
"RTN","RORRP015",59,0)
 ;
"RTN","RORRP015",60,0)
 ; A negative value of the first "^"-piece of the @RESULTS@(0)
"RTN","RORRP015",61,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP015",62,0)
 ; details).
"RTN","RORRP015",63,0)
 ;
"RTN","RORRP015",64,0)
 ; Otherwise, number of divisions and the value of the FROM parameter
"RTN","RORRP015",65,0)
 ; for the next procedure call are returned in the @RESULTS@(0) and
"RTN","RORRP015",66,0)
 ; the subsequent nodes of the global array contain the divisions.
"RTN","RORRP015",67,0)
 ; 
"RTN","RORRP015",68,0)
 ; @RESULTS@(0)          Result Descriptor
"RTN","RORRP015",69,0)
 ;                         ^01: Number of divisions
"RTN","RORRP015",70,0)
 ;                         ^02: FromName
"RTN","RORRP015",71,0)
 ;                         ^03: FromIEN
"RTN","RORRP015",72,0)
 ;
"RTN","RORRP015",73,0)
 ; @RESULTS@(i)          Division
"RTN","RORRP015",74,0)
 ;                         ^01: IEN
"RTN","RORRP015",75,0)
 ;                         ^02: Name
"RTN","RORRP015",76,0)
 ;                         ^03: Facility Number
"RTN","RORRP015",77,0)
 ;                         ^04: Institution IEN
"RTN","RORRP015",78,0)
 ;
"RTN","RORRP015",79,0)
DIVLIST(RESULTS,PART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP015",80,0)
 N BUF,RC,RORERRDL,RORMSG,TMP,DIERR
"RTN","RORRP015",81,0)
 D CLEAR^RORERR("DIVLIST^RORRP015",1)
"RTN","RORRP015",82,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP015",83,0)
 ;--- Check the parameters
"RTN","RORRP015",84,0)
 S PART=$G(PART),FLAGS=$G(FLAGS)
"RTN","RORRP015",85,0)
 I PART="??" S PART=""  ;user selects All Divisions
"RTN","RORRP015",86,0)
 S NUMBER=$S($G(NUMBER)>0:+NUMBER,1:"*")
"RTN","RORRP015",87,0)
 ;--- Setup the start point
"RTN","RORRP015",88,0)
 I $G(FROM)'=""  D  S FROM=$P(FROM,U)
"RTN","RORRP015",89,0)
 . S:$P(FROM,U,2)>0 FROM("IEN")=+$P(FROM,U,2)
"RTN","RORRP015",90,0)
 ;--- Get the list of divisions
"RTN","RORRP015",91,0)
 S BUF="@;.01;1;.07I",TMP="P"_$S(FLAGS["B":"B",1:"")
"RTN","RORRP015",92,0)
 D LIST^DIC(40.8,,BUF,TMP,NUMBER,.FROM,PART,"B",,,,"RORMSG")
"RTN","RORRP015",93,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP015",94,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,40.8)
"RTN","RORRP015",95,0)
 . K ^TMP("DILIST",$J)
"RTN","RORRP015",96,0)
 ;--- Success
"RTN","RORRP015",97,0)
 S TMP=$G(^TMP("DILIST",$J,0)),BUF=+$P(TMP,U)
"RTN","RORRP015",98,0)
 K ^TMP("DILIST",$J,0)
"RTN","RORRP015",99,0)
 S:$P(TMP,U,3) $P(BUF,U,2,3)=$G(FROM)_U_$G(FROM("IEN"))
"RTN","RORRP015",100,0)
 S @RESULTS@(0)=BUF
"RTN","RORRP015",101,0)
 Q
"RTN","RORRP015",102,0)
 ;
"RTN","RORRP015",103,0)
 ;***** RETURNS THE LIST OF HOSPITAL LOCATIONS
"RTN","RORRP015",104,0)
 ; RPC: [ROR LIST HOSPITAL LOCATIONS]
"RTN","RORRP015",105,0)
 ;
"RTN","RORRP015",106,0)
 ; .RESULTS      Reference to a local variable where the results
"RTN","RORRP015",107,0)
 ;               are returned to.
"RTN","RORRP015",108,0)
 ;
"RTN","RORRP015",109,0)
 ; [HLTYPES]     List of location types separated by commas (internal
"RTN","RORRP015",110,0)
 ;               values of the TYPE field of the HOSPITAL LOCATION
"RTN","RORRP015",111,0)
 ;               file). Only locations of the types defined by this
"RTN","RORRP015",112,0)
 ;               parameter are selected by the procedure. By default
"RTN","RORRP015",113,0)
 ;               ($G(HLTYPES)=""), all locations are selected.
"RTN","RORRP015",114,0)
 ;
"RTN","RORRP015",115,0)
 ; [DIVIEN]      Division IEN. If this parameter is defined and
"RTN","RORRP015",116,0)
 ;               greater than zero then only the locations associated 
"RTN","RORRP015",117,0)
 ;               with this division will be selected.
"RTN","RORRP015",118,0)
 ;
"RTN","RORRP015",119,0)
 ; [PART]        The partial match restriction.
"RTN","RORRP015",120,0)
 ;
"RTN","RORRP015",121,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORRP015",122,0)
 ;                 A  Include active locations (default)
"RTN","RORRP015",123,0)
 ;                 B  Backwards. Traverses the index in the opposite
"RTN","RORRP015",124,0)
 ;                    direction of normal traversal.
"RTN","RORRP015",125,0)
 ;                 I  Include inactive locations
"RTN","RORRP015",126,0)
 ;
"RTN","RORRP015",127,0)
 ; [NUMBER]      Maximum number of entries to return. A value of "*"
"RTN","RORRP015",128,0)
 ;               or no value in this parameter designates all entries.
"RTN","RORRP015",129,0)
 ;
"RTN","RORRP015",130,0)
 ; [FROM]        The index entry(s) from which to begin the list
"RTN","RORRP015",131,0)
 ;                 ^01: FromName
"RTN","RORRP015",132,0)
 ;                 ^02: FromIEN
"RTN","RORRP015",133,0)
 ;
"RTN","RORRP015",134,0)
 ;               For example, a FROM value of "VA" would list entries
"RTN","RORRP015",135,0)
 ;               following VA. You can use the 2-nd and 3-rd "^"-
"RTN","RORRP015",136,0)
 ;               pieces of the @RESULTS@(0) node to continue the
"RTN","RORRP015",137,0)
 ;               listing in the subsequent procedure calls.
"RTN","RORRP015",138,0)
 ;
"RTN","RORRP015",139,0)
 ;               NOTE: The FROM value itself is not included in
"RTN","RORRP015",140,0)
 ;                     the resulting list.
"RTN","RORRP015",141,0)
 ;
"RTN","RORRP015",142,0)
 ; The ^TMP("DILIST",$J) global node is used by the procedure.
"RTN","RORRP015",143,0)
 ;
"RTN","RORRP015",144,0)
 ; See description of the LIST^DIC for more details about the
"RTN","RORRP015",145,0)
 ; PART, NUMBER and FROM parameters.
"RTN","RORRP015",146,0)
 ;
"RTN","RORRP015",147,0)
 ; Return Values:
"RTN","RORRP015",148,0)
 ;
"RTN","RORRP015",149,0)
 ; A negative value of the first "^"-piece of the @RESULTS@(0)
"RTN","RORRP015",150,0)
 ; indicates an error (see the RPCSTK^RORERR procedure for more
"RTN","RORRP015",151,0)
 ; details).
"RTN","RORRP015",152,0)
 ;
"RTN","RORRP015",153,0)
 ; Otherwise, number of hospital locations and the value of the
"RTN","RORRP015",154,0)
 ; FROM parameter for the next procedure call are returned in
"RTN","RORRP015",155,0)
 ; the @RESULTS@(0) and the subsequent nodes of the global array
"RTN","RORRP015",156,0)
 ; contain the locations.
"RTN","RORRP015",157,0)
 ; 
"RTN","RORRP015",158,0)
 ; @RESULTS@(0)          Result Descriptor
"RTN","RORRP015",159,0)
 ;                         ^01: Number of locations
"RTN","RORRP015",160,0)
 ;                         ^02: FromName
"RTN","RORRP015",161,0)
 ;                         ^03: FromIEN
"RTN","RORRP015",162,0)
 ;
"RTN","RORRP015",163,0)
 ; @RESULTS@(i)          Hospital Location
"RTN","RORRP015",164,0)
 ;                         ^01: IEN
"RTN","RORRP015",165,0)
 ;                         ^02: Name
"RTN","RORRP015",166,0)
 ;                         ^03: Type (internal)
"RTN","RORRP015",167,0)
 ;                         ^04: Institution IEN
"RTN","RORRP015",168,0)
 ;                         ^05: Division IEN
"RTN","RORRP015",169,0)
 ;                         ^06: Active (0/1)
"RTN","RORRP015",170,0)
 ;
"RTN","RORRP015",171,0)
 ; NOTE: The 6th "^"-piece of the location record (Active) is
"RTN","RORRP015",172,0)
 ;       populated only if both "A" and "I" flags are used.
"RTN","RORRP015",173,0)
 ;
"RTN","RORRP015",174,0)
HLOCLIST(RESULTS,HLTYPES,DIVIEN,PART,FLAGS,NUMBER,FROM) ;
"RTN","RORRP015",175,0)
 N BUF,I,RC,RORERRDL,RORHLT,RORMSG,SCR,TMP
"RTN","RORRP015",176,0)
 D CLEAR^RORERR("HLOCLIST^RORRP015",1)
"RTN","RORRP015",177,0)
 K RESULTS  S RESULTS=$NA(^TMP("DILIST",$J))  K @RESULTS
"RTN","RORRP015",178,0)
 ;--- Check the parameters
"RTN","RORRP015",179,0)
 S HLTYPES=$$UP^XLFSTR($TR($G(HLTYPES)," "))
"RTN","RORRP015",180,0)
 F I=1:1  S TMP=$P(HLTYPES,",",I)  Q:TMP=""  S RORHLT(TMP)=""
"RTN","RORRP015",181,0)
 S DIVIEN=$S($G(DIVIEN)>0:+DIVIEN,1:0)
"RTN","RORRP015",182,0)
 S PART=$G(PART),FLAGS=$G(FLAGS)
"RTN","RORRP015",183,0)
 S NUMBER=$S($G(NUMBER)>0:+NUMBER,1:"*")
"RTN","RORRP015",184,0)
 ;--- If neither "A" nor "I" flag is provided, add the "A" (default)
"RTN","RORRP015",185,0)
 S:$TR(FLAGS,"AI")=FLAGS FLAGS=FLAGS_"A"
"RTN","RORRP015",186,0)
 ;--- Setup the start point
"RTN","RORRP015",187,0)
 I $G(FROM)'=""  D  S FROM=$P(FROM,U)
"RTN","RORRP015",188,0)
 . S:$P(FROM,U,2)>0 FROM("IEN")=+$P(FROM,U,2)
"RTN","RORRP015",189,0)
 ;--- Compile the screen logic (be careful with naked references)
"RTN","RORRP015",190,0)
 S SCR=""
"RTN","RORRP015",191,0)
 D:$D(RORHLT)>1
"RTN","RORRP015",192,0)
 . S SCR=SCR_"S D=$P($G(^(0)),U,3) I D'="""",$D(RORHLT(D)) "
"RTN","RORRP015",193,0)
 S:DIVIEN SCR=SCR_"I $P($G(^(0)),U,15)=DIVIEN "
"RTN","RORRP015",194,0)
 S:FLAGS'["A" SCR=SCR_"I '$$ACTLOC^RORRP015(+Y) "
"RTN","RORRP015",195,0)
 S:FLAGS'["I" SCR=SCR_"I $$ACTLOC^RORRP015(+Y) "
"RTN","RORRP015",196,0)
 ;--- Get the list of locations
"RTN","RORRP015",197,0)
 S BUF="@;.01;2I;3I;3.5I",TMP="P"_$S(FLAGS["B":"B",1:"")
"RTN","RORRP015",198,0)
 D LIST^DIC(44,,BUF,TMP,NUMBER,.FROM,PART,"B",SCR,,,"RORMSG")
"RTN","RORRP015",199,0)
 I $G(DIERR)  D  D RPCSTK^RORERR(.RESULTS,RC)  Q
"RTN","RORRP015",200,0)
 . S RC=$$DBS^RORERR("RORMSG",-9,,,44)
"RTN","RORRP015",201,0)
 . K ^TMP("DILIST",$J)
"RTN","RORRP015",202,0)
 ;--- Populate the Active field if both flags are used
"RTN","RORRP015",203,0)
 I FLAGS["I",FLAGS["A"  S I=0  D
"RTN","RORRP015",204,0)
 . F  S I=$O(@RESULTS@(I))  Q:I=""  D
"RTN","RORRP015",205,0)
 . . S $P(@RESULTS@(I,0),U,6)=$$ACTLOC(+@RESULTS@(I,0))
"RTN","RORRP015",206,0)
 ;--- Success
"RTN","RORRP015",207,0)
 S TMP=$G(^TMP("DILIST",$J,0)),BUF=+$P(TMP,U)
"RTN","RORRP015",208,0)
 K ^TMP("DILIST",$J,0)
"RTN","RORRP015",209,0)
 S:$P(TMP,U,3) $P(BUF,U,2,3)=$G(FROM)_U_$G(FROM("IEN"))
"RTN","RORRP015",210,0)
 S @RESULTS@(0)=BUF
"RTN","RORRP015",211,0)
 Q
"RTN","RORUTL11")
0^6^B3286551^B3195130
"RTN","RORUTL11",1,0)
RORUTL11 ;HCIOFO/SG - ACCESS AND SECURITY UTILITIES ; 6/2/11 4:12pm
"RTN","RORUTL11",2,0)
 ;;1.5;CLINICAL CASE REGISTRIES;**13,14,15**;Feb 17, 2006;Build 27
"RTN","RORUTL11",3,0)
 ;
"RTN","RORUTL11",4,0)
 ;******************************************************************************
"RTN","RORUTL11",5,0)
 ;******************************************************************************
"RTN","RORUTL11",6,0)
 ;                 --- ROUTINE MODIFICATION LOG ---
"RTN","RORUTL11",7,0)
 ;        
"RTN","RORUTL11",8,0)
 ;PKG/PATCH    DATE        DEVELOPER    MODIFICATION
"RTN","RORUTL11",9,0)
 ;-----------  ----------  -----------  ----------------------------------------
"RTN","RORUTL11",10,0)
 ;ROR*1.5*13   DEC  2010   A SAUNDERS   Added tag VERSRV to return an associated
"RTN","RORUTL11",11,0)
 ;                                      version to the GUI during RPC call ROR
"RTN","RORUTL11",12,0)
 ;                                      GET M VERSION
"RTN","RORUTL11",13,0)
 ;ROR*1.5*14   APR  2011   A SAUNDERS   Updated version in tag VERSRV
"RTN","RORUTL11",14,0)
 ;
"RTN","RORUTL11",15,0)
 ;ROR*1.5*15   JUN 2011    C RAY        Updated version
"RTN","RORUTL11",16,0)
 ;                                      
"RTN","RORUTL11",17,0)
 ;******************************************************************************
"RTN","RORUTL11",18,0)
 ;******************************************************************************
"RTN","RORUTL11",19,0)
 Q
"RTN","RORUTL11",20,0)
 ;
"RTN","RORUTL11",21,0)
 ;***** REBUILDS THE "ACL" CROSS-REFERENCE (USER ACCESS)
"RTN","RORUTL11",22,0)
 ;
"RTN","RORUTL11",23,0)
 ; Return Values:
"RTN","RORUTL11",24,0)
 ;       <0  Error code
"RTN","RORUTL11",25,0)
 ;        0  Ok
"RTN","RORUTL11",26,0)
 ;
"RTN","RORUTL11",27,0)
RNDXACL() ;
"RTN","RORUTL11",28,0)
 N DA,DIK,REGIEN,ROOT
"RTN","RORUTL11",29,0)
 S ROOT=$$ROOT^DILFD(798.1,,1)  K @ROOT@("ACL")
"RTN","RORUTL11",30,0)
 S REGIEN=0
"RTN","RORUTL11",31,0)
 F  S REGIEN=$O(@ROOT@(REGIEN))  Q:'REGIEN  D
"RTN","RORUTL11",32,0)
 . S DIK=$$ROOT^DILFD(798.118,","_REGIEN_","),DIK(1)=".01^ACL"
"RTN","RORUTL11",33,0)
 . S DA(1)=REGIEN  D ENALL^DIK
"RTN","RORUTL11",34,0)
 Q 0
"RTN","RORUTL11",35,0)
 ;
"RTN","RORUTL11",36,0)
 ;***** CHECKS IF THE RPC CAN BE CALLED BY THE CURRENT USER
"RTN","RORUTL11",37,0)
 ;
"RTN","RORUTL11",38,0)
 ; RPCNAME       Name of the RPC
"RTN","RORUTL11",39,0)
 ;
"RTN","RORUTL11",40,0)
 ; [REGIEN]      Registry IEN
"RTN","RORUTL11",41,0)
 ;
"RTN","RORUTL11",42,0)
 ; [FLAGS]       Flags that control the execution (can be combined):
"RTN","RORUTL11",43,0)
 ;                 A  Administrator Only
"RTN","RORUTL11",44,0)
 ;                 I  IRM Only
"RTN","RORUTL11",45,0)
 ;
"RTN","RORUTL11",46,0)
 ; Return Values:
"RTN","RORUTL11",47,0)
 ;       <0  Error code
"RTN","RORUTL11",48,0)
 ;        0  Ok
"RTN","RORUTL11",49,0)
 ;       >0  Access denied
"RTN","RORUTL11",50,0)
 ;
"RTN","RORUTL11",51,0)
RPCHECK(RPCNAME,REGIEN,FLAGS) ;
"RTN","RORUTL11",52,0)
 N ACCESS,KEY,RC
"RTN","RORUTL11",53,0)
 Q:$G(DUZ)'>0 $$ERROR^RORERR(-40,,,,"DUZ")
"RTN","RORUTL11",54,0)
 S FLAGS=$G(FLAGS),REGIEN=+$G(REGIEN)
"RTN","RORUTL11",55,0)
 ;---
"RTN","RORUTL11",56,0)
 S (ACCESS,RC)=0
"RTN","RORUTL11",57,0)
 D  Q:ACCESS 0
"RTN","RORUTL11",58,0)
 . I REGIEN  Q:$D(^ROR(798.1,"ACL",DUZ,REGIEN))<10
"RTN","RORUTL11",59,0)
 . E  Q:$D(^ROR(798.1,"ACL",DUZ))<10
"RTN","RORUTL11",60,0)
 . I FLAGS["I"  Q:'$D(^XUSEC("ROR VA IRM",DUZ))
"RTN","RORUTL11",61,0)
 . I FLAGS["A"  S RC=1,KEY=""  D  Q:RC
"RTN","RORUTL11",62,0)
 . . F  S KEY=$O(^ROR(798.1,"ACL",DUZ,REGIEN,KEY))  Q:KEY=""  D  Q:'RC
"RTN","RORUTL11",63,0)
 . . . I KEY?1"ROR"1.E  S:KEY["ADMIN" RC=0
"RTN","RORUTL11",64,0)
 . S ACCESS=1
"RTN","RORUTL11",65,0)
 ;---
"RTN","RORUTL11",66,0)
 D ACVIOLTN^RORLOG(X,$G(REGIEN),RPCNAME)
"RTN","RORUTL11",67,0)
 Q 1
"RTN","RORUTL11",68,0)
 ;
"RTN","RORUTL11",69,0)
 ;***** RETURNS SERVER VERSION
"RTN","RORUTL11",70,0)
 ;REMOTE PROCEDURE: ROR GET M VERSION
"RTN","RORUTL11",71,0)
 ;
"RTN","RORUTL11",72,0)
 ;The purpose of this RPC is to catch when the GUI executable has been
"RTN","RORUTL11",73,0)
 ;upgraded AND REQUIRES an associated M patch, but the M patch has not
"RTN","RORUTL11",74,0)
 ;been installed yet.
"RTN","RORUTL11",75,0)
 ;
"RTN","RORUTL11",76,0)
 ; VAL n.n.n represents the CCR package version and the m patch number that
"RTN","RORUTL11",77,0)
 ; contains the associated M changes that the GUI is expecting.
"RTN","RORUTL11",78,0)
 ;
"RTN","RORUTL11",79,0)
 ;NOTE TO CCR MAINTENANCE TEAM: For M changes made by the maintenance team,
"RTN","RORUTL11",80,0)
 ;the server version below should not be modified.  The only time the server
"RTN","RORUTL11",81,0)
 ;version should be modified is if the GUI was changed AND there were
"RTN","RORUTL11",82,0)
 ;associated M changes needed for it.
"RTN","RORUTL11",83,0)
 ;
"RTN","RORUTL11",84,0)
VERSRV(VAL) ;
"RTN","RORUTL11",85,0)
 S VAL="1.5.15"
"RTN","RORUTL11",86,0)
 Q
"RTN","RORX019")
0^8^B164858937^B148477652
"RTN","RORX019",1,0)
RORX019 ;BPOIFO/ACS - LIVER SCORE BY RANGE ; 5/18/11 12:39pm
"RTN","RORX019",2,0)
 ;;1.5;CLINICAL CASE REGISTRIES;**10,13,14,15**;Feb 17, 2006;Build 27
"RTN","RORX019",3,0)
 ;
"RTN","RORX019",4,0)
 ;******************************************************************************
"RTN","RORX019",5,0)
 ;******************************************************************************
"RTN","RORX019",6,0)
 ;                 --- ROUTINE MODIFICATION LOG ---
"RTN","RORX019",7,0)
 ;        
"RTN","RORX019",8,0)
 ;PKG/PATCH    DATE        DEVELOPER    MODIFICATION
"RTN","RORX019",9,0)
 ;-----------  ----------  -----------  ----------------------------------------
"RTN","RORX019",10,0)
 ;ROR*1.5*10   MAR  2010   A SAUNDERS   Routine created
"RTN","RORX019",11,0)
 ;ROR*1.5*13   DEC  2010   A SAUNDERS   User can select specific patients,
"RTN","RORX019",12,0)
 ;                                      clinics, or divisions for the report.
"RTN","RORX019",13,0)
 ;                                      Modified XML tags for sort.
"RTN","RORX019",14,0)
 ;ROR*1.5*14   APR  2011   A SAUNDERS   Added APRI and FIB4 scores.
"RTN","RORX019",15,0)
 ;ROR*1.5*15   MAY  2011   C RAY        Modified to exclude null tests
"RTN","RORX019",16,0)
 ;******************************************************************************
"RTN","RORX019",17,0)
 ;******************************************************************************
"RTN","RORX019",18,0)
 Q
"RTN","RORX019",19,0)
 ;************************************************************************
"RTN","RORX019",20,0)
 ;COMPILE THE "LIVER SCORE BY RANGE" REPORT (EXTRINISIC FUNCTION)
"RTN","RORX019",21,0)
 ;REPORT CODE: 019
"RTN","RORX019",22,0)
 ;
"RTN","RORX019",23,0)
 ;Called by entry "Liver Score by Range" in ROR REPORT PARAMETERS (#799.34)
"RTN","RORX019",24,0)
 ;
"RTN","RORX019",25,0)
 ;INPUT
"RTN","RORX019",26,0)
 ;  RORTSK     Task number and task parameters
"RTN","RORX019",27,0)
 ;
"RTN","RORX019",28,0)
 ;
"RTN","RORX019",29,0)
 ;  Below is a sample RORTSK input array for utilization in 2003, most recent
"RTN","RORX019",30,0)
 ;  scores, MELD range from 10 to 30, MELD Na range from 20 to 50:
"RTN","RORX019",31,0)
 ;  
"RTN","RORX019",32,0)
 ;  RORTSK=nnn   (the task number)
"RTN","RORX019",33,0)
 ;  RORTSK("EP")="$$MLDRANGE^RORX019"
"RTN","RORX019",34,0)
 ;  RORTSK("PARAMS","DATE_RANGE_3","A","END")=3031231
"RTN","RORX019",35,0)
 ;  RORTSK("PARAMS","DATE_RANGE_3","A","START")=3030101
"RTN","RORX019",36,0)
 ;  RORTSK("PARAMS","ICD9FILT","A","FILTER")="ALL"
"RTN","RORX019",37,0)
 ;  RORTSK("PARAMS","LRGRANGES","C",1)=""
"RTN","RORX019",38,0)
 ;  RORTSK("PARAMS","LRGRANGES","C",1,"H")=30
"RTN","RORX019",39,0)
 ;  RORTSK("PARAMS","LRGRANGES","C",1,"L")=10
"RTN","RORX019",40,0)
 ;  RORTSK("PARAMS","LRGRANGES","C",2)=""
"RTN","RORX019",41,0)
 ;  RORTSK("PARAMS","LRGRANGES","C",2,"H")=50
"RTN","RORX019",42,0)
 ;  RORTSK("PARAMS","LRGRANGES","C",2,"L")=20
"RTN","RORX019",43,0)
 ;  RORTSK("PARAMS","OPTIONS","A","COMPLETE")=1
"RTN","RORX019",44,0)
 ;  RORTSK("PARAMS","OPTIONS","A","MOST_RECENT")=1
"RTN","RORX019",45,0)
 ;  RORTSK("PARAMS","PATIENTS","A","DE_AFTER")=1
"RTN","RORX019",46,0)
 ;  RORTSK("PARAMS","PATIENTS","A","DE_BEFORE")=1
"RTN","RORX019",47,0)
 ;  RORTSK("PARAMS","PATIENTS","A","DE_DURING")=1
"RTN","RORX019",48,0)
 ;  RORTSK("PARAMS","REGIEN")=1
"RTN","RORX019",49,0)
 ;  
"RTN","RORX019",50,0)
 ;  If the user selected an 'as of' date = 12/31/2005:
"RTN","RORX019",51,0)
 ;  RORTSK("PARAMS","OPTIONS","A","MOST_RECENT")=1
"RTN","RORX019",52,0)
 ;     is replaced with:  
"RTN","RORX019",53,0)
 ;  RORTSK("PARAMS","OPTIONS","A","MAX_DATE")=3051231
"RTN","RORX019",54,0)
 ;
"RTN","RORX019",55,0)
 ;
"RTN","RORX019",56,0)
 ;OUTPUT
"RTN","RORX019",57,0)
 ;  <0  Error code
"RTN","RORX019",58,0)
 ;   0  Ok
"RTN","RORX019",59,0)
 ;************************************************************************
"RTN","RORX019",60,0)
MLDRANGE(RORTSK) ;
"RTN","RORX019",61,0)
 N RORREG        ; Registry IEN
"RTN","RORX019",62,0)
 N RORSDT        ; report start date
"RTN","RORX019",63,0)
 N ROREDT        ; report end date
"RTN","RORX019",64,0)
 N RORDATA       ; array to hold ROR data and summary totals
"RTN","RORX019",65,0)
 N RORPTIEN      ; IEN of patient in the ROR registry
"RTN","RORX019",66,0)
 N DFN           ; DFN of patient in the PATIENT file (#2)
"RTN","RORX019",67,0)
 N RORLC         ; sub-file and array of LOINC codes to search Lab data
"RTN","RORX019",68,0)
 N RORCDLIST     ; Flag to indicate whether a clinic or division list exists
"RTN","RORX019",69,0)
 N RORCDSTDT     ; Start date for clinic/division utilization search
"RTN","RORX019",70,0)
 N RORCDENDT     ; End date for clinic/division utilization search
"RTN","RORX019",71,0)
 ;
"RTN","RORX019",72,0)
 N REPORT,RC,I,TMP,SFLAGS,PARAMS
"RTN","RORX019",73,0)
 ;--- Establish the root XML Node of the report and put into output
"RTN","RORX019",74,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX019",75,0)
 Q:REPORT<0 REPORT
"RTN","RORX019",76,0)
 ;
"RTN","RORX019",77,0)
 ;--- Get registry IEN
"RTN","RORX019",78,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")  ; Registry IEN
"RTN","RORX019",79,0)
 ;
"RTN","RORX019",80,0)
 ;--- Set standard report parameters data into output:
"RTN","RORX019",81,0)
 ;registry, comment, patients (before, during, after), options (summary vs.
"RTN","RORX019",82,0)
 ;complete), other registries, and other diagnoses
"RTN","RORX019",83,0)
 S PARAMS=$$PARAMS^RORXU002(.RORTSK,REPORT,.RORSDT,.ROREDT,.SFLAGS) Q:PARAMS<0 PARAMS
"RTN","RORX019",84,0)
 ;
"RTN","RORX019",85,0)
 ;--- Add range parameters to output
"RTN","RORX019",86,0)
 S RC=$$PARAMS^RORX019A(PARAMS,.RORDATA,.RORTSK) Q:RC<0 RC
"RTN","RORX019",87,0)
 ;
"RTN","RORX019",88,0)
 ;--- Get ULNAST value for calculations
"RTN","RORX019",89,0)
 I $D(RORTSK("PARAMS","ULNAST")) S RORDATA("ULNAST")=$G(RORTSK("PARAMS","ULNAST"))
"RTN","RORX019",90,0)
 ;
"RTN","RORX019",91,0)
 ;--- Put report header data into output:
"RTN","RORX019",92,0)
 ;report creation date, task number, last registry update date, last
"RTN","RORX019",93,0)
 ;data extraction date, and ULNAST if present
"RTN","RORX019",94,0)
 S RC=$$HEADER(REPORT,PARAMS) Q:RC<0 RC
"RTN","RORX019",95,0)
 ;
"RTN","RORX019",96,0)
 ;--- Get test ranges requested
"RTN","RORX019",97,0)
 ;I=1 ==> report = MELD      I=2 ==> report = MELD Na
"RTN","RORX019",98,0)
 ;I=3 ==> report = APRI      I=4 ==> report = FIB-4
"RTN","RORX019",99,0)
 S I=0 F  S I=$O(RORTSK("PARAMS","LRGRANGES","C",I)) Q:I=""  D
"RTN","RORX019",100,0)
 . S RORDATA("L",I)=$G(RORTSK("PARAMS","LRGRANGES","C",I,"L")) ;low range
"RTN","RORX019",101,0)
 . S RORDATA("H",I)=$G(RORTSK("PARAMS","LRGRANGES","C",I,"H")) ;high range
"RTN","RORX019",102,0)
 ;
"RTN","RORX019",103,0)
 ;--- Get Max Date for test results  OUTPUT: RORDATA("DATE")
"RTN","RORX019",104,0)
 ;In the GUI, the user selects either 'most recent' or 'as of' date
"RTN","RORX019",105,0)
 S RORDATA("DATE")=$$PARAM^RORTSK01("OPTIONS","MAX_DATE")
"RTN","RORX019",106,0)
 I $G(RORDATA("DATE"))="" S RORDATA("DATE")=DT
"RTN","RORX019",107,0)
 ;
"RTN","RORX019",108,0)
 ;--- Create 'patients' table
"RTN","RORX019",109,0)
 N RORBODY S RORBODY=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,REPORT)
"RTN","RORX019",110,0)
 D ADDATTR^RORTSK11(RORTSK,RORBODY,"TABLE","PATIENTS")
"RTN","RORX019",111,0)
 ;
"RTN","RORX019",112,0)
 ;--- Check utilization
"RTN","RORX019",113,0)
 N CNT,ECNT,UTSDT,UTEDT,SKIPSDT,SKIPEDT
"RTN","RORX019",114,0)
 S (CNT,ECNT,RC)=0,SKIPEDT=ROREDT,SKIPSDT=RORSDT
"RTN","RORX019",115,0)
 ; Utilization date range is always sent
"RTN","RORX019",116,0)
 S UTSDT=$$PARAM^RORTSK01("DATE_RANGE_3","START")\1
"RTN","RORX019",117,0)
 S UTEDT=$$PARAM^RORTSK01("DATE_RANGE_3","END")\1
"RTN","RORX019",118,0)
 ; Combined date range
"RTN","RORX019",119,0)
 S SKIPSDT=$$DTMIN^RORUTL18(SKIPSDT,$G(UTSDT))
"RTN","RORX019",120,0)
 S SKIPEDT=$$DTMAX^RORUTL18(SKIPEDT,$G(UTEDT))
"RTN","RORX019",121,0)
 ;
"RTN","RORX019",122,0)
 ;--- Number of patients in the registry - used for calculating the
"RTN","RORX019",123,0)
 ;task progress percentage (shown on the GUI screen)
"RTN","RORX019",124,0)
 N RORPTCNT S RORPTCNT=$$REGSIZE^RORUTL02(+RORREG) S:RORPTCNT<0 RORPTCNT=0
"RTN","RORX019",125,0)
 ;
"RTN","RORX019",126,0)
 ;--- LOINC codes
"RTN","RORX019",127,0)
 I "1,2"[RORDATA("IDLST") D  ;If MELD or MELD-NA scores requested
"RTN","RORX019",128,0)
 . ;create list for future comparison
"RTN","RORX019",129,0)
 . S RORDATA("CR_LOINC")=";15045-8;21232-4;2160-0;" ;Creatinine
"RTN","RORX019",130,0)
 . S RORDATA("BIL_LOINC")=";14631-6;1975-2;" ;Bilirubin
"RTN","RORX019",131,0)
 . S RORDATA("SOD_LOINC")=";2947-0;2951-2;32717-1;" ;Sodium
"RTN","RORX019",132,0)
 . S RORDATA("INR_LOINC")=";34714-6;6301-6;" ;INR 
"RTN","RORX019",133,0)
 . ;set up array for future call to Lab API
"RTN","RORX019",134,0)
 . S RORLC="CH" ;chemistry sub-file to search in #63
"RTN","RORX019",135,0)
 . S RORLC(1)="15045-8^LN" ;Creatinine LOINC
"RTN","RORX019",136,0)
 . S RORLC(2)="21232-4^LN" ;Creatinine LOINC
"RTN","RORX019",137,0)
 . S RORLC(3)="2160-0^LN"  ;Creatinine LOINC
"RTN","RORX019",138,0)
 . S RORLC(4)="14631-6^LN" ;Bilirubin LOINC
"RTN","RORX019",139,0)
 . S RORLC(5)="1975-2^LN"  ;Bilirubin LOINC
"RTN","RORX019",140,0)
 . S RORLC(6)="2947-0^LN"  ;Sodium LOINC
"RTN","RORX019",141,0)
 . S RORLC(7)="2951-2^LN"  ;Sodium LOINC
"RTN","RORX019",142,0)
 . S RORLC(8)="32717-1^LN" ;Sodium LOINC
"RTN","RORX019",143,0)
 . S RORLC(9)="34714-6^LN" ;INR LOINC
"RTN","RORX019",144,0)
 . S RORLC(10)="6301-6^LN" ;INR LOINC
"RTN","RORX019",145,0)
 ;
"RTN","RORX019",146,0)
 I "3,4"[RORDATA("IDLST") D  ;If APRI or FIB-4 scores requested
"RTN","RORX019",147,0)
 . ;create list for future comparison
"RTN","RORX019",148,0)
 . S RORDATA("AST_LOINC")=";1916-6;1920-8;127344-1;" ;AST 
"RTN","RORX019",149,0)
 . S RORDATA("PLAT_LOINC")=";777-3;778-1;26515-7;" ;Platelets 
"RTN","RORX019",150,0)
 . S RORDATA("ALT_LOINC")=";1742-6;16325-3;" ;ALT 
"RTN","RORX019",151,0)
 . ;set up array for future call to Lab API
"RTN","RORX019",152,0)
 . S RORLC="CH" ;chemistry sub-file to search in #63
"RTN","RORX019",153,0)
 . S RORLC(1)="1916-6^LN" ;AST LOINC
"RTN","RORX019",154,0)
 . S RORLC(2)="1920-8^LN" ;AST LOINC
"RTN","RORX019",155,0)
 . ;S RORLC(3)="127344-1^LN" ;AST LOINC
"RTN","RORX019",156,0)
 . S RORLC(4)="777-3^LN" ;Platelets LOINC
"RTN","RORX019",157,0)
 . S RORLC(5)="778-1^LN" ;Platelets LOINC
"RTN","RORX019",158,0)
 . S RORLC(6)="26515-7^LN" ;Platelets LOINC
"RTN","RORX019",159,0)
 . S RORLC(7)="1742-6^LN" ;ALT LOINC
"RTN","RORX019",160,0)
 . S RORLC(8)="16325-3^LN" ;ALT LOINC
"RTN","RORX019",161,0)
 ;
"RTN","RORX019",162,0)
 ;=== Set up Clinic/Division list parameters
"RTN","RORX019",163,0)
 S RORCDLIST=$$CDPARMS^RORXU001(.RORTSK,.RORCDSTDT,.RORCDENDT,1)
"RTN","RORX019",164,0)
 ;
"RTN","RORX019",165,0)
 ;--- Get registry records
"RTN","RORX019",166,0)
 N RCC,FLAG,TMP,DFN,SKIP
"RTN","RORX019",167,0)
 S (CNT,RORPTIEN,RC)=0
"RTN","RORX019",168,0)
 S FLAG=$G(RORTSK("PARAMS","ICD9FILT","A","FILTER"))
"RTN","RORX019",169,0)
 F  S RORPTIEN=$O(^RORDATA(798,"AC",RORREG,RORPTIEN))  Q:RORPTIEN'>0  D  Q:RC<0
"RTN","RORX019",170,0)
 . ;--- Calculate 'progress' for the GUI display
"RTN","RORX019",171,0)
 . S TMP=$S(RORPTCNT>0:CNT/RORPTCNT,1:"")
"RTN","RORX019",172,0)
 . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX019",173,0)
 . S CNT=CNT+1
"RTN","RORX019",174,0)
 . ;--- Get patient DFN
"RTN","RORX019",175,0)
 . S DFN=$$PTIEN^RORUTL01(RORPTIEN) Q:DFN'>0
"RTN","RORX019",176,0)
 . ;check for patient list and quit if not on list
"RTN","RORX019",177,0)
 . I $D(RORTSK("PARAMS","PATIENTS","C")),'$D(RORTSK("PARAMS","PATIENTS","C",DFN)) Q
"RTN","RORX019",178,0)
 . ;--- Check if the patient should be skipped
"RTN","RORX019",179,0)
 . Q:$$SKIP^RORXU005(RORPTIEN,SFLAGS,SKIPSDT,SKIPEDT)
"RTN","RORX019",180,0)
 . ;--- Check if patient has passed the ICD9 filter
"RTN","RORX019",181,0)
 . S RCC=0
"RTN","RORX019",182,0)
 . I FLAG'="ALL" D
"RTN","RORX019",183,0)
 . . S RCC=$$ICD^RORXU010(DFN,RORREG)
"RTN","RORX019",184,0)
 . I (FLAG="INCLUDE")&(RCC=0) Q
"RTN","RORX019",185,0)
 . I (FLAG="EXCLUDE")&(RCC=1) Q
"RTN","RORX019",186,0)
 . ;
"RTN","RORX019",187,0)
 . ;--- Check for Clinic or Division list and quit if not in list
"RTN","RORX019",188,0)
 . I RORCDLIST,'$$CDUTIL^RORXU001(.RORTSK,DFN,RORCDSTDT,RORCDENDT) Q
"RTN","RORX019",189,0)
 . ;
"RTN","RORX019",190,0)
 . ;--- Check for any utilization in the corresponding date range
"RTN","RORX019",191,0)
 . S SKIP=0 I $G(UTSDT)>0 D
"RTN","RORX019",192,0)
 .. N UTIL K TMP S TMP("ALL")=1
"RTN","RORX019",193,0)
 .. S UTIL=+$$UTIL^RORXU003(UTSDT,UTEDT,DFN,.TMP)
"RTN","RORX019",194,0)
 .. S:'UTIL SKIP=1
"RTN","RORX019",195,0)
 . ;--- Skip the patient if they have no utilization in the range
"RTN","RORX019",196,0)
 . I $G(SKIP) Q
"RTN","RORX019",197,0)
 . ;
"RTN","RORX019",198,0)
 . ;--- For each patient, process the registry record and create report
"RTN","RORX019",199,0)
 . I $$PATIENT(DFN,RORBODY,.RORDATA,RORPTIEN,.RORLC)<0 S ECNT=ECNT+1 ;error count
"RTN","RORX019",200,0)
 ;
"RTN","RORX019",201,0)
 K ^TMP("RORX019",$J)
"RTN","RORX019",202,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX019",203,0)
 ;
"RTN","RORX019",204,0)
 ;************************************************************************
"RTN","RORX019",205,0)
 ;ADD PATIENT DATA TO THE REPORT (EXTRINISIC FUNCTION)
"RTN","RORX019",206,0)
 ;
"RTN","RORX019",207,0)
 ;INPUT
"RTN","RORX019",208,0)
 ;  DFN      Patient DFN in PATIENT file (#2)
"RTN","RORX019",209,0)
 ;  PTAG     Reference IEN to the 'body' parent XML tag
"RTN","RORX019",210,0)
 ;  RORDATA  Array with ROR data
"RTN","RORX019",211,0)
 ;  RORPTIEN Patient IEN in the ROR registry
"RTN","RORX019",212,0)
 ;  RORLC    sub-file and LOINC codes to search for
"RTN","RORX019",213,0)
 ;
"RTN","RORX019",214,0)
 ;OUTPUT
"RTN","RORX019",215,0)
 ;  1        ok
"RTN","RORX019",216,0)
 ; <0        error
"RTN","RORX019",217,0)
 ;************************************************************************
"RTN","RORX019",218,0)
PATIENT(DFN,PTAG,RORDATA,RORPTIEN,RORLC) ;
"RTN","RORX019",219,0)
 ;Calculate the scores requested by the user
"RTN","RORX019",220,0)
 I ((RORDATA("IDLST")[1)!(RORDATA("IDLST")[2)) I $$CALCMLD^RORX019A(DFN,PTAG,.RORDATA,RORPTIEN,.RORLC)<0 Q 1
"RTN","RORX019",221,0)
 I ((RORDATA("IDLST")[3)!(RORDATA("IDLST")[4)) I $$CALCFIB^RORX019A(DFN,PTAG,.RORDATA,RORPTIEN,.RORLC)<0 Q 1
"RTN","RORX019",222,0)
 I '$$INRANGE(.RORDATA) Q 1  ;exclude patient from report if ANY score is out of range
"RTN","RORX019",223,0)
 I '$$SKIP(.RORDATA) Q 1  ;exclude patient from report with null scores
"RTN","RORX019",224,0)
 ;--- Get patient data and put into the report
"RTN","RORX019",225,0)
 N VADM,VA,RORDOD,MTAG,TTAG
"RTN","RORX019",226,0)
 D VADEM^RORUTL05(DFN,1)
"RTN","RORX019",227,0)
 ;--- The <PATIENT> tag
"RTN","RORX019",228,0)
 S PTAG=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,PTAG,,DFN)
"RTN","RORX019",229,0)
 I PTAG<0 Q PTAG
"RTN","RORX019",230,0)
 ;--- Patient Name
"RTN","RORX019",231,0)
 D ADDVAL^RORTSK11(RORTSK,"NAME",VADM(1),PTAG,1)
"RTN","RORX019",232,0)
 ;--- Last 4 digits of the SSN
"RTN","RORX019",233,0)
 D ADDVAL^RORTSK11(RORTSK,"LAST4",VA("BID"),PTAG,2)
"RTN","RORX019",234,0)
 ;--- Date of death
"RTN","RORX019",235,0)
 S RORDOD=$$DATE^RORXU002($P(VADM(6),U)\1)
"RTN","RORX019",236,0)
 D ADDVAL^RORTSK11(RORTSK,"DOD",$G(RORDOD),PTAG,1)
"RTN","RORX019",237,0)
 ;--- MELDDATA tag
"RTN","RORX019",238,0)
 S MTAG=$$ADDVAL^RORTSK11(RORTSK,"MELDDATA",,PTAG)
"RTN","RORX019",239,0)
 I MTAG<0 Q MTAG
"RTN","RORX019",240,0)
 ;--- Test Result Values
"RTN","RORX019",241,0)
 N TNAME
"RTN","RORX019",242,0)
 I ((RORDATA("IDLST")[1)!(RORDATA("IDLST")[2)) D
"RTN","RORX019",243,0)
 .F TNAME="BILI","CR","INR" D TSTRSLT(TNAME,MTAG)
"RTN","RORX019",244,0)
 .I RORDATA("IDLST")[2 D TSTRSLT("NA",MTAG)
"RTN","RORX019",245,0)
 I ((RORDATA("IDLST")[3)!(RORDATA("IDLST")[4)) D
"RTN","RORX019",246,0)
 .F TNAME="AST","PLAT" D TSTRSLT(TNAME,MTAG)
"RTN","RORX019",247,0)
 .I RORDATA("IDLST")[4 D TSTRSLT("ALT",MTAG)
"RTN","RORX019",248,0)
 ;---  MELD score
"RTN","RORX019",249,0)
 I RORDATA("IDLST")[1 D ADDVAL^RORTSK11(RORTSK,"MELD",$G(RORDATA("SCORE",1)),PTAG,3)
"RTN","RORX019",250,0)
 ;---  MELD-Na Score
"RTN","RORX019",251,0)
 I RORDATA("IDLST")[2 D ADDVAL^RORTSK11(RORTSK,"MELDNA",$G(RORDATA("SCORE",2)),PTAG,3)
"RTN","RORX019",252,0)
 ;---  APRI Score
"RTN","RORX019",253,0)
 I RORDATA("IDLST")[3 D ADDVAL^RORTSK11(RORTSK,"APRI",$G(RORDATA("SCORE",3)),PTAG,3)
"RTN","RORX019",254,0)
 ;---  FIB-4 Score
"RTN","RORX019",255,0)
 I RORDATA("IDLST")[4 D ADDVAL^RORTSK11(RORTSK,"FIB4",$G(RORDATA("SCORE",4)),PTAG,3)
"RTN","RORX019",256,0)
 Q ($S($G(TTAG)<0:TTAG,1:1))
"RTN","RORX019",257,0)
 ;
"RTN","RORX019",258,0)
 ;*****************************************************
"RTN","RORX019",259,0)
 ;Procedure to add test name, date and results to report
"RTN","RORX019",260,0)
 ;INPUT
"RTN","RORX019",261,0)
 ;   TNAME       Name of test 
"RTN","RORX019",262,0)
 ;   MTAG        IEN of parent record
"RTN","RORX019",263,0)
 ;OUTPUT         n/a
"RTN","RORX019",264,0)
 ;******************************************************
"RTN","RORX019",265,0)
TSTRSLT(TNAME,MTAG) ;
"RTN","RORX019",266,0)
 ;--- Test Result Values
"RTN","RORX019",267,0)
 ;--- TEST tag
"RTN","RORX019",268,0)
 N TNAMEMIX
"RTN","RORX019",269,0)
 S TTAG=$$ADDVAL^RORTSK11(RORTSK,"TEST",,MTAG)
"RTN","RORX019",270,0)
 I TTAG<0 Q
"RTN","RORX019",271,0)
 ;--- Mixed case test name for GUI application
"RTN","RORX019",272,0)
 I TNAME="BILI" S TNAMEMIX="Bili"
"RTN","RORX019",273,0)
 I TNAME="CR" S TNAMEMIX="Cr"
"RTN","RORX019",274,0)
 I TNAME="INR" S TNAMEMIX="INR"
"RTN","RORX019",275,0)
 I TNAME="NA" S TNAMEMIX="Na"
"RTN","RORX019",276,0)
 I TNAME="AST" S TNAMEMIX="AST"
"RTN","RORX019",277,0)
 I TNAME="PLAT" S TNAMEMIX="Platelet"
"RTN","RORX019",278,0)
 I TNAME="ALT" S TNAMEMIX="ALT"
"RTN","RORX019",279,0)
 ;---  Test Name
"RTN","RORX019",280,0)
 D ADDVAL^RORTSK11(RORTSK,"TNAME",TNAMEMIX,TTAG)
"RTN","RORX019",281,0)
 ;---  Test Date
"RTN","RORX019",282,0)
 D ADDVAL^RORTSK11(RORTSK,"DATE",$P($G(RORDATA(TNAME)),U,2),TTAG)
"RTN","RORX019",283,0)
 ;---  Test Result Value
"RTN","RORX019",284,0)
 D ADDVAL^RORTSK11(RORTSK,"RESULT",$P($G(RORDATA(TNAME)),U,1),TTAG)
"RTN","RORX019",285,0)
 Q
"RTN","RORX019",286,0)
 ;****************************************************************
"RTN","RORX019",287,0)
 ;Function to check whether patient should be included on report
"RTN","RORX019",288,0)
 ;To be included patient must have a score for at least one of
"RTN","RORX019",289,0)
 ;the scores requested by the user
"RTN","RORX019",290,0)
 ;
"RTN","RORX019",291,0)
 ;INPUT
"RTN","RORX019",292,0)
 ;   RORDATA   Array with ROR Data
"RTN","RORX019",293,0)
 ;OUTPUT
"RTN","RORX019",294,0)
 ;   1         Include
"RTN","RORX019",295,0)
 ;   0         Exclude
"RTN","RORX019",296,0)
 ;***************************************************************
"RTN","RORX019",297,0)
SKIP(RORDATA) ;
"RTN","RORX019",298,0)
 ;
"RTN","RORX019",299,0)
 N RETURN
"RTN","RORX019",300,0)
 S RETURN=0
"RTN","RORX019",301,0)
 I RORDATA("IDLST")[1,+$G(RORDATA("SCORE",1)) S RETURN=1
"RTN","RORX019",302,0)
 I RORDATA("IDLST")[2,+$G(RORDATA("SCORE",2)) S RETURN=1
"RTN","RORX019",303,0)
 I RORDATA("IDLST")[3,+$G(RORDATA("SCORE",3)) S RETURN=1
"RTN","RORX019",304,0)
 I RORDATA("IDLST")[4,+$G(RORDATA("SCORE",4)) S RETURN=1
"RTN","RORX019",305,0)
 Q RETURN
"RTN","RORX019",306,0)
 ;************************************************************************
"RTN","RORX019",307,0)
 ;DETERMINE IF THE SCORES ARE WITHIN THE REQUESTED RANGES
"RTN","RORX019",308,0)
 ;-- If both tests contain ranges: scores for BOTH tests must fall in the
"RTN","RORX019",309,0)
 ;ranges...treated like an 'AND'
"RTN","RORX019",310,0)
 ;-- If 1 test contains a range: only patients with scores in the requested range
"RTN","RORX019",311,0)
 ;will be displayed, and the test without the range will also be displayed
"RTN","RORX019",312,0)
 ;with the calculated score (if applicable)
"RTN","RORX019",313,0)
 ;-- If neither test contains a range: all patients and their test results
"RTN","RORX019",314,0)
 ;and scores (null if they can't be calculated) are returned
"RTN","RORX019",315,0)
 ;
"RTN","RORX019",316,0)
 ;INPUT
"RTN","RORX019",317,0)
 ;  RORDATA  Array with ROR data
"RTN","RORX019",318,0)
 ;OUTPUT
"RTN","RORX019",319,0)
 ;  1        include on report
"RTN","RORX019",320,0)
 ;  0        exclude from report
"RTN","RORX019",321,0)
 ;************************************************************************
"RTN","RORX019",322,0)
INRANGE(RORDATA) ;
"RTN","RORX019",323,0)
 ;include data and quit if no range was sent in
"RTN","RORX019",324,0)
 Q:($D(RORDATA("RANGE"))'>1) 1
"RTN","RORX019",325,0)
 ;check scores to see if they are within the user-selected range(s)
"RTN","RORX019",326,0)
 N I,RETURN,SCORE S RETURN=1 ;default is set to 'within range'
"RTN","RORX019",327,0)
 S I=0 F  S I=$O(RORDATA("RANGE",I)) Q:I=""  D
"RTN","RORX019",328,0)
 . I $G(RORDATA("L",I))'="" D
"RTN","RORX019",329,0)
 .. S SCORE=$G(RORDATA("SCORE",I))
"RTN","RORX019",330,0)
 .. I $G(SCORE)="" S RETURN=0 Q
"RTN","RORX019",331,0)
 .. I SCORE<RORDATA("L",I) S RETURN=0
"RTN","RORX019",332,0)
 . I $G(RORDATA("H",I))'="" D
"RTN","RORX019",333,0)
 .. S SCORE=$G(RORDATA("SCORE",I))
"RTN","RORX019",334,0)
 .. I $G(SCORE)="" S RETURN=0 Q
"RTN","RORX019",335,0)
 .. I SCORE>$G(RORDATA("H",I)) S RETURN=0
"RTN","RORX019",336,0)
 ;
"RTN","RORX019",337,0)
 Q RETURN
"RTN","RORX019",338,0)
 ;
"RTN","RORX019",339,0)
 ;************************************************************************
"RTN","RORX019",340,0)
 ;ADD THE HEADERS TO THE REPORT (EXTRINISIC FUNCTION)
"RTN","RORX019",341,0)
 ;
"RTN","RORX019",342,0)
 ;INPUT
"RTN","RORX019",343,0)
 ;  PARTAG  Reference IEN to the 'report' parent XML tag
"RTN","RORX019",344,0)
 ;  PARAMS  Reference IEN to the 'params' parent XML tag
"RTN","RORX019",345,0)
 ;
"RTN","RORX019",346,0)
 ;OUTPUT
"RTN","RORX019",347,0)
 ;  <0      error
"RTN","RORX019",348,0)
 ;  >0      'Header' XML tag number or error code
"RTN","RORX019",349,0)
 ;************************************************************************
"RTN","RORX019",350,0)
HEADER(PARTAG,PARAMS) ;
"RTN","RORX019",351,0)
 N HEADER,RC,COL,COLUMNS,TMP S RC=0
"RTN","RORX019",352,0)
 ;call to $$HEADER^RORXU002 will populate the report created date, task number,
"RTN","RORX019",353,0)
 ;last registry update, and last data extraction.
"RTN","RORX019",354,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX019",355,0)
 Q:HEADER<0 HEADER
"RTN","RORX019",356,0)
 ;manually build the table defintion(s) listed below
"RTN","RORX019",357,0)
 ;PATIENTS(#,NAME,LAST4,DOD,TEST,DATE,RESULT,MELD,MELDNA,APRI,FIB4)
"RTN","RORX019",358,0)
 S COLUMNS=$$ADDVAL^RORTSK11(RORTSK,"TBLDEF",,HEADER)
"RTN","RORX019",359,0)
 D ADDATTR^RORTSK11(RORTSK,COLUMNS,"NAME","PATIENTS")
"RTN","RORX019",360,0)
 D ADDATTR^RORTSK11(RORTSK,COLUMNS,"HEADER","1")
"RTN","RORX019",361,0)
 D ADDATTR^RORTSK11(RORTSK,COLUMNS,"FOOTER","1")
"RTN","RORX019",362,0)
 ;--- Required columns
"RTN","RORX019",363,0)
 F COL="#","NAME","LAST4","DOD","TEST","DATE","RESULT"  D
"RTN","RORX019",364,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,COLUMNS)
"RTN","RORX019",365,0)
 . D ADDATTR^RORTSK11(RORTSK,TMP,"NAME",COL)
"RTN","RORX019",366,0)
 ;--- Additional columns
"RTN","RORX019",367,0)
 I RORDATA("IDLST")[1 D
"RTN","RORX019",368,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,COLUMNS)
"RTN","RORX019",369,0)
 . D ADDATTR^RORTSK11(RORTSK,TMP,"NAME","MELD")
"RTN","RORX019",370,0)
 I RORDATA("IDLST")[2 D
"RTN","RORX019",371,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,COLUMNS)
"RTN","RORX019",372,0)
 . ;D ADDATTR^RORTSK11(RORTSK,TMP,"NAME","MELDNA")
"RTN","RORX019",373,0)
 . ;note: the column name length above was causing problems in the
"RTN","RORX019",374,0)
 . ;XSL diaglog file entry 7981019.001, so we shortened it to just "NA".
"RTN","RORX019",375,0)
 . D ADDATTR^RORTSK11(RORTSK,TMP,"NAME","NA")
"RTN","RORX019",376,0)
 I RORDATA("IDLST")[3 D
"RTN","RORX019",377,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,COLUMNS)
"RTN","RORX019",378,0)
 . D ADDATTR^RORTSK11(RORTSK,TMP,"NAME","APRI")
"RTN","RORX019",379,0)
 I RORDATA("IDLST")[4 D
"RTN","RORX019",380,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,COLUMNS)
"RTN","RORX019",381,0)
 . D ADDATTR^RORTSK11(RORTSK,TMP,"NAME","FIB4")
"RTN","RORX019",382,0)
 ;--- LOINC codes
"RTN","RORX019",383,0)
 N LTAG S LTAG=$$ADDVAL^RORTSK11(RORTSK,"LOINC_CODES",,PARTAG)
"RTN","RORX019",384,0)
 N CTAG S CTAG=$$ADDVAL^RORTSK11(RORTSK,"CODE",,LTAG)
"RTN","RORX019",385,0)
 D ADDATTR^RORTSK11(RORTSK,CTAG,"CODE","ALT: 1742-6, 16325-3")
"RTN","RORX019",386,0)
 N CTAG S CTAG=$$ADDVAL^RORTSK11(RORTSK,"CODE",,LTAG)
"RTN","RORX019",387,0)
 D ADDATTR^RORTSK11(RORTSK,CTAG,"CODE","AST: 1916-6, 1920-8, 127344-1")
"RTN","RORX019",388,0)
 N CTAG S CTAG=$$ADDVAL^RORTSK11(RORTSK,"CODE",,LTAG)
"RTN","RORX019",389,0)
 D ADDATTR^RORTSK11(RORTSK,CTAG,"CODE","Billirubin: 14631-6, 1975-2")
"RTN","RORX019",390,0)
 N CTAG S CTAG=$$ADDVAL^RORTSK11(RORTSK,"CODE",,LTAG)
"RTN","RORX019",391,0)
 D ADDATTR^RORTSK11(RORTSK,CTAG,"CODE","Creatinine: 15045-8, 21232-4, 2160-0")
"RTN","RORX019",392,0)
 N CTAG S CTAG=$$ADDVAL^RORTSK11(RORTSK,"CODE",,LTAG)
"RTN","RORX019",393,0)
 D ADDATTR^RORTSK11(RORTSK,CTAG,"CODE","INR: 34714-6, 6301-6")
"RTN","RORX019",394,0)
 N CTAG S CTAG=$$ADDVAL^RORTSK11(RORTSK,"CODE",,LTAG)
"RTN","RORX019",395,0)
 D ADDATTR^RORTSK11(RORTSK,CTAG,"CODE","Platelets: 777-3, 778-1, 26515-7")
"RTN","RORX019",396,0)
 N CTAG S CTAG=$$ADDVAL^RORTSK11(RORTSK,"CODE",,LTAG)
"RTN","RORX019",397,0)
 D ADDATTR^RORTSK11(RORTSK,CTAG,"CODE","Sodium: 2947-0, 2951-2, 32717-1")
"RTN","RORX019",398,0)
 ;
"RTN","RORX019",399,0)
 ;Add ULNAST value if passed in
"RTN","RORX019",400,0)
 I $G(RORTSK("PARAMS","ULNAST")) D
"RTN","RORX019",401,0)
 . N ULNAST S ULNAST=$$ADDVAL^RORTSK11(RORTSK,"ULNAST",,PARAMS)
"RTN","RORX019",402,0)
 . D ADDATTR^RORTSK11(RORTSK,ULNAST,"VALUES",$G(RORDATA("ULNAST")))
"RTN","RORX019",403,0)
 ;
"RTN","RORX019",404,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX019",405,0)
 ;
"RTN","RORX020")
0^1^B68556557^B216151292
"RTN","RORX020",1,0)
RORX020 ;BPOIFO/ACS - RENAL FUNCTION BY RANGE ; 6/2/11 4:19pm
"RTN","RORX020",2,0)
 ;;1.5;CLINICAL CASE REGISTRIES;**10,13,14,15**;Feb 17, 2006;Build 27
"RTN","RORX020",3,0)
 ;
"RTN","RORX020",4,0)
 ; This routine uses the following IAs:
"RTN","RORX020",5,0)
 ;
"RTN","RORX020",6,0)
 ; #4290         ^PXRMINDX(120.5 (controlled)
"RTN","RORX020",7,0)
 ; #3647         $$EN^GMVPXRM (controlled)
"RTN","RORX020",8,0)
 ; #10061        DEM^VADPT (supported)
"RTN","RORX020",9,0)
 ; #10105        PWR^XLFMTH (supported)
"RTN","RORX020",10,0)
 ; #5047         $$GETIEN^GMVGETVT (supported)
"RTN","RORX020",11,0)
 ; #3556         GCPR^LA7QRY (supported)
"RTN","RORX020",12,0)
 ;
"RTN","RORX020",13,0)
 ;******************************************************************************
"RTN","RORX020",14,0)
 ;******************************************************************************
"RTN","RORX020",15,0)
 ;                 --- ROUTINE MODIFICATION LOG ---
"RTN","RORX020",16,0)
 ;        
"RTN","RORX020",17,0)
 ;PKG/PATCH    DATE        DEVELOPER    MODIFICATION
"RTN","RORX020",18,0)
 ;-----------  ----------  -----------  ----------------------------------------
"RTN","RORX020",19,0)
 ;ROR*1.5*10   MAR  2010   A SAUNDERS   Routine created
"RTN","RORX020",20,0)
 ;ROR*1.5*13   DEC  2010   A SAUNDERS   User can select specific patients,
"RTN","RORX020",21,0)
 ;                                      clinics, or divisions for the report.
"RTN","RORX020",22,0)
 ;                                      Modified XML tags for sort.
"RTN","RORX020",23,0)
 ;ROR*1.5*14   APR  2011   A SAUNDERS   CALCRF: Age calculation now uses 
"RTN","RORX020",24,0)
 ;                                      $$AGE^RORX019A.
"RTN","RORX020",25,0)
 ;ROR*1.5*15   JUN  2011   C RAY        Added calculation for eGRF by CKD-EPI
"RTN","RORX020",26,0)
 ;******************************************************************************
"RTN","RORX020",27,0)
 ;******************************************************************************
"RTN","RORX020",28,0)
 Q
"RTN","RORX020",29,0)
 ;
"RTN","RORX020",30,0)
 ;************************************************************************
"RTN","RORX020",31,0)
 ;COMPILE THE "RENAL FUNCTION BY RANGE" REPORT
"RTN","RORX020",32,0)
 ;REPORT CODE: 020
"RTN","RORX020",33,0)
 ;
"RTN","RORX020",34,0)
 ;Called by entry "Renal Function by Range" in ROR REPORT PARAMETERS (#799.34)
"RTN","RORX020",35,0)
 ;
"RTN","RORX020",36,0)
 ;INPUT
"RTN","RORX020",37,0)
 ;  RORTSK     Task number and task parameters
"RTN","RORX020",38,0)
 ;  
"RTN","RORX020",39,0)
 ;  Below is a sample RORTSK input array for utilization in 2003, most recent
"RTN","RORX020",40,0)
 ;  scores, CrCL range from 20 to 50, eGFR range from 30 to 60:
"RTN","RORX020",41,0)
 ;  
"RTN","RORX020",42,0)
 ;  RORTSK=nnn   (the task number)
"RTN","RORX020",43,0)
 ;  RORTSK("EP")="$$RFRANGE^RORX020"
"RTN","RORX020",44,0)
 ;  RORTSK("PARAMS","DATE_RANGE_3","A","END")=3031231
"RTN","RORX020",45,0)
 ;  RORTSK("PARAMS","DATE_RANGE_3","A","START")=3030101
"RTN","RORX020",46,0)
 ;  RORTSK("PARAMS","ICD9FILT","A","FILTER")="ALL"
"RTN","RORX020",47,0)
 ;  RORTSK("PARAMS","LRGRANGES","C",1)=""
"RTN","RORX020",48,0)
 ;  RORTSK("PARAMS","LRGRANGES","C",1,"H")=50
"RTN","RORX020",49,0)
 ;  RORTSK("PARAMS","LRGRANGES","C",1,"L")=20
"RTN","RORX020",50,0)
 ;  RORTSK("PARAMS","LRGRANGES","C",2)=""
"RTN","RORX020",51,0)
 ;  RORTSK("PARAMS","LRGRANGES","C",2,"H")=60
"RTN","RORX020",52,0)
 ;  RORTSK("PARAMS","LRGRANGES","C",2,"L")=30
"RTN","RORX020",53,0)
 ;  RORTSK("PARAMS","OPTIONS","A","COMPLETE")=1
"RTN","RORX020",54,0)
 ;  RORTSK("PARAMS","OPTIONS","A","MOST_RECENT")=1
"RTN","RORX020",55,0)
 ;  RORTSK("PARAMS","PATIENTS","A","DE_AFTER")=1
"RTN","RORX020",56,0)
 ;  RORTSK("PARAMS","PATIENTS","A","DE_BEFORE")=1
"RTN","RORX020",57,0)
 ;  RORTSK("PARAMS","PATIENTS","A","DE_DURING")=1
"RTN","RORX020",58,0)
 ;  RORTSK("PARAMS","REGIEN")=1
"RTN","RORX020",59,0)
 ;  
"RTN","RORX020",60,0)
 ;  If the user selected an 'as of' date = 12/31/2005:
"RTN","RORX020",61,0)
 ;     RORTSK("PARAMS","OPTIONS","A","MOST_RECENT")=1
"RTN","RORX020",62,0)
 ;  is replaced with:  
"RTN","RORX020",63,0)
 ;     RORTSK("PARAMS","OPTIONS","A","MAX_DATE")=3051231
"RTN","RORX020",64,0)
 ;
"RTN","RORX020",65,0)
 ;OUTPUT
"RTN","RORX020",66,0)
 ;  <0  Error code
"RTN","RORX020",67,0)
 ;   0  Ok
"RTN","RORX020",68,0)
 ;************************************************************************
"RTN","RORX020",69,0)
RFRANGE(RORTSK) ;
"RTN","RORX020",70,0)
 N RORDATA       ; array to hold ROR data and summary totals
"RTN","RORX020",71,0)
 N RORREG        ; Registry IEN
"RTN","RORX020",72,0)
 N RORSDT        ; report start date
"RTN","RORX020",73,0)
 N ROREDT        ; report end date
"RTN","RORX020",74,0)
 N RORPTIEN      ; IEN of patient in the ROR registry
"RTN","RORX020",75,0)
 N DFN           ; DFN of patient in the PATIENT file (#2)
"RTN","RORX020",76,0)
 N RORLC         ; sub-file and array of LOINC codes to search Lab data
"RTN","RORX020",77,0)
 N RORCDLIST     ; Flag to indicate whether a clinic or division list exists
"RTN","RORX020",78,0)
 N RORCDSTDT     ; Start date for clinic/division utilization search
"RTN","RORX020",79,0)
 N RORCDENDT     ; End date for clinic/division utilization search
"RTN","RORX020",80,0)
 ;
"RTN","RORX020",81,0)
 N REPORT,RC,I,SFLAGS,PARAMS
"RTN","RORX020",82,0)
 ;--- Establish the root XML Node of the report and put into output
"RTN","RORX020",83,0)
 S REPORT=$$ADDVAL^RORTSK11(RORTSK,"REPORT")
"RTN","RORX020",84,0)
 Q:REPORT<0 REPORT
"RTN","RORX020",85,0)
 ;
"RTN","RORX020",86,0)
 ;--- Get registry IEN
"RTN","RORX020",87,0)
 S RORREG=$$PARAM^RORTSK01("REGIEN")  ; Registry IEN
"RTN","RORX020",88,0)
 ;
"RTN","RORX020",89,0)
 ;--- Set standard report parameters data into output:
"RTN","RORX020",90,0)
 ;registry, comment, patients (before, during, after), options (summary vs.
"RTN","RORX020",91,0)
 ;complete), other registries, and other diagnoses
"RTN","RORX020",92,0)
 S PARAMS=$$PARAMS^RORXU002(.RORTSK,REPORT,.RORSDT,.ROREDT,.SFLAGS) Q:PARAMS<0 PARAMS
"RTN","RORX020",93,0)
 ;
"RTN","RORX020",94,0)
 ;--- Add range parameters to output
"RTN","RORX020",95,0)
 S RC=$$PARAMS^RORX020A(PARAMS,.RORDATA) Q:RC<0 RC
"RTN","RORX020",96,0)
 ;
"RTN","RORX020",97,0)
 ;--- Put report header data into output:
"RTN","RORX020",98,0)
 ;report creation date, task number, last registry update date, and
"RTN","RORX020",99,0)
 ;last data extraction date
"RTN","RORX020",100,0)
 S RC=$$HEADER^RORX020A(REPORT,.RORTSK) Q:RC<0 RC
"RTN","RORX020",101,0)
 ;
"RTN","RORX020",102,0)
 ;--- Get Renal ranges requested
"RTN","RORX020",103,0)
 ;I=1 ==> report = CrCL      I=2 ==> report = eGFR by MDRD
"RTN","RORX020",104,0)
 S I=0 F  S I=$O(RORTSK("PARAMS","LRGRANGES","C",I)) Q:I=""  D
"RTN","RORX020",105,0)
 . S RORDATA("L",I)=$G(RORTSK("PARAMS","LRGRANGES","C",I,"L")) ;low range
"RTN","RORX020",106,0)
 . S RORDATA("H",I)=$G(RORTSK("PARAMS","LRGRANGES","C",I,"H")) ;high range
"RTN","RORX020",107,0)
 ;
"RTN","RORX020",108,0)
 ;--- Get GMRV VITAL TYPE pointer for HEIGHT
"RTN","RORX020",109,0)
 S RORDATA("HGTP")=$$GETIEN^GMVGETVT("HEIGHT",1)
"RTN","RORX020",110,0)
 I '$G(RORDATA("HGTP")) Q -1
"RTN","RORX020",111,0)
 ;
"RTN","RORX020",112,0)
 ;--- Get Max Date  OUTPUT: RORDATA("DATE")  - Max Date for test scores
"RTN","RORX020",113,0)
 S RORDATA("DATE")=$$PARAM^RORTSK01("OPTIONS","MAX_DATE")
"RTN","RORX020",114,0)
 I $G(RORDATA("DATE"))="" S RORDATA("DATE")=DT
"RTN","RORX020",115,0)
 ;
"RTN","RORX020",116,0)
 ;--- Summary vs. complete report requested
"RTN","RORX020",117,0)
 S RORDATA("COMPLETE")=0 ;default to 'summary' only
"RTN","RORX020",118,0)
 I $$PARAM^RORTSK01("OPTIONS","COMPLETE") S RORDATA("COMPLETE")=1
"RTN","RORX020",119,0)
 ;
"RTN","RORX020",120,0)
 ;--- Set the number of Renal ranges and initialize their values to 0
"RTN","RORX020",121,0)
 S RORDATA("RCNT")=5 D INIT^RORX020A(.RORDATA)
"RTN","RORX020",122,0)
 ;
"RTN","RORX020",123,0)
 ;--- Create 'patients' table
"RTN","RORX020",124,0)
 N RORBODY S RORBODY=$$ADDVAL^RORTSK11(RORTSK,"PATIENTS",,REPORT)
"RTN","RORX020",125,0)
 D ADDATTR^RORTSK11(RORTSK,RORBODY,"TABLE","PATIENTS")
"RTN","RORX020",126,0)
 ;
"RTN","RORX020",127,0)
 ;--- Check utilization
"RTN","RORX020",128,0)
 N CNT,ECNT,UTSDT,UTEDT,SKIPSDT,SKIPEDT
"RTN","RORX020",129,0)
 S (CNT,ECNT,RC)=0,SKIPEDT=ROREDT,SKIPSDT=RORSDT
"RTN","RORX020",130,0)
 ; Utilization date range is always sent
"RTN","RORX020",131,0)
 S UTSDT=$$PARAM^RORTSK01("DATE_RANGE_3","START")\1
"RTN","RORX020",132,0)
 S UTEDT=$$PARAM^RORTSK01("DATE_RANGE_3","END")\1
"RTN","RORX020",133,0)
 ; Combined date range
"RTN","RORX020",134,0)
 S SKIPSDT=$$DTMIN^RORUTL18(SKIPSDT,$G(UTSDT))
"RTN","RORX020",135,0)
 S SKIPEDT=$$DTMAX^RORUTL18(SKIPEDT,$G(UTEDT))
"RTN","RORX020",136,0)
 ;
"RTN","RORX020",137,0)
 ;--- Number of patients in the registry - used for calculating the
"RTN","RORX020",138,0)
 ;task progress percentage (shown on the GUI screen)
"RTN","RORX020",139,0)
 N RORPTCNT S RORPTCNT=$$REGSIZE^RORUTL02(+RORREG) S:RORPTCNT<0 RORPTCNT=0
"RTN","RORX020",140,0)
 ;
"RTN","RORX020",141,0)
 ;--- LOINC codes for Creatinine
"RTN","RORX020",142,0)
 ;create list for future comparison
"RTN","RORX020",143,0)
 S RORDATA("LOINC")=";15045-8;21232-4;2160-0;"
"RTN","RORX020",144,0)
 ;set up array for future call to Lab API
"RTN","RORX020",145,0)
 S RORLC="CH" ;chemistry sub-file to search in #63
"RTN","RORX020",146,0)
 S RORLC(1)="15045-8^LN" ;Creatinine LOINC
"RTN","RORX020",147,0)
 S RORLC(2)="21232-4^LN" ;Creatinine LOINC
"RTN","RORX020",148,0)
 S RORLC(3)="2160-0^LN"  ;Creatinine LOINC
"RTN","RORX020",149,0)
 ;
"RTN","RORX020",150,0)
 ;--- RACE code 2054-5 = 'black or african american' in RACE file (IEN=9)
"RTN","RORX020",151,0)
 S RORDATA("BAM")=";9;"
"RTN","RORX020",152,0)
 ;
"RTN","RORX020",153,0)
 ;=== Set up Clinic/Division list parameters
"RTN","RORX020",154,0)
 S RORCDLIST=$$CDPARMS^RORXU001(.RORTSK,.RORCDSTDT,.RORCDENDT,1)
"RTN","RORX020",155,0)
 ;
"RTN","RORX020",156,0)
 ;--- Get registry records
"RTN","RORX020",157,0)
 N RCC,FLAG,SKIP,TMP
"RTN","RORX020",158,0)
 S (CNT,RORPTIEN,RC)=0
"RTN","RORX020",159,0)
 S FLAG=$G(RORTSK("PARAMS","ICD9FILT","A","FILTER"))
"RTN","RORX020",160,0)
 F  S RORPTIEN=$O(^RORDATA(798,"AC",RORREG,RORPTIEN))  Q:RORPTIEN'>0  D  Q:RC<0
"RTN","RORX020",161,0)
 . ;--- Calculate 'progress' for the GUI display
"RTN","RORX020",162,0)
 . S TMP=$S(RORPTCNT>0:CNT/RORPTCNT,1:"")
"RTN","RORX020",163,0)
 . S RC=$$LOOP^RORTSK01(TMP)  Q:RC<0
"RTN","RORX020",164,0)
 . S CNT=CNT+1
"RTN","RORX020",165,0)
 . ;--- Get the patient DFN
"RTN","RORX020",166,0)
 . S DFN=$$PTIEN^RORUTL01(RORPTIEN)  Q:DFN'>0
"RTN","RORX020",167,0)
 . ;--- Check for patient list and quit if not on list
"RTN","RORX020",168,0)
 . I $D(RORTSK("PARAMS","PATIENTS","C")),'$D(RORTSK("PARAMS","PATIENTS","C",DFN)) Q
"RTN","RORX020",169,0)
 . ;--- Check if the patient should be skipped
"RTN","RORX020",170,0)
 . Q:$$SKIP^RORXU005(RORPTIEN,SFLAGS,SKIPSDT,SKIPEDT)
"RTN","RORX020",171,0)
 . ;--- Check if patient has passed the ICD9 filter
"RTN","RORX020",172,0)
 . S RCC=0
"RTN","RORX020",173,0)
 . I FLAG'="ALL" D
"RTN","RORX020",174,0)
 . . S RCC=$$ICD^RORXU010(DFN,RORREG)
"RTN","RORX020",175,0)
 . I (FLAG="INCLUDE")&(RCC=0) Q
"RTN","RORX020",176,0)
 . I (FLAG="EXCLUDE")&(RCC=1) Q
"RTN","RORX020",177,0)
 . ;
"RTN","RORX020",178,0)
 . ;--- Check for Clinic or Division list and quit if not in list
"RTN","RORX020",179,0)
 . I RORCDLIST,'$$CDUTIL^RORXU001(.RORTSK,DFN,RORCDSTDT,RORCDENDT) Q
"RTN","RORX020",180,0)
 . ;
"RTN","RORX020",181,0)
 . ;--- Check for utilization in the corresponding 'utilization' date range
"RTN","RORX020",182,0)
 . S SKIP=0 I $G(UTSDT)>0 D
"RTN","RORX020",183,0)
 .. N UTIL K TMP S TMP("ALL")=1
"RTN","RORX020",184,0)
 .. S UTIL=+$$UTIL^RORXU003(UTSDT,UTEDT,DFN,.TMP)
"RTN","RORX020",185,0)
 .. I 'UTIL S SKIP=1
"RTN","RORX020",186,0)
 . ;--- Skip the patient if they have no utilization in the range
"RTN","RORX020",187,0)
 . I $G(SKIP) Q
"RTN","RORX020",188,0)
 . ;
"RTN","RORX020",189,0)
 . ;--- For each patient, process the registry record and create report
"RTN","RORX020",190,0)
 . I $$PATIENT(DFN,RORBODY,.RORDATA,RORPTIEN,.RORLC)<0 S ECNT=ECNT+1 ;error count
"RTN","RORX020",191,0)
 ;
"RTN","RORX020",192,0)
 ;--- If user selected eGFR by MDRD (ID=2) or eGFR by CKD-EPI (ID=3), create summary report
"RTN","RORX020",193,0)
 I RORDATA("IDLST")[2!(RORDATA("IDLST")[3) S RC=$$SUMMARY^RORX020A(RORTSK,REPORT,.RORDATA)
"RTN","RORX020",194,0)
 Q:RC<0 RC
"RTN","RORX020",195,0)
 K ^TMP("RORX020",$J),^TMP("ROROUT",$J)
"RTN","RORX020",196,0)
 Q $S(RC<0:RC,ECNT>0:-43,1:0)
"RTN","RORX020",197,0)
 ;
"RTN","RORX020",198,0)
 ;************************************************************************
"RTN","RORX020",199,0)
 ;ADD THE PATIENT DATA TO THE REPORT
"RTN","RORX020",200,0)
 ;
"RTN","RORX020",201,0)
 ;INPUT
"RTN","RORX020",202,0)
 ;  DFN      Patient DFN in PATIENT file (#2)
"RTN","RORX020",203,0)
 ;  PTAG     Reference IEN to the 'body' parent XML tag
"RTN","RORX020",204,0)
 ;  RORDATA  Array with ROR data
"RTN","RORX020",205,0)
 ;  RORPTIEN Patient IEN in the ROR registry
"RTN","RORX020",206,0)
 ;  RORLC    sub-file and LOINC codes to search for
"RTN","RORX020",207,0)
 ;
"RTN","RORX020",208,0)
 ;OUTPUT
"RTN","RORX020",209,0)
 ;  1        ok
"RTN","RORX020",210,0)
 ; <0        error
"RTN","RORX020",211,0)
 ;************************************************************************
"RTN","RORX020",212,0)
PATIENT(DFN,PTAG,RORDATA,RORPTIEN,RORLC) ;
"RTN","RORX020",213,0)
 ;calculate Renal Function scores
"RTN","RORX020",214,0)
 I $$CALCRF^RORX020B(DFN,.RORDATA,RORPTIEN,.RORLC)<0 Q 1  ;quit if patient data not available
"RTN","RORX020",215,0)
 I '$$INRANGE^RORX020A(.RORDATA) Q 1  ;quit if score(s) out of requested range
"RTN","RORX020",216,0)
 ;if eGFR by MDRD requested, add 1 to appropriate category count
"RTN","RORX020",217,0)
 I RORDATA("IDLST")[2 D MDRDCAT^RORX020A(.RORDATA)
"RTN","RORX020",218,0)
 ;if eGFR by CKD-EPI requested, add 1 to appropriate category count
"RTN","RORX020",219,0)
 I RORDATA("IDLST")[3 D CKDCAT^RORX020A(.RORDATA)
"RTN","RORX020",220,0)
 Q:'RORDATA("COMPLETE") 1  ;continue only if 'complete' report is requested
"RTN","RORX020",221,0)
 ;--- Get patient data and put into the report
"RTN","RORX020",222,0)
 N VADM,VA,RORDOD,TTAG,RTAG
"RTN","RORX020",223,0)
 D VADEM^RORUTL05(DFN,1)
"RTN","RORX020",224,0)
 ;--- The <PATIENT> tag
"RTN","RORX020",225,0)
 S PTAG=$$ADDVAL^RORTSK11(RORTSK,"PATIENT",,PTAG,,DFN)
"RTN","RORX020",226,0)
 I PTAG<0 Q PTAG
"RTN","RORX020",227,0)
 ;--- Patient Name
"RTN","RORX020",228,0)
 D ADDVAL^RORTSK11(RORTSK,"NAME",VADM(1),PTAG,1)
"RTN","RORX020",229,0)
 ;--- Last 4 digits of the SSN
"RTN","RORX020",230,0)
 D ADDVAL^RORTSK11(RORTSK,"LAST4",VA("BID"),PTAG,2)
"RTN","RORX020",231,0)
 ;--- Date of death
"RTN","RORX020",232,0)
 S RORDOD=$$DATE^RORXU002($P(VADM(6),U)\1)
"RTN","RORX020",233,0)
 D ADDVAL^RORTSK11(RORTSK,"DOD",$G(RORDOD),PTAG,1)
"RTN","RORX020",234,0)
 ;--- RENAL DATA tag
"RTN","RORX020",235,0)
 S RTAG=$$ADDVAL^RORTSK11(RORTSK,"RNLDATA",,PTAG)
"RTN","RORX020",236,0)
 Q:RTAG<0 RTAG
"RTN","RORX020",237,0)
 ;---  CR Test Tag
"RTN","RORX020",238,0)
 S TTAG=$$ADDVAL^RORTSK11(RORTSK,"TEST",,RTAG)
"RTN","RORX020",239,0)
 Q:TTAG<0 TTAG
"RTN","RORX020",240,0)
 ;---  Date Cr Test Taken
"RTN","RORX020",241,0)
 D ADDVAL^RORTSK11(RORTSK,"DATE",$G(RORDATA("CRDATE")),TTAG)
"RTN","RORX020",242,0)
 ;---  Cr Test Value
"RTN","RORX020",243,0)
 D ADDVAL^RORTSK11(RORTSK,"RESULT",$G(RORDATA("CR")),TTAG)
"RTN","RORX020",244,0)
 ;--- Height tag
"RTN","RORX020",245,0)
 S TTAG=$$ADDVAL^RORTSK11(RORTSK,"HEIGHT",,RTAG)
"RTN","RORX020",246,0)
 Q:TTAG<0 TTAG
"RTN","RORX020",247,0)
 ;---  Date Height Taken
"RTN","RORX020",248,0)
 D ADDVAL^RORTSK11(RORTSK,"DATE",$G(RORDATA("HDATE")),TTAG)
"RTN","RORX020",249,0)
 ;---  Height value
"RTN","RORX020",250,0)
 D ADDVAL^RORTSK11(RORTSK,"RESULT",$G(RORDATA("HGT")),TTAG)
"RTN","RORX020",251,0)
 ;---  Calculated CRCL
"RTN","RORX020",252,0)
 I RORDATA("IDLST")[1 D ADDVAL^RORTSK11(RORTSK,"CRCL",$G(RORDATA("SCORE",1)),PTAG,3)
"RTN","RORX020",253,0)
 ;---  Calculated eGFR by MDRD
"RTN","RORX020",254,0)
 I RORDATA("IDLST")[2 D ADDVAL^RORTSK11(RORTSK,"MDRD",$G(RORDATA("SCORE",2)),PTAG,3)
"RTN","RORX020",255,0)
 ;---  Calculated eGFR by CKD-EPI
"RTN","RORX020",256,0)
 I RORDATA("IDLST")[3 D ADDVAL^RORTSK11(RORTSK,"CKD",$G(RORDATA("SCORE",3)),PTAG,3)
"RTN","RORX020",257,0)
 Q ($S(TTAG<0:TTAG,1:1))
"RTN","RORX020",258,0)
 ;
"RTN","RORX020A")
0^2^B53998936^B42700433
"RTN","RORX020A",1,0)
RORX020A ;BPOIFO/ACS - RENAL FUNCTION BY RANGE (CONT.) ; 5/20/11 12:11pm
"RTN","RORX020A",2,0)
 ;;1.5;CLINICAL CASE REGISTRIES;**10,14,15**;Feb 17, 2006;Build 27
"RTN","RORX020A",3,0)
 ;
"RTN","RORX020A",4,0)
 Q
"RTN","RORX020A",5,0)
 ;******************************************************************************
"RTN","RORX020A",6,0)
 ;******************************************************************************
"RTN","RORX020A",7,0)
 ;                 --- ROUTINE MODIFICATION LOG ---
"RTN","RORX020A",8,0)
 ;        
"RTN","RORX020A",9,0)
 ;PKG/PATCH    DATE        DEVELOPER    MODIFICATION
"RTN","RORX020A",10,0)
 ;-----------  ----------  -----------  ----------------------------------------
"RTN","RORX020A",11,0)
 ;ROR*1.5*14   APR  2011   A SAUNDERS   HEADER: Added LOINCs to report header
"RTN","RORX020A",12,0)
 ;                                      
"RTN","RORX020A",13,0)
 ;******************************************************************************
"RTN","RORX020A",14,0)
 ;******************************************************************************
"RTN","RORX020A",15,0)
 ;
"RTN","RORX020A",16,0)
 ;************************************************************************
"RTN","RORX020A",17,0)
 ;ADD THE HEADERS TO THE REPORT (EXTRINSIC FUNCTION)
"RTN","RORX020A",18,0)
 ;
"RTN","RORX020A",19,0)
 ;INPUT
"RTN","RORX020A",20,0)
 ;  PARTAG  Reference IEN to the 'report' parent XML tag
"RTN","RORX020A",21,0)
 ;
"RTN","RORX020A",22,0)
 ;OUTPUT
"RTN","RORX020A",23,0)
 ;  <0      error
"RTN","RORX020A",24,0)
 ;  >0      'Header' XML tag number or error code
"RTN","RORX020A",25,0)
 ;************************************************************************
"RTN","RORX020A",26,0)
HEADER(PARTAG,RORTSK) ;
"RTN","RORX020A",27,0)
 N HEADER,RC,COL,COLUMNS,TMP S RC=0
"RTN","RORX020A",28,0)
 ;call to $$HEADER^RORXU002 will populate the report created date, task number,
"RTN","RORX020A",29,0)
 ;last registry update, and last data extraction.
"RTN","RORX020A",30,0)
 S HEADER=$$HEADER^RORXU002(.RORTSK,PARTAG)
"RTN","RORX020A",31,0)
 Q:HEADER<0 HEADER
"RTN","RORX020A",32,0)
 ;manually build the table definition(s) listed below
"RTN","RORX020A",33,0)
 ;PATIENTS(#,NAME,LAST4,DOD,TEST,DATE,RESULT,CRCL,EGFR)
"RTN","RORX020A",34,0)
 S COLUMNS=$$ADDVAL^RORTSK11(RORTSK,"TBLDEF",,HEADER)
"RTN","RORX020A",35,0)
 D ADDATTR^RORTSK11(RORTSK,COLUMNS,"NAME","PATIENTS")
"RTN","RORX020A",36,0)
 D ADDATTR^RORTSK11(RORTSK,COLUMNS,"HEADER","1")
"RTN","RORX020A",37,0)
 D ADDATTR^RORTSK11(RORTSK,COLUMNS,"FOOTER","1")
"RTN","RORX020A",38,0)
 ;--- Required columns
"RTN","RORX020A",39,0)
 F COL="#","NAME","LAST4","DOD","TEST","DATE","RESULT"  D
"RTN","RORX020A",40,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,COLUMNS)
"RTN","RORX020A",41,0)
 . D ADDATTR^RORTSK11(RORTSK,TMP,"NAME",COL)
"RTN","RORX020A",42,0)
 ;--- Additional columns
"RTN","RORX020A",43,0)
 I RORDATA("IDLST")[1 D
"RTN","RORX020A",44,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,COLUMNS)
"RTN","RORX020A",45,0)
 . D ADDATTR^RORTSK11(RORTSK,TMP,"NAME","CRCL")
"RTN","RORX020A",46,0)
 I RORDATA("IDLST")[2 D
"RTN","RORX020A",47,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,COLUMNS)
"RTN","RORX020A",48,0)
 . D ADDATTR^RORTSK11(RORTSK,TMP,"NAME","MDRD")
"RTN","RORX020A",49,0)
 I RORDATA("IDLST")[3 D
"RTN","RORX020A",50,0)
 . S TMP=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,COLUMNS)
"RTN","RORX020A",51,0)
 . D ADDATTR^RORTSK11(RORTSK,TMP,"NAME","CKD")
"RTN","RORX020A",52,0)
 ;--- LOINC codes
"RTN","RORX020A",53,0)
 N LTAG S LTAG=$$ADDVAL^RORTSK11(RORTSK,"LOINC_CODES",,PARTAG)
"RTN","RORX020A",54,0)
 N CTAG S CTAG=$$ADDVAL^RORTSK11(RORTSK,"CODE",,LTAG)
"RTN","RORX020A",55,0)
 D ADDATTR^RORTSK11(RORTSK,CTAG,"CODE","Creatinine: 15045-8, 21232-4, 2160-0")
"RTN","RORX020A",56,0)
 ;---
"RTN","RORX020A",57,0)
 Q $S(RC<0:RC,1:HEADER)
"RTN","RORX020A",58,0)
 ;
"RTN","RORX020A",59,0)
 ;*****************************************************************************
"RTN","RORX020A",60,0)
 ;INITIALIZE THE RANGE COUNTS TO 0
"RTN","RORX020A",61,0)
 ;
"RTN","RORX020A",62,0)
 ;INPUT
"RTN","RORX020A",63,0)
 ;  RORDATA  Array with ROR data
"RTN","RORX020A",64,0)
 ;           RORDATA("RCNT") Number of ranges/groupings to initialize
"RTN","RORX020A",65,0)
 ;*****************************************************************************
"RTN","RORX020A",66,0)
INIT(RORDATA) ;
"RTN","RORX020A",67,0)
 I $G(RORDATA("RCNT"))="" Q
"RTN","RORX020A",68,0)
 N I
"RTN","RORX020A",69,0)
 F I=1:1:RORDATA("RCNT") D
"RTN","RORX020A",70,0)
 .I RORDATA("IDLST")[2 S RORDATA("NPMDRD",I)=0
"RTN","RORX020A",71,0)
 .I RORDATA("IDLST")[3 S RORDATA("NPCKD",I)=0
"RTN","RORX020A",72,0)
 Q
"RTN","RORX020A",73,0)
 ;
"RTN","RORX020A",74,0)
 ;*****************************************************************************
"RTN","RORX020A",75,0)
 ;OUTPUT REPORT 'RANGE' PARAMETERS, SET UP REPORT ID LIST (EXTRINISIC FUNCTION)
"RTN","RORX020A",76,0)
 ;
"RTN","RORX020A",77,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORX020A",78,0)
 ;
"RTN","RORX020A",79,0)
 ; Return Values:
"RTN","RORX020A",80,0)
 ;        RORDATA("IDLST") - list of IDs for tests requested
"RTN","RORX020A",81,0)
 ;        RORDATA("RANGE") - 1 if range passed in for either test, else 0
"RTN","RORX020A",82,0)
 ;       <0  Error code
"RTN","RORX020A",83,0)
 ;        0  Ok
"RTN","RORX020A",84,0)
 ;*****************************************************************************
"RTN","RORX020A",85,0)
PARAMS(PARTAG,RORDATA) ;
"RTN","RORX020A",86,0)
 N PARAMS,DESC,TMP,RC,RANGE S RC=0
"RTN","RORX020A",87,0)
 S RORDATA("RANGE")=0 ;initialize to 'no range passed in'
"RTN","RORX020A",88,0)
 ;--- Lab test ranges
"RTN","RORX020A",89,0)
 I $D(RORTSK("PARAMS","LRGRANGES","C"))>1  D  Q:RC<0 RC
"RTN","RORX020A",90,0)
 . N GRC,ELEMENT,NODE,RTAG,RANGE
"RTN","RORX020A",91,0)
 . S NODE=$NA(RORTSK("PARAMS","LRGRANGES","C"))
"RTN","RORX020A",92,0)
 . S RTAG=$$ADDVAL^RORTSK11(RORTSK,"LRGRANGES",,PARTAG)
"RTN","RORX020A",93,0)
 . S (GRC,RC)=0
"RTN","RORX020A",94,0)
 . F  S GRC=$O(@NODE@(GRC))  Q:GRC'>0  D  Q:RC<0
"RTN","RORX020A",95,0)
 . . S RANGE=0,DESC=$$RTEXT(GRC,.RORDATA)
"RTN","RORX020A",96,0)
 . . S ELEMENT=$$ADDVAL^RORTSK11(RORTSK,"LRGRANGE",DESC,RTAG)
"RTN","RORX020A",97,0)
 . . I ELEMENT<0 S RC=ELEMENT Q
"RTN","RORX020A",98,0)
 . . D ADDATTR^RORTSK11(RORTSK,ELEMENT,"ID",GRC)
"RTN","RORX020A",99,0)
 . . ;add the user-requested test ID to the test ID 'list'
"RTN","RORX020A",100,0)
 . . S RORDATA("IDLST")=$G(RORDATA("IDLST"))_$S($G(RORDATA("IDLST"))'="":","_GRC,1:GRC)
"RTN","RORX020A",101,0)
 . . ;--- Process the range values
"RTN","RORX020A",102,0)
 . . S TMP=$G(@NODE@(GRC,"L"))
"RTN","RORX020A",103,0)
 . . I TMP'="" D  S RANGE=1
"RTN","RORX020A",104,0)
 . . . D ADDATTR^RORTSK11(RORTSK,ELEMENT,"LOW",TMP)
"RTN","RORX020A",105,0)
 . . S TMP=$G(@NODE@(GRC,"H"))
"RTN","RORX020A",106,0)
 . . I TMP'="" D  S RANGE=1
"RTN","RORX020A",107,0)
 . . . D ADDATTR^RORTSK11(RORTSK,ELEMENT,"HIGH",TMP)
"RTN","RORX020A",108,0)
 . . I RANGE D 
"RTN","RORX020A",109,0)
 . . . D ADDATTR^RORTSK11(RORTSK,ELEMENT,"RANGE",1)
"RTN","RORX020A",110,0)
 . . . S RORDATA("RANGE")=1
"RTN","RORX020A",111,0)
 ;--- Success
"RTN","RORX020A",112,0)
 ;if user didn't select any tests, default to both tests
"RTN","RORX020A",113,0)
 I $G(RORDATA("IDLST"))="" S RORDATA("IDLST")="1,2,3"
"RTN","RORX020A",114,0)
 Q RC
"RTN","RORX020A",115,0)
 ;
"RTN","RORX020A",116,0)
 ;*****************************************************************************
"RTN","RORX020A",117,0)
 ;RETURN RANGE TEXT AND ADD RANGE VALUES TO RORDATA (EXTRINISIC FUNCTION) 
"RTN","RORX020A",118,0)
 ;ID=1: MELD
"RTN","RORX020A",119,0)
 ;ID=2: MELD-Na
"RTN","RORX020A",120,0)
 ;
"RTN","RORX020A",121,0)
 ;INPUT:
"RTN","RORX020A",122,0)
 ;  GRC   Test ID number
"RTN","RORX020A",123,0)
 ;  RORDATA - Array with ROR data
"RTN","RORX020A",124,0)
 ;
"RTN","RORX020A",125,0)
 ;OUTPUT:
"RTN","RORX020A",126,0)
 ;  RORDATA("L",ID) - test ID low range
"RTN","RORX020A",127,0)
 ;  RORDATA("H",ID) - test ID high range
"RTN","RORX020A",128,0)
 ;  Description - <range>
"RTN","RORX020A",129,0)
 ;*****************************************************************************
"RTN","RORX020A",130,0)
RTEXT(GRC,RORDATA) ;
"RTN","RORX020A",131,0)
 N RANGE,TMP
"RTN","RORX020A",132,0)
 S RANGE=""
"RTN","RORX020A",133,0)
 ;--- Range
"RTN","RORX020A",134,0)
 I $D(RORTSK("PARAMS","LRGRANGES","C",GRC))>1 D
"RTN","RORX020A",135,0)
 . ;--- Low
"RTN","RORX020A",136,0)
 . S TMP=$G(RORTSK("PARAMS","LRGRANGES","C",GRC,"L"))
"RTN","RORX020A",137,0)
 . S RORDATA("L",GRC)=$G(TMP)
"RTN","RORX020A",138,0)
 . S:TMP'="" RANGE=RANGE_" not less than "_TMP
"RTN","RORX020A",139,0)
 . ;--- High
"RTN","RORX020A",140,0)
 . S TMP=$G(RORTSK("PARAMS","LRGRANGES","C",GRC,"H"))
"RTN","RORX020A",141,0)
 . S RORDATA("H",GRC)=$G(TMP)
"RTN","RORX020A",142,0)
 . I TMP'=""  D:RANGE'=""  S RANGE=RANGE_" not greater than "_TMP
"RTN","RORX020A",143,0)
 . . S RANGE=RANGE_" and"
"RTN","RORX020A",144,0)
 ;--- Description
"RTN","RORX020A",145,0)
 S TMP=$G(RORTSK("PARAMS","LRGRANGES","C",GRC))
"RTN","RORX020A",146,0)
 S:TMP="" TMP="Unknown ("_GRC_")"
"RTN","RORX020A",147,0)
 Q TMP_" - "_$S(RANGE'="":"numeric results"_RANGE,1:"all results")
"RTN","RORX020A",148,0)
 ;
"RTN","RORX020A",149,0)
 ;************************************************************************
"RTN","RORX020A",150,0)
 ;DETERMINE IF THE SCORES ARE WITHIN THE REQUESTED RANGES (EXTRINSIC FUNCTION)
"RTN","RORX020A",151,0)
 ;If not in the range, exclude from report
"RTN","RORX020A",152,0)
 ;
"RTN","RORX020A",153,0)
 ;INPUT:
"RTN","RORX020A",154,0)
 ;  RORDATA  RORDATA("SCORE",I) contains computed test score for test ID 'I'
"RTN","RORX020A",155,0)
 ;
"RTN","RORX020A",156,0)
 ;OUTPUT:
"RTN","RORX020A",157,0)
 ;  1  include on report
"RTN","RORX020A",158,0)
 ;  0  exclude from report
"RTN","RORX020A",159,0)
 ;************************************************************************
"RTN","RORX020A",160,0)
INRANGE(RORDATA) ;
"RTN","RORX020A",161,0)
 ;if range exists for either test, and any result is considered 'invalid',
"RTN","RORX020A",162,0)
 ;then skip the range check and exclude data from report
"RTN","RORX020A",163,0)
 ;I $G(RORDATA("RANGE")),'$G(RORDATA("CALC")) Q 0
"RTN","RORX020A",164,0)
 ;if range does not exist for either test, and any result is considered 'invalid',
"RTN","RORX020A",165,0)
 ;then skip the range check and include data in the report
"RTN","RORX020A",166,0)
 I '$G(RORDATA("RANGE")),'$G(RORDATA("CALC")) Q 1
"RTN","RORX020A",167,0)
 ;
"RTN","RORX020A",168,0)
 ;---Range Check
"RTN","RORX020A",169,0)
 N I,RETURN S RETURN=1 ;default is set to 'within range'
"RTN","RORX020A",170,0)
 S I=0 F  S I=$O(RORDATA("SCORE",I)) Q:I=""  D
"RTN","RORX020A",171,0)
 . I $G(RORDATA("L",I))'="" D
"RTN","RORX020A",172,0)
 .. ;if score is less than 'low' range, do not include on report 
"RTN","RORX020A",173,0)
 .. I $G(RORDATA("SCORE",I))<RORDATA("L",I) S RETURN=0
"RTN","RORX020A",174,0)
 . I $G(RORDATA("H",I))'="" D
"RTN","RORX020A",175,0)
 .. ;if score is higher than 'high' range, do not include on report 
"RTN","RORX020A",176,0)
 .. I $G(RORDATA("SCORE",I))>RORDATA("H",I) S RETURN=0
"RTN","RORX020A",177,0)
 ;
"RTN","RORX020A",178,0)
 Q RETURN
"RTN","RORX020A",179,0)
 ;
"RTN","RORX020A",180,0)
 ;************************************************************************
"RTN","RORX020A",181,0)
 ;ADD 1 TO APPROPRIATE eGFR CATEGORY
"RTN","RORX020A",182,0)
 ;
"RTN","RORX020A",183,0)
 ;INPUT
"RTN","RORX020A",184,0)
 ;  RORDATA  Array with ROR data
"RTN","RORX020A",185,0)
 ;************************************************************************
"RTN","RORX020A",186,0)
MDRDCAT(RORDATA) ;
"RTN","RORX020A",187,0)
 I '$G(RORDATA("SCORE",2)) Q  ;quit if no score was calculated
"RTN","RORX020A",188,0)
 I $G(RORDATA("SCORE",2))>89 S RORDATA("NPMDRD",1)=$G(RORDATA("NPMDRD",1))+1 Q
"RTN","RORX020A",189,0)
 I $G(RORDATA("SCORE",2))>59 S RORDATA("NPMDRD",2)=$G(RORDATA("NPMDRD",2))+1 Q
"RTN","RORX020A",190,0)
 I $G(RORDATA("SCORE",2))>29 S RORDATA("NPMDRD",3)=$G(RORDATA("NPMDRD",3))+1 Q
"RTN","RORX020A",191,0)
 I $G(RORDATA("SCORE",2))>14 S RORDATA("NPMDRD",4)=$G(RORDATA("NPMDRD",4))+1 Q
"RTN","RORX020A",192,0)
 S RORDATA("NPMDRD",5)=$G(RORDATA("NPMDRD",5))+1 Q
"RTN","RORX020A",193,0)
 Q
"RTN","RORX020A",194,0)
 ;
"RTN","RORX020A",195,0)
 ;************************************************************************
"RTN","RORX020A",196,0)
 ;ADD 1 TO APPROPRIATE eGFR CATEGORY
"RTN","RORX020A",197,0)
 ;
"RTN","RORX020A",198,0)
 ;INPUT
"RTN","RORX020A",199,0)
 ;  RORDATA  Array with ROR data
"RTN","RORX020A",200,0)
 ;************************************************************************
"RTN","RORX020A",201,0)
CKDCAT(RORDATA) ;
"RTN","RORX020A",202,0)
 I '$G(RORDATA("SCORE",3)) Q  ;quit if no score was calculated
"RTN","RORX020A",203,0)
 I $G(RORDATA("SCORE",3))>89 S RORDATA("NPCKD",1)=$G(RORDATA("NPCKD",1))+1 Q
"RTN","RORX020A",204,0)
 I $G(RORDATA("SCORE",3))>59 S RORDATA("NPCKD",2)=$G(RORDATA("NPCKD",2))+1 Q
"RTN","RORX020A",205,0)
 I $G(RORDATA("SCORE",3))>29 S RORDATA("NPCKD",3)=$G(RORDATA("NPCKD",3))+1 Q
"RTN","RORX020A",206,0)
 I $G(RORDATA("SCORE",3))>14 S RORDATA("NPCKD",4)=$G(RORDATA("NPCKD",4))+1 Q
"RTN","RORX020A",207,0)
 S RORDATA("NPCKD",5)=$G(RORDATA("NPCKD",5))+1 Q
"RTN","RORX020A",208,0)
 Q
"RTN","RORX020A",209,0)
 ;*****************************************************************************
"RTN","RORX020A",210,0)
 ;ADD SUMMARY DATA TO THE REPORT (EXTRINSIC FUNCTION)
"RTN","RORX020A",211,0)
 ;
"RTN","RORX020A",212,0)
 ;INPUT
"RTN","RORX020A",213,0)
 ;  RORTSK   Task number and task parameters
"RTN","RORX020A",214,0)
 ;  REPORT   'Report' XML tag number
"RTN","RORX020A",215,0)
 ;  RORDATA  Array with summary data:
"RTN","RORX020A",216,0)
 ;           RORDATA("NP",1) - total count of patients in 1st range
"RTN","RORX020A",217,0)
 ;           RORDATA("NP",2) - total count of patients in 2nd range
"RTN","RORX020A",218,0)
 ;           RORDATA("NP",3) - total count of patients in 3rd range
"RTN","RORX020A",219,0)
 ;           RORDATA("NP",4) - total count of patients in 4th range
"RTN","RORX020A",220,0)
 ;           RORDATA("NP",5) - total count of patients in 5th range
"RTN","RORX020A",221,0)
 ;
"RTN","RORX020A",222,0)
 ;OUTPUT
"RTN","RORX020A",223,0)
 ;  STAG     XML 'summary' tag number or error code
"RTN","RORX020A",224,0)
 ;*****************************************************************************
"RTN","RORX020A",225,0)
SUMMARY(RORTSK,REPORT,RORDATA) ; Add the summary values to the report
"RTN","RORX020A",226,0)
 N SUMMARY,I,STAG,RORTAG,RORNAME,RORRANGE
"RTN","RORX020A",227,0)
 S SUMMARY=$$ADDVAL^RORTSK11(RORTSK,"SUMMARY",,REPORT)
"RTN","RORX020A",228,0)
 Q:SUMMARY<0 SUMMARY
"RTN","RORX020A",229,0)
 ;add data for the summary entries
"RTN","RORX020A",230,0)
 F I=1:1:RORDATA("RCNT")  D  Q:STAG<0
"RTN","RORX020A",231,0)
 . S STAG=$$ADDVAL^RORTSK11(RORTSK,"DATA",,SUMMARY)
"RTN","RORX020A",232,0)
 . Q:STAG<0
"RTN","RORX020A",233,0)
 . ;get each value
"RTN","RORX020A",234,0)
 . S RORTAG="S"_I S RORNAME=$P($T(@RORTAG),";;",2)
"RTN","RORX020A",235,0)
 . S RORRANGE=$P($T(@RORTAG),";;",3)
"RTN","RORX020A",236,0)
 . D ADDVAL^RORTSK11(RORTSK,"DESC",$G(RORNAME),STAG) ;severity
"RTN","RORX020A",237,0)
 . D ADDVAL^RORTSK11(RORTSK,"VALUES",$G(RORRANGE),STAG) ;range
"RTN","RORX020A",238,0)
 . D ADDVAL^RORTSK11(RORTSK,"NPMDRD",$G(RORDATA("NPMDRD",I)),STAG) ;count
"RTN","RORX020A",239,0)
 . D ADDVAL^RORTSK11(RORTSK,"NPCKD",$G(RORDATA("NPCKD",I)),STAG) ;count
"RTN","RORX020A",240,0)
 Q STAG
"RTN","RORX020A",241,0)
 ;************************************************************************
"RTN","RORX020A",242,0)
 ;eGFR by MDRD Categories and Values for the summary table.
"RTN","RORX020A",243,0)
 ;NOTE: the number of entries below must match the value of RORDATA("RCNT")
"RTN","RORX020A",244,0)
 ;************************************************************************
"RTN","RORX020A",245,0)
S1 ;;Normal or CKD1;;>=90 mL/min/1.73m
"RTN","RORX020A",246,0)
S2 ;;CKD2 (Mild);;60-89 mL/min/1.73m
"RTN","RORX020A",247,0)
S3 ;;CKD3 (Moderate);;30-59 mL/min/1.73m
"RTN","RORX020A",248,0)
S4 ;;CKD4 (Severe);;15-29 mL/min/1.73m
"RTN","RORX020A",249,0)
S5 ;;CKD5 (Kidney failure);;<15 mL/min/1.73m
"RTN","RORX020B")
0^10^B63829872^n/a
"RTN","RORX020B",1,0)
RORX020B ;BPOIFO/ACS - RENAL FUNCTION BY RANGE RPT (cont) ; 9/1/11 2:13pm
"RTN","RORX020B",2,0)
 ;;1.5;CLINICAL CASE REGISTRIES;**15**;Feb 17, 2006;Build 27
"RTN","RORX020B",3,0)
 ;
"RTN","RORX020B",4,0)
 ; This routine uses the following IAs:
"RTN","RORX020B",5,0)
 ;
"RTN","RORX020B",6,0)
 ; #4290         ^PXRMINDX(120.5 (controlled)
"RTN","RORX020B",7,0)
 ; #3647         $$EN^GMVPXRM (controlled)
"RTN","RORX020B",8,0)
 ; #10061        DEM^VADPT (supported)
"RTN","RORX020B",9,0)
 ; #3556         GCPR^LA7QRY (supported)
"RTN","RORX020B",10,0)
 ;
"RTN","RORX020B",11,0)
 ;************************************************************************
"RTN","RORX020B",12,0)
 ;CALCULATE THE RENAL FUNCTION VALUE(S)
"RTN","RORX020B",13,0)
 ;Note1: If no range has been passed in and a patient has a Creatinine 
"RTN","RORX020B",14,0)
 ;       result > 12, the patient will be listed on the report with an 
"RTN","RORX020B",15,0)
 ;       asterisk (*) next to the test result value, but no scores will be 
"RTN","RORX020B",16,0)
 ;       calculated.
"RTN","RORX020B",17,0)
 ;Note2: If no range has been passed in and a patient has an invalid Height
"RTN","RORX020B",18,0)
 ;       result, the patient will be listed on the report with an asterisk (*)
"RTN","RORX020B",19,0)
 ;       next to the test result value, but no CrCl score will be calculated. 
"RTN","RORX020B",20,0)
 ;Note3: If a range has been passed in and the patient has a Creatinine result 
"RTN","RORX020B",21,0)
 ;       >12, the patient will NOT be listed on the report.
"RTN","RORX020B",22,0)
 ;
"RTN","RORX020B",23,0)
 ;INPUT
"RTN","RORX020B",24,0)
 ;  DFN      Patient DFN in PATIENT file (#2)
"RTN","RORX020B",25,0)
 ;  RORDATA  Array with ROR data
"RTN","RORX020B",26,0)
 ;           RORDATA("BAM") - 'black' or 'african american' race pointers
"RTN","RORX020B",27,0)
 ;  RORPTIEN Patient IEN in the ROR registry
"RTN","RORX020B",28,0)
 ;  RORLC    sub-file and LOINC codes to search for
"RTN","RORX020B",29,0)
 ;  
"RTN","RORX020B",30,0)
 ;OUTPUT
"RTN","RORX020B",31,0)
 ;  RORDATA  Array with ROR data
"RTN","RORX020B",32,0)
 ;  1        Patient will be listed on report
"RTN","RORX020B",33,0)
 ; -1        Patient will not be listed on report
"RTN","RORX020B",34,0)
 ;************************************************************************
"RTN","RORX020B",35,0)
CALCRF(DFN,RORDATA,RORPTIEN,RORLC) ;
"RTN","RORX020B",36,0)
 N RORID,RORST,ROREND,RORLAB,RORMSG,RC
"RTN","RORX020B",37,0)
 N RORXXX,RORRACES
"RTN","RORX020B",38,0)
 S RORDATA("CALC")=1 ;default - the score for this patient should be calculated
"RTN","RORX020B",39,0)
 K RORDATA("SCORE",1),RORDATA("SCORE",2),RORDATA("SCORE",3) ;test scores
"RTN","RORX020B",40,0)
 K RORDATA("CVAL"),RORDATA("CINV"),RORDATA("CR"),RORDATA("CRDATE") ;Cr data
"RTN","RORX020B",41,0)
 K RORDATA("HGT"),RORDATA("HDATE") ;height data
"RTN","RORX020B",42,0)
 ;get patient ICN or SSN
"RTN","RORX020B",43,0)
 S RORID=$$PTID^RORUTL02(DFN)
"RTN","RORX020B",44,0)
 Q:'$G(RORID) -1
"RTN","RORX020B",45,0)
 ;---SET UP LAB API INPUT/OUTPUT PARMS---
"RTN","RORX020B",46,0)
 S RORST="2000101^CD" ;start date 1/1/1900
"RTN","RORX020B",47,0)
 S ROREND=$G(RORDATA("DATE"))\1 ;end date
"RTN","RORX020B",48,0)
 ;add 1 to the end date so the Lab API INCLUDES tests on that date
"RTN","RORX020B",49,0)
 N X1,X2,X3 S X1=ROREND,X2=1 D C^%DTC S ROREND=X K X,X1,X2
"RTN","RORX020B",50,0)
 S ROREND=ROREND_"^CD"
"RTN","RORX020B",51,0)
 S RORLAB=$NA(^TMP("ROROUT",$J)) ;lab API output global
"RTN","RORX020B",52,0)
 K RORMSG,@RORLAB ;initialize prior to call
"RTN","RORX020B",53,0)
 ;---CALL LAB API USING COLLECTION DATE AND LOINC CODE LIST---
"RTN","RORX020B",54,0)
 S RC=$$GCPR^LA7QRY(RORID,RORST,ROREND,.RORLC,"*",.RORMSG,RORLAB)
"RTN","RORX020B",55,0)
 I $G(RC)="",$D(RORMSG)>1  D  ;quit if error returned
"RTN","RORX020B",56,0)
 . N ERR,I,LST,TMP
"RTN","RORX020B",57,0)
 . S (ERR,LST)=""
"RTN","RORX020B",58,0)
 . F I=1:1  S ERR=$O(RORMSG(ERR))  Q:ERR=""  D
"RTN","RORX020B",59,0)
 . . S LST=LST_","_ERR,TMP=RORMSG(ERR)
"RTN","RORX020B",60,0)
 . . K RORMSG(ERR)  S RORMSG(I)=TMP
"RTN","RORX020B",61,0)
 . S LST=$P(LST,",",2,999)  Q:(LST=3)!(LST=99)
"RTN","RORX020B",62,0)
 . S RC=$$ERROR^RORERR(-27,,.RORMSG,RORPTIEN)
"RTN","RORX020B",63,0)
 I RC<0 Q -1
"RTN","RORX020B",64,0)
 ;Note: the Lab API returns data in the form of HL7 segments
"RTN","RORX020B",65,0)
 N TMP,RORSPEC,RORVAL,RORNODE,RORSEG,SEGTYPE,RORLOINC,RORDONE,RORDATE,FS
"RTN","RORX020B",66,0)
 S FS="|" ;default HL7 field separator for lab data
"RTN","RORX020B",67,0)
 S RORDONE=0 ;flag to indicate if 'valid' data has been found
"RTN","RORX020B",68,0)
 S RORNODE=0 F  S RORNODE=$O(^TMP("ROROUT",$J,RORNODE)) Q:((RORNODE="")!(RORDONE))  D
"RTN","RORX020B",69,0)
 . S RORSEG=$G(^TMP("ROROUT",$J,RORNODE)) ;get entire HL7 segment
"RTN","RORX020B",70,0)
 . S SEGTYPE=$P(RORSEG,FS,1) ;get segment type (PID,OBR,OBX,etc.)
"RTN","RORX020B",71,0)
 . Q:SEGTYPE'="OBX"  ;we want OBX segments only
"RTN","RORX020B",72,0)
 . S RORSPEC=$P($P(RORSEG,FS,4),U,2) ;specimen type string (urine, serum, etc.)
"RTN","RORX020B",73,0)
 . S RORSPEC=":"_RORSPEC_":" ;append ":" as prefix and suffix
"RTN","RORX020B",74,0)
 . I ((RORSPEC[":UA:")!(RORSPEC[":UR:")) Q  ;quit if specimen type is urine
"RTN","RORX020B",75,0)
 . S RORLOINC=$P($P(RORSEG,FS,4),"^",1) ;get LOINC code
"RTN","RORX020B",76,0)
 . Q:(RORDATA("LOINC")'[(";"_RORLOINC_";"))  ;LOINC must match Creatinine
"RTN","RORX020B",77,0)
 . ;test result found
"RTN","RORX020B",78,0)
 . S RORVAL=$P(RORSEG,FS,6) ;Creatinine test result value
"RTN","RORX020B",79,0)
 . Q:($G(RORVAL)'>0)  ;quit if no value
"RTN","RORX020B",80,0)
 . S RORDATE=$$HL7TFM^XLFDT($P(RORSEG,FS,15)) ;get date collected
"RTN","RORX020B",81,0)
 . S RORDATE=RORDATE\1
"RTN","RORX020B",82,0)
 . ;store 'valid' (12 or less) value if no 'valid' value has been stored yet
"RTN","RORX020B",83,0)
 . I RORVAL'>12,$O(RORDATA("CVAL",0))="" S RORDATA("CVAL",RORDATE)=RORVAL,RORDONE=1 Q
"RTN","RORX020B",84,0)
 . ;store 'invalid' (>12) value if no other value has been stored
"RTN","RORX020B",85,0)
 . I RORVAL>12,$O(RORDATA("CVAL",0))="",$O(RORDATA("CINV",0))="" D
"RTN","RORX020B",86,0)
 .. S RORDATA("CINV",RORDATE)=$G(RORVAL)_"*" ;mark as 'invalid' value
"RTN","RORX020B",87,0)
 ;
"RTN","RORX020B",88,0)
 ;quit if patient had no Creatinine results (valid or invalid)
"RTN","RORX020B",89,0)
 Q:(($D(RORDATA("CVAL"))'>1)&($D(RORDATA("CINV"))'>1)) -1
"RTN","RORX020B",90,0)
 ;
"RTN","RORX020B",91,0)
 ;--- set Creatinine result and date into data array
"RTN","RORX020B",92,0)
 N DATE
"RTN","RORX020B",93,0)
 S DATE=$O(RORDATA("CVAL",0)) ;'valid' Cr date
"RTN","RORX020B",94,0)
 I $G(DATE)="" D  ;if no 'valid' Cr value, get 'invalid' value
"RTN","RORX020B",95,0)
 . S DATE=$O(RORDATA("CINV",0))
"RTN","RORX020B",96,0)
 . S RORDATA("CVAL",DATE)=$G(RORDATA("CINV",DATE))
"RTN","RORX020B",97,0)
 . S RORDATA("CALC")=0 ;no score calculations can be done on 'invalid' data
"RTN","RORX020B",98,0)
 S RORDATA("CR")=$G(RORDATA("CVAL",DATE))
"RTN","RORX020B",99,0)
 ;S RORDATA("CRDATE")=$P((9999999-$G(DATE)),".",1)
"RTN","RORX020B",100,0)
 S RORDATA("CRDATE")=DATE\1
"RTN","RORX020B",101,0)
 ;
"RTN","RORX020B",102,0)
 ;--- get height date and height IEN
"RTN","RORX020B",103,0)
 N RORHTDT,RORHTIEN,RORARY
"RTN","RORX020B",104,0)
 S RORDATE=RORDATA("DATE")
"RTN","RORX020B",105,0)
 S RORHTDT=$O(^PXRMINDX(120.5,"PI",DFN,RORDATA("HGTP"),RORDATE),-1) ;height date
"RTN","RORX020B",106,0)
 Q:$G(RORHTDT)="" -1
"RTN","RORX020B",107,0)
 S RORHTIEN=$O(^PXRMINDX(120.5,"PI",DFN,RORDATA("HGTP"),RORHTDT,0)) ;height IEN
"RTN","RORX020B",108,0)
 Q:$G(RORHTIEN)="" -1
"RTN","RORX020B",109,0)
 ;--- call API to get get height measurement
"RTN","RORX020B",110,0)
 K RORARY D EN^GMVPXRM(.RORARY,RORHTIEN,"I")
"RTN","RORX020B",111,0)
 S RORDATA("HGT")=$G(RORARY(7)),RORDATA("HDATE")=$P(RORHTDT,".",1)
"RTN","RORX020B",112,0)
 I ($G(RORDATA("HGT"))'>0) Q -1  ;quit if height not > 0
"RTN","RORX020B",113,0)
 ;strip out characters "IN", ",E"
"RTN","RORX020B",114,0)
 I ((RORDATA("HGT")["IN")!(RORDATA("HGT")[",E")) S RORDATA("HGT")=+RORDATA("HGT")
"RTN","RORX020B",115,0)
 ;mark as 'invalid' if height contains "CM", or "'" or double quote
"RTN","RORX020B",116,0)
 I ((RORDATA("HGT")["CM")!(RORDATA("HGT")["'")!(RORDATA("HGT")["""")) D
"RTN","RORX020B",117,0)
 . I RORDATA("IDLST")[1 S RORDATA("CALC")=0 ;no CrCl calculations can be done on 'invalid' data
"RTN","RORX020B",118,0)
 . S RORDATA("HGT")=RORDATA("HGT")_"*" ;mark as 'invalid' value
"RTN","RORX020B",119,0)
 ;set CALC flag to 0 and add "*" if invalid height: not between 36 and 96 inches
"RTN","RORX020B",120,0)
 I ((RORDATA("HGT")'["*")&((RORDATA("HGT")<36)!(RORDATA("HGT")>96))) D
"RTN","RORX020B",121,0)
 . I RORDATA("IDLST")[1 S RORDATA("CALC")=0 ;no CrCl calculations can be done on 'invalid' data
"RTN","RORX020B",122,0)
 . S RORDATA("HGT")=RORDATA("HGT")_"*" ;mark as 'invalid' value
"RTN","RORX020B",123,0)
 ;
"RTN","RORX020B",124,0)
 ;include patient on reports but don't calculate score if no high/low
"RTN","RORX020B",125,0)
 ;range passed in and invalid CR data exists
"RTN","RORX020B",126,0)
 I RORDATA("CR")["*",RORDATA("RANGE")=0 Q 1
"RTN","RORX020B",127,0)
 ;don't include patient on report if range IS passed in and invalid Cr data
"RTN","RORX020B",128,0)
 ;exists since neither score can't be calculated
"RTN","RORX020B",129,0)
 I RORDATA("CR")["*",RORDATA("RANGE")=1 Q -1
"RTN","RORX020B",130,0)
 ;
"RTN","RORX020B",131,0)
 ;---CALCULATE RENAL TEST SCORES USING VALID CR VALUE
"RTN","RORX020B",132,0)
 ;
"RTN","RORX020B",133,0)
 ;--- get patient race, gender, age, and dob using DEM^VADPT
"RTN","RORX020B",134,0)
 N RORDEM,RORGENDER,RORRACE,RORM,RORF,RORAGE,VAROOT
"RTN","RORX020B",135,0)
 S (RORF,RORM)=0
"RTN","RORX020B",136,0)
 S VAROOT="RORDEM" D DEM^VADPT
"RTN","RORX020B",137,0)
 S RORGENDER=$P($G(RORDEM(5)),U,1) ;M or F
"RTN","RORX020B",138,0)
 Q:$G(RORGENDER)="" -1
"RTN","RORX020B",139,0)
 S:RORGENDER="F" RORF=1 S:RORGENDER="M" RORM=1
"RTN","RORX020B",140,0)
 ;--- get age
"RTN","RORX020B",141,0)
 ;if 'most recent' date, use age returned from DEM^VADPT
"RTN","RORX020B",142,0)
 ;if not 'most recent', calculate age
"RTN","RORX020B",143,0)
 I $$PARAM^RORTSK01("OPTIONS","MOST_RECENT") S RORAGE=RORDEM(4)
"RTN","RORX020B",144,0)
 E  S RORAGE=$$AGE^RORX019A(DFN,RORDATE)
"RTN","RORX020B",145,0)
 ;
"RTN","RORX020B",146,0)
 ;---  construct race array
"RTN","RORX020B",147,0)
 K RORRACES
"RTN","RORX020B",148,0)
 S RORCNT=$G(RORDEM(12)) I RORCNT>0 D
"RTN","RORX020B",149,0)
 .F RORXXX=1:1:RORCNT D
"RTN","RORX020B",150,0)
 ..S RORRACES($P($G(RORDEM(12,RORXXX)),U,1))=""
"RTN","RORX020B",151,0)
 ;
"RTN","RORX020B",152,0)
 ;--- Cockcroft-Gault CrCl ---
"RTN","RORX020B",153,0)
 ;Calculation: (140-age) x ideal weight in kg (*.85 if female)/(creatinine*72)
"RTN","RORX020B",154,0)
 ;Ideal weight in kg:
"RTN","RORX020B",155,0)
 ;  males   = 51.65+(1.85*(height-60))
"RTN","RORX020B",156,0)
 ;  females = 48.67+(1.65*(height-60))
"RTN","RORX020B",157,0)
 ;  
"RTN","RORX020B",158,0)
 N RORMIW,RORFIW,MULT2,TMP
"RTN","RORX020B",159,0)
 D
"RTN","RORX020B",160,0)
 . ;if male, use this calculation
"RTN","RORX020B",161,0)
 . I RORM=1 D  ;get male ideal weight in kg 
"RTN","RORX020B",162,0)
 .. S MULT2=1 ;no additional multiplier if male
"RTN","RORX020B",163,0)
 .. Q:RORDATA("HGT")["*"  ;quit if invalid height value
"RTN","RORX020B",164,0)
 .. S RORMIW=51.65+(1.85*(RORDATA("HGT")-60)) ;male ideal weight
"RTN","RORX020B",165,0)
 .. S TMP=(140-RORAGE)*RORMIW/(RORDATA("CR")*72) ;CrCl score
"RTN","RORX020B",166,0)
 . ;if female, use this calculation
"RTN","RORX020B",167,0)
 . I RORF=1 D
"RTN","RORX020B",168,0)
 .. S MULT2=.742 ;set multiplier for eGFR calculation if female
"RTN","RORX020B",169,0)
 .. Q:RORDATA("HGT")["*"  ;quit if invalid height value
"RTN","RORX020B",170,0)
 .. S RORFIW=48.67+(1.65*(RORDATA("HGT")-60)) ;female ideal weight
"RTN","RORX020B",171,0)
 .. S TMP=(140-RORAGE)*RORFIW*.85/(RORDATA("CR")*72) ;CrCl score
"RTN","RORX020B",172,0)
 . ;
"RTN","RORX020B",173,0)
 . I RORDATA("IDLST")[1 S RORDATA("SCORE",1)=$S($G(TMP)>0:$J($G(TMP),0,0),1:"") ;round CrCl score to whole number
"RTN","RORX020B",174,0)
 ;
"RTN","RORX020B",175,0)
 ;--- eGFR by MDRD ---
"RTN","RORX020B",176,0)
 ;default race multiplier set to 1 (i.e. no multiplier)
"RTN","RORX020B",177,0)
 N RORCNT,MULT1,I S MULT1=1
"RTN","RORX020B",178,0)
 D
"RTN","RORX020B",179,0)
 . ;get count of race values (could be more than 1 entry)
"RTN","RORX020B",180,0)
 . S RORCNT=$G(RORDEM(12)) I RORCNT>0 D
"RTN","RORX020B",181,0)
 .. ;check each race value for match on 'black or 'african american'
"RTN","RORX020B",182,0)
 .. F I=1:1:RORCNT D  Q:MULT1=1.212
"RTN","RORX020B",183,0)
 ... S RORRACE=$P($G(RORDEM(12,I)),U,1) ;race pointer value
"RTN","RORX020B",184,0)
 ... ;if any of the race values are black or african american, set multiplier
"RTN","RORX020B",185,0)
 ... I $G(RORDATA("BAM"))[(";"_$G(RORRACE)_";") S MULT1=1.212
"RTN","RORX020B",186,0)
 . ;--- calculate eGFR by MDRD score  Calculation:
"RTN","RORX020B",187,0)
 . ;(175 * (creatinine ^ -1.154) * (age ^ -.203) *1.212 (if black) * .742 (if female)
"RTN","RORX020B",188,0)
 . S TMP=175*($$PWR^XLFMTH(RORDATA("CR"),-1.154))*($$PWR^XLFMTH(RORAGE,-0.203))*MULT1*MULT2 ;eGFR
"RTN","RORX020B",189,0)
 . ;
"RTN","RORX020B",190,0)
 . I RORDATA("IDLST")[2 S RORDATA("SCORE",2)=$J($G(TMP),0,0) ;round eGFR score to whole number
"RTN","RORX020B",191,0)
 ;
"RTN","RORX020B",192,0)
 ;---  eGFR by CKD-EPI ---
"RTN","RORX020B",193,0)
 ;141*MIN(RORDATA("CR")/(.7 if female;.9 if male))**(-0.329 if female; -0.411 if male)*max(RORDATA("CR")/(.7 if female;.9 if male))**AGE*(1.018 if female)*(1.159 if black)
"RTN","RORX020B",194,0)
 I RORDATA("IDLST")[3 D
"RTN","RORX020B",195,0)
 .N RORFX
"RTN","RORX020B",196,0)
 .S RORFX(1)=$S(RORGENDER="F":.7,1:.9)
"RTN","RORX020B",197,0)
 .S RORFX(2)=$S(RORGENDER="F":-.329,1:-.411)
"RTN","RORX020B",198,0)
 .S RORFX(3)=$S(RORGENDER="F":1.018,1:1)
"RTN","RORX020B",199,0)
 .S RORFX(4)=$S($D(RORRACES(9)):1.159,1:1)
"RTN","RORX020B",200,0)
 .S RORFX(5)=RORDATA("CR")/RORFX(1)
"RTN","RORX020B",201,0)
 .S TMP=141*($$PWR^XLFMTH($$MIN^XLFMTH(RORFX(5),1),RORFX(2)))*($$PWR^XLFMTH($$MAX^XLFMTH(RORFX(5),1),-1.209))*($$PWR^XLFMTH(.993,RORAGE))*(RORFX(3))*(RORFX(4))
"RTN","RORX020B",202,0)
 .S RORDATA("SCORE",3)=$J($G(TMP),0,0)
"RTN","RORX020B",203,0)
 ;
"RTN","RORX020B",204,0)
 Q 1
"RTN","RORXU002")
0^4^B116207704^B111065586
"RTN","RORXU002",1,0)
RORXU002 ;HCIOFO/SG - REPORT BUILDER UTILITIES ; 6/2/11 4:24pm
"RTN","RORXU002",2,0)
 ;;1.5;CLINICAL CASE REGISTRIES;**1,10,13,15**;Feb 17, 2006;Build 27
"RTN","RORXU002",3,0)
 ;
"RTN","RORXU002",4,0)
 ; This routine uses the following IAs:
"RTN","RORXU002",5,0)
 ;
"RTN","RORXU002",6,0)
 ; #3990   $$ICDD^ICDCODE (supported)
"RTN","RORXU002",7,0)
 ; #2050   BLD^DIALOG (supported)
"RTN","RORXU002",8,0)
 ; #2056   GETS^DIQ (supported)
"RTN","RORXU002",9,0)
 ; #2056   $$GET1^DIQ (supported)
"RTN","RORXU002",10,0)
 ; #10103  $$NOW^XLFDT  (supported)
"RTN","RORXU002",11,0)
 ; #10104  $$TRIM^XLFSTR (supported)
"RTN","RORXU002",12,0)
 ; #417    Read access to .01 field of file #40.8 (controlled)
"RTN","RORXU002",13,0)
 ; #10040  Read access to file #44 (supported)
"RTN","RORXU002",14,0)
 ;
"RTN","RORXU002",15,0)
 ;******************************************************************************
"RTN","RORXU002",16,0)
 ;******************************************************************************
"RTN","RORXU002",17,0)
 ;                 --- ROUTINE MODIFICATION LOG ---
"RTN","RORXU002",18,0)
 ;        
"RTN","RORXU002",19,0)
 ;PKG/PATCH    DATE        DEVELOPER    MODIFICATION
"RTN","RORXU002",20,0)
 ;-----------  ----------  -----------  ----------------------------------------
"RTN","RORXU002",21,0)
 ;ROR*1.5*10   APR  2010   A SAUNDERS   Modified Lab Tests Ranges section in
"RTN","RORXU002",22,0)
 ;                                      PARAMS tag to include the 3 new reports.
"RTN","RORXU002",23,0)
 ;ROR*1.5*13   DEC  2010   A SAUNDERS   Added Division and Clinic sections in
"RTN","RORXU002",24,0)
 ;                                      PARAMS tag (pulled from RORXU006).
"RTN","RORXU002",25,0)
 ;ROR*1.5*15   JUN  2011   C RAY        Added HIV_DX 
"RTN","RORXU002",26,0)
 ;
"RTN","RORXU002",27,0)
 ;******************************************************************************
"RTN","RORXU002",28,0)
 ;******************************************************************************
"RTN","RORXU002",29,0)
 Q
"RTN","RORXU002",30,0)
 ;
"RTN","RORXU002",31,0)
 ;***** SCANS THE TABLE DEFINITION (RORSRC) FOR COLUMN NAMES
"RTN","RORXU002",32,0)
 ;
"RTN","RORXU002",33,0)
 ; .TERM         Reference to a local variable where
"RTN","RORXU002",34,0)
 ;               is terminator is returned
"RTN","RORXU002",35,0)
 ;
"RTN","RORXU002",36,0)
 ; Return Values:
"RTN","RORXU002",37,0)
 ;       ""  End of definition
"RTN","RORXU002",38,0)
 ;      ...  Name of the column
"RTN","RORXU002",39,0)
 ;
"RTN","RORXU002",40,0)
COLSCAN(TERM) ;
"RTN","RORXU002",41,0)
 N CH,I,TOKEN
"RTN","RORXU002",42,0)
 F I=1:1  S TERM=$E(RORSRC,I)  Q:"(,)"[TERM
"RTN","RORXU002",43,0)
 S TOKEN=$E(RORSRC,1,I-1)
"RTN","RORXU002",44,0)
 F I=I+1:1  S CH=$E(RORSRC,I)  Q:(CH="")!("(,)"'[CH)
"RTN","RORXU002",45,0)
 S $E(RORSRC,1,I-1)=""
"RTN","RORXU002",46,0)
 Q TOKEN
"RTN","RORXU002",47,0)
 ;
"RTN","RORXU002",48,0)
 ;***** CHECKS THE FILEMAN DATE/TIME VALUE
"RTN","RORXU002",49,0)
DATE(DT) ;
"RTN","RORXU002",50,0)
 Q $S(DT>0:+DT,1:"")
"RTN","RORXU002",51,0)
 ;
"RTN","RORXU002",52,0)
 ;***** OUTPUTS THE BASIC HEADER TO THE REPORT
"RTN","RORXU002",53,0)
 ;
"RTN","RORXU002",54,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORXU002",55,0)
 ;
"RTN","RORXU002",56,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORXU002",57,0)
 ;
"RTN","RORXU002",58,0)
 ; Return Values:
"RTN","RORXU002",59,0)
 ;       <0  Error code
"RTN","RORXU002",60,0)
 ;       >0  IEN of the HEADER element
"RTN","RORXU002",61,0)
 ;
"RTN","RORXU002",62,0)
HEADER(RORTSK,PARTAG) ;
"RTN","RORXU002",63,0)
 N HEADER,IENS,REGIEN,RORBUF,RORMSG,TMP,DIERR
"RTN","RORXU002",64,0)
 S HEADER=$$ADDVAL^RORTSK11(RORTSK,"HEADER",,PARTAG)
"RTN","RORXU002",65,0)
 Q:HEADER<0 HEADER
"RTN","RORXU002",66,0)
 D ADDVAL^RORTSK11(RORTSK,"DATE",$$DATE($$NOW^XLFDT),HEADER)
"RTN","RORXU002",67,0)
 D ADDVAL^RORTSK11(RORTSK,"TASK_NUMBER",RORTSK,HEADER)
"RTN","RORXU002",68,0)
 S REGIEN=+$$PARAM^RORTSK01("REGIEN")
"RTN","RORXU002",69,0)
 ;---
"RTN","RORXU002",70,0)
 S IENS=REGIEN_","
"RTN","RORXU002",71,0)
 D GETS^DIQ(798.1,IENS,"1;2","I","RORBUF","RORMSG")
"RTN","RORXU002",72,0)
 Q:$G(DIERR) $$DBS^RORERR("RORMSG",-9,,,798.1,IENS)
"RTN","RORXU002",73,0)
 S TMP=$G(RORBUF(798.1,IENS,1,"I"))
"RTN","RORXU002",74,0)
 D ADDVAL^RORTSK11(RORTSK,"UPDATED_UNTIL",$$DATE(TMP),HEADER)
"RTN","RORXU002",75,0)
 S TMP=$G(RORBUF(798.1,IENS,2,"I"))
"RTN","RORXU002",76,0)
 D ADDVAL^RORTSK11(RORTSK,"EXTRACTED_UNTIL",$$DATE(TMP),HEADER)
"RTN","RORXU002",77,0)
 Q HEADER
"RTN","RORXU002",78,0)
 ;
"RTN","RORXU002",79,0)
 ;***** PARSES THE COMMA-SEPARATED LIST
"RTN","RORXU002",80,0)
 ;
"RTN","RORXU002",81,0)
 ; .LIST         Reference to a local variable that contains a list.
"RTN","RORXU002",82,0)
 ;               Items of the list are returned as the subscripts of
"RTN","RORXU002",83,0)
 ;               this variable.
"RTN","RORXU002",84,0)
 ;
"RTN","RORXU002",85,0)
LIST(LIST) ;
"RTN","RORXU002",86,0)
 N I,TMP,VAL
"RTN","RORXU002",87,0)
 F I=1:1  S VAL=$P(LIST,",",I)  Q:VAL=""  D
"RTN","RORXU002",88,0)
 . S TMP=$$TRIM^XLFSTR(VAL)
"RTN","RORXU002",89,0)
 . S:TMP'="" LIST(TMP)=""
"RTN","RORXU002",90,0)
 Q
"RTN","RORXU002",91,0)
 ;
"RTN","RORXU002",92,0)
 ;***** COMPILES A TEXT DESCRIPTION FOR THE REPORT OPTIONS
"RTN","RORXU002",93,0)
 ;
"RTN","RORXU002",94,0)
 ; .OPTIONS      Reference to a local variable containing
"RTN","RORXU002",95,0)
 ;               the options as subscripts
"RTN","RORXU002",96,0)
 ;
"RTN","RORXU002",97,0)
 ; [DLGNUM]      Number of the dialog that contains the template
"RTN","RORXU002",98,0)
 ;               (7980000.018, by default).
"RTN","RORXU002",99,0)
 ;
"RTN","RORXU002",100,0)
 ; Return Values:
"RTN","RORXU002",101,0)
 ;      ...  Text description of the options
"RTN","RORXU002",102,0)
 ;
"RTN","RORXU002",103,0)
OPTXT(OPTIONS,DLGNUM) ;
"RTN","RORXU002",104,0)
 N I,J,NS,RORBUF,TEXT,TMP
"RTN","RORXU002",105,0)
 S:$G(DLGNUM)'>0 DLGNUM=7980000.018
"RTN","RORXU002",106,0)
 D BLD^DIALOG(DLGNUM,,,"RORBUF")
"RTN","RORXU002",107,0)
 S TEXT="",I=0
"RTN","RORXU002",108,0)
 F  S I=$O(RORBUF(I))  Q:I=""  D:$E(RORBUF(I),1)'=" "
"RTN","RORXU002",109,0)
 . S NS=0
"RTN","RORXU002",110,0)
 . F J=1:1  S TMP=$TR($P(RORBUF(I),",",J)," ")  Q:TMP=""  D
"RTN","RORXU002",111,0)
 . . S:$D(OPTIONS(TMP)) NS=2**(J-1)+NS
"RTN","RORXU002",112,0)
 . Q:'NS
"RTN","RORXU002",113,0)
 . S TMP=$$TRIM^XLFSTR($G(RORBUF(I+NS)))
"RTN","RORXU002",114,0)
 . S:TMP'="" TEXT=TEXT_", "_TMP
"RTN","RORXU002",115,0)
 Q $P(TEXT,", ",2,999)
"RTN","RORXU002",116,0)
 ;
"RTN","RORXU002",117,0)
 ;***** OUTPUTS THE PARAMETERS TO THE REPORT
"RTN","RORXU002",118,0)
 ;
"RTN","RORXU002",119,0)
 ; .RORTSK       Task number and task parameters
"RTN","RORXU002",120,0)
 ;
"RTN","RORXU002",121,0)
 ; PARTAG        Reference (IEN) to the parent tag
"RTN","RORXU002",122,0)
 ;
"RTN","RORXU002",123,0)
 ; .STDT         Start and end dates of the report
"RTN","RORXU002",124,0)
 ; .ENDT         are returned via these parameters
"RTN","RORXU002",125,0)
 ;
"RTN","RORXU002",126,0)
 ; [.FLAGS]      Flags for the $$SKIP^RORXU005 are returned via this
"RTN","RORXU002",127,0)
 ;               parameter. The "D" (skip deceased patients) and "G"
"RTN","RORXU002",128,0)
 ;               (skip pending patients) flags are always added.
"RTN","RORXU002",129,0)
 ;
"RTN","RORXU002",130,0)
 ; Return Values:
"RTN","RORXU002",131,0)
 ;       <0  Error code
"RTN","RORXU002",132,0)
 ;       >0  IEN of the PARAMETERS element
"RTN","RORXU002",133,0)
 ;
"RTN","RORXU002",134,0)
PARAMS(RORTSK,PARTAG,STDT,ENDT,FLAGS) ;
"RTN","RORXU002",135,0)
 N BUF,ELEMENT,I,LTAG,MODE,NAME,PARAMS,RC,REGIEN,RORMSG,TMP,IEN,DIERR
"RTN","RORXU002",136,0)
 S PARAMS=$$ADDVAL^RORTSK11(RORTSK,"PARAMETERS",,PARTAG)
"RTN","RORXU002",137,0)
 S RC=0,(ENDT,STDT)="",FLAGS=""
"RTN","RORXU002",138,0)
 ;
"RTN","RORXU002",139,0)
 ;=== Registry name
"RTN","RORXU002",140,0)
 S REGIEN=+$$PARAM^RORTSK01("REGIEN")
"RTN","RORXU002",141,0)
 I REGIEN>0  D  Q:RC<0 RC
"RTN","RORXU002",142,0)
 . S TMP=$P($$REGNAME^RORUTL01(REGIEN),U)
"RTN","RORXU002",143,0)
 . I TMP=""  S RC=-1  Q
"RTN","RORXU002",144,0)
 . S RC=$$ADDVAL^RORTSK11(RORTSK,"REGNAME",TMP,PARAMS)
"RTN","RORXU002",145,0)
 ;
"RTN","RORXU002",146,0)
 ;=== Alternate date ranges
"RTN","RORXU002",147,0)
 F I=2:1:3  D  Q:RC<0
"RTN","RORXU002",148,0)
 . S STDT=$$PARAM^RORTSK01("DATE_RANGE_"_I,"START")\1  Q:STDT'>0
"RTN","RORXU002",149,0)
 . S ENDT=$$PARAM^RORTSK01("DATE_RANGE_"_I,"END")\1    Q:ENDT'>0
"RTN","RORXU002",150,0)
 . S ELEMENT=$$ADDVAL^RORTSK11(RORTSK,"DATE_RANGE_"_I,,PARAMS)
"RTN","RORXU002",151,0)
 . I ELEMENT<0  S RC=+ELEMENT  Q
"RTN","RORXU002",152,0)
 . S RC=$$ADDATTR^RORTSK11(RORTSK,ELEMENT,"START",STDT)  Q:RC<0
"RTN","RORXU002",153,0)
 . S RC=$$ADDATTR^RORTSK11(RORTSK,ELEMENT,"END",ENDT)
"RTN","RORXU002",154,0)
 Q:RC<0 RC
"RTN","RORXU002",155,0)
 ;
"RTN","RORXU002",156,0)
 ;=== Main date range
"RTN","RORXU002",157,0)
 S STDT=$$PARAM^RORTSK01("DATE_RANGE","START")\1
"RTN","RORXU002",158,0)
 S ENDT=$$PARAM^RORTSK01("DATE_RANGE","END")\1
"RTN","RORXU002",159,0)
 I STDT>0,ENDT>0  D  Q:RC<0 RC
"RTN","RORXU002",160,0)
 . S ELEMENT=$$ADDVAL^RORTSK11(RORTSK,"DATE_RANGE",,PARAMS)
"RTN","RORXU002",161,0)
 . I ELEMENT<0  S RC=+ELEMENT  Q
"RTN","RORXU002",162,0)
 . S RC=$$ADDATTR^RORTSK11(RORTSK,ELEMENT,"START",STDT)  Q:RC<0
"RTN","RORXU002",163,0)
 . S RC=$$ADDATTR^RORTSK11(RORTSK,ELEMENT,"END",ENDT)
"RTN","RORXU002",164,0)
 E  S (ENDT,STDT)=""
"RTN","RORXU002",165,0)
 ;
"RTN","RORXU002",166,0)
 ;=== Task comment
"RTN","RORXU002",167,0)
 S TMP=$$PARAM^RORTSK01("TASK_COMMENT")
"RTN","RORXU002",168,0)
 D:TMP'="" ADDVAL^RORTSK11(RORTSK,"TASK_COMMENT",TMP,PARAMS)
"RTN","RORXU002",169,0)
 ;
"RTN","RORXU002",170,0)
 ;=== Clinic Selection - patch 13
"RTN","RORXU002",171,0)
 D:$D(RORTSK("PARAMS","CLINICS","C"))
"RTN","RORXU002",172,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"CLINICS",,PARAMS)  Q:LTAG'>0
"RTN","RORXU002",173,0)
 . S IEN=0
"RTN","RORXU002",174,0)
 . F  S IEN=$O(RORTSK("PARAMS","CLINICS","C",IEN))  Q:IEN'>0  D
"RTN","RORXU002",175,0)
 . . S TMP=$$GET1^DIQ(44,IEN_",",.01,,,"RORMSG")
"RTN","RORXU002",176,0)
 . . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,44,IEN_",")
"RTN","RORXU002",177,0)
 . . Q:TMP=""
"RTN","RORXU002",178,0)
 . . D ADDVAL^RORTSK11(RORTSK,"CLINIC",TMP,LTAG,,IEN)
"RTN","RORXU002",179,0)
 D:$$PARAM^RORTSK01("CLINICS","ALL")
"RTN","RORXU002",180,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"CLINICS","ALL",PARAMS)
"RTN","RORXU002",181,0)
 ;
"RTN","RORXU002",182,0)
 ;=== Division Selection - patch 13
"RTN","RORXU002",183,0)
 D:$D(RORTSK("PARAMS","DIVISIONS","C"))
"RTN","RORXU002",184,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"DIVISIONS",,PARAMS)  Q:LTAG'>0
"RTN","RORXU002",185,0)
 . S IEN=0
"RTN","RORXU002",186,0)
 . F  S IEN=$O(RORTSK("PARAMS","DIVISIONS","C",IEN))  Q:IEN'>0  D
"RTN","RORXU002",187,0)
 . . S TMP=$$GET1^DIQ(40.8,IEN_",",.01,,,"RORMSG")
"RTN","RORXU002",188,0)
 . . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,40.8,IEN_",")
"RTN","RORXU002",189,0)
 . . Q:TMP=""
"RTN","RORXU002",190,0)
 . . D ADDVAL^RORTSK11(RORTSK,"DIVISION",TMP,LTAG,,IEN)
"RTN","RORXU002",191,0)
 D:$$PARAM^RORTSK01("DIVISIONS","ALL")
"RTN","RORXU002",192,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"DIVISIONS","ALL",PARAMS)
"RTN","RORXU002",193,0)
 ;
"RTN","RORXU002",194,0)
 ;
"RTN","RORXU002",195,0)
 ;=== Patient selection and Options
"RTN","RORXU002",196,0)
 F NAME="PATIENTS","OPTIONS"  D  Q:RC<0
"RTN","RORXU002",197,0)
 . K BUF  M BUF=RORTSK("PARAMS",NAME,"A")  Q:$D(BUF)<10
"RTN","RORXU002",198,0)
 . ;--- Generate the XML tags
"RTN","RORXU002",199,0)
 . S ELEMENT=$$ADDVAL^RORTSK11(RORTSK,NAME,$$OPTXT(.BUF),PARAMS)
"RTN","RORXU002",200,0)
 . I ELEMENT'>0  S RC=ELEMENT  Q
"RTN","RORXU002",201,0)
 . S TMP=""
"RTN","RORXU002",202,0)
 . F  S TMP=$O(BUF(TMP))  Q:TMP=""  D  Q:RC<0
"RTN","RORXU002",203,0)
 . . S RC=$$ADDATTR^RORTSK11(RORTSK,ELEMENT,TMP,"1")
"RTN","RORXU002",204,0)
 . ;--- Compile the flags
"RTN","RORXU002",205,0)
 . D:NAME="PATIENTS"
"RTN","RORXU002",206,0)
 . . S:'$D(BUF("DE_BEFORE")) FLAGS=FLAGS_"P"
"RTN","RORXU002",207,0)
 . . S:'$D(BUF("DE_DURING")) FLAGS=FLAGS_"N"
"RTN","RORXU002",208,0)
 . . S:'$D(BUF("DE_AFTER")) FLAGS=FLAGS_"F"
"RTN","RORXU002",209,0)
 Q:RC<0 RC
"RTN","RORXU002",210,0)
 ;
"RTN","RORXU002",211,0)
 ;=== Other Registries
"RTN","RORXU002",212,0)
 I $D(RORTSK("PARAMS","OTHER_REGISTRIES","C"))>1  D  Q:RC<0 RC
"RTN","RORXU002",213,0)
 . N NODE,REGIEN
"RTN","RORXU002",214,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"OTHER_REGISTRIES",,PARAMS)
"RTN","RORXU002",215,0)
 . I LTAG<0  S RC=+LTAG  Q
"RTN","RORXU002",216,0)
 . S NODE=$NA(RORTSK("PARAMS","OTHER_REGISTRIES","C"))
"RTN","RORXU002",217,0)
 . S REGIEN=0
"RTN","RORXU002",218,0)
 . F  S REGIEN=$O(@NODE@(REGIEN))  Q:REGIEN'>0  D  Q:RC<0
"RTN","RORXU002",219,0)
 . . S TMP=$P($$REGNAME^RORUTL01(REGIEN),U,2)
"RTN","RORXU002",220,0)
 . . S MODE=+$G(@NODE@(REGIEN))
"RTN","RORXU002",221,0)
 . . I 'MODE!(TMP="")  K @NODE@(REGIEN)  Q
"RTN","RORXU002",222,0)
 . . S TMP=TMP_" ("_$S(MODE<0:"Exclude",1:"Include")_")"
"RTN","RORXU002",223,0)
 . . S RC=$$ADDVAL^RORTSK11(RORTSK,"REGNAME",TMP,LTAG)
"RTN","RORXU002",224,0)
 . S FLAGS=FLAGS_"R"
"RTN","RORXU002",225,0)
 ;
"RTN","RORXU002",226,0)
 ;=== Local Fields
"RTN","RORXU002",227,0)
 I $D(RORTSK("PARAMS","LOCAL_FIELDS","C"))>1  D  Q:RC<0 RC
"RTN","RORXU002",228,0)
 . N NODE,IEN,IENS
"RTN","RORXU002",229,0)
 . S LTAG=$$ADDVAL^RORTSK11(RORTSK,"LOCAL_FIELDS",,PARAMS)
"RTN","RORXU002",230,0)
 . I LTAG<0  S RC=+LTAG  Q
"RTN","RORXU002",231,0)
 . S NODE=$NA(RORTSK("PARAMS","LOCAL_FIELDS","C"))
"RTN","RORXU002",232,0)
 . S IEN=0
"RTN","RORXU002",233,0)
 . F  S IEN=$O(@NODE@(IEN))  Q:IEN'>0  D  Q:RC<0
"RTN","RORXU002",234,0)
 . . S TMP=$$GET1^DIQ(799.53,IEN_",",.01,,,"RORMSG")
"RTN","RORXU002",235,0)
 . . D:$G(DIERR) DBS^RORERR("RORMSG",-9,,,799.53,IEN_",")
"RTN","RORXU002",236,0)
 . . S MODE=+$G(@NODE@(IEN))
"RTN","RORXU002",237,0)
 . . I 'MODE!(TMP="")  K @NODE@(IEN)  Q
"RTN","RORXU002",238,0)
 . . S TMP=TMP_" ("_$S(MODE<0:"Exclude",1:"Include")_")"
"RTN","RORXU002",239,0)
 . . S RC=$$ADDVAL^RORTSK11(RORTSK,"FIELD",TMP,LTAG)
"RTN","RORXU002",240,0)
 . S FLAGS=FLAGS_"O"
"RTN","RORXU002",241,0)
 ;
"RTN","RORXU002",242,0)
 ;=== Lab test ranges
"RTN","RORXU002",243,0)
 I $D(RORTSK("PARAMS","LRGRANGES","C"))>1  D  Q:RC<0 RC
"RTN","RORXU002",244,0)
 . N TYPE S TYPE=3 ;default = 3 for 'lab by range' report
"RTN","RORXU002",245,0)
 . I $G(RORTSK("EP"))["BMIRANGE" S TYPE=5 ;change to 5 if BMI
"RTN","RORXU002",246,0)
 . I $G(RORTSK("EP"))["MLDRANGE" S TYPE=6 ;change to 6 if MELD
"RTN","RORXU002",247,0)
 . I $G(RORTSK("EP"))["RFRANGE" S TYPE=7 ;change to 7 if Renal
"RTN","RORXU002",248,0)
 . N GRC,NODE
"RTN","RORXU002",249,0)
 . S NODE=$NA(RORTSK("PARAMS","LRGRANGES","C"))
"RTN","RORXU002",250,0)
 . S GRC=0
"RTN","RORXU002",251,0)
 . F  S GRC=$O(@NODE@(GRC))  Q:GRC'>0  D  Q:RC<0
"RTN","RORXU002",252,0)
 . . S RC=$$ITEMIEN^RORUTL09(TYPE,REGIEN,GRC,.TMP)
"RTN","RORXU002",253,0)
 . . S:RC'<0 @NODE@(GRC)=TMP
"RTN","RORXU002",254,0)
 ;
"RTN","RORXU002",255,0)
 ;=== ICD-9 filter/group/codes
"RTN","RORXU002",256,0)
 N LEV1FILT,LEV2GRP,LEV3ICD9,ICD9IEN,ICD9CODE,GRPNAME,FILTER,ICD9DESC
"RTN","RORXU002",257,0)
 S FILTER=$G(RORTSK("PARAMS","ICD9FILT","A","FILTER"))
"RTN","RORXU002",258,0)
 I $L(FILTER)>0 D  ;quit if no ICD9 filter exists
"RTN","RORXU002",259,0)
 . S LEV1FILT=$$ADDVAL^RORTSK11(RORTSK,"ICD9FILT",,PARAMS)
"RTN","RORXU002",260,0)
 . I LEV1FILT<0 S RC=LEV1FILT Q
"RTN","RORXU002",261,0)
 . ;add filter value to the output
"RTN","RORXU002",262,0)
 . S RC=$$ADDATTR^RORTSK11(RORTSK,LEV1FILT,"FILTER",FILTER)
"RTN","RORXU002",263,0)
 . ;if there's an ICD9 group, process it
"RTN","RORXU002",264,0)
 . I $D(RORTSK("PARAMS","ICD9FILT","G"))>1 D  Q:RC<0
"RTN","RORXU002",265,0)
 .. S NODE=$NA(RORTSK("PARAMS","ICD9FILT","G"))
"RTN","RORXU002",266,0)
 .. S GRPNAME=0,RC=0
"RTN","RORXU002",267,0)
 .. F  S GRPNAME=$O(@NODE@(GRPNAME)) Q:GRPNAME=""  D  Q:RC<0
"RTN","RORXU002",268,0)
 ... S LEV2GRP=$$ADDVAL^RORTSK11(RORTSK,"GROUP",,LEV1FILT)
"RTN","RORXU002",269,0)
 ... I LEV2GRP'>0  S RC=LEV2GRP Q 
"RTN","RORXU002",270,0)
 ... ;add group name to the output
"RTN","RORXU002",271,0)
 ... D ADDATTR^RORTSK11(RORTSK,LEV2GRP,"ID",GRPNAME)
"RTN","RORXU002",272,0)
 ... S ICD9IEN=0
"RTN","RORXU002",273,0)
 ... F  S ICD9IEN=$O(@NODE@(GRPNAME,"C",ICD9IEN)) Q:ICD9IEN'>0  D
"RTN","RORXU002",274,0)
 .... S ICD9CODE=+$G(@NODE@(GRPNAME,"C",ICD9IEN)) Q:ICD9CODE'>0
"RTN","RORXU002",275,0)
 .... ;get diagnosis description
"RTN","RORXU002",276,0)
 .... N RORDESC K RORDESC S TMP=$$ICDD^ICDCODE(ICD9CODE,"RORDESC")
"RTN","RORXU002",277,0)
 .... S ICD9DESC=$G(RORDESC(1))
"RTN","RORXU002",278,0)
 .... S LEV3ICD9=$$ADDVAL^RORTSK11(RORTSK,"ICD9",$G(ICD9DESC),LEV2GRP)
"RTN","RORXU002",279,0)
 .... D ADDATTR^RORTSK11(RORTSK,LEV3ICD9,"ID",$G(ICD9CODE))
"RTN","RORXU002",280,0)
 .... K RORDESC
"RTN","RORXU002",281,0)
 ;
"RTN","RORXU002",282,0)
 ;=== get Max Date
"RTN","RORXU002",283,0)
 N MAXDT S MAXDT=$$PARAM^RORTSK01("OPTIONS","MAX_DATE")
"RTN","RORXU002",284,0)
 I $G(MAXDT)>0 D ADDVAL^RORTSK11(RORTSK,"MAX_DATE",MAXDT,PARAMS)
"RTN","RORXU002",285,0)
 ;
"RTN","RORXU002",286,0)
 ;=== get HIV_DX
"RTN","RORXU002",287,0)
 N RORMODE S RORMODE=$$PARAM^RORTSK01("HIV_DX")
"RTN","RORXU002",288,0)
 S RORMODE=$S(RORMODE=1:"Include",RORMODE=-1:"Exclude",1:"")
"RTN","RORXU002",289,0)
 I RORMODE'="" D
"RTN","RORXU002",290,0)
 . D ADDVAL^RORTSK11(RORTSK,"HIV_DX",RORMODE,PARAMS)
"RTN","RORXU002",291,0)
 . S FLAGS=FLAGS_"H"
"RTN","RORXU002",292,0)
 ;
"RTN","RORXU002",293,0)
 ;=== Defaults
"RTN","RORXU002",294,0)
 S TMP=$TR(FLAGS,"FNP")  S:$L(FLAGS)-$L(TMP)=3 FLAGS=TMP
"RTN","RORXU002",295,0)
 S FLAGS=FLAGS_"DG"
"RTN","RORXU002",296,0)
 ;
"RTN","RORXU002",297,0)
 ;=== Success
"RTN","RORXU002",298,0)
 Q PARAMS
"RTN","RORXU002",299,0)
 ;
"RTN","RORXU002",300,0)
 ;***** GENERATES TABLE DEFINITION
"RTN","RORXU002",301,0)
 ;
"RTN","RORXU002",302,0)
 ; TBLREF        Reference to the definition table in the source
"RTN","RORXU002",303,0)
 ;               code (TAG^ROUTINE). See the HEADER^RORX013 for
"RTN","RORXU002",304,0)
 ;               examples of table definitions.
"RTN","RORXU002",305,0)
 ;
"RTN","RORXU002",306,0)
 ; HEADER        IEN of the HEADER element
"RTN","RORXU002",307,0)
 ;
"RTN","RORXU002",308,0)
 ; Return Values:
"RTN","RORXU002",309,0)
 ;       <0  Error code
"RTN","RORXU002",310,0)
 ;        0  Ok
"RTN","RORXU002",311,0)
 ;
"RTN","RORXU002",312,0)
TBLDEF(TBLREF,HEADER) ;
"RTN","RORXU002",313,0)
 N COND,IT,NAME,RC,RORSRC,TBLDEF,TERM,TGET
"RTN","RORXU002",314,0)
 S TGET="S RORSRC=$T("_$P(TBLREF,"^")_"+IT^"_$P(TBLREF,"^",2)_")"
"RTN","RORXU002",315,0)
 S RC=0
"RTN","RORXU002",316,0)
 F IT=1:1  X TGET  S RORSRC=$P(RORSRC,";;",2)  Q:RORSRC=""  D  Q:RC<0
"RTN","RORXU002",317,0)
 . S COND=$$TRIM^XLFSTR($P(RORSRC,U,2,999))
"RTN","RORXU002",318,0)
 . I COND'=""  X COND  E  Q
"RTN","RORXU002",319,0)
 . S RORSRC=$$TRIM^XLFSTR($P(RORSRC,U))
"RTN","RORXU002",320,0)
 . S NAME=$$COLSCAN(.TERM)  Q:(NAME="")!(TERM'="(")
"RTN","RORXU002",321,0)
 . S TBLDEF=$$ADDVAL^RORTSK11(RORTSK,"TBLDEF",,HEADER)
"RTN","RORXU002",322,0)
 . I TBLDEF<0  S RC=TBLDEF  Q
"RTN","RORXU002",323,0)
 . D ADDATTR^RORTSK11(RORTSK,TBLDEF,"NAME",NAME)
"RTN","RORXU002",324,0)
 . D ADDATTR^RORTSK11(RORTSK,TBLDEF,"HEADER","1")
"RTN","RORXU002",325,0)
 . D ADDATTR^RORTSK11(RORTSK,TBLDEF,"FOOTER","1")
"RTN","RORXU002",326,0)
 . D TBLDEF1(TBLDEF)
"RTN","RORXU002",327,0)
 Q $S(RC<0:RC,1:0)
"RTN","RORXU002",328,0)
 ;
"RTN","RORXU002",329,0)
 ;***** GENERATES <COLUMN> ELEMENTS FROM TABLE DEFINITION (RORSRC)
"RTN","RORXU002",330,0)
 ;
"RTN","RORXU002",331,0)
 ; PTAG          IEN of the parent element
"RTN","RORXU002",332,0)
 ;
"RTN","RORXU002",333,0)
TBLDEF1(PTAG) ;
"RTN","RORXU002",334,0)
 N COLUMN,NAME,TERM
"RTN","RORXU002",335,0)
 F  S NAME=$$COLSCAN(.TERM)  Q:NAME=""  D  Q:")"[TERM
"RTN","RORXU002",336,0)
 . S COLUMN=$$ADDVAL^RORTSK11(RORTSK,"COLUMN",,PTAG)
"RTN","RORXU002",337,0)
 . D ADDATTR^RORTSK11(RORTSK,COLUMN,"NAME",NAME)
"RTN","RORXU002",338,0)
 . D:TERM="(" TBLDEF1(COLUMN)
"RTN","RORXU002",339,0)
 Q
"RTN","RORXU005")
0^3^B19990482^B18041693
"RTN","RORXU005",1,0)
RORXU005 ;HCIOFO/SG - REPORT BUILDER UTILITIES ; 5/25/11 11:48am
"RTN","RORXU005",2,0)
 ;;1.5;CLINICAL CASE REGISTRIES;**1,15**;Feb 17, 2006;Build 27
"RTN","RORXU005",3,0)
 ;
"RTN","RORXU005",4,0)
 ; This routine uses the following IAs:
"RTN","RORXU005",5,0)
 ;
"RTN","RORXU005",6,0)
 ; #10035        Direct read of the DOD field of the file #2
"RTN","RORXU005",7,0)
 ;
"RTN","RORXU005",8,0)
 Q
"RTN","RORXU005",9,0)
 ;
"RTN","RORXU005",10,0)
 ;***** CALLBACK FUNCTION FOR DRUG SEARCH API
"RTN","RORXU005",11,0)
REIMBCB(RORDST,ORDER,FLAGS,DRUG,DATE) ;
"RTN","RORXU005",12,0)
 S RORDST=1
"RTN","RORXU005",13,0)
 Q 2
"RTN","RORXU005",14,0)
 ;
"RTN","RORXU005",15,0)
 ;***** RETURNS THE REIMBURSEMENT LEVEL FOR THE PATIENT
"RTN","RORXU005",16,0)
 ;
"RTN","RORXU005",17,0)
 ; RORIEN        IEN of the patient's record in the registry
"RTN","RORXU005",18,0)
 ;
"RTN","RORXU005",19,0)
 ; ROR8DRGS      Either closed root of the ARV drug list prepared by
"RTN","RORXU005",20,0)
 ;               the $$DRUGLIST^RORUTL16 or the Registry IEN. In the
"RTN","RORXU005",21,0)
 ;               latter case, the list will be compiled automatically.
"RTN","RORXU005",22,0)
 ;
"RTN","RORXU005",23,0)
 ; STDT          Start date
"RTN","RORXU005",24,0)
 ; ENDT          End date
"RTN","RORXU005",25,0)
 ;
"RTN","RORXU005",26,0)
 ; Return Values:
"RTN","RORXU005",27,0)
 ;       <0  Error code
"RTN","RORXU005",28,0)
 ;        0  Neither Clinical AIDS nor ARV drugs
"RTN","RORXU005",29,0)
 ;       10  ARV drugs
"RTN","RORXU005",30,0)
 ;       20  Clinical AIDS
"RTN","RORXU005",31,0)
 ;       30  Both Clinical AIDS and ARV drugs
"RTN","RORXU005",32,0)
 ;
"RTN","RORXU005",33,0)
REIMBLVL(RORIEN,ROR8DRGS,STDT,ENDT) ;
"RTN","RORXU005",34,0)
 N PATIEN,RC,RLVL,RORDST
"RTN","RORXU005",35,0)
 S RLVL=0
"RTN","RORXU005",36,0)
 ;--- Clinical AIDS
"RTN","RORXU005",37,0)
 S:$$CLINAIDS^RORHIVUT(+RORIEN,ENDT) RLVL=RLVL+20
"RTN","RORXU005",38,0)
 ;--- ARV Drugs
"RTN","RORXU005",39,0)
 S PATIEN=$$PTIEN^RORUTL01(RORIEN)
"RTN","RORXU005",40,0)
 S RORDST("RORCB")="$$REIMBCB^RORXU005"
"RTN","RORXU005",41,0)
 S RC=$$RXSEARCH^RORUTL14(PATIEN,ROR8DRGS,.RORDST,"IOV",STDT,ENDT)
"RTN","RORXU005",42,0)
 S:$G(RORDST)>0 RLVL=RLVL+10
"RTN","RORXU005",43,0)
 ;--- Reimbursement level
"RTN","RORXU005",44,0)
 Q $S(RC<0:RC,1:RLVL)
"RTN","RORXU005",45,0)
 ;
"RTN","RORXU005",46,0)
 ;***** RETURNS THE PATIENT'S LIST OF RISK FACTORS
"RTN","RORXU005",47,0)
 ;
"RTN","RORXU005",48,0)
 ; RORIEN        IEN of the patient's record in the registry
"RTN","RORXU005",49,0)
 ;
"RTN","RORXU005",50,0)
 ; Return Values:
"RTN","RORXU005",51,0)
 ;       <0  Error code
"RTN","RORXU005",52,0)
 ;       ""  No risk factors have been found
"RTN","RORXU005",53,0)
 ;  " ... "  A string containing the risk factor numbers
"RTN","RORXU005",54,0)
 ;           separated by commas and spaces
"RTN","RORXU005",55,0)
 ;
"RTN","RORXU005",56,0)
RISKS(RORIEN) ;
"RTN","RORXU005",57,0)
 Q:'$D(^RORDATA(799.4,+RORIEN,0)) ""
"RTN","RORXU005",58,0)
 N FLD,FLDLST,I,RISKLST,RORBUF,RORMSG,DIERR
"RTN","RORXU005",59,0)
 S FLDLST="14.01;14.02;14.03;14.04;14.08;14.07;14.09;14.1;14.11;14.12;14.13;14.16;14.17"
"RTN","RORXU005",60,0)
 ;--- Load the risk fields
"RTN","RORXU005",61,0)
 S IENS=(+RORIEN)_","
"RTN","RORXU005",62,0)
 D GETS^DIQ(799.4,IENS,FLDLST,"I","RORBUF","RORMSG")
"RTN","RORXU005",63,0)
 Q:$G(DIERR) $$DBS^RORERR(799.4,-9,,,799.4,IENS)
"RTN","RORXU005",64,0)
 ;--- Process the data
"RTN","RORXU005",65,0)
 S RISKLST=""
"RTN","RORXU005",66,0)
 F I=1:1  S FLD=$P(FLDLST,";",I)  Q:FLD=""  D:FLD>0
"RTN","RORXU005",67,0)
 . S:$G(RORBUF(799.4,IENS,FLD,"I"))=1 RISKLST=RISKLST_", "_I
"RTN","RORXU005",68,0)
 Q $P(RISKLST,", ",2,999)
"RTN","RORXU005",69,0)
 ;
"RTN","RORXU005",70,0)
 ;***** DETERMINES IF THE PATIENT SHOULD NOT BE INCLUDED IN THE REPORT
"RTN","RORXU005",71,0)
 ;
"RTN","RORXU005",72,0)
 ; RORIEN        IEN of the patient's record in the registry
"RTN","RORXU005",73,0)
 ;
"RTN","RORXU005",74,0)
 ; FLAGS         Flags that control the execution (can be combined)
"RTN","RORXU005",75,0)
 ;
"RTN","RORXU005",76,0)
 ;                 C  Skip confirmed patients
"RTN","RORXU005",77,0)
 ;                 G  Skip pending patients
"RTN","RORXU005",78,0)
 ;
"RTN","RORXU005",79,0)
 ;                 D  Skip deceased patients
"RTN","RORXU005",80,0)
 ;                 L  Skip alive patients
"RTN","RORXU005",81,0)
 ;
"RTN","RORXU005",82,0)
 ;                 P  Skip patients confirmed before the start date
"RTN","RORXU005",83,0)
 ;                 N  Skip patients confirmed during the report
"RTN","RORXU005",84,0)
 ;                    time frame
"RTN","RORXU005",85,0)
 ;                 F  Skip patients added after the end date
"RTN","RORXU005",86,0)
 ;
"RTN","RORXU005",87,0)
 ;                 O  Process LOCAL_FIELDS
"RTN","RORXU005",88,0)
 ;                 R  Process OTHER_REGISTRIES
"RTN","RORXU005",89,0)
 ;
"RTN","RORXU005",90,0)
 ; [STDT]        Start date of the report (FileMan).
"RTN","RORXU005",91,0)
 ;               Time is ignored and the beginning of the day is
"RTN","RORXU005",92,0)
 ;               considered as the boundary (STDT\1).
"RTN","RORXU005",93,0)
 ;
"RTN","RORXU005",94,0)
 ;               If not defined or not greater than 0 then 0 is used.
"RTN","RORXU005",95,0)
 ;
"RTN","RORXU005",96,0)
 ; [ENDT]        End date of the report (FileMan).
"RTN","RORXU005",97,0)
 ;               Time is ignored and the end of the day is
"RTN","RORXU005",98,0)
 ;               considered as the boundary (ENDT\1+1).
"RTN","RORXU005",99,0)
 ;
"RTN","RORXU005",100,0)
 ;               If not defined or not greater than 0 then 9999999
"RTN","RORXU005",101,0)
 ;               is used.
"RTN","RORXU005",102,0)
 ;
"RTN","RORXU005",103,0)
 ; Return Values:
"RTN","RORXU005",104,0)
 ;        0  Include the patient's data in the report
"RTN","RORXU005",105,0)
 ;        1  Skip the patient
"RTN","RORXU005",106,0)
 ;
"RTN","RORXU005",107,0)
SKIP(RORIEN,FLAGS,STDT,ENDT) ;
"RTN","RORXU005",108,0)
 N DOD,IEN,MODE,NODE,PTIEN,REGIEN,SKIP,STATUS,TMP
"RTN","RORXU005",109,0)
 S SKIP=0
"RTN","RORXU005",110,0)
 ;--- Always skip patients marked for deletion
"RTN","RORXU005",111,0)
 Q:$$SKIPNA(RORIEN,FLAGS,.STATUS) 1
"RTN","RORXU005",112,0)
 ;---Include all registry patients if flags are not provided
"RTN","RORXU005",113,0)
 Q:FLAGS="" 0
"RTN","RORXU005",114,0)
 ;
"RTN","RORXU005",115,0)
 ;--- Confirmed
"RTN","RORXU005",116,0)
 I FLAGS["C"  Q:STATUS'=4 1
"RTN","RORXU005",117,0)
 ;
"RTN","RORXU005",118,0)
 ;--- Alive/Deceased patients
"RTN","RORXU005",119,0)
 S STDT=$S($G(STDT)>0:STDT\1,1:0)
"RTN","RORXU005",120,0)
 I $TR(FLAGS,"LD")'=FLAGS  D  Q:$S(TMP:FLAGS["L",1:FLAGS["D") 1
"RTN","RORXU005",121,0)
 . S:'$D(PTIEN) PTIEN=+$$PTIEN^RORUTL01(RORIEN)
"RTN","RORXU005",122,0)
 . S DOD=+$P($G(^DPT(PTIEN,.35)),U)
"RTN","RORXU005",123,0)
 . S TMP=$S(DOD>0:DOD'<STDT,1:1)
"RTN","RORXU005",124,0)
 ;
"RTN","RORXU005",125,0)
 ;--- Confirmed before/during/after the date range
"RTN","RORXU005",126,0)
 S ENDT=$S($G(ENDT)>0:ENDT\1,1:9999999)+1
"RTN","RORXU005",127,0)
 I $TR(FLAGS,"PNF")'=FLAGS  D  Q:TMP 1
"RTN","RORXU005",128,0)
 . S TMP=+$$CONFDT^RORUTL18(RORIEN)  ; Date Confirmed
"RTN","RORXU005",129,0)
 . S TMP=$S(TMP<STDT:FLAGS["P",TMP>ENDT:FLAGS["F",1:FLAGS["N")
"RTN","RORXU005",130,0)
 ;
"RTN","RORXU005",131,0)
 ;--- Other registries
"RTN","RORXU005",132,0)
 I FLAGS["R"  D  Q:SKIP 1
"RTN","RORXU005",133,0)
 . S NODE=$NA(RORTSK("PARAMS","OTHER_REGISTRIES","C"))
"RTN","RORXU005",134,0)
 . Q:$D(@NODE)<10
"RTN","RORXU005",135,0)
 . S:'$D(PTIEN) PTIEN=+$$PTIEN^RORUTL01(RORIEN)
"RTN","RORXU005",136,0)
 . S REGIEN=0
"RTN","RORXU005",137,0)
 . F  S REGIEN=$O(@NODE@(REGIEN))  Q:REGIEN'>0  D  Q:SKIP
"RTN","RORXU005",138,0)
 . . S MODE=+$G(@NODE@(REGIEN))  Q:'MODE
"RTN","RORXU005",139,0)
 . . S IEN=$$PRRIEN^RORUTL01(PTIEN,REGIEN)
"RTN","RORXU005",140,0)
 . . I IEN'>0  S SKIP=1
"RTN","RORXU005",141,0)
 . . E  S:$$SKIPNA(IEN,FLAGS) SKIP=1
"RTN","RORXU005",142,0)
 . . S:MODE<0 SKIP='SKIP  ; Exclude
"RTN","RORXU005",143,0)
 ;
"RTN","RORXU005",144,0)
 ;--- Local Fields
"RTN","RORXU005",145,0)
 I FLAGS["O"  D  Q:SKIP 1
"RTN","RORXU005",146,0)
 . S NODE=$NA(RORTSK("PARAMS","LOCAL_FIELDS","C"))
"RTN","RORXU005",147,0)
 . Q:$D(@NODE)<10
"RTN","RORXU005",148,0)
 . S IEN=0
"RTN","RORXU005",149,0)
 . F  S IEN=$O(@NODE@(IEN))  Q:IEN'>0  D  Q:SKIP
"RTN","RORXU005",150,0)
 . . S MODE=+$G(@NODE@(IEN))  Q:'MODE
"RTN","RORXU005",151,0)
 . . S:'$D(^RORDATA(798,RORIEN,20,"B",IEN)) SKIP=1
"RTN","RORXU005",152,0)
 . . S:MODE<0 SKIP='SKIP  ; Exclude
"RTN","RORXU005",153,0)
 ;
"RTN","RORXU005",154,0)
 ;--- Local HIV Diagnosis
"RTN","RORXU005",155,0)
 I FLAGS["H" D  Q:SKIP 1
"RTN","RORXU005",156,0)
 . N RORV
"RTN","RORXU005",157,0)
 . S MODE=+RORTSK("PARAMS","HIV_DX") Q:'MODE
"RTN","RORXU005",158,0)
 . S RORV=+$P($G(^RORDATA(799.4,RORIEN,12)),U,8)
"RTN","RORXU005",159,0)
 . S:RORV'=1 SKIP=1
"RTN","RORXU005",160,0)
 . S:MODE<0 SKIP='SKIP
"RTN","RORXU005",161,0)
 ;
"RTN","RORXU005",162,0)
 ;--- Include in the report
"RTN","RORXU005",163,0)
 Q 0
"RTN","RORXU005",164,0)
 ;
"RTN","RORXU005",165,0)
 ;***** CHECKS STATUS OF THE PATIENT'S REGISTRY RECORD (internal)
"RTN","RORXU005",166,0)
 ;
"RTN","RORXU005",167,0)
 ; IEN798        IEN of the patient's record in the registry
"RTN","RORXU005",168,0)
 ;
"RTN","RORXU005",169,0)
 ; FLAGS         Flags that control the execution
"RTN","RORXU005",170,0)
 ;
"RTN","RORXU005",171,0)
 ; [.STATUS]     Status code is returned via this parameter.
"RTN","RORXU005",172,0)
 ;
"RTN","RORXU005",173,0)
 ; Return Values:
"RTN","RORXU005",174,0)
 ;        0  Continue processing of the patient's data
"RTN","RORXU005",175,0)
 ;        1  Skip the patient
"RTN","RORXU005",176,0)
 ;
"RTN","RORXU005",177,0)
SKIPNA(IEN798,FLAGS,STATUS) ;
"RTN","RORXU005",178,0)
 Q:$$ACTIVE^RORDD(IEN798,,.STATUS) 0  ; Active patient
"RTN","RORXU005",179,0)
 Q:(STATUS=5)!(STATUS="") 1           ; Deleted patient
"RTN","RORXU005",180,0)
 Q:(STATUS=4)&(FLAGS["G") 1           ; Pending patient
"RTN","RORXU005",181,0)
 Q 0
"VER")
8.0^22.0
"^DD",799.1,799.1,0)
FIELD^^1^5
"^DD",799.1,799.1,0,"DDA")
N
"^DD",799.1,799.1,0,"DT")
3050805
"^DD",799.1,799.1,0,"NM","ROR LIST ITEM")

"^DD",799.1,799.1,0,"PT",798.128,.02)

"^DD",799.1,799.1,0,"PT",798.129,.02)

"^DD",799.1,799.1,0,"PT",799.51,.03)

"^DD",799.1,799.1,0,"VRPK")
ROR
"^DD",799.1,799.1,0,"VRRV")
1.1^ROR*1*5
"^DD",799.1,799.1,.01,0)
TEXT^RFX^^0;1^Q:$$VAEDT^RORDD(799.1,,-1)  K:$L(X)>60!($L(X)<1) X
"^DD",799.1,799.1,.01,1,0)
^.1^^0
"^DD",799.1,799.1,.01,3)
Enter text of the item (1-60 characters).
"^DD",799.1,799.1,.01,8.5)
@
"^DD",799.1,799.1,.01,9)
@
"^DD",799.1,799.1,.01,21,0)
^^4^4^3050427^
"^DD",799.1,799.1,.01,21,1,0)
This field contains a text representation of the
"^DD",799.1,799.1,.01,21,2,0)
item (external value). The text is displayed by 
"^DD",799.1,799.1,.01,21,3,0)
the GUI in the list of possible values of the
"^DD",799.1,799.1,.01,21,4,0)
registry field that this item is associated with.
"^DD",799.1,799.1,.01,"DEL",1,0)
I $$VADEL^RORDD(799.1,,-1)
"^DD",799.1,799.1,.01,"DT")
3051116
"^DD",799.1,799.1,.02,0)
TYPE^RSX^3:Lab Group;4:Drug Group;5:BMI Group;6:MELD Group;7:Renal Group;^0;2^Q:$$VAEDT^RORDD(799.1,,-1)
"^DD",799.1,799.1,.02,8.5)
@
"^DD",799.1,799.1,.02,9)
@
"^DD",799.1,799.1,.02,21,0)
^.001^3^3^3090825^^^^
"^DD",799.1,799.1,.02,21,1,0)
An internal value of this field links the item to
"^DD",799.1,799.1,.02,21,2,0)
the registry field. The items with the same type
"^DD",799.1,799.1,.02,21,3,0)
define the possible values of the registry field.
"^DD",799.1,799.1,.02,23,0)
^.001^3^3^3090825^^^^
"^DD",799.1,799.1,.02,23,1,0)
When a new registry field needs to be added, add
"^DD",799.1,799.1,.02,23,2,0)
another code to the definition of this field and create
"^DD",799.1,799.1,.02,23,3,0)
the corresponding item records.
"^DD",799.1,799.1,.02,"DT")
3011112
"^DD",799.1,799.1,.03,0)
REGISTRY^RP798.1'X^ROR(798.1,^0;3^Q:$$VAEDT^RORDD(799.1,,-1)
"^DD",799.1,799.1,.03,8.5)
@
"^DD",799.1,799.1,.03,9)
@
"^DD",799.1,799.1,.03,21,0)
^.001^2^2^3050513^^^
"^DD",799.1,799.1,.03,21,1,0)
This field identifies the registry that the item
"^DD",799.1,799.1,.03,21,2,0)
is associated with.
"^DD",799.1,799.1,.03,"DT")
3011112
"^DD",799.1,799.1,.04,0)
CODE^RNJ2,0X^^0;4^Q:$$VAEDT^RORDD(799.1,,-1)  K:+X'=X!(X>99)!(X<1)!(X?.E1"."1N.N) X
"^DD",799.1,799.1,.04,3)
Type a Number between 1 and 99, 0 Decimal Digits.
"^DD",799.1,799.1,.04,8.5)
@
"^DD",799.1,799.1,.04,9)
@
"^DD",799.1,799.1,.04,21,0)
^.001^3^3^3030625^^^
"^DD",799.1,799.1,.04,21,1,0)
This field contains a code (internal value) of the
"^DD",799.1,799.1,.04,21,2,0)
item. The codes are unique only among the items of
"^DD",799.1,799.1,.04,21,3,0)
the same type associated with the same registry.
"^DD",799.1,799.1,.04,"DT")
3011112
"^DD",799.1,799.1,1,0)
DATE OF INACTIVATION^D^^0;5^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",799.1,799.1,1,21,0)
^.001^4^4^3021126^^^
"^DD",799.1,799.1,1,21,1,0)
If this field has a value, the item will be
"^DD",799.1,799.1,1,21,2,0)
considered inactive after this date. Use this 
"^DD",799.1,799.1,1,21,3,0)
field to disable unnecessary items instead of
"^DD",799.1,799.1,1,21,4,0)
deleting them.
"^DD",799.1,799.1,1,23,0)
^.001^3^3^3021126^^^
"^DD",799.1,799.1,1,23,1,0)
The $$ITEMLIST^RORUTL01 function analyzes this field 
"^DD",799.1,799.1,1,23,2,0)
when it loads the requested list of items and skips the
"^DD",799.1,799.1,1,23,3,0)
inactive items.
"^DD",799.1,799.1,1,"DT")
3021126
"^DD",799.31,799.31,0)
FIELD^^.01^1
"^DD",799.31,799.31,0,"DDA")
N
"^DD",799.31,799.31,0,"DT")
3021130
"^DD",799.31,799.31,0,"NM","ROR XML ITEM")

"^DD",799.31,799.31,0,"PT",798.87,.01)

"^DD",799.31,799.31,0,"PT",798.872,.01)

"^DD",799.31,799.31,0,"VRPK")
ROR
"^DD",799.31,799.31,0,"VRRV")
1.5^ROR 1.5
"^DD",799.31,799.31,.01,0)
NAME^RFX^^0;1^Q:$$VAEDT^RORDD(799.31,,-1)  K:$L(X)>30!($L(X)<2)!'(X'?1P.E) X
"^DD",799.31,799.31,.01,1,0)
^.1^^0
"^DD",799.31,799.31,.01,3)
Enter the tag name (2-30 characters).
"^DD",799.31,799.31,.01,8.5)
@
"^DD",799.31,799.31,.01,9)
@
"^DD",799.31,799.31,.01,21,0)
^.001^4^4^3030506^^
"^DD",799.31,799.31,.01,21,1,0)
This field stores the tag name. The name should 
"^DD",799.31,799.31,.01,21,2,0)
not contain spaces and any punctuation marks 
"^DD",799.31,799.31,.01,21,3,0)
except underscore. See an XML reference guide for
"^DD",799.31,799.31,.01,21,4,0)
more details.
"^DD",799.31,799.31,.01,23,0)
^^4^4^3060203^
"^DD",799.31,799.31,.01,23,1,0)
Please use shorter names for tags that will be used
"^DD",799.31,799.31,.01,23,2,0)
more often and/or will be repeated many times in the
"^DD",799.31,799.31,.01,23,3,0)
report. This will decrease amount of the overhead data
"^DD",799.31,799.31,.01,23,4,0)
transmitted from the server to the GUI.
"^DD",799.31,799.31,.01,"DEL",1,0)
I $$VADEL^RORDD(799.31,,-1)
"^DD",799.31,799.31,.01,"DT")
3050722
"^DD",799.51,799.51,0)
FIELD^^.09^5
"^DD",799.51,799.51,0,"DDA")
N
"^DD",799.51,799.51,0,"DT")
3040114
"^DD",799.51,799.51,0,"IX","AR",799.51,.02)

"^DD",799.51,799.51,0,"IX","B",799.51,.01)

"^DD",799.51,799.51,0,"NM","ROR GENERIC DRUG")

"^DD",799.51,799.51,0,"VRPK")
ROR
"^DD",799.51,799.51,0,"VRRV")
1.1^ROR*1*5
"^DD",799.51,799.51,.01,0)
NAME^RFX^^0;1^Q:$$VAEDT^RORDD(799.51,$G(DA))  K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",799.51,799.51,.01,1,0)
^.1
"^DD",799.51,799.51,.01,1,1,0)
799.51^B
"^DD",799.51,799.51,.01,1,1,1)
S ^ROR(799.51,"B",$E(X,1,30),DA)=""
"^DD",799.51,799.51,.01,1,1,2)
K ^ROR(799.51,"B",$E(X,1,30),DA)
"^DD",799.51,799.51,.01,1,1,3)
Do not delete!
"^DD",799.51,799.51,.01,3)
Name must be 3-30 characters, not numeric or starting with punctuation.
"^DD",799.51,799.51,.01,8.5)
@
"^DD",799.51,799.51,.01,9)
@
"^DD",799.51,799.51,.01,21,0)
^.001^4^4^3040124^^^
"^DD",799.51,799.51,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF 
"^DD",799.51,799.51,.01,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",799.51,799.51,.01,21,3,0)
 
"^DD",799.51,799.51,.01,21,4,0)
The NAME field stores a short name of the drug.
"^DD",799.51,799.51,.01,"DEL",1,0)
I $$VADEL^RORDD(799.51,$G(DA))
"^DD",799.51,799.51,.02,0)
REGISTRY^RP798.1'X^ROR(798.1,^0;2^Q:$$VAEDT^RORDD(799.51,$G(DA))
"^DD",799.51,799.51,.02,1,0)
^.1
"^DD",799.51,799.51,.02,1,1,0)
799.51^AR
"^DD",799.51,799.51,.02,1,1,1)
S ^ROR(799.51,"AR",$E(X,1,30),DA)=""
"^DD",799.51,799.51,.02,1,1,2)
K ^ROR(799.51,"AR",$E(X,1,30),DA)
"^DD",799.51,799.51,.02,1,1,3)
Do not delete!
"^DD",799.51,799.51,.02,1,1,"%D",0)
^^2^2^3040124^
"^DD",799.51,799.51,.02,1,1,"%D",1,0)
This cross-reference groups all drugs associated
"^DD",799.51,799.51,.02,1,1,"%D",2,0)
with a particular registry together.
"^DD",799.51,799.51,.02,1,1,"DT")
3030818
"^DD",799.51,799.51,.02,8.5)
@
"^DD",799.51,799.51,.02,9)
@
"^DD",799.51,799.51,.02,21,0)
^^5^5^3040124^
"^DD",799.51,799.51,.02,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF 
"^DD",799.51,799.51,.02,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",799.51,799.51,.02,21,3,0)
 
"^DD",799.51,799.51,.02,21,4,0)
This field identifies the registry that the drug 
"^DD",799.51,799.51,.02,21,5,0)
is associated with.
"^DD",799.51,799.51,.02,"DT")
3040114
"^DD",799.51,799.51,.03,0)
DRUG GROUP^R*P799.1'X^ROR(799.1,^0;3^Q:$$VAEDT^RORDD(799.51,$G(DA))  S Y=$P($G(^ROR(799.51,DA,0)),U,2),DIC("S")="S D=$G(^(0)) I $P(D,U,2)=4"_$S(Y>0:",$P(D,U,3)="_Y,1:"") D ^DIC K DIC S DIC=DIE,X=+Y K:Y<0 X
"^DD",799.51,799.51,.03,3)

"^DD",799.51,799.51,.03,8.5)
@
"^DD",799.51,799.51,.03,9)
@
"^DD",799.51,799.51,.03,12)
Only Drug Groups can be selected.
"^DD",799.51,799.51,.03,12.1)
S DIC("S")="S D=$G(^(0)) I $P(D,U,2)=4"_$S(Y>0:",$P(D,U,3)="_Y,1:"")
"^DD",799.51,799.51,.03,21,0)
^^2^2^3040124^
"^DD",799.51,799.51,.03,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF 
"^DD",799.51,799.51,.03,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",799.51,799.51,.03,23,0)
^^2^2^3040124^
"^DD",799.51,799.51,.03,23,1,0)
This field is not used currently. It is reserved for 
"^DD",799.51,799.51,.03,23,2,0)
future use.
"^DD",799.51,799.51,.03,"DT")
3040124
"^DD",799.51,799.51,.04,0)
VA GENERIC^RP50.6'X^PSNDF(50.6,^0;4^Q:$$VAEDT^RORDD(799.51,$G(DA))
"^DD",799.51,799.51,.04,8.5)
@
"^DD",799.51,799.51,.04,9)
@
"^DD",799.51,799.51,.04,21,0)
^^2^2^3040124^
"^DD",799.51,799.51,.04,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS A PART OF 
"^DD",799.51,799.51,.04,21,2,0)
NATIONAL REGISTRY DEFINITION!
"^DD",799.51,799.51,.04,"DT")
3040114
"^DD",799.51,799.51,.09,0)
NATIONAL^SX^0:NO;1:YES;^0;9^Q:$$VAEDT^RORDD(799.51,,-1)
"^DD",799.51,799.51,.09,8.5)
@
"^DD",799.51,799.51,.09,9)
@
"^DD",799.51,799.51,.09,21,0)
^^6^6^3060203^
"^DD",799.51,799.51,.09,21,1,0)
ONLY AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN
"^DD",799.51,799.51,.09,21,2,0)
EDIT THIS FIELD!
"^DD",799.51,799.51,.09,21,3,0)
 
"^DD",799.51,799.51,.09,21,4,0)
Drugs associated with the national registries must
"^DD",799.51,799.51,.09,21,5,0)
have this field set to "YES". This prevents local
"^DD",799.51,799.51,.09,21,6,0)
editing of other fields of the record.
"^DD",799.51,799.51,.09,"DEL",1,0)
I $$VADEL^RORDD(799.51,,-1)
"^DD",799.51,799.51,.09,"DT")
3030818
"^DD",799.6,799.6,0)
FIELD^^5^14
"^DD",799.6,799.6,0,"DDA")
N
"^DD",799.6,799.6,0,"DT")
3051101
"^DD",799.6,799.6,0,"NM","ROR HISTORICAL DATA EXTRACTION")

"^DD",799.6,799.6,0,"PT",798.1,21.01)

"^DD",799.6,799.6,0,"VRPK")
ROR
"^DD",799.6,799.6,.01,0)
NAME^RFX^^0;1^Q:$$VAEDT^RORDD(799.6,$G(DA))  K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",799.6,799.6,.01,1,0)
^.1^^-1
"^DD",799.6,799.6,.01,1,2,0)
^^TRIGGER^799.6^.07
"^DD",799.6,799.6,.01,1,2,1)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(0)=X S Y(1)=$S($D(^RORDATA(799.6,D0,0)):^(0),1:"") S X=$P(Y(1),U,7)'>0 I X S X=DIV S Y(1)=$S($D(^RORDATA(799.6,D0,0)):^(0),1:"") S X=$P(Y(1),U,7),X=X S DIU=X K Y S X=DIV S X=DT X ^DD(799.6,.01,1,2,1.4)
"^DD",799.6,799.6,.01,1,2,1.4)
S DIH=$G(^RORDATA(799.6,DIV(0),0)),DIV=X S $P(^(0),U,7)=DIV,DIH=799.6,DIG=.07 D ^DICR
"^DD",799.6,799.6,.01,1,2,2)
Q
"^DD",799.6,799.6,.01,1,2,3)
Do not delete!
"^DD",799.6,799.6,.01,1,2,"%D",0)
^^7^7^3051101^
"^DD",799.6,799.6,.01,1,2,"%D",1,0)
If the ACTIVATION DATE field (.07) is empty, then
"^DD",799.6,799.6,.01,1,2,"%D",2,0)
this trigger populates it with the current date 
"^DD",799.6,799.6,.01,1,2,"%D",3,0)
when the package is installed.
"^DD",799.6,799.6,.01,1,2,"%D",4,0)
 
"^DD",799.6,799.6,.01,1,2,"%D",5,0)
Thus the historical data extraction parameters
"^DD",799.6,799.6,.01,1,2,"%D",6,0)
become active and will be processed by the next 
"^DD",799.6,799.6,.01,1,2,"%D",7,0)
run of the nightly task.
"^DD",799.6,799.6,.01,1,2,"CREATE CONDITION")
ACTIVATION DATE'>0
"^DD",799.6,799.6,.01,1,2,"CREATE VALUE")
TODAY
"^DD",799.6,799.6,.01,1,2,"DELETE VALUE")
NO EFFECT
"^DD",799.6,799.6,.01,1,2,"DT")
3051031
"^DD",799.6,799.6,.01,1,2,"FIELD")
ACTIVATION DATE
"^DD",799.6,799.6,.01,3)
Enter the unique data extraction name (3-30 characters).
"^DD",799.6,799.6,.01,8.5)
@
"^DD",799.6,799.6,.01,9)
@
"^DD",799.6,799.6,.01,20,0)
^.3LA^1^1
"^DD",799.6,799.6,.01,20,1,0)
DEFINITION
"^DD",799.6,799.6,.01,21,0)
^^7^7^3060203^
"^DD",799.6,799.6,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A
"^DD",799.6,799.6,.01,21,2,0)
NATIONAL HISTORICAL DATA EXTRACTION DEFINITION!
"^DD",799.6,799.6,.01,21,3,0)
 
"^DD",799.6,799.6,.01,21,4,0)
This field stores the unique name of the
"^DD",799.6,799.6,.01,21,5,0)
historical data extraction. If an extraction is
"^DD",799.6,799.6,.01,21,6,0)
initiated by a patch, it is a good idea to include
"^DD",799.6,799.6,.01,21,7,0)
the patch number.
"^DD",799.6,799.6,.01,"DEL",1,0)
I $$VADEL^RORDD(799.6,$G(DA))
"^DD",799.6,799.6,.01,"DT")
3051101
"^DD",799.6,799.6,.02,0)
TYPE^RSX^1:Auto (HL7 messages);2:Manual (host files);^0;2^Q:$$VAEDT^RORDD(799.6,$G(DA))
"^DD",799.6,799.6,.02,8.5)
@
"^DD",799.6,799.6,.02,9)
@
"^DD",799.6,799.6,.02,20,0)
^.3LA^1^1
"^DD",799.6,799.6,.02,20,1,0)
DEFINITION
"^DD",799.6,799.6,.02,21,0)
^^15^15^3060203^
"^DD",799.6,799.6,.02,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A 
"^DD",799.6,799.6,.02,21,2,0)
NATIONAL HISTORICAL DATA EXTRACTION DEFINITION!
"^DD",799.6,799.6,.02,21,3,0)
 
"^DD",799.6,799.6,.02,21,4,0)
This field defines the type of data extraction.
"^DD",799.6,799.6,.02,21,5,0)
 
"^DD",799.6,799.6,.02,21,6,0)
Automatic data extractions are initiated by the 
"^DD",799.6,799.6,.02,21,7,0)
CCR patches. Data is extracted by the nightly task
"^DD",799.6,799.6,.02,21,8,0)
and sent via regular batch HL7 messages.
"^DD",799.6,799.6,.02,21,9,0)
 
"^DD",799.6,799.6,.02,21,10,0)
Manual data extractions are initiated by the users
"^DD",799.6,799.6,.02,21,11,0)
using the options from the maintenance menu. They 
"^DD",799.6,799.6,.02,21,12,0)
schedule the data extraction tasks and verify 
"^DD",799.6,799.6,.02,21,13,0)
their completion. Data is written to host files, 
"^DD",799.6,799.6,.02,21,14,0)
which are transferred to the AAC via FTP or any
"^DD",799.6,799.6,.02,21,15,0)
other means.
"^DD",799.6,799.6,.02,"DEL",1,0)
I $$VADEL^RORDD(799.6,$G(DA))
"^DD",799.6,799.6,.02,"DT")
3051031
"^DD",799.6,799.6,.03,0)
START DATE^RDX^^0;3^Q:$$VAEDT^RORDD(799.6,$G(DA))  S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",799.6,799.6,.03,1,0)
^.1
"^DD",799.6,799.6,.03,1,1,0)
^^TRIGGER^799.6^.04
"^DD",799.6,799.6,.03,1,1,1)
K DIV S DIV=X,D0=DA,DIV(0)=D0 S Y(0)=X S Y(1)=$S($D(^RORDATA(799.6,D0,0)):^(0),1:"") S X=$P(Y(1),U,4)'>0 I X S X=DIV S Y(1)=$S($D(^RORDATA(799.6,D0,0)):^(0),1:"") S X=$P(Y(1),U,4),X=X S DIU=X K Y S X=DIV S X=DT X ^DD(799.6,.03,1,1,1.4)
"^DD",799.6,799.6,.03,1,1,1.4)
S DIH=$G(^RORDATA(799.6,DIV(0),0)),DIV=X S $P(^(0),U,4)=DIV,DIH=799.6,DIG=.04 D ^DICR
"^DD",799.6,799.6,.03,1,1,2)
Q
"^DD",799.6,799.6,.03,1,1,3)
Do not delete!
"^DD",799.6,799.6,.03,1,1,"%D",0)
^^3^3^3051101^
"^DD",799.6,799.6,.03,1,1,"%D",1,0)
If the END DATE field (.04) is empty, then this
"^DD",799.6,799.6,.03,1,1,"%D",2,0)
trigger populates it with the current date when
"^DD",799.6,799.6,.03,1,1,"%D",3,0)
the package is installed.
"^DD",799.6,799.6,.03,1,1,"CREATE CONDITION")
END DATE'>0
"^DD",799.6,799.6,.03,1,1,"CREATE VALUE")
TODAY
"^DD",799.6,799.6,.03,1,1,"DELETE VALUE")
NO EFFECT
"^DD",799.6,799.6,.03,1,1,"DT")
3051101
"^DD",799.6,799.6,.03,1,1,"FIELD")
END DATE
"^DD",799.6,799.6,.03,8.5)
@
"^DD",799.6,799.6,.03,9)
@
"^DD",799.6,799.6,.03,20,0)
^.3LA^1^1
"^DD",799.6,799.6,.03,20,1,0)
DEFINITION
"^DD",799.6,799.6,.03,21,0)
^.001^5^5^3051101^^
"^DD",799.6,799.6,.03,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A 
"^DD",799.6,799.6,.03,21,2,0)
NATIONAL HISTORICAL DATA EXTRACTION DEFINITION!
"^DD",799.6,799.6,.03,21,3,0)
 
"^DD",799.6,799.6,.03,21,4,0)
This field indicates the start date for the 
"^DD",799.6,799.6,.03,21,5,0)
historical data extraction.
"^DD",799.6,799.6,.03,"DEL",1,0)
I $$VADEL^RORDD(799.6,$G(DA))
"^DD",799.6,799.6,.03,"DT")
3051101
"^DD",799.6,799.6,.04,0)
END DATE^DX^^0;4^Q:$$VAEDT^RORDD(799.6,$G(DA))  S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",799.6,799.6,.04,5,1,0)
799.6^.03^1
"^DD",799.6,799.6,.04,8.5)
@
"^DD",799.6,799.6,.04,9)
@
"^DD",799.6,799.6,.04,20,0)
^.3LA^1^1
"^DD",799.6,799.6,.04,20,1,0)
DEFINITION
"^DD",799.6,799.6,.04,21,0)
^^5^5^3051101^
"^DD",799.6,799.6,.04,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A 
"^DD",799.6,799.6,.04,21,2,0)
NATIONAL HISTORICAL DATA EXTRACTION DEFINITION!
"^DD",799.6,799.6,.04,21,3,0)
 
"^DD",799.6,799.6,.04,21,4,0)
This field indicates the end date for the 
"^DD",799.6,799.6,.04,21,5,0)
historical data extraction.
"^DD",799.6,799.6,.04,"DEL",1,0)
I $$VADEL^RORDD(799.6,$G(DA))
"^DD",799.6,799.6,.04,"DT")
3051101
"^DD",799.6,799.6,.05,0)
PATIENTS PER BATCH^NJ9,0X^^0;5^Q:$$VAEDT^RORDD(799.6,$G(DA))  K:+X'=X!(X>999999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",799.6,799.6,.05,3)
Type a Number between 1 and 999999999, 0 Decimal Digits.
"^DD",799.6,799.6,.05,8.5)
@
"^DD",799.6,799.6,.05,9)
@
"^DD",799.6,799.6,.05,20,0)
^.3LA^2^2
"^DD",799.6,799.6,.05,20,1,0)
DEFINITION
"^DD",799.6,799.6,.05,20,2,0)
MANUAL
"^DD",799.6,799.6,.05,21,0)
^^6^6^3051219^
"^DD",799.6,799.6,.05,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A 
"^DD",799.6,799.6,.05,21,2,0)
NATIONAL HISTORICAL DATA EXTRACTION DEFINITION!
"^DD",799.6,799.6,.05,21,3,0)
 
"^DD",799.6,799.6,.05,21,4,0)
The PATIENTS PER BATCH field holds the maximum
"^DD",799.6,799.6,.05,21,5,0)
number of patients whose data is written into a
"^DD",799.6,799.6,.05,21,6,0)
single historical data extraction output file.
"^DD",799.6,799.6,.05,23,0)
^.001^2^2^3060203^^^^
"^DD",799.6,799.6,.05,23,1,0)
This field is used only during manual historical data
"^DD",799.6,799.6,.05,23,2,0)
extractions.
"^DD",799.6,799.6,.05,"DEL",1,0)
I $$VADEL^RORDD(799.6,$G(DA))
"^DD",799.6,799.6,.05,"DT")
3050725
"^DD",799.6,799.6,.06,0)
MAXIMUM MESSAGE SIZE^NJ4,1X^^0;6^Q:$$VAEDT^RORDD(799.6,$G(DA))  K:+X'=X!(X>99)!(X<0)!(X?.E1"."2N.N) X
"^DD",799.6,799.6,.06,3)
Type a Number between 0 and 99, 1 Decimal Digit.
"^DD",799.6,799.6,.06,8.5)
@
"^DD",799.6,799.6,.06,9)
@
"^DD",799.6,799.6,.06,20,0)
^.3LA^2^2
"^DD",799.6,799.6,.06,20,1,0)
DEFINITION
"^DD",799.6,799.6,.06,20,2,0)
AUTO
"^DD",799.6,799.6,.06,21,0)
^.001^7^7^3051219^^
"^DD",799.6,799.6,.06,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A 
"^DD",799.6,799.6,.06,21,2,0)
NATIONAL HISTORICAL DATA EXTRACTION DEFINITION!
"^DD",799.6,799.6,.06,21,3,0)
 
"^DD",799.6,799.6,.06,21,4,0)
This field stores the maximum size (in megabytes)
"^DD",799.6,799.6,.06,21,5,0)
of a batch HL7 message that can be sent to Austin
"^DD",799.6,799.6,.06,21,6,0)
Automation Center (AAC). If this field is empty or
"^DD",799.6,799.6,.06,21,7,0)
contains 0, the size is not limited.
"^DD",799.6,799.6,.06,23,0)
^.001^11^11^3060203^^
"^DD",799.6,799.6,.06,23,1,0)
Actual size of an HL7 batch can be greater than the
"^DD",799.6,799.6,.06,23,2,0)
value of this field because the software does not break
"^DD",799.6,799.6,.06,23,3,0)
in the middle of an individual HL7 message.
"^DD",799.6,799.6,.06,23,4,0)
 
"^DD",799.6,799.6,.06,23,5,0)
For example, if the maximum size is 10Mb, the current
"^DD",799.6,799.6,.06,23,6,0)
size is 9Mb and 3Mb should be sent for the patient
"^DD",799.6,799.6,.06,23,7,0)
being processed then the actual size of the batch will
"^DD",799.6,799.6,.06,23,8,0)
be 12Mb.
"^DD",799.6,799.6,.06,23,9,0)
 
"^DD",799.6,799.6,.06,23,10,0)
This field is used only during automatic historical 
"^DD",799.6,799.6,.06,23,11,0)
data extractions.
"^DD",799.6,799.6,.06,"DEL",1,0)
I $$VADEL^RORDD(799.6,$G(DA))
"^DD",799.6,799.6,.06,"DT")
3051101
"^DD",799.6,799.6,.07,0)
ACTIVATION DATE^D^^0;7^S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",799.6,799.6,.07,5,1,0)
799.6^.01^2
"^DD",799.6,799.6,.07,8.5)
@
"^DD",799.6,799.6,.07,9)
@
"^DD",799.6,799.6,.07,20,0)
^.3LA^2^2
"^DD",799.6,799.6,.07,20,1,0)
STATE
"^DD",799.6,799.6,.07,20,2,0)
AUTO
"^DD",799.6,799.6,.07,21,0)
^^5^5^3051219^
"^DD",799.6,799.6,.07,21,1,0)
This field is used only for automatic data 
"^DD",799.6,799.6,.07,21,2,0)
extractions. If it is empty, then the nightly task
"^DD",799.6,799.6,.07,21,3,0)
ignores this record completely. Otherwise, the
"^DD",799.6,799.6,.07,21,4,0)
data extraction will not start before the date and
"^DD",799.6,799.6,.07,21,5,0)
time stored in this field.
"^DD",799.6,799.6,.07,"DT")
3051031
"^DD",799.6,799.6,.08,0)
BASE FILE NAME^FX^^0;8^K:$L(X)>15!($L(X)<1) X
"^DD",799.6,799.6,.08,3)
Answer must be 1-15 characters in length.
"^DD",799.6,799.6,.08,8.5)
@
"^DD",799.6,799.6,.08,9)
@
"^DD",799.6,799.6,.08,20,0)
^.3LA^2^2
"^DD",799.6,799.6,.08,20,1,0)
DEFINITION
"^DD",799.6,799.6,.08,20,2,0)
MANUAL
"^DD",799.6,799.6,.08,21,0)
^^19^19^3051219^
"^DD",799.6,799.6,.08,21,1,0)
The base part for the output file names is stored
"^DD",799.6,799.6,.08,21,2,0)
in this field. It is populated either by a patch 
"^DD",799.6,799.6,.08,21,3,0)
or by the user (if they are instructed to do so).
"^DD",799.6,799.6,.08,21,4,0)
 
"^DD",799.6,799.6,.08,21,5,0)
The output file names will have the following
"^DD",799.6,799.6,.08,21,6,0)
structure:
"^DD",799.6,799.6,.08,21,7,0)
 
"^DD",799.6,799.6,.08,21,8,0)
  BASE-SSS-TT.HDT
"^DD",799.6,799.6,.08,21,9,0)
 
"^DD",799.6,799.6,.08,21,10,0)
where 'BASE' is the value of this field, 'SSS' is
"^DD",799.6,799.6,.08,21,11,0)
the site number (3 digits), and 'TT' is the
"^DD",799.6,799.6,.08,21,12,0)
sequential number of the task (2 digits).
"^DD",799.6,799.6,.08,21,13,0)
                                                     
"^DD",799.6,799.6,.08,21,14,0)
If the task is restarted, the optional numeric
"^DD",799.6,799.6,.08,21,15,0)
modifier '##' (2 digits) will be added to the name
"^DD",799.6,799.6,.08,21,16,0)
so that the already extracted data will not be
"^DD",799.6,799.6,.08,21,17,0)
overwritten:
"^DD",799.6,799.6,.08,21,18,0)
                                                     
"^DD",799.6,799.6,.08,21,19,0)
  BASE-SSS-TT-##.HDT 
"^DD",799.6,799.6,.08,23,0)
^^2^2^3060203^
"^DD",799.6,799.6,.08,23,1,0)
This field is used only during manual historical data
"^DD",799.6,799.6,.08,23,2,0)
extractions.
"^DD",799.6,799.6,.08,"DT")
3051219
"^DD",799.6,799.6,.09,0)
NATIONAL^SX^0:NO;1:YES;^0;9^Q:$$VAEDT^RORDD(799.6,,-1)
"^DD",799.6,799.6,.09,8.5)
@
"^DD",799.6,799.6,.09,9)
@
"^DD",799.6,799.6,.09,20,0)
^.3LA^1^1
"^DD",799.6,799.6,.09,20,1,0)
DEFINITION
"^DD",799.6,799.6,.09,21,0)
^^6^6^3060203^
"^DD",799.6,799.6,.09,21,1,0)
ONLY AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN
"^DD",799.6,799.6,.09,21,2,0)
EDIT THIS FIELD!
"^DD",799.6,799.6,.09,21,3,0)
 
"^DD",799.6,799.6,.09,21,4,0)
National historical data extractions (backpulls)
"^DD",799.6,799.6,.09,21,5,0)
must have this field set to "YES". This prevents
"^DD",799.6,799.6,.09,21,6,0)
local editing of other fields of the definitions.
"^DD",799.6,799.6,.09,"DEL",1,0)
I $$VADEL^RORDD(799.6,$G(DA))
"^DD",799.6,799.6,.09,"DT")
3050725
"^DD",799.6,799.6,1,0)
DATA AREA^799.61P^^1;0
"^DD",799.6,799.6,1,9)
@
"^DD",799.6,799.6,1,20,0)
^.3LA^1^1
"^DD",799.6,799.6,1,20,1,0)
DEFINITION
"^DD",799.6,799.6,1,21,0)
^.001^7^7^3051219^^
"^DD",799.6,799.6,1,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A 
"^DD",799.6,799.6,1,21,2,0)
NATIONAL HISTORICAL DATA EXTRACTION DEFINITION!
"^DD",799.6,799.6,1,21,3,0)
 
"^DD",799.6,799.6,1,21,4,0)
This multiple lists all data areas in which the 
"^DD",799.6,799.6,1,21,5,0)
data extraction will be performed. It can also
"^DD",799.6,799.6,1,21,6,0)
contain additional time frames for these data
"^DD",799.6,799.6,1,21,7,0)
areas.
"^DD",799.6,799.6,2,0)
OUTPUT DIRECTORY^F^^2;E1,240^K:$L(X)>240!($L(X)<1) X
"^DD",799.6,799.6,2,3)
Enter a valid name of the output directory (1-240 characters).
"^DD",799.6,799.6,2,20,0)
^.3LA^2^2
"^DD",799.6,799.6,2,20,1,0)
PARAMETERS
"^DD",799.6,799.6,2,20,2,0)
MANUAL
"^DD",799.6,799.6,2,21,0)
^^19^19^3060203^
"^DD",799.6,799.6,2,21,1,0)
A directory must be created within the file system
"^DD",799.6,799.6,2,21,2,0)
of the host operating system (VMS, Windows,
"^DD",799.6,799.6,2,21,3,0)
etc.). Text files containing historical data in
"^DD",799.6,799.6,2,21,4,0)
the HL7 format will be created in this directory
"^DD",799.6,799.6,2,21,5,0)
by the data extraction tasks.
"^DD",799.6,799.6,2,21,6,0)
 
"^DD",799.6,799.6,2,21,7,0)
The full name of the directory must be entered as
"^DD",799.6,799.6,2,21,8,0)
a value of this field. For example, the value can
"^DD",799.6,799.6,2,21,9,0)
look something like this:
"^DD",799.6,799.6,2,21,10,0)
 
"^DD",799.6,799.6,2,21,11,0)
   VA2$:[OUTPUT] - VAX VMS 
"^DD",799.6,799.6,2,21,12,0)
   D:\Output\    - Windows, MS-DOS
"^DD",799.6,799.6,2,21,13,0)
 
"^DD",799.6,799.6,2,21,14,0)
Because a file name will be concatenated to the
"^DD",799.6,799.6,2,21,15,0)
directory name, the trailing slash in the Windows
"^DD",799.6,799.6,2,21,16,0)
directory name is required.
"^DD",799.6,799.6,2,21,17,0)
 
"^DD",799.6,799.6,2,21,18,0)
Do not forget to enable read/write access to this
"^DD",799.6,799.6,2,21,19,0)
directory for M processes!
"^DD",799.6,799.6,2,"DT")
3050722
"^DD",799.6,799.6,3,0)
REGISTRY NAME^799.63^^3;0
"^DD",799.6,799.6,3,9)
@
"^DD",799.6,799.6,3,21,0)
^^3^3^3051219^
"^DD",799.6,799.6,3,21,1,0)
This multiple references the registries that the
"^DD",799.6,799.6,3,21,2,0)
data extraction will be performed for and
"^DD",799.6,799.6,3,21,3,0)
indicates the extraction status.
"^DD",799.6,799.6,3,"DT")
3051031
"^DD",799.6,799.6,4,0)
TASK^799.64^^4;0
"^DD",799.6,799.6,4,9)
@
"^DD",799.6,799.6,4,20,0)
^.3LA^2^2
"^DD",799.6,799.6,4,20,1,0)
STATE
"^DD",799.6,799.6,4,20,2,0)
MANUAL
"^DD",799.6,799.6,5,0)
STATUS^CJ2,0^^ ; ^S X=$$HDESTAT^RORDD01(+$G(D0))
"^DD",799.6,799.6,5,9)
^
"^DD",799.6,799.6,5,9.01)

"^DD",799.6,799.6,5,9.1)
S X=$$HDESTAT^RORDD01(+$G(D0))
"^DD",799.6,799.6,5,20,0)
^.3LA^1^1
"^DD",799.6,799.6,5,20,1,0)
STATE
"^DD",799.6,799.6,5,21,0)
^^7^7^3060106^
"^DD",799.6,799.6,5,21,1,0)
This field indicates a generic status of the 
"^DD",799.6,799.6,5,21,2,0)
historical data extraction:
"^DD",799.6,799.6,5,21,3,0)
 
"^DD",799.6,799.6,5,21,4,0)
  ""  Unknown/Undefined
"^DD",799.6,799.6,5,21,5,0)
   0  Inactive
"^DD",799.6,799.6,5,21,6,0)
   1  Pending/Active
"^DD",799.6,799.6,5,21,7,0)
   2  Completed
"^DD",799.6,799.6,5,"DT")
3051114
"^DD",799.6,799.61,0)
DATA AREA SUB-FIELD^^.03^3
"^DD",799.6,799.61,0,"DT")
3050722
"^DD",799.6,799.61,0,"NM","DATA AREA")

"^DD",799.6,799.61,0,"UP")
799.6
"^DD",799.6,799.61,.01,0)
DATA AREA^MP799.33'X^ROR(799.33,^0;1^Q:$$VAEDT^RORDD(799.6,$G(DA(1)))
"^DD",799.6,799.61,.01,1,0)
^.1^^0
"^DD",799.6,799.61,.01,3)

"^DD",799.6,799.61,.01,8.5)
@
"^DD",799.6,799.61,.01,9)
@
"^DD",799.6,799.61,.01,20,0)
^.3LA^^0
"^DD",799.6,799.61,.01,21,0)
^^6^6^3051219^
"^DD",799.6,799.61,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A 
"^DD",799.6,799.61,.01,21,2,0)
NATIONAL HISTORICAL DATA EXTRACTION DEFINITION!
"^DD",799.6,799.61,.01,21,3,0)
 
"^DD",799.6,799.61,.01,21,4,0)
Select the data area where the data extraction 
"^DD",799.6,799.61,.01,21,5,0)
will be performed. Data will be extracted only 
"^DD",799.6,799.61,.01,21,6,0)
from the data areas referenced by this field.
"^DD",799.6,799.61,.01,"DEL",1,0)
I $$VADEL^RORDD(799.6,$G(DA(1)))
"^DD",799.6,799.61,.01,"DT")
3050725
"^DD",799.6,799.61,.02,0)
START DATE^DX^^0;2^Q:$$VAEDT^RORDD(799.6,$G(DA(1)))  S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",799.6,799.61,.02,1,0)
^.1
"^DD",799.6,799.61,.02,1,1,0)
^^TRIGGER^799.61^.03
"^DD",799.6,799.61,.02,1,1,1)
X ^DD(799.61,.02,1,1,1.3) I X S X=DIV S Y(1)=$S($D(^RORDATA(799.6,D0,1,D1,0)):^(0),1:"") S X=$P(Y(1),U,3),X=X S DIU=X K Y S X=DIV S X=DT X ^DD(799.61,.02,1,1,1.4)
"^DD",799.6,799.61,.02,1,1,1.3)
K DIV S DIV=X,D0=DA(1),DIV(0)=D0,D1=DA,DIV(1)=D1 S Y(0)=X S Y(1)=$S($D(^RORDATA(799.6,D0,1,D1,0)):^(0),1:"") S X=$P(Y(1),U,3)'>0
"^DD",799.6,799.61,.02,1,1,1.4)
S DIH=$G(^RORDATA(799.6,DIV(0),1,DIV(1),0)),DIV=X S $P(^(0),U,3)=DIV,DIH=799.61,DIG=.03 D ^DICR
"^DD",799.6,799.61,.02,1,1,2)
Q
"^DD",799.6,799.61,.02,1,1,3)
Do not delete!
"^DD",799.6,799.61,.02,1,1,"%D",0)
^^3^3^3060106^
"^DD",799.6,799.61,.02,1,1,"%D",1,0)
If the END DATE field (.03) is empty, then this 
"^DD",799.6,799.61,.02,1,1,"%D",2,0)
trigger populates it with the current date when
"^DD",799.6,799.61,.02,1,1,"%D",3,0)
the package is installed.
"^DD",799.6,799.61,.02,1,1,"CREATE CONDITION")
END DATE'>0
"^DD",799.6,799.61,.02,1,1,"CREATE VALUE")
TODAY
"^DD",799.6,799.61,.02,1,1,"DELETE VALUE")
NO EFFECT
"^DD",799.6,799.61,.02,1,1,"FIELD")
END DATE
"^DD",799.6,799.61,.02,8.5)
@
"^DD",799.6,799.61,.02,9)
@
"^DD",799.6,799.61,.02,20,0)
^.3LA^^0
"^DD",799.6,799.61,.02,21,0)
^^10^10^3051219^
"^DD",799.6,799.61,.02,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A 
"^DD",799.6,799.61,.02,21,2,0)
NATIONAL HISTORICAL DATA EXTRACTION DEFINITION!
"^DD",799.6,799.61,.02,21,3,0)
 
"^DD",799.6,799.61,.02,21,4,0)
This field stores the start date of an additional 
"^DD",799.6,799.61,.02,21,5,0)
data extraction time frame for this data area.
"^DD",799.6,799.61,.02,21,6,0)
 
"^DD",799.6,799.61,.02,21,7,0)
If this field is empty, then the data is extracted
"^DD",799.6,799.61,.02,21,8,0)
only in the main time frame defined by the
"^DD",799.6,799.61,.02,21,9,0)
top-level fields START DATE (.03) and END DATE
"^DD",799.6,799.61,.02,21,10,0)
(.04).
"^DD",799.6,799.61,.02,"DEL",1,0)
I $$VADEL^RORDD(799.6,$G(DA(1)))
"^DD",799.6,799.61,.02,"DT")
3051101
"^DD",799.6,799.61,.03,0)
END DATE^DX^^0;3^Q:$$VAEDT^RORDD(799.6,$G(DA(1)))  S %DT="EX" D ^%DT S X=Y K:Y<1 X
"^DD",799.6,799.61,.03,5,1,0)
799.61^.02^1
"^DD",799.6,799.61,.03,8.5)
@
"^DD",799.6,799.61,.03,9)
@
"^DD",799.6,799.61,.03,20,0)
^.3LA^^0
"^DD",799.6,799.61,.03,21,0)
^^10^10^3051219^
"^DD",799.6,799.61,.03,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A 
"^DD",799.6,799.61,.03,21,2,0)
NATIONAL HISTORICAL DATA EXTRACTION DEFINITION!
"^DD",799.6,799.61,.03,21,3,0)
 
"^DD",799.6,799.61,.03,21,4,0)
This field stores the end date of an additional 
"^DD",799.6,799.61,.03,21,5,0)
data extraction time frame for this data area.
"^DD",799.6,799.61,.03,21,6,0)
 
"^DD",799.6,799.61,.03,21,7,0)
If this field is empty, then the data is extracted
"^DD",799.6,799.61,.03,21,8,0)
only in the main time frame defined by the
"^DD",799.6,799.61,.03,21,9,0)
top-level fields START DATE (.03) and END DATE
"^DD",799.6,799.61,.03,21,10,0)
(.04).
"^DD",799.6,799.61,.03,"DEL",1,0)
I $$VADEL^RORDD(799.6,$G(DA(1)))
"^DD",799.6,799.61,.03,"DT")
3051101
"^DD",799.6,799.63,0)
REGISTRY NAME SUB-FIELD^^.02^2
"^DD",799.6,799.63,0,"DT")
3051031
"^DD",799.6,799.63,0,"NM","REGISTRY NAME")

"^DD",799.6,799.63,0,"UP")
799.6
"^DD",799.6,799.63,.01,0)
REGISTRY NAME^MRFX^^0;1^Q:$$VAEDT^RORDD(799.6,$G(DA(1)))  K:$L(X)>30!($L(X)<3) X I $D(X) K:'$D(^ROR(798.1,"B",$E(X,1,30))) X
"^DD",799.6,799.63,.01,1,0)
^.1^^0
"^DD",799.6,799.63,.01,3)
Enter the registry name (3-30 characters).
"^DD",799.6,799.63,.01,4)
I $G(X)="??" N D,DIC,DZ S DIC="^ROR(798.1,",DIC(0)="",D="B",DZ="??" D DQ^DICQ,EN^DDIOL("",,"!")
"^DD",799.6,799.63,.01,8.5)
@
"^DD",799.6,799.63,.01,9)
@
"^DD",799.6,799.63,.01,20,0)
^.3LA^1^1
"^DD",799.6,799.63,.01,20,1,0)
DEFINITION
"^DD",799.6,799.63,.01,21,0)
^^5^5^3051101^
"^DD",799.6,799.63,.01,21,1,0)
YOU MUST NOT EDIT THIS FIELD IF IT IS PART OF A 
"^DD",799.6,799.63,.01,21,2,0)
NATIONAL HISTORICAL DATA EXTRACTION DEFINITION!
"^DD",799.6,799.63,.01,21,3,0)
 
"^DD",799.6,799.63,.01,21,4,0)
Enter a name of the registry exactly as it appears
"^DD",799.6,799.63,.01,21,5,0)
in the ROR REGISTRY PARAMETERS file (#798.1).
"^DD",799.6,799.63,.01,23,0)
^.001^3^3^3051101^^^^
"^DD",799.6,799.63,.01,23,1,0)
Names of the registries are used here instead of 
"^DD",799.6,799.63,.01,23,2,0)
pointers because the KIDS pointer resolving feature 
"^DD",799.6,799.63,.01,23,3,0)
does not work for .01 fields.
"^DD",799.6,799.63,.01,"DEL",1,0)
I $$VADEL^RORDD(799.6,$G(DA(1)))
"^DD",799.6,799.63,.01,"DT")
3051031
"^DD",799.6,799.63,.02,0)
COMPLETION DATE/TIME^D^^0;2^S %DT="ESTX" D ^%DT S X=Y K:Y<1 X
"^DD",799.6,799.63,.02,8.5)
@
"^DD",799.6,799.63,.02,9)
@
"^DD",799.6,799.63,.02,20,0)
^.3LA^1^1
"^DD",799.6,799.63,.02,20,1,0)
STATE
"^DD",799.6,799.63,.02,21,0)
^^7^7^3060203^
"^DD",799.6,799.63,.02,21,1,0)
A valid date in this field indicates that the data
"^DD",799.6,799.63,.02,21,2,0)
extraction has been successfully completed for
"^DD",799.6,799.63,.02,21,3,0)
this registry. 
"^DD",799.6,799.63,.02,21,4,0)
 
"^DD",799.6,799.63,.02,21,5,0)
If the data must be re-extracted, clear this field
"^DD",799.6,799.63,.02,21,6,0)
and the nightly task will repeat the historical
"^DD",799.6,799.63,.02,21,7,0)
data extraction for this registry.
"^DD",799.6,799.63,.02,23,0)
^^4^4^3060203^
"^DD",799.6,799.63,.02,23,1,0)
This field is populated by the $$CHECKMSG^ROR10 
"^DD",799.6,799.63,.02,23,2,0)
function after it confirms successful transmission of 
"^DD",799.6,799.63,.02,23,3,0)
the HL7 messages before the next nightly data
"^DD",799.6,799.63,.02,23,4,0)
extraction.
"^DD",799.6,799.63,.02,"DT")
3051031
"^DD",799.6,799.64,0)
TASK SUB-FIELD^^1^6
"^DD",799.6,799.64,0,"DT")
3050725
"^DD",799.6,799.64,0,"IX","T",799.64,.02)

"^DD",799.6,799.64,0,"NM","TASK")

"^DD",799.6,799.64,0,"UP")
799.6
"^DD",799.6,799.64,.01,0)
START RECORD IEN^MNJ22,9^^0;1^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."10N.N) X
"^DD",799.6,799.64,.01,1,0)
^.1^^0
"^DD",799.6,799.64,.01,3)
Enter a patient's IEN (DFN).
"^DD",799.6,799.64,.01,8.5)
@
"^DD",799.6,799.64,.01,9)
@
"^DD",799.6,799.64,.01,21,0)
^^16^16^3060203^
"^DD",799.6,799.64,.01,21,1,0)
All patients of the registries are distributed 
"^DD",799.6,799.64,.01,21,2,0)
between the data extraction tasks. Each task
"^DD",799.6,799.64,.01,21,3,0)
extracts the data of the patients whose DFNs are
"^DD",799.6,799.64,.01,21,4,0)
not less than the value of this field in the task
"^DD",799.6,799.64,.01,21,5,0)
record and are less than the value of the field in
"^DD",799.6,799.64,.01,21,6,0)
the next task record.
"^DD",799.6,799.64,.01,21,7,0)
                                                     
"^DD",799.6,799.64,.01,21,8,0)
The first task always has 1 as a value in this
"^DD",799.6,799.64,.01,21,9,0)
field (just in case).
"^DD",799.6,799.64,.01,21,10,0)
                                                     
"^DD",799.6,799.64,.01,21,11,0)
The last task extracts the data of all patients
"^DD",799.6,799.64,.01,21,12,0)
whose registry records have IENs not less than the
"^DD",799.6,799.64,.01,21,13,0)
value of this field.  
"^DD",799.6,799.64,.01,21,14,0)
                                                     
"^DD",799.6,799.64,.01,21,15,0)
Usually, this field should not be edited. It is
"^DD",799.6,799.64,.01,21,16,0)
populated automatically when the task is created.
"^DD",799.6,799.64,.01,23,0)
^^7^7^3060203^
"^DD",799.6,799.64,.01,23,1,0)
The value of this field is not a real pointer to the 
"^DD",799.6,799.64,.01,23,2,0)
ROR REGISTRY RECORD file. There can be no record in the
"^DD",799.6,799.64,.01,23,3,0)
local registry with an IEN stored in this field.
"^DD",799.6,799.64,.01,23,4,0)
 
"^DD",799.6,799.64,.01,23,5,0)
The historical data extraction task will start 
"^DD",799.6,799.64,.01,23,6,0)
processing from the registry record with an IEN that 
"^DD",799.6,799.64,.01,23,7,0)
is not less than the value of this field.
"^DD",799.6,799.64,.01,"DT")
3051114
"^DD",799.6,799.64,.02,0)
TASK NUMBER^NJ10,0I^^0;2^K:+X'=X!(X>9899999999)!(X<1)!(X?.E1"."1N.N) X
"^DD",799.6,799.64,.02,1,0)
^.1
"^DD",799.6,799.64,.02,1,1,0)
799.64^T
"^DD",799.6,799.64,.02,1,1,1)
S ^RORDATA(799.6,DA(1),4,"T",$E(X,1,30),DA)=""
"^DD",799.6,799.64,.02,1,1,2)
K ^RORDATA(799.6,DA(1),4,"T",$E(X,1,30),DA)
"^DD",799.6,799.64,.02,1,1,3)
Do not delete!
"^DD",799.6,799.64,.02,1,1,"DT")
3050725
"^DD",799.6,799.64,.02,3)
Type a Number between 1 and 9899999999, 0 Decimal Digits.
"^DD",799.6,799.64,.02,8.5)
@
"^DD",799.6,799.64,.02,9)
@
"^DD",799.6,799.64,.02,21,0)
^^6^6^3050725^
"^DD",799.6,799.64,.02,21,1,0)
This field contains the number of the Taskman 
"^DD",799.6,799.64,.02,21,2,0)
task (scheduled or running) that does the data
"^DD",799.6,799.64,.02,21,3,0)
extraction.
"^DD",799.6,799.64,.02,21,4,0)
 
"^DD",799.6,799.64,.02,21,5,0)
This field cannot be edited. It is updated
"^DD",799.6,799.64,.02,21,6,0)
automatically by the data extraction task.
"^DD",799.6,799.64,.02,"DT")
3050725
"^DD",799.6,799.64,.03,0)
STATUS^S^0:Unknown;1:Active> Pending;2:Active> Running;3:Inactive> Finished;4:Inactive> Available;5:Inactive> Interrupted;100:Inactive> Crashed;101:Inactive> Errors;102:Active> Suspended;103:Active> Stopping;^0;3^Q
"^DD",799.6,799.64,.03,3)

"^DD",799.6,799.64,.03,8.5)
@
"^DD",799.6,799.64,.03,9)
@
"^DD",799.6,799.64,.03,21,0)
^^2^2^3050725^
"^DD",799.6,799.64,.03,21,1,0)
The STATUS field stores the last known task
"^DD",799.6,799.64,.03,21,2,0)
status.
"^DD",799.6,799.64,.03,23,0)
^^8^8^3060203^
"^DD",799.6,799.64,.03,23,1,0)
This field is populated with the value returned by the
"^DD",799.6,799.64,.03,23,2,0)
$$STATUS^RORTSK02 function. It will reflect the last 
"^DD",799.6,799.64,.03,23,3,0)
known status of the task even after the task is deleted
"^DD",799.6,799.64,.03,23,4,0)
by the Taskman and its record is deleted from the ROR
"^DD",799.6,799.64,.03,23,5,0)
TASK file (#798.8).
"^DD",799.6,799.64,.03,23,6,0)
 
"^DD",799.6,799.64,.03,23,7,0)
Please do not get value of this field directly; use the
"^DD",799.6,799.64,.03,23,8,0)
$$STATUS^RORHDTUT function instead.
"^DD",799.6,799.64,.03,"DT")
3051114
"^DD",799.6,799.64,.04,0)
NEXT PATIENT IEN^NJ22,9^^0;4^K:+X'=X!(X>999999999999)!(X<1)!(X?.E1"."10N.N) X
"^DD",799.6,799.64,.04,3)
Enter the next patient IEN (1-999999999999, 9 Decimal Digits).
"^DD",799.6,799.64,.04,8.5)
@
"^DD",799.6,799.64,.04,9)
@
"^DD",799.6,799.64,.04,21,0)
^.001^10^10^3060122^^
"^DD",799.6,799.64,.04,21,1,0)
If the data extraction task is stopped, it 
"^DD",799.6,799.64,.04,21,2,0)
finishes processing the current patient and stores
"^DD",799.6,799.64,.04,21,3,0)
the IEN of the patient that should be processed
"^DD",799.6,799.64,.04,21,4,0)
next as the value of this field.
"^DD",799.6,799.64,.04,21,5,0)
 
"^DD",799.6,799.64,.04,21,6,0)
When the task is restarted, it starts from the
"^DD",799.6,799.64,.04,21,7,0)
patient IEN stored in this field.
"^DD",799.6,799.64,.04,21,8,0)
 
"^DD",799.6,799.64,.04,21,9,0)
Usually, this field should not be edited. It is
"^DD",799.6,799.64,.04,21,10,0)
updated automatically by the data extraction task.
"^DD",799.6,799.64,.04,23,0)
^^7^7^3060203^
"^DD",799.6,799.64,.04,23,1,0)
The value of this field is not a real pointer to the 
"^DD",799.6,799.64,.04,23,2,0)
ROR PATIENT file. There can be no record in the file
"^DD",799.6,799.64,.04,23,3,0)
with IEN stored in this field.
"^DD",799.6,799.64,.04,23,4,0)
 
"^DD",799.6,799.64,.04,23,5,0)
The restarted historical data extraction task will 
"^DD",799.6,799.64,.04,23,6,0)
continue processing from the patient with an IEN that
"^DD",799.6,799.64,.04,23,7,0)
is not less than the value of this field.
"^DD",799.6,799.64,.04,"DT")
3060122
"^DD",799.6,799.64,.05,0)
FILE NAME^F^^0;5^K:$L(X)>50!($L(X)<1) X
"^DD",799.6,799.64,.05,3)
Answer must be 1-50 characters in length.
"^DD",799.6,799.64,.05,8.5)
@
"^DD",799.6,799.64,.05,9)
@
"^DD",799.6,799.64,.05,21,0)
^.001^22^22^3051101^^
"^DD",799.6,799.64,.05,21,1,0)
The output file name is stored in this field. This
"^DD",799.6,799.64,.05,21,2,0)
name is generated automatically when the task is
"^DD",799.6,799.64,.05,21,3,0)
created. The name has the following structure:
"^DD",799.6,799.64,.05,21,4,0)
 
"^DD",799.6,799.64,.05,21,5,0)
   BASE-SSS-TT.HDT
"^DD",799.6,799.64,.05,21,6,0)
 
"^DD",799.6,799.64,.05,21,7,0)
where 'BASE' is the base part of the file name
"^DD",799.6,799.64,.05,21,8,0)
provided by the user during creation of the task
"^DD",799.6,799.64,.05,21,9,0)
table 'SSS' is the site number (3 digits), and
"^DD",799.6,799.64,.05,21,10,0)
'TT' is the sequential number of the task (2
"^DD",799.6,799.64,.05,21,11,0)
digits).
"^DD",799.6,799.64,.05,21,12,0)
 
"^DD",799.6,799.64,.05,21,13,0)
If the task is restarted, the optional numeric
"^DD",799.6,799.64,.05,21,14,0)
modifier '##' (2 digits) can be added to the name
"^DD",799.6,799.64,.05,21,15,0)
so that the already extracted data will not be
"^DD",799.6,799.64,.05,21,16,0)
overwritten:
"^DD",799.6,799.64,.05,21,17,0)
 
"^DD",799.6,799.64,.05,21,18,0)
   BASE-SSS-TT-##.HDT
"^DD",799.6,799.64,.05,21,19,0)
 
"^DD",799.6,799.64,.05,21,20,0)
Usually, this field should not be edited. It is
"^DD",799.6,799.64,.05,21,21,0)
populated automatically when the task is created
"^DD",799.6,799.64,.05,21,22,0)
or restarted.
"^DD",799.6,799.64,.05,"DT")
3050722
"^DD",799.6,799.64,1,0)
ERROR^799.641P^^1;0
"^DD",799.6,799.64,1,9)
@
"^DD",799.6,799.64,1,21,0)
^^11^11^3060106^
"^DD",799.6,799.64,1,21,1,0)
This multiple contains a list of registry records 
"^DD",799.6,799.64,1,21,2,0)
that were processed with errors.
"^DD",799.6,799.64,1,21,3,0)
                                 
"^DD",799.6,799.64,1,21,4,0)
When the data extraction task is restarted, it
"^DD",799.6,799.64,1,21,5,0)
tries to re-extract the data for these patients.
"^DD",799.6,799.64,1,21,6,0)
If it succeeds, it deletes the corresponding
"^DD",799.6,799.64,1,21,7,0)
records from the list.
"^DD",799.6,799.64,1,21,8,0)
                                 
"^DD",799.6,799.64,1,21,9,0)
The records of the multiple have the same IENs as
"^DD",799.6,799.64,1,21,10,0)
the corresponding registry records in the ROR
"^DD",799.6,799.64,1,21,11,0)
REGISTRY RECORD file (#798).
"^DD",799.6,799.641,0)
ERROR SUB-FIELD^^.01^1
"^DD",799.6,799.641,0,"DT")
3050722
"^DD",799.6,799.641,0,"IX","B",799.641,.01)

"^DD",799.6,799.641,0,"NM","ERROR")

"^DD",799.6,799.641,0,"UP")
799.64
"^DD",799.6,799.641,.01,0)
ERROR^MP798.4'X^RORDATA(798.4,^0;1^S:$D(X) DINUM=X
"^DD",799.6,799.641,.01,1,0)
^.1
"^DD",799.6,799.641,.01,1,1,0)
799.641^B
"^DD",799.6,799.641,.01,1,1,1)
S ^RORDATA(799.6,DA(2),4,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",799.6,799.641,.01,1,1,2)
K ^RORDATA(799.6,DA(2),4,DA(1),1,"B",$E(X,1,30),DA)
"^DD",799.6,799.641,.01,8.5)
@
"^DD",799.6,799.641,.01,9)
@
"^DD",799.6,799.641,.01,"DT")
3060122
"^DIC",799.1,799.1,0)
ROR LIST ITEM^799.1
"^DIC",799.1,799.1,0,"GL")
^ROR(799.1,
"^DIC",799.1,799.1,"%",0)
^1.005^^0
"^DIC",799.1,799.1,"%D",0)
^^15^15^3050427^
"^DIC",799.1,799.1,"%D",1,0)
THIS FILE MUST NOT BE MODIFIED LOCALLY! ONLY 
"^DIC",799.1,799.1,"%D",2,0)
AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN EDIT
"^DIC",799.1,799.1,"%D",3,0)
THIS FILE!
"^DIC",799.1,799.1,"%D",4,0)
 
"^DIC",799.1,799.1,"%D",5,0)
This file contains code sets used within different
"^DIC",799.1,799.1,"%D",6,0)
registries.
"^DIC",799.1,799.1,"%D",7,0)
 
"^DIC",799.1,799.1,"%D",8,0)
Records of the file are uniquely identified by the
"^DIC",799.1,799.1,"%D",9,0)
type (it associates the set of values with the 
"^DIC",799.1,799.1,"%D",10,0)
registry field), registry and item code. The "A"
"^DIC",799.1,799.1,"%D",11,0)
primary key and the "KEY" uniqueness index are
"^DIC",799.1,799.1,"%D",12,0)
used for this purpose.
"^DIC",799.1,799.1,"%D",13,0)
 
"^DIC",799.1,799.1,"%D",14,0)
DO NOT DELETE RECORDS FROM THIS FILE IF THEY HAVE 
"^DIC",799.1,799.1,"%D",15,0)
BEEN DISTRIBUTED TO THE SITES ALREADY!
"^DIC",799.1,"B","ROR LIST ITEM",799.1)

"^DIC",799.31,799.31,0)
ROR XML ITEM^799.31
"^DIC",799.31,799.31,0,"GL")
^ROR(799.31,
"^DIC",799.31,799.31,"%",0)
^1.005^^0
"^DIC",799.31,799.31,"%D",0)
^^7^7^3040124^
"^DIC",799.31,799.31,"%D",1,0)
THIS FILE MUST NOT BE MODIFIED LOCALLY! ONLY 
"^DIC",799.31,799.31,"%D",2,0)
AUTHORIZED NATIONAL REGISTRY DEVELOPERS CAN EDIT
"^DIC",799.31,799.31,"%D",3,0)
THIS FILE!
"^DIC",799.31,799.31,"%D",4,0)
 
"^DIC",799.31,799.31,"%D",5,0)
The ROR XML ELEMENT file contains a list of XML 
"^DIC",799.31,799.31,"%D",6,0)
tags and attributes that can be used in the 
"^DIC",799.31,799.31,"%D",7,0)
reports.
"^DIC",799.31,"B","ROR XML ITEM",799.31)

"^DIC",799.51,799.51,0)
ROR GENERIC DRUG^799.51
"^DIC",799.51,799.51,0,"GL")
^ROR(799.51,
"^DIC",799.51,799.51,"%",0)
^1.005^^0
"^DIC",799.51,799.51,"%D",0)
^^5^5^3060203^
"^DIC",799.51,799.51,"%D",1,0)
This file contains a list of registry specific
"^DIC",799.51,799.51,"%D",2,0)
generic medications. For example, the ARV 
"^DIC",799.51,799.51,"%D",3,0)
(anti-retroviral) medications associated with the
"^DIC",799.51,799.51,"%D",4,0)
Human Immunodeficiency Virus (HIV) registry are
"^DIC",799.51,799.51,"%D",5,0)
stored here.
"^DIC",799.51,"B","ROR GENERIC DRUG",799.51)

"^DIC",799.6,799.6,0)
ROR HISTORICAL DATA EXTRACTION^799.6
"^DIC",799.6,799.6,0,"GL")
^RORDATA(799.6,
"^DIC",799.6,799.6,"%",0)
^1.005^^0
"^DIC",799.6,799.6,"%D",0)
^^9^9^3051031^
"^DIC",799.6,799.6,"%D",1,0)
Records of this file store parameters of the 
"^DIC",799.6,799.6,"%D",2,0)
historical data extractions (backpulls) performed
"^DIC",799.6,799.6,"%D",3,0)
on the registries and reflect status of these data
"^DIC",799.6,799.6,"%D",4,0)
extractions.
"^DIC",799.6,799.6,"%D",5,0)
 
"^DIC",799.6,799.6,"%D",6,0)
Records of the file are uniquely identified by the
"^DIC",799.6,799.6,"%D",7,0)
historical data extraction name (the "A" primary
"^DIC",799.6,799.6,"%D",8,0)
key and the uniqueness index "B" are used for that
"^DIC",799.6,799.6,"%D",9,0)
purpose).
"^DIC",799.6,"B","ROR HISTORICAL DATA EXTRACTION",799.6)

"BLD",7618,6)
^16
**END**
**END**
